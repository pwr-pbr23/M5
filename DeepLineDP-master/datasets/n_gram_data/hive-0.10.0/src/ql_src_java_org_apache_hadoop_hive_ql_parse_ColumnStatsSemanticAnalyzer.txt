/**
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hive ql parse
import java io ioexception
import java util arraylist
import java util linkedhashmap
import java util linkedlist
import java util list
import java util map
import org apache commons logging log
import org apache commons logging logfactory
import org apache hadoop hive conf hiveconf
import org apache hadoop hive metastore api fieldschema
import org apache hadoop hive ql context
import org apache hadoop hive ql errormsg
import org apache hadoop hive ql metadata hiveexception
import org apache hadoop hive ql metadata partition
import org apache hadoop hive ql metadata table
/**
* columnstatssemanticanalyzer.
* handles semantic analysis and rewrite for gathering column statistics both at the level of a
* partition and a table. note that table statistics are implemented in semanticanalyzer.
*
*/
public class columnstatssemanticanalyzer extends semanticanalyzer
private static final log log   logfactory
getlog columnstatssemanticanalyzer class
private astnode originaltree
private astnode rewrittentree
private string rewrittenquery
private context ctx
private boolean isrewritten
private boolean istablelevel
private string tablename
private list<string> colnames
private list<string> coltype
private string partname
private class partitionlist
private final string partkeys
private string partkeytypes
private final string partvalues
private int numpartitions
private int numpartitionvalues
partitionlist int numpartitions
this numpartitions   numpartitions
partkeys   new string
partvalues   new string
public int getnumpartitions
return numpartitions
public void setnumpartitions int numpartitions
this numpartitions   numpartitions
public string getpartvalues
return partvalues
public string getpartkeys
return partkeys
public void addpartvalue string partvalue  int index
partvalues   new string partvalue
public void addpartkey string partkey  int index
partkeys   new string partkey
public int getnumpartvalues
return numpartitionvalues
public void setnumpartvalues int numpartvalues
numpartitionvalues   numpartvalues
public string getpartkeytypes
return partkeytypes
public void setpartkeytypes string partkeytypes
this partkeytypes   partkeytypes
public void setpartkeytype string partkeytype  int index
partkeytypes   partkeytype
public columnstatssemanticanalyzer hiveconf conf  throws semanticexception
super conf
private boolean shouldrewrite astnode tree
boolean rwt   false
if  tree getchildcount   > 1
astnode child0    astnode  tree getchild 0
astnode child1
if  child0 gettoken   gettype      hiveparser tok_tab
child0    astnode  child0 getchild 0
if  child0 gettoken   gettype      hiveparser tok_tabname
child1    astnode  tree getchild 1
if  child1 gettoken   gettype      hiveparser tok_tabcolname
rwt   true
return rwt
private boolean ispartitionlevelstats astnode tree
boolean ispartitioned   false
astnode child    astnode  tree getchild 0
if  child getchildcount   > 1
child    astnode  child getchild 1
if  child gettoken   gettype      hiveparser tok_partspec
ispartitioned   true
return ispartitioned
private string gettablename astnode tree
return getunescapedname  astnode  tree getchild 0  getchild 0
private partitionlist getpartkeyvaluepairsfromast astnode tree
astnode child     astnode  tree getchild 0  getchild 1
int numparts   child getchildcount
partitionlist partlist   new partitionlist numparts
string partkey
string partvalue
int numpartvalue   0
for  int i   0  i < numparts  i
partkey   new string getunescapedname  astnode  child getchild i  getchild 0
if  child getchild i  getchildcount   > 1
partvalue   new string getunescapedname  astnode  child getchild i  getchild 1
partvalue   partvalue replaceall
numpartvalue    1
else
partvalue   null
partlist addpartkey partkey  i
if  partvalue    null
partlist addpartvalue partvalue  i
partlist setnumpartvalues numpartvalue
return partlist
private list<string> getcolumnname astnode tree
int numcols   tree getchild 1  getchildcount
list<string> colname   new linkedlist<string>
for  int i   0  i < numcols  i
colname add i  new string getunescapedname  astnode  tree getchild 1  getchild i
return colname
private int getnumcolumns astnode tree
return tree getchild 1  getchildcount
private void validatepartitionkeys string tablename  partitionlist partlist  throws
semanticexception
table tbl
try
tbl   db gettable tablename
catch  hiveexception e
throw new semanticexception errormsg invalid_table getmsg tablename
list<fieldschema> partkeys   tbl getpartitionkeys
string inputpartkeys   partlist getpartkeys
if  inputpartkeys length    partkeys size
throw new semanticexception errormsg columnstatscollector_incorrect_num_part_key getmsg
map<string  integer> partkeysmap   new linkedhashmap<string  integer>
for  int i 0  i <inputpartkeys length  i
partkeysmap put inputpartkeys tolowercase    new integer 1
// verify that the user specified part keys match the part keys in the table
for  fieldschema partkey partkeys
if   partkeysmap containskey partkey getname   tolowercase
throw new semanticexception errormsg columnstatscollector_invalid_part_key getmsg
private string getpartitionkeystype string tablename  partitionlist partlist  throws
semanticexception
table tbl
try
tbl   db gettable tablename
catch  hiveexception e
throw new semanticexception errormsg invalid_table getmsg tablename
list<fieldschema> partkeys   tbl getpartitionkeys
string inputpartkeys   partlist getpartkeys
string inputpartkeytypes   new string
for  int i 0  i < inputpartkeys length  i
for  fieldschema partkey partkeys
if  inputpartkeys equalsignorecase partkey getname
inputpartkeytypes   new string partkey gettype
break
return inputpartkeytypes
private string constructpartitionname string tablename  partitionlist partlist
throws semanticexception
table tbl
partition part
string partkeys   partlist getpartkeys
string partvalues   partlist getpartvalues
try
tbl   db gettable tablename
catch  hiveexception e
throw new semanticexception errormsg invalid_table getmsg tablename
map<string  string> partspec   new linkedhashmap<string  string>
for  int i 0  i<partkeys length  i
partspec put partkeys tolowercase    partvalues
try
part   db getpartition tbl  partspec  false
catch  hiveexception e
throw new semanticexception errormsg invalid_partition getmsg partname
if  part    null
throw new semanticexception errormsg columnstatscollector_invalid_partition getmsg
return part getname
private void validatepartitionclause string tablename  partitionlist partlist  throws
semanticexception
int numpartkeys   partlist getnumpartitions
int numpartvalues   partlist getnumpartvalues
// raise error if the user has specified dynamic partitions in the partitioning clause
if  numpartkeys    numpartvalues
throw new semanticexception errormsg columnstatscollector_invalid_syntax getmsg
// validate the user specified partition keys match the partition keys in the table
validatepartitionkeys tablename  partlist
private stringbuilder genpartitionclause partitionlist partlist  throws semanticexception
stringbuilder whereclause   new stringbuilder
boolean predpresent   false
stringbuilder groupbyclause   new stringbuilder
boolean aggpresent   false
stringbuilder retclause   null
string partkeys   partlist getpartkeys
string partvalues   partlist getpartvalues
string partkeystype   getpartitionkeystype tablename  partlist
for  int i   0  i < partlist getnumpartitions    i
if  partvalues    null
if   predpresent
whereclause append partkeys
whereclause append
if  partkeystype equalsignorecase
whereclause append
whereclause append partvalues
if  partkeystype equalsignorecase
whereclause append
predpresent   true
else
whereclause append
whereclause append partkeys
whereclause append
if  partkeystype equalsignorecase
whereclause append
whereclause append partvalues
if  partkeystype equalsignorecase
whereclause append
else
if   aggpresent
groupbyclause append partkeys
aggpresent   true
else
groupbyclause append
groupbyclause append partkeys
// attach the predicate and group by to the return clause
if  predpresent
retclause   new stringbuilder whereclause
if  aggpresent
retclause append groupbyclause
return retclause
private int getnumbitvectorsforndvestimation hiveconf conf
int numbitvectors
float percentageerror   hiveconf getfloatvar conf  hiveconf confvars hive_stats_ndv_error
if  percentageerror <  2 4
numbitvectors   1024
else if  percentageerror <  3 4
numbitvectors   1024
else if  percentageerror <  4 8
numbitvectors   512
else if  percentageerror <  6 8
numbitvectors   256
else if  percentageerror <  9 7
numbitvectors   128
else if  percentageerror <  13 8
numbitvectors   64
else if  percentageerror <  19 6
numbitvectors   32
else if  percentageerror <  28 2
numbitvectors   16
else if  percentageerror <  40 9
numbitvectors   8
else if  percentageerror <  61 0
numbitvectors   4
else
numbitvectors   2
return numbitvectors
private list<string> gettablecolumntype string tablename  list<string> colnames  int numcols
throws semanticexception
list<string> coltypes   new linkedlist<string>
string colname
table tbl
try
tbl   db gettable tablename
catch  hiveexception e
throw new semanticexception errormsg invalid_table getmsg tablename
list<fieldschema> cols   tbl getcols
for  int i 0  i <numcols  i
colname   colnames get i
for  fieldschema col  cols
if  colname equalsignorecase col getname
coltypes add i  new string col gettype
return coltypes
private list<string> getpartitioncolumntype string tablename  string partname
list<string> colnames  int numcols  throws semanticexception
list<string> coltypes   new linkedlist<string>
string colname
table tbl
try
tbl   db gettable tablename
catch  hiveexception e
throw new semanticexception errormsg invalid_table getmsg tablename
list<string> partnames   new arraylist<string>
partnames add partname
list<partition> partitionlist
try
partitionlist   db getpartitionsbynames tbl  partnames
catch  hiveexception e
throw new semanticexception errormsg invalid_partition getmsg partname
partition part   partitionlist get 0
list<fieldschema> cols   part getcols
for  int i 0  i <numcols  i
colname   colnames get i
for  fieldschema col  cols
if  colname equalsignorecase col getname
coltypes add i  new string col gettype
return coltypes
private string genrewrittenquery list<string> colnames  int numbitvectors  partitionlist partlist
boolean ispartitionstats  throws semanticexception
stringbuilder rewrittenquerybuilder   new stringbuilder
string rewrittenquery
for  int i   0  i < colnames size    i
if  i > 0
rewrittenquerybuilder append
rewrittenquerybuilder append
rewrittenquerybuilder append colnames get i
rewrittenquerybuilder append
rewrittenquerybuilder append numbitvectors
rewrittenquerybuilder append
rewrittenquerybuilder append
rewrittenquerybuilder append tablename
isrewritten   true
// if partition level statistics is requested, add predicate and group by as needed to rewritten
// query
if  ispartitionstats
rewrittenquerybuilder append genpartitionclause partlist
rewrittenquery   rewrittenquerybuilder tostring
rewrittenquery   new variablesubstitution   substitute conf  rewrittenquery
return rewrittenquery
private astnode genrewrittentree string rewrittenquery  throws semanticexception
astnode rewrittentree
// parse the rewritten query string
try
ctx   new context conf
catch  ioexception e
throw new semanticexception errormsg columnstatscollector_io_error getmsg
ctx setcmd rewrittenquery
parsedriver pd   new parsedriver
try
rewrittentree   pd parse rewrittenquery  ctx
catch  parseexception e
throw new semanticexception errormsg columnstatscollector_parse_error getmsg
rewrittentree   parseutils findrootnonnulltoken rewrittentree
return rewrittentree
public columnstatssemanticanalyzer hiveconf conf  astnode tree  throws semanticexception
super conf
/* rewrite only analyze table <> column <> compute statistics; don't rewrite analyze table
* command - table stats are collected by the table scan operator and is not rewritten to
* an aggregation.
*/
if  shouldrewrite tree
tablename   new string gettablename tree
colnames   getcolumnname tree
int numcols   getnumcolumns tree
// save away the original ast
originaltree   tree
boolean ispartitionstats   ispartitionlevelstats tree
partitionlist partlist   null
if  ispartitionstats
istablelevel   false
partlist   getpartkeyvaluepairsfromast tree
validatepartitionclause tablename  partlist
partname   constructpartitionname tablename  partlist
coltype   getpartitioncolumntype tablename  partname  colnames  numcols
else
istablelevel   true
coltype   gettablecolumntype tablename  colnames  numcols
int numbitvectors   getnumbitvectorsforndvestimation conf
rewrittenquery   genrewrittenquery colnames  numbitvectors  partlist  ispartitionstats
rewrittentree   genrewrittentree rewrittenquery
else
// not an analyze table column compute statistics statement - don't do any rewrites
originaltree   rewrittentree   tree
rewrittenquery   null
isrewritten   false
@override
public void analyze astnode ast  context origctx  throws semanticexception
qb qb
qbparseinfo qbp
// initialize qb
init
// setup the necessary metadata if originating from analyze rewrite
if  isrewritten
qb   getqb
qb setanalyzerewrite true
qbp   qb getparseinfo
qbp settablename tablename
qbp settbllvl istablelevel
if   istablelevel
qbp setpartname partname
qbp setcolname colnames
qbp setcoltype coltype
initctx ctx
log info
analyzeinternal rewrittentree
else
initctx origctx
log info
analyzeinternal originaltree