/*
derby - class org.apache.derby.impl.store.raw.data.allocationcache
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl store raw data
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi error standardexception
import org apache derby iapi store raw containerhandle
import org apache derby impl store raw data basecontainerhandle
/**
an auxiliary object to cache the allocation information for a file container.
<b>only a filecontainer should use this object</b>
<p>
the allocation cache contains an array of allocextents and 3 arrays of longs:
<ol><li>extentpagenums[i] is the page number of the i'th extent
<li>lowrange[i] is the smallest page number managed by extent i
<li>hirange[i] is the largest page number managed by extent i
</ol>
<p>
note thate extentpagenums and lowrange does not change once the extent has
been created, but hirange will change for the last extent as more pages are
allocated.
<p>
extents can be individually invalidated or the entire cache (all extends)
can be invalidated at once.
<p> mt - unsafe
synrhonized access to all methods must be enforced by the caller of
allocationcache
*/
class allocationcache
private int numextents
private long lowrange 	   lowrange to hirange defines the
private long hirange 		   smallest and largest logical page number
// manages by extent i
private boolean isdirty 	   changes to the in memory allocation cache
private allocextent extents
private long extentpagenums
private boolean isvalid
protected allocationcache
numextents   0
isvalid   false
/* reset the allocation cache in case when filecontainer object is reused */
protected void reset
numextents   0
isvalid   false
if  lowrange    null
for  int i   0  i < lowrange length  i
lowrange   containerhandle invalid_page_number
hirange   containerhandle invalid_page_number
extentpagenums   containerhandle invalid_page_number
extents   null
isdirty   false
/**
get the page number for the allocation page that is managing this page number
*/
protected long getallocpagenumber basecontainerhandle handle
long pagenumber
long firstallocpagenumber
throws standardexception
// try to see if we can figure this out without validating the cache
for  int i   0  i < numextents  i
if  lowrange <  pagenumber    pagenumber <  hirange
return extentpagenums
if   isvalid
/* can't find the page. validate the cache first, then try to find it again */
validate handle  firstallocpagenumber
for  int i   0  i < numextents  i
if  lowrange <  pagenumber    pagenumber <  hirange
return extentpagenums
return containerhandle invalid_page_number
/**
get the last (allocated) page of the container
*/
protected long getlastpagenumber basecontainerhandle handle  long firstallocpagenumber
throws standardexception
if   isvalid
validate handle  firstallocpagenumber
return hirange
/**
set the page number to be unfilled
*/
protected void trackunfilledpage long pagenumber  boolean unfilled
// do not validate the alloc cache just for the purpose of updating the
// unfilled bit
if   isvalid     numextents <  0
return
// we are calling this without getting the alloccache semaphore - be
// careful that extents[i] will go null at any time.
for  int i   0  i < numextents  i
if  lowrange <  pagenumber    pagenumber <  hirange
allocextent ext   extents
if  ext    null
ext trackunfilledpage pagenumber  unfilled
extents    null
isdirty   true
break
protected long getunfilledpagenumber basecontainerhandle handle
long firstallocpagenumber
long pagenum
throws standardexception
// get the next unfilled page number
if   isvalid
validate handle  firstallocpagenumber
if  pagenum    containerhandle invalid_page_number
for  int i   0  i < numextents  i
if  extents    null
return extents getunfilledpagenumber pagenum
else
for  int i   0  i < numextents  i
if  pagenum <  hirange
if  extents    null
return extents getunfilledpagenumber pagenum
return containerhandle invalid_page_number
/**
returns estimated number of allocated pages
**/
protected long getestimatedpagecount basecontainerhandle handle
long firstallocpagenumber
throws standardexception
if   isvalid
validate handle  firstallocpagenumber
long estpagecount   0
for  int i   0  i < numextents  i
if  extents    null
estpagecount    extents getallocatedpagecount
return estpagecount
protected spaceinformation getallpagecounts
basecontainerhandle handle
long firstallocpagenumber
throws standardexception
long currallocpages   0
long numallocatedpages   0
long numfreepages   0
long numunfilledpages   0
if   isvalid
validate handle  firstallocpagenumber
for  int i   0  i < numextents  i
if  extents    null
currallocpages   extents getallocatedpagecount
numallocatedpages    currallocpages
numunfilledpages    extents getunfilledpagecount
numfreepages
extents gettotalpagecount     currallocpages
if  sanitymanager debug
sanitymanager assert numunfilledpages <  numallocatedpages
i
numunfilledpages
numallocatedpages
numfreepages
return new spaceinformation
numallocatedpages
numfreepages
numunfilledpages
/* invalidate all extents */
protected void invalidate
if  sanitymanager debug
if  sanitymanager debug_on filecontainer space_trace
sanitymanager debug
filecontainer space_trace
for  int i   0  i < numextents  i
isdirty   false
extents   null
isvalid   false
/* invalidate the extent that is managed by this alloc page */
protected void invalidate allocpage allocpage  long allocpagenum
throws standardexception
if  sanitymanager debug
if  sanitymanager debug_on filecontainer space_trace
sanitymanager debug
filecontainer space_trace
allocpagenum
isvalid   false
if  numextents    0
return
for  int i   0  i < numextents  i
if  extentpagenums    allocpagenum
// update unfilled page info
if  allocpage    null    extents    null
isdirty
// replace unfilledpage bitmap with the one in the allocation
// cache, which has the more current information
// call this only in invalidate, when the reference to the
// extent is about to be nulled out
allocpage updateunfilledpageinfo extents
isdirty   false
extents   null
return
// handle the case where a new alloc page that has never been entered
// into the cache is asked to be invalidated
if  allocpagenum > hirange
return
if  sanitymanager debug
sanitymanager throwassert
allocpagenum
/* invalidate the last extent */
protected void invalidatelastextent
if  sanitymanager debug
if  sanitymanager debug_on filecontainer space_trace
sanitymanager debug
filecontainer space_trace
extentpagenums
isvalid   false
if  numextents > 0
extents   null
/**
get the last valid page of the file container.  a valid page is one that
is not deallocated or freed.
*/
protected long getlastvalidpage basecontainerhandle handle
long firstallocpagenumber
throws standardexception
allocextent extent   null
int extentnumber
long lastvalidpagenumber   containerhandle invalid_page_number
if   isvalid
validate handle  firstallocpagenumber
if  numextents    0 	   no extent at all  no page in the container
return containerhandle invalid_page_number
// start from the last extent, goes backward till a valid page is found
for  extentnumber   numextents 1
extentnumber >  0
extentnumber
extent   extents
lastvalidpagenumber   extent getlastvalidpagenumber
if  lastvalidpagenumber    containerhandle invalid_page_number
break
return lastvalidpagenumber
/*
get the next page (after pagenumber) that is valid
*/
protected long getnextvalidpage basecontainerhandle handle
long pagenumber
long firstallocpagenumber
throws standardexception
int extentnumber
if   isvalid
validate handle  firstallocpagenumber
if  numextents    0 	   no extent at all  no page in the container
return containerhandle invalid_page_number
// find the extent whose hirange is > pagenumber.  most of the time,
// this is the extent this pagenumber is in, but some times, when
// pagenumber == hirange of extent i, extent i+1 is found.
allocextent extent   null
for  extentnumber   0  extentnumber < numextents  extentnumber
if  pagenumber < hirange
extent   extents
break
if  extent    null 		   extent has been invalidated or not there
// the cache is valid and up to date,
// the only reason why we cannot find an extent is if this is the
// last valid page of the container
return containerhandle invalid_page_number
// extent == extents[extentnumber]
if  sanitymanager debug
sanitymanager assert extent    extents
// we found an extent which may contain a valid page that is of higher
// pagenumber than the passed in page number.  still need to walk the
// extent array to make sure
long nextvalidpage   containerhandle invalid_page_number
while extentnumber < numextents
extent   extents
nextvalidpage   extent getnextvalidpagenumber pagenumber
if  nextvalidpage    containerhandle invalid_page_number
break
extentnumber
return nextvalidpage
/**
get the page status of a page
*/
protected int getpagestatus basecontainerhandle handle  long pagenumber
long firstallocpagenumber
throws standardexception
allocextent extent   null
for  int i   0  i < numextents  i
if  lowrange <  pagenumber    pagenumber <  hirange
extent   extents
break
if  extent    null
if  sanitymanager debug
if  isvalid
sanitymanager debug_print
isvalid ?
for  int i   0  i < numextents  i
sanitymanager debug_print        i       extentpagenums
lowrange       hirange
if  extents    null
sanitymanager debug_print
else
sanitymanager debug_print    extents todebugstring
sanitymanager throwassert   pagenumber
if   isvalid
validate handle  firstallocpagenumber
// try again
for  int i   0  i < numextents  i
if  lowrange <  pagenumber    pagenumber <  hirange
extent   extents
break
if  sanitymanager debug
if  extent    null
sanitymanager throwassert
pagenumber
return extent getpagestatus pagenumber
/**
validate the cache, find all alloc pages and fill in the arrays
*/
private void validate basecontainerhandle handle  long firstallocpagenumber
throws standardexception
if  numextents    0 	   never been initialized  read it all in
long pagenum   firstallocpagenumber
while  isvalid
growarrays   numextents
object obj   handle getallocpage pagenum
if  sanitymanager debug
if  obj    null
sanitymanager throwassert
numextents
pagenum
if      obj instanceof allocpage
sanitymanager throwassert
pagenum
obj getclass   getname
allocpage allocpage    allocpage obj
setarrays numextents 1  allocpage
if  allocpage islast
isvalid   true
else
// get next alloc page
pagenum   allocpage getnextallocpagenumber
allocpage unlatch
else		   has been initialized before  but is now invalidated
for  int i   0  i < numextents 1  i
if  extents    null 	   reinitialize this extent
allocpage allocpage
allocpage handle getallocpage extentpagenums
setarrays i  allocpage
if  sanitymanager debug
if  i < numextents 1
if  extentpagenums
allocpage getnextallocpagenumber
sanitymanager throwassert
extentpagenums
allocpage getnextallocpagenumber
allocpage unlatch
// always get the last alloc page to see if the number of alloc
// pages remain the same
long pagenum   extentpagenums
while   isvalid
allocpage allocpage    allocpage handle getallocpage pagenum
if  extents    null
setarrays numextents 1  allocpage
if   allocpage islast
growarrays   numextents
pagenum   allocpage getnextallocpagenumber
else
isvalid   true
allocpage unlatch
/* shorthand to set the 4 array values */
private void setarrays int i  allocpage allocpage
if  sanitymanager debug
if  sanitymanager debug_on filecontainer space_trace
sanitymanager debug
filecontainer space_trace
i       allocpage getpagenumber
allocextent extent   allocpage getallocextent
extents   extent
lowrange   extent getfirstpagenum
hirange   extent getlastpagenum
extentpagenums   allocpage getpagenumber
/* shorthand to grow the 4 arrays to the desired size */
private void growarrays int size
int oldlength
if  lowrange    null    lowrange length    0
oldlength   0
else
oldlength   lowrange length
if  oldlength >  size 	   no need to grow
return
long savelow   lowrange
long savehi   hirange
allocextent saveextents   extents
boolean savedirty   isdirty
long savepagenums   extentpagenums
lowrange   new long
hirange   new long
isdirty   new boolean
extents   new allocextent
extentpagenums   new long
if  oldlength > 0
if  sanitymanager debug
sanitymanager assert oldlength    savehi length
sanitymanager assert oldlength    saveextents length
sanitymanager assert oldlength    savepagenums length
system arraycopy savelow  	  0  lowrange  	0  savelow length
system arraycopy savehi 	  0  hirange  	0  savehi length
system arraycopy savedirty 	  0  isdirty    0  savedirty length
system arraycopy saveextents  0  extents 	0  saveextents length
system arraycopy savepagenums 0 extentpagenums 0  savepagenums length
for  int i   oldlength  i < size  i
lowrange   containerhandle invalid_page_number
hirange   containerhandle invalid_page_number
isdirty   false
extentpagenums   containerhandle invalid_page_number
extents   null
/**
dump the allocation cache information
*/
protected void dumpallocationcache
if  sanitymanager debug
if  sanitymanager debug_on filecontainer space_trace
sanitymanager debug filecontainer space_trace
isvalid ?
for  int i   0  i < numextents  i
sanitymanager debug
filecontainer space_trace
i       extentpagenums
lowrange       hirange
if  extents    null
sanitymanager debug
filecontainer space_trace
else
sanitymanager debug
filecontainer space_trace
extents todebugstring