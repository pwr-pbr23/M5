/*
derby - class org.apache.derby.impl.sql.execute.genericrichecker
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl sql execute
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi error standardexception
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi types rowlocation
import org apache derby iapi sql conn languageconnectioncontext
import org apache derby iapi sql dictionary conglomeratedescriptor
import org apache derby iapi sql execute execrow
import org apache derby iapi sql execute execindexrow
import org apache derby iapi store access conglomeratecontroller
import org apache derby iapi store access dynamiccompiledopenconglominfo
import org apache derby iapi store access scancontroller
import org apache derby iapi store access staticcompiledopenconglominfo
import org apache derby iapi store access transactioncontroller
import org apache derby iapi services io formatablebitset
import java util enumeration
import java util hashtable
/**
* generic implementation of a referential integrity
* checker.  abstract.
*/
public abstract class genericrichecker
protected fkinfo					fkinfo
protected dynamiccompiledopenconglominfo fkdcocis
protected staticcompiledopenconglominfo fkscocis
protected dynamiccompiledopenconglominfo refdcoci
protected staticcompiledopenconglominfo refscoci
protected transactioncontroller		tc
private hashtable 		scancontrollers
private int				numcolumns
private	indexrow		indexqualifierrow
/**
* @param tc		the xact controller
* @param fkinfo	the foreign key information
*
* @exception standardexception		thrown on failure
*/
genericrichecker transactioncontroller tc  fkinfo fkinfo
throws standardexception
this fkinfo   fkinfo
this tc   tc
scancontrollers   new hashtable
numcolumns   fkinfo colarray length
indexqualifierrow   new indexrow numcolumns
fkdcocis   new dynamiccompiledopenconglominfo
fkscocis   new staticcompiledopenconglominfo
for  int index   0  index < fkinfo fkconglomnumbers length  index
fkdcocis   tc getdynamiccompiledconglominfo fkinfo fkconglomnumbers
fkscocis   tc getstaticcompiledconglominfo fkinfo fkconglomnumbers
refdcoci   tc getdynamiccompiledconglominfo fkinfo refconglomnumber
refscoci   tc getstaticcompiledconglominfo fkinfo refconglomnumber
/**
* check the validity of this row
*
* @param row	the row to check
*
* @exception standardexception on error
*/
abstract void docheck execrow row  boolean restrictcheckonly  throws standardexception
public void docheck execrow row  throws standardexception
docheck row  false     check all the referential actions
/**
* get a scan controller positioned using searchrow as
* the start/stop position.  the assumption is that searchrow
* is of the same format as the index being opened.
* the scan is set up to return no columns.
* note: we only need an instantaneous lock on the
* table that we are probing as we are just checking
* for the existance of a row.  all updaters, whether
* to the primary or foreign key tables, will hold an
* x lock on the table that they are updating and will
* be probing the other table, so instantaneous locks
* will not change the semantics.
*
* resolve:  due to the current ri implementation
* we cannot always get instantaneous locks.  we
* will call a method to find out what kind of
* locking to do until the implementation changes.
*
* @param conglomnumber		the particular conglomerate we
*							are interested in
* @param searchrow			the row to match
*
* @exception standardexception on error
*/
protected scancontroller getscancontroller long conglomnumber
staticcompiledopenconglominfo scoci
dynamiccompiledopenconglominfo dcoci  execrow searchrow
throws standardexception
int				isolevel   getricheckisolationlevel
scancontroller 	scan
long			hashkey   new long conglomnumber
/*
** if we haven't already opened this scan controller,
** we'll open it now and stick it in the hash table.
*/
if   scan    scancontroller scancontrollers get hashkey      null
setupqualifierrow searchrow
scan
tc opencompiledscan
false                        				   hold
0  										   read only
transactioncontroller mode_record 		   row locking
isolevel
formatablebitset null  							   retrieve all fields
indexqualifierrow getrowarray       		   startkeyvalue
scancontroller ge             			   startsearchop
null                          			   qualifier
indexqualifierrow getrowarray       		   stopkeyvalue
scancontroller gt              			   stopsearchop
scoci
dcoci
scancontrollers put hashkey  scan
else
/*
** if the base row is the same row as the previous
** row, this call to setupqualfierrow is redundant,
** but it is safer this way so we'll take the
** marginal performance hit (marginal relative
** to the index scans that we are making).
*/
setupqualifierrow searchrow
scan reopenscan
indexqualifierrow getrowarray       	   startkeyvalue
scancontroller ge             		   startsearchop
null                          		   qualifier
indexqualifierrow getrowarray    		   stopkeyvalue
scancontroller gt             		   stopsearchop
return scan
/*
** do reference copy for the qualifier row.  no cloning.
** so we cannot get another row until we are done with
** this one.
*/
private void setupqualifierrow execrow baserow
datavaluedescriptor indexcolarray   indexqualifierrow getrowarray
datavaluedescriptor basecolarray   baserow getrowarray
for  int i   0  i < numcolumns  i
indexcolarray   basecolarray   1]
/**
* are any of the fields null in the row passed
* in.  the only fields that are checked are those
* corresponding to the colarray in fkinfo.
*/
boolean isanyfieldnull execrow baserow
datavaluedescriptor basecolarray   baserow getrowarray
for  int i   0  i < numcolumns  i
datavaluedescriptor storable   basecolarray   1]
if  storable isnull
return true
return false
/**
* clean up all scan controllers
*
* @exception standardexception on error
*/
void close
throws standardexception
enumeration e   scancontrollers elements
while  e hasmoreelements
scancontroller scan    scancontroller e nextelement
scan close
scancontrollers clear
/**
* get the isolation level for the scan for
* the ri check.
*
* note: the level will eventually be instantaneous
* locking once the implemenation changes.
*
* @return the isolation level for the scan for
* the ri check.
*/
int getricheckisolationlevel
return transactioncontroller isolation_read_committed_noholdlock