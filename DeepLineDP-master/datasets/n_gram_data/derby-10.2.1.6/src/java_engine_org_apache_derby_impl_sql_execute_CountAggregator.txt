/*
derby - class org.apache.derby.impl.sql.execute.countaggregator
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl sql execute
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi error standardexception
import org apache derby iapi sql execute execaggregator
import org apache derby iapi services io storedformatids
import org apache derby iapi services io formatable
import java io objectoutput
import java io objectinput
import java io ioexception
/**
* aggregator for count()/count(*).
* @author jamie
*/
public final class countaggregator
extends systemaggregator
private long value
private boolean iscountstar
/**
*/
public void setup string aggregatename
iscountstar   aggregatename equals
/**
* @see execaggregator#merge
*
* @exception	standardexception	on error
*/
public void merge execaggregator addend
throws standardexception
if  sanitymanager debug
sanitymanager assert addend instanceof countaggregator
value      countaggregator addend  value
/**
* return the result of the aggregation.  just
* spit out the running count.
*
* @return the value as a long
*/
public datavaluedescriptor getresult
return new org apache derby iapi types sqllongint value
/**
* accumulate for count().  toss out all nulls in this kind of count.
* increment the count for count(*). count even the null values.
*
* @param addend	value to be added in
* @param ga		the generic aggregator that is calling me
*
* @see execaggregator#accumulate
*/
public void accumulate datavaluedescriptor addend  object ga
throws standardexception
if  iscountstar
value
else
super accumulate addend  ga
protected final void accumulate datavaluedescriptor addend
value
/**
* @return execaggregator the new aggregator
*/
public execaggregator newaggregator
countaggregator ca   new countaggregator
ca iscountstar   iscountstar
return ca
public boolean iscountstar
return iscountstar
/////////////////////////////////////////////////////////////
//
// externalizable interface
//
/////////////////////////////////////////////////////////////
/**
* although we are not expected to be persistent per se,
* we may be written out by the sorter temporarily.  so
* we need to be able to write ourselves out and read
* ourselves back in.
*
* @exception ioexception thrown on error
*/
public final void writeexternal objectoutput out  throws ioexception
super writeexternal out
out writeboolean iscountstar
out writelong value
/**
* @see java.io.externalizable#readexternal
*
* @exception ioexception io exception
* @exception classnotfoundexception on error
*/
public final void readexternal objectinput in
throws ioexception  classnotfoundexception
super readexternal in
iscountstar   in readboolean
value   in readlong
/////////////////////////////////////////////////////////////
//
// formatable interface
//
/////////////////////////////////////////////////////////////
/**
* get the formatid which corresponds to this class.
*
*	@return	the formatid of this class
*/
public	int	gettypeformatid     return storedformatids agg_count_v01_id