/*
derby - class org.apache.derby.impl.sql.execute.nestedloopjoinresultset
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl sql execute
import org apache derby iapi services monitor monitor
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi services stream headerprintwriter
import org apache derby iapi services stream infostreams
import org apache derby iapi error standardexception
import org apache derby iapi sql activation
import org apache derby iapi sql resultset
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi reference sqlstate
import org apache derby iapi sql execute execrow
import org apache derby iapi sql execute executioncontext
import org apache derby iapi sql execute noputresultset
import org apache derby iapi services loader generatedmethod
/**
* takes 2 noputresultsets and a join filter and returns
* the join's rows satisfying the filter as a result set.
*/
class nestedloopjoinresultset extends joinresultset
private boolean returnedrowmatchingrightside   false
private execrow righttemplate
//
// resultset interface (leftover from noputresultset)
//
/**
* clear any private state that changes during scans.
* this includes things like the last row seen, etc.
* this does not include immutable things that are
* typically set up in the constructor.
* <p>
* this method is called on open()/close() and reopen()
* <p>
* warning: this should be implemented in every sub
* class and it should always call super.clearscanstate().
*/
void clearscanstate
returnedrowmatchingrightside   false
super clearscanstate
/**
* return the requested values computed
* from the next row (if any) for which
* the restriction evaluates to true.
* <p>
* restriction parameters
* are evaluated for each row.
*
* @exception standardexception		thrown on error
* @exception standardexception		resultsetnotopen thrown if closed
* @return the next row in the join result
*/
public execrow	getnextrowcore   throws standardexception
execrow result   null
boolean haverow   false
boolean restrict   false
int colinctr
int coloutctr
datavaluedescriptor restrictboolean
begintime   getcurrenttimemillis
if    isopen
throw standardexception newexception sqlstate lang_result_set_not_open
/* if we have a row from the left side and the right side is not open,
* then we get an error on the previous next, either on the next on
* the left or the open on the right.  so, we do a next on the left
* and then open the right if that succeeds.
*/
if    isrightopen    leftrow    null
leftrow   leftresultset getnextrowcore
if  leftrow    null
closeright
else
rowsseenleft
openright
while  leftrow    null     haverow
if  onerowrightside    returnedrowmatchingrightside
rightrow   null
returnedrowmatchingrightside   false
else
rightrow   rightresultset getnextrowcore
/* if this is a not exists join, we just need to reverse the logic
* of exists join.  to make the implementation simple, we create a
* right side template, which is never really needed. (beetle 5173)
*/
if  notexistsrightside
if  rightrow    null         none satisfied
rightrow   righttemplate     then we are
else
rightrow   null
returnedrowmatchingrightside    rightrow    null
if  rightrow    null
/* current scan on right is exhausted.  need to close old scan
* and open new scan with new "parameters".  openright()
* will reopen if already open.
*/
leftrow   leftresultset getnextrowcore
if  leftrow    null
closeright
else
rowsseenleft
openright
else
rowsseenright
if  restriction    null
restrictboolean
datavaluedescriptor  restriction invoke activation
// if the result is null, we make it false --
// so the row won't be returned.
restrict      restrictboolean isnull
restrictboolean getboolean
if    restrict
/* update the run time statistics */
rowsfiltered
continue
/* merge the rows, doing just in time allocation for mergedrow.
* (by convention, left row is to left of right row.)
*/
if  mergedrow    null
mergedrow   getexecutionfactory   getvaluerow leftnumcols   rightnumcols
for  colinctr   1  coloutctr   1  colinctr <  leftnumcols
colinctr    coloutctr
mergedrow setcolumn coloutctr
leftrow getcolumn colinctr
if    notexistsrightside
for  colinctr   1  colinctr <  rightnumcols
colinctr    coloutctr
mergedrow setcolumn coloutctr
rightrow getcolumn colinctr
setcurrentrow mergedrow
haverow   true
/* do we have a row to return? */
if  haverow
result   mergedrow
rowsreturned
else
clearcurrentrow
nexttime    getelapsedmillis begintime
return result
/**
* if the result set has been opened,
* close the open scan.
*
* @exception standardexception thrown on error
*/
public void	close   throws standardexception
if   isopen
begintime   getcurrenttimemillis
// we don't want to keep around a pointer to the
// row ... so it can be thrown away.
// revisit: does this need to be in a finally
// block, to ensure that it is executed?
clearcurrentrow
super close
returnedrowmatchingrightside   false
closetime    getelapsedmillis begintime
/**
* return the total amount of time spent in this resultset
*
* @param type	current_resultset_only - time spent only in this resultset
*				entire_resultset_tree  - time spent in this resultset and below.
*
* @return long		the total amount of time spent (in milliseconds).
*/
public long gettimespent int type
long tottime   constructortime   opentime   nexttime   closetime
if  type    noputresultset current_resultset_only
return	tottime   leftresultset gettimespent entire_resultset_tree
rightresultset gettimespent entire_resultset_tree
else
return tottime
/*
* class interface
*
*/
nestedloopjoinresultset noputresultset leftresultset
int leftnumcols
noputresultset rightresultset
int rightnumcols
activation activation
generatedmethod restriction
int resultsetnumber
boolean onerowrightside
boolean notexistsrightside
double optimizerestimatedrowcount
double optimizerestimatedcost
string usersuppliedoptimizeroverrides
super leftresultset  leftnumcols  rightresultset  rightnumcols
activation  restriction  resultsetnumber
onerowrightside  notexistsrightside  optimizerestimatedrowcount
optimizerestimatedcost  usersuppliedoptimizeroverrides
if  notexistsrightside
righttemplate   getexecutionfactory   getvaluerow rightnumcols