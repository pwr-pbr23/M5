/*
derby - class org.apache.derby.impl.sql.execute.bulktablescanresultset
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl sql execute
import org apache derby iapi sql execute cursorresultset
import org apache derby iapi error standardexception
import org apache derby iapi types rowlocation
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi sql resultset
import org apache derby iapi sql execute execrow
import org apache derby iapi sql execute execindexrow
import org apache derby iapi sql execute noputresultset
import org apache derby iapi sql activation
import org apache derby iapi store access groupfetchscancontroller
import org apache derby iapi store access qualifier
import org apache derby iapi store access scancontroller
import org apache derby iapi store access staticcompiledopenconglominfo
import org apache derby iapi store access transactioncontroller
import org apache derby iapi types rowlocation
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi services loader generatedmethod
import org apache derby iapi services io formatablebitset
/**
* read a base table or index in bulk.  most of the
* work for this method is inherited from tablescanresultset.
* this class overrides getnextrowcore (and extends
* re/opencore) to use a row array and fetch rows
* from the store in bulk  (using fetchnextgroup).
* <p>
* since it retrieves rows in bulk, locking is not
* as is usual -- locks may have already been released
* on rows as they are returned to the user.  hence,
* this resultset is not suitable for a query running
* isolation level 1, cursor stability.
* <p>
* note that this code is only accessable from an
* optimizer override.  if it makes sense to have the
* optimizer select bulk reads, then this should
* probably be rolled into tablescanresultset.
*
* @author jamie
*/
class bulktablescanresultset extends tablescanresultset
implements cursorresultset
private datavaluedescriptor rowarray
private int currowposition
private int numrowsinarray
private static int out_of_rows   0
/**
* constructor.  just save off the rowsperread argument
* and pass everything else down to tablescanresultset
*
* @see org.apache.derby.iapi.sql.execute.resultsetfactory#getbulktablescanresultset
*
* @exception standardexception thrown on failure to open
*/
bulktablescanresultset long conglomid
staticcompiledopenconglominfo scoci  activation activation
generatedmethod resultrowallocator
int resultsetnumber
generatedmethod startkeygetter  int startsearchoperator
generatedmethod stopkeygetter  int stopsearchoperator
boolean samestartstopposition
qualifier qualifiers
string tablename
string usersuppliedoptimizeroverrides
string indexname
boolean isconstraint
boolean forupdate
int colrefitem
int indexcolitem
int lockmode
boolean tablelocked
int isolationlevel
int rowsperread
boolean onerowscan
double optimizerestimatedrowcount
double optimizerestimatedcost
throws standardexception
super conglomid
scoci
activation
resultrowallocator
resultsetnumber
startkeygetter
startsearchoperator
stopkeygetter
stopsearchoperator
samestartstopposition
qualifiers
tablename
usersuppliedoptimizeroverrides
indexname
isconstraint
forupdate
colrefitem
indexcolitem
lockmode
tablelocked
isolationlevel
rowsperread
onerowscan
optimizerestimatedrowcount
optimizerestimatedcost
if  sanitymanager debug
/* bulk fetch of size 1 is same as a regular table scan
* and is supposed to be detected at compile time.
*/
if  rowsperread    1
sanitymanager throwassert
/* bulk table scan implies that scan is not
* a 1 row scan.
*/
if  onerowscan
sanitymanager throwassert
rowsperread
/**
* open the scan controller
*
* @param tc transaction controller will open one if null
*
* @exception standardexception thrown on failure to open
*/
protected void openscancontroller transactioncontroller tc
throws standardexception
datavaluedescriptor startpositionrow   startposition    null ? null   startposition getrowarray
datavaluedescriptor stoppositionrow   stopposition    null ? null   stopposition getrowarray
// clear the qualifiers's orderable cache
if  qualifiers    null
clearorderablecache qualifiers
// get the current transaction controller
if  tc    null
tc   activation gettransactioncontroller
scancontroller   tc opencompiledscan
activation getresultsetholdability
forupdate ? transactioncontroller openmode_forupdate   0
lockmode
isolationlevel
accessedcols
startpositionrow
// not used when giving null start position
startsearchoperator
qualifiers
stoppositionrow
// not used when giving null stop position
stopsearchoperator
scoci
dcoci
/* remember that we opened the scan */
scancontrolleropened   true
rowsthisscan   0
/*
** inform the activation of the estimated number of rows.  only
** do it here, not in reopen, so that we don't do this costly
** check too often.
*/
activation informofrowcount
this
scancontroller getestimatedrowcount
/**
* open up the result set.  delegate
* most work to tablescanresultset.opencore().
* create a new array with <rowsperread> rows
* for use in fetchnextgroup().
*
* @exception standardexception thrown on failure to open
*/
public void opencore   throws standardexception
super opencore
/*
** add the extra time we spent after
** the super class -- tablescanresultset()
** already added up its time in opencore().
*/
begintime   getcurrenttimemillis
rowarray   new datavaluedescriptor
// we only allocate the first row -- the
// store clones as needed for the rest
// of the rows
rowarray   candidate getrowarrayclone
numrowsinarray   0
currowposition    1
opentime    getelapsedmillis begintime
/**
* reopen the result set.  delegate
* most work to tablescanresultset.reopencore().
* reuse the array of rows.
*
* @exception standardexception thrown on failure to open
*/
public void reopencore   throws standardexception
super reopencore
numrowsinarray   0
currowposition    1
/**
* return the next row (if any) from the scan (if open).
* reload the rowarray as necessary.
*
* @exception standardexception thrown on failure to get next row
*/
public execrow getnextrowcore   throws standardexception
execrow result   null
checkcancellationflag
begintime   getcurrenttimemillis
if  isopen    scancontrolleropened
if  currentrow    null
currentrow
getcompactrow candidate
accessedcols
formatablebitset  null
iskeyed
outer 		for
if  currowposition >  numrowsinarray   1
if  reloadarray      out_of_rows
setcurrentrow null
setrowcountifpossible rowsthisscan
return null
while    currowposition < numrowsinarray
candidate setrowarray rowarray
currentrow   setcompactrow candidate  currentrow
rowsseen
rowsthisscan
/*
** skip rows where there are start or stop positioners
** that do not implement ordered null semantics and
** there are columns in those positions that contain
** null.
*/
if  skiprow candidate
rowsfiltered
continue
result   currentrow
break outer
setcurrentrow result
nexttime    getelapsedmillis begintime
return result
/*
** load up rowarray with a batch of
** rows.
*/
private int reloadarray   throws standardexception
currowposition    1
numrowsinarray
groupfetchscancontroller  scancontroller  fetchnextgroup
rowarray   rowlocation  null
return numrowsinarray
/**
* if the result set has been opened,
* close the open scan.  delegate most
* of the work to tablescanresultset.
*
* @exception standardexception on error
*/
public void	close   throws standardexception
/*
** we'll let tablescanresultset track
** the time it takes to close up, so
** no timing here.
*/
super close
numrowsinarray    1
currowposition    1
rowarray   null
/**
* can we get instantaneous locks when getting share row
* locks at read committed.
*/
protected boolean cangetinstantaneouslocks
return true
/**
* @see noputresultset#requiresrelocking
*/
public boolean requiresrelocking
// indexrowtobaserow needs to relock if we didn't keep the lock
return
isolationlevel    transactioncontroller isolation_read_committed
isolationlevel    transactioncontroller isolation_read_committed_noholdlock
isolationlevel    transactioncontroller isolation_read_uncommitted