/*
derby - class org.apache.derby.iapi.services.io.arrayinputstream
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby iapi services io
import java io inputstream
import java io ioexception
import java io objectinput
import java io eofexception
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi services io limitobjectinput
import org apache derby iapi services io errorobjectinput
import java io utfdataformatexception
/**
an inputstream that allows reading from an array of bytes. the array
of bytes that is read from can be changed without having to create a new
instance of this class.
*/
public final class arrayinputstream extends inputstream implements limitobjectinput
private byte pagedata
private int		start
private int		end 		   exclusive
private int		position
public arrayinputstream
this null
private errorobjectinput oi
public arrayinputstream byte data
super
setdata data
oi   new org apache derby iapi services io formatidinputstream this
public arrayinputstream byte data  int offset  int length  throws ioexception
this data
setlimit offset  length
/*
** public methods
*/
/**
set the array of bytes to be read.
*/
public void setdata byte data
pagedata   data
clearlimit
public void setdata byte data  int offset  int length  throws ioexception
pagedata   data
setlimit offset  length
/**
return a reference to the array of bytes this stream is going to read
from so that caller may load it with stuff
*/
public byte getdata
return pagedata
/*
** methods of inputstream
*/
public int read   throws ioexception
if  position    end
return  1     end of file
return pagedata   0xff
public int read byte b  int off  int len  throws ioexception
if   position   len  > end
len   end   position
if  len    0
return  1     end of file
system arraycopy pagedata  position  b  off  len
position    len
return len
public long skip long count   throws ioexception
if   position   count  > end
count   end   position
if  count    0
return 0     end of file
position    count
return count
public int getposition
return position
public final void setposition int newposition
throws ioexception
if   newposition >  start      newposition < end
position   newposition
else
throw new eofexception
public int available   throws ioexception
return end   position
/**
a setlimit which also sets the position to be offset.
@exception ioexception limit is out of range
*/
public int setlimit int offset  int length  throws ioexception
if   offset < 0      length < 0
start   end   position   0
throw new eofexception
start   offset
end   offset   length
if  end > pagedata length
start   end   position   0
throw new eofexception
position   start
return length
/*
** methods of limit
*/
public final void setlimit int length  throws ioexception
start   position
end     position   length
if  end <  pagedata length
return
else
start   end   position   0
throw new eofexception
/**
clears the limit by setting the limit to be the entire byte array.
@see limit#clearlimit
*/
public final int clearlimit
if  pagedata    null
start   0
int remainingbytes   end   position
end   pagedata length
return remainingbytes
else
start   end   position   0
return 0
/*
** methods of datainput
*/
public final void readfully byte b  throws ioexception
readfully b  0  b length
public final void readfully byte b  int off  int len  throws ioexception
if   position   len  > end
throw new eofexception
system arraycopy pagedata  position  b  off  len
position    len
public final int skipbytes int n  throws ioexception
if   position   n  > end
throw new eofexception
position    n
return n
public final boolean readboolean   throws ioexception
if  position    end
throw new eofexception       end of file
return pagedata    0
public final byte readbyte   throws ioexception
if  position    end
throw new eofexception       end of file
return pagedata
public final int readunsignedbyte   throws ioexception
if  position    end
throw new eofexception       end of file
return pagedata   0xff
public final short readshort   throws ioexception
int pos   position
byte data   pagedata
if  pos >   end   1
throw new eofexception       end of file
int s     data   0xff  << 8     data   0xff
position   pos
return  short  s
public final int readunsignedshort   throws ioexception
int    pos    position
byte data   pagedata
if  pos >   end   1
throw new eofexception       end of file
int us     data   0xff  << 8     data   0xff
position   pos
return us
public final char readchar   throws ioexception
int    pos    position
byte data   pagedata
if  pos >   end  1
throw new eofexception       end of file
int c     data   0xff  << 8     data   0xff
position   pos
return  char  c
public final int readint   throws ioexception
int pos   position
byte data   pagedata
if  pos >   end   3
throw new eofexception       end of file
int i     data   0xff  << 24
data   0xff  << 16
data   0xff  <<  8
data   0xff
position   pos
return i
public final long readlong   throws ioexception
int    pos    position
byte data   pagedata
if  pos >   end   7
throw new eofexception       end of file
long l
long   data   0xff   << 56
long   data   0xff   << 48
long   data   0xff   << 40
long   data   0xff   << 32
long   data   0xff   << 24
long   data   0xff   << 16
long   data   0xff   <<  8
long   data   0xff
position   pos
return l
public final float readfloat   throws ioexception
return float intbitstofloat readint
public final double readdouble   throws ioexception
return double longbitstodouble readlong
public final string readline   throws ioexception
return oi readline
public final string readutf   throws ioexception
return oi readutf
/**
* read in a cloudscape utf formated string into a char[].
* <p>
* this routine inline's the code to read a utf format string from a
* byte[] array (pagedata), into a char[] array.  the string will
* be read into the char[] array passed into this routine through
* rawdata_array[0] if it is big enough.  if it is not big enough
* a new char[] will be alocated and returned to the caller by putting
* it into rawdata_array[0].
* <p>
* to see detailed description of the cloudscape utf format see
* the writeexternal() routine of sqlchar.
* <p>
* the routine returns the number of char's read into the returned
* char[], note that this length may smaller than the actual length
* of the char[] array.
*
* @return the the number of valid char's in the returned char[].
*
* @param rawdata_array this parameter uses a element array to implement
*                      an in/out function parameter.  the char[] array
*                      in rawdata_array[0] is used to read the data into
*                      unless it is not big enough, then a new array
*                      is allocated and the old one discarded.  in
*                      either case on return rawdata_array[0] contains
*                      the filled in char[] - caller must allow that
*                      the array may or may not be different from the
*                      one passed in.
*
* @exception  standardexception  standard exception policy.
**/
public final int readcloudscapeutf char rawdata_array
throws ioexception
// copy globals locally, to give compiler chance to optimize.
byte  data      pagedata
int     end_pos   end
int     pos       position
// get header length - stored as an unsigned short.
int utflen
if  pos   1 < end_pos
utflen      data   0xff  << 8     data   0xff
else
throw new eofexception       end of file
/**
* 3 cases - can they all happen?
*
* o utflen == 0 and end is marked e0, 0, 0
* o utflen == 0 and there is no data (ie. 0 length string)
* o utflen != 0, utflen is exact length of following bytes
**/
// requiredlength is the amount of bytes to read from the array,
// either the utflen in the header length, or the number of bytes
// available in the array.  throw an exception if we know up front
// that utflen is bigger than number of bytes in the array.
int requiredlength
if  utflen    0
// this is the only place we need to check for end of file,
// the subsequent loop will not read past bytes_available_in_array.
if  utflen <   end_pos   pos
requiredlength   utflen
else
throw new eofexception
else
// the byte header returned 0, so read what is left in the array.
requiredlength    end_pos   pos
// use the passed in char[] array if it is long enough, otherwise
// allocate a new array, and will pass it back to caller at the end.
// note that requiredlength is the worst case length for the array,
// as the number of char characters must be <= number of bytes (ie.
// all characters were stored compressed in 1 byte each - the ascii
// default) - if there are any 2 or 3 byte stored characters then
// the array will have extra space at the end.  "strlen" tracks the
// real number of char's in str[].
char str   rawdata_array
if   str    null      requiredlength > str length
str   new char
rawdata_array   str
end_pos   pos   requiredlength
int strlen   0
while  pos < end_pos
int char1    data   0xff
// top fours bits of the first unsigned byte that maps to a 1,2
// or 3 byte character
//
// 0000xxxx	- 0 - 1 byte char
// 0001xxxx - 1 - 1 byte char
// 0010xxxx - 2 - 1 byte char
// 0011xxxx - 3 - 1 byte char
// 0100xxxx - 4 - 1 byte char
// 0101xxxx - 5 - 1 byte char
// 0110xxxx - 6 - 1 byte char
// 0111xxxx - 7 - 1 byte char
// 1000xxxx - 8 - error
// 1001xxxx - 9 - error
// 1010xxxx - 10 - error
// 1011xxxx - 11 - error
// 1100xxxx - 12 - 2 byte char
// 1101xxxx - 13 - 2 byte char
// 1110xxxx - 14 - 3 byte char
// 1111xxxx - 15 - error
int char2  char3
if   char1   0x80     0x00
// one byte character
str    char  char1
else if   char1   0x60     0x40     we know the top bit is set here
// two byte character, make sure read of next byte is in bounds.
if  pos >  end_pos
throw new utfdataformatexception
char2    data   0xff
if   char2   0xc0     0x80
throw new utfdataformatexception
str    char    char1   0x1f  << 6     char2   0x3f
else if   char1   0x70     0x60     we know the top bit is set here
// three byte character
// 3 byte character, make sure read of next 2 bytes in bounds.
if  pos   1 >  end_pos
throw new utfdataformatexception
char2    data   0xff
char3    data   0xff
if   char1    0xe0
char2       0
char3       0
utflen    0
// we reached the end of a long string,
// that was terminated with
// (11100000, 00000000, 00000000)
break
else if    char2   0xc0     0x80       char3   0xc0     0x80
throw new utfdataformatexception
else
str    char
char1   0x0f  << 12
char2   0x3f  <<  6
char3   0x3f  <<  0
else
throw new utfdataformatexception
// update global on successful read exit.
position   pos
return strlen
/**
* read a compressed int from the stream.
* <p>
* read a compressed int from the stream, which is assumed to have
* been written by a call to compressnumber.writeint().
* <p>
* code from compressednumber is inlined here so that these fields can
* be read from the array with a minimum of function calls.
* <p>
* the format of a compressed int is as follows:
*
* formats are (with x representing value bits):
* <pre>
* 1 byte- 00xxxxxx                            val <= 63 (0x3f)
* 2 byte- 01xxxxxx xxxxxxxx                   val > 63 && <= 16383 (0x3fff)
* 4 byte- 1xxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx val > 16383 && <= max_int
* </pre>
*
* @exception  standardexception  standard exception policy.
**/
public final int readcompressedint
throws ioexception
int    pos    position
byte data   pagedata
try
int value   data
if   value   ~0x3f     0
// entire value is stored in this byte, we also know that the
// 0x80 bit was not set, so no need to mask off the sign
// extension from the byte to int conversion.
else if   value   0x80     0
// value stored in 2 bytes.  only use low 6 bits from 1st byte.
if  sanitymanager debug
sanitymanager assert  value   0x40     0x40
// top 8 bits of 2 byte value is stored in this byte, we also
// know that the 0x80 bit was not set, so no need to mask off
// the sign extension from the 1st byte to int conversion.
// need to mask the byte in data[pos + 1] to account for
// possible sign extension.
value
value   0x3f  << 8     data   0xff
else
// value stored in 4 bytes.  only use low 7 bits from 1st byte.
if  sanitymanager debug
sanitymanager assert  value   0x80     0x80
// top 8 bits of 4 byte value is stored in this byte, we also
// know that the 0x80 bit was set, so need to mask off the
// sign extension from the 1st byte to int conversion.  need to
// mask the bytes from the next 3 bytes data[pos + 1,2,3] to
// account for possible sign extension.
//
value
value         0x7f  << 24
data   0xff  << 16
data   0xff  <<  8
data   0xff
position   pos
return value
catch  java lang arrayindexoutofboundsexception ex
throw new eofexception       end of file
/**
* read a compressed long from the stream.
* <p>
* read a compressed long from the stream, which is assumed to have
* been written by a call to compressnumber.writelong().
* <p>
* code from compressednumber is inlined here so that these fields can
* be read from the array with a minimum of function calls.
* <p>
* the format of a compressed int is as follows:
*
* formats are (with x representing value bits):
* <pre>
* value <= 16383 (0x3fff):
*     2 byte - 00xxxxxx xxxxxxxx
*
* value > 16383 && <= 0x3fffffff:
*     4 byte - 01xxxxxx xxxxxxxx xxxxxxxx xxxxxxxx
*
* value > 0x3fffffff && <= max_long:
*     8 byte - 1xxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx
* </pre>
*
**/
public final long readcompressedlong
throws ioexception
try
// copy globals locally, to give compiler chance to optimize.
int     pos           position
byte  data          pagedata
// int_value tells whether it is 1, 4, or 8 bytes long.
int     int_value     data
// build up long value and return it through this variable.
long    long_value
if   int_value   ~0x3f     0
// 2 byte representation
// 1st byte of value is stored in int_value, we also know that
// the 0x80 bit was not set, so no need to mask off the sign
// extension from the 1st byte to int conversion.
long_value     int_value << 8     data   0xff
else if   int_value   0x80     0
// value stored in 4 bytes.  only use low 6 bits from 1st byte.
// need to mask the bytes from the next 3 bytes
// data[pos + 1,2,3] to account for possible sign extension.
long_value
int_value     0x3f  << 24
data   0xff  << 16
data   0xff  <<  8
data   0xff
else
// top 7 bits of 4 byte value is stored in int_value, we also
// know that the 0x80 bit was set, so need to mask off the
// sign extension from the 1st byte to int conversion.  need to
// mask the bytes from the next 7 bytes data[pos + 1,2,...] to
// account for possible sign extension.
//
// value stored in 8 bytes.  only use low 6 bits from 1st byte.
long_value
long   int_value     0x7f   << 56
long   data   0xff   << 48
long   data   0xff   << 40
long   data   0xff   << 32
long   data   0xff   << 24
long   data   0xff   << 16
long   data   0xff   <<  8
long   data   0xff
position   pos
return long_value
catch  java lang arrayindexoutofboundsexception ex
// let java figure out if we went past end of data[] array.
throw new eofexception       end of file
public object readobject   throws classnotfoundexception  ioexception
return oi readobject
public string geterrorinfo
return oi geterrorinfo
public exception getnestedexception
return oi getnestedexception