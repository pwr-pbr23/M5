/*
derby - class org.apache.derby.client.net.netlogwriter
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby client net
// network traffic tracer.
// this class traces communication buffers for both sends and receives.
// the value of the hex bytes are traced along with the ascii and ebcdic translations.
public class netlogwriter extends org apache derby client am logwriter
// the recevie constant is used to indicate that the bytes were read to a stream.
// it indicates to this class that a receive header should be used.
public static final int type_trace_receive   2
// the send constant is used to indicate that the bytes were written to
// a stream.  it indicates to this class that a send header should be used.
public static final int type_trace_send   1
//------------------------------ internal constants --------------------------
// this class was implemented using character arrays to translate bytes
// into ascii and ebcdic.  the goal was to be able to quickly index into the
// arrays to find the characters.  char arrays instead of strings were used as
// much as possible in an attempt to help speed up performance.
// an array of characters used to translate bytes to ascii.
// the position in the array corresponds to the hex value of the character.
private static final char asciichar__
// 0   1   2   3   4   5   6   7   8   9   a   b   c   d   e   f
0
1
2
3
4
5
6
7
8
9
a
b
c
d
e
f
// this column position header is used to mark offsets into the trace.
private static final string colposheader__
// an array of characters used to translate bytes to ebcdic.
// the position in the array corresponds to the hex value of the
// character.
private static final char ebcdicchar__
// 0   1   2   3   4   5   6   7   8   9   a   b   c   d   e   f
0
1
2
3
4
5
6
7
8
9
a
b
c
d
e
f
// an array of characters representing hex numbers.
private static final char hexdigit__
// the receive header comes befor bytes which would be read from a stream.
private static final string receiveheader__
// the send header comes before bytes which would be written to a stream.
private static final string sendheader__
private static final char spacechar__
private static final char zerochar__
// this mapping table associates a codepoint to a string describing the codepoint.
// this is needed because the trace prints the first codepoint in send and receive buffers.
// this is created lazily because there is no need to create the mapping if tracing isn't used.
// so this array will only be created when the com buffer trace is started.
private static codepointnametable codepointnametable__   null
//-----------------------------internal state---------------------------------
//-----------------------------constructors/finalizer-------------------------
// one netlogwriter object is created per data source, iff tracing is enabled.
public netlogwriter java io printwriter printwriter  int tracelevel
super printwriter  tracelevel
// initialize the codepoint name table if not previously initialized.
// this is done lazily so that it is not created if the trace isn't used (save some init time).
if  codepointnametable__    null
codepointnametable__   new codepointnametable
//------------------------------entry points----------------------------------
// specialization of logwriter.traceconnectsexit()
public void traceconnectsexit org apache derby client am connection connection
if  tracesuspended
return
netconnection c    netconnection  connection
synchronized  printwriter_
super traceconnectsexit c
dncnetprint
printwriter_ print     c getsqlam
printwriter_ print     c getagent
printwriter_ print     c getcmntcpip
printwriter_ print     c getrdb
printwriter_ print     c getsecmgr
printwriter_ print     c getxamgr
printwriter_ print     c getsyncptmgr
printwriter_ print     c getrsyncmgr
printwriter_ println
printwriter_ flush
public void traceconnectsresetexit org apache derby client am connection connection
if  tracesuspended
return
netconnection c    netconnection  connection
synchronized  printwriter_
super traceconnectsresetexit c
dncnetprint
printwriter_ print     c getsqlam
printwriter_ print     c getagent
printwriter_ print     c getcmntcpip
printwriter_ print     c getrdb
printwriter_ print     c getsecmgr
printwriter_ print     c getxamgr
printwriter_ print     c getsyncptmgr
printwriter_ print     c getrsyncmgr
printwriter_ println
printwriter_ flush
// pass the connection handle and print it in the header
// what exactly is supposed to be passed,  assume one complete dss packet
// write the communication buffer data to the trace.
// the data is passed in via a byte array.  the start and length of the data is given.
// the type is needed to indicate if the data is part of the send or receive buffer.
// the class name, method name, and trcpt number are also written to the trace.
// not much checking is performed on the parameters.  this is done to help performance.
synchronized public void traceprotocolflow byte buff
int offset
int len
int type
string classname
string methodname
int tracepoint
if  tracesuspended
return
if   loggingenabled org apache derby jdbc clientdatasource trace_protocol_flows
return
synchronized  printwriter_
super tracepoint    tracepoint  classname  methodname
int fulllen   len
boolean printcolpos   true
while  fulllen >  2       format each dsshdr seperately
// get the length of this dsshdr
len     buff   0xff  << 8      buff   0xff  << 0
// check for valid dss header or not all of dss block
if   len < 10      len > fulllen
len   fulllen
// subtract that length from the full length
fulllen    len
// the data will only be written if there is a non-zero positive length.
if  len    0
string codepointname   null
// if the length <= 10, lookup the first codepoint so it's name can be printed
if  len >  10
// get the int value of the two byte unsigned codepoint.
int codepoint   getcodepoint buff  offset   8
codepointname   codepointnametable__ lookup codepoint
// if this is not a valid codepoint then format the entire buffer
// as one block.
if  codepointname    null
len    fulllen
fulllen   0
if   printcolpos       not 1st dss header of this buffer  write seperator
dncnetprintln
if  codepointname    null
// codepointname was still null so either < 10 bytes were given or
// the codepoint wasn't found in the table.  just print the plain send header.
dncnetprintln getheader type
else
// codepointname isn't null so the name of the codepoint will be printed.
printheaderwithcodepointname codepointname  type
// print the col position header in the trace.
if  printcolpos       first dss header of buffer  need column position header
dncnetprintln colposheader__
printcolpos   false
// a char array will be used to translate the bytes to their character
// representations along with ascii and ebcdic representations.
char trcdump   new char
// bcounter, acounter, ecounter are offsets used to help position the characters
short bcounter   7
short acounter   43
short ecounter   61
// the lines will be counted starting at zero.
// this is hard coded since we are at the beginning.
trcdump   zerochar__
trcdump   zerochar__
trcdump   zerochar__
trcdump   zerochar__
// the 0's are already in the trace so bump the line counter up a row.
int linecounter   0x10
// make sure the character array has all blanks in it.
// some of these blanks will be replaced later with values.
// the 0's were not wrote over.
for  int j   4  j < 77  j
trcdump   spacechar__
// i will maintain the position in the byte array to be traced.
int i   0
do
// get the unsigned value of the byte.
//                  int num = b[off++] & 0xff;
int num    buff < 0  ? buff   256   buff
offset
i
// place the characters representing the bytes in the array.
trcdump   hexdigit__
trcdump   hexdigit__
// place the ascii and ebcdc representations in the array.
trcdump   asciichar__
trcdump   ebcdicchar__
if    i % 8     0
if    i % 16     0
// print the array each time 16 bytes are processed.
dncnetprintln trcdump
if  i    len
// not yet at the end of the byte array.
if   len   i  < 16
// this is the last line so blank it all out.
// this keeps the last line looking pretty in case
// < 16 bytes remain.
for  int j   0  j < trcdump length  j
trcdump   spacechar__
// reset the counters.
bcounter   0
acounter   43
ecounter   61
// reset the linecounter if it starts to get too large.
if  linecounter    0x100000
linecounter   0
// place the characters representing the line counter in the array.
trcdump   hexdigit__
trcdump   hexdigit__
trcdump   hexdigit__
trcdump   hexdigit__
bcounter    3
// bump up the line counter.
linecounter    0x10
else
// 8 bytes were processed so move the counter to adjust for
// spaces between the columns of bytes.
bcounter    2
// do this until we all the data has been traced.
while  i < len
// print the last line and add some blank lines to make it easier to read.
if  len % 16    0
dncnetprintln trcdump
dncnetprintln
// gets the int value of the two byte unsigned codepoint.
private static int getcodepoint byte buff  int offset
return   buff   0xff  << 8
buff   0xff  << 0
private static string getheader int type
switch  type
case type_trace_send
return sendheader__
case type_trace_receive
return receiveheader__
default
return null
private static int getstartposition int type
switch  type
case type_trace_send
return 20     this is right after
case type_trace_receive
return 23     this is right after
default
return 0
private void printheaderwithcodepointname string codepointname  int type
// create a char array so some of the characters
// can be replaced with the name of the codepoint.
char headerarray   getheader type  tochararray
// at most, 16 character name will be used.  this is so
// the headers on top of the ascii and ebcdic rows aren't shifted.
int replacelen    codepointname length   < 17  ? codepointname length     16
int offset   getstartposition type
for  int i   0  i < replacelen  i
headerarray   codepointname charat i
dncnetprintln headerarray
private void dncnetprint string s
synchronized  printwriter_
printwriter_ print     s
printwriter_ flush
private void dncnetprintln string s
synchronized  printwriter_
printwriter_ println     s
printwriter_ flush
private void dncnetprintln char s
synchronized  printwriter_
printwriter_ print
printwriter_ println s
printwriter_ flush