/*
derby - class org.apache.derby.iapi.store.access.genericscancontroller
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby iapi store access
import org apache derby iapi services io storable
import org apache derby iapi error standardexception
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi types rowlocation
import org apache derby iapi services io formatablebitset
/**
the set of interfaces implemented by all types of scancontrollers.
<p>
a scan is the mechanism for iterating over the rows in a conglomerate,
the scan controller is the interface through which access clients
control the underlying scan.  an instance of a scan controller can
be thought of as an open scan.
<p>
scans are opened from a transactioncontroller.
<p>
a scancontroller can handle partial rows. partial rows are described in
rowutil.
<br>
a scan controller is opened with a formatablebitset that describes the
columns that need to be returned on a fetch call. this formatablebitset
need not include any columns referenced in the qualifers, start
and/or stop keys.
@see transactioncontroller#openscan
@see rowcountable
@see rowutil
**/
public interface genericscancontroller extends rowcountable
/**
close the scan.  this method always succeeds, and never throws
any exceptions. callers must not use the scan controller after
closing it; they are strongly advised to clear out the scan
controller reference after closing.
@exception  standardexception  standard exception policy.
**/
void close
throws standardexception
/**
* return scaninfo object which describes performance of scan.
* <p>
* return scaninfo object which contains information about the current
* state of the scan.
* <p>
* the statistics gathered by the scan are not reset to 0 by a reopenscan(),
* rather they continue to accumulate.
* <p>
*
*
* @see scaninfo
*
* @return the scaninfo object which contains info about current scan.
*
* @exception  standardexception  standard exception policy.
**/
scaninfo getscaninfo
throws standardexception
/**
* return whether this is a keyed conglomerate.
* <p>
*
* @return whether this is a keyed conglomerate.
**/
boolean iskeyed
/**
* return whether this scan is table locked.
* <p>
* implementation of this is not complete.  currently it does not give back
* the right information on covering locks or lock escalation.  if the
* openscan() caller specifies a mode_table as the lock_level then this
* routine will always return true.  if the openscan() caller specifies a
* mode_record as the lock_level then this routine will return true iff
* the lock level of the system has been overridden either by the
* derby.storage.rowlocking=false property, or by a shipped
* configuration which disables row locking.
* <p>
*
* @return whether this scan is table locked.
**/
boolean istablelocked
/**
* return a row location object to be used in calls to fetchlocation.
* <p>
* return a row location object of the correct type to be used in calls to
* fetchlocation.
* <p>
*
* @return a row location object to be used in calls to fetchlocation.
*
* @exception  standardexception  standard exception policy.
**/
rowlocation newrowlocationtemplate
throws standardexception
/**
reposition the current scan.  this call is semantically the same as if
the current scan had been closed and a openscan() had been called instead.
the scan is reopened with against the same conglomerate, and the scan
is reopened with the same "scan column list", "hold" and "forupdate"
parameters passed in the original openscan.
<p>
the statistics gathered by the scan are not reset to 0 by a reopenscan(),
rather they continue to accumulate.
<p>
@param startkeyvalue  an indexable row which holds a
(partial) key value which, in combination with the
startsearchoperator, defines the starting position of
the scan.  if null, the starting position of the scan
is the first row of the conglomerate.
@param startsearchoperator an operator which defines
how the startkeyvalue is to be searched for.  if
startsearchoperator is scancontroller.ge, the scan starts on
the first row which is greater than or equal to the
startkeyvalue.  if startsearchoperation is scancontroller.gt,
the scan starts on the first row whose key is greater than
startkeyvalue.  the startsearchoperation parameter is
ignored if the startkeyvalue parameter is null.
@param qualifier an array of qualifiers which, applied
to each key, restrict the rows returned by the scan.  rows
for which any one of the qualifiers returns false are not
returned by the scan. if null, all rows are returned.
@param stopkeyvalue  an indexable row which holds a
(partial) key value which, in combination with the
stopsearchoperator, defines the ending position of
the scan.  if null, the ending position of the scan
is the last row of the conglomerate.
@param stopsearchoperator an operator which defines
how the stopkeyvalue is used to determine the scan stopping
position. if stopsearchoperation is scancontroller.ge, the scan
stops just before the first row which is greater than or
equal to the stopkeyvalue.  if stopsearchoperation is
scancontroller.gt, the scan stops just before the first row whose
key is greater than	startkeyvalue.  the stopsearchoperation
parameter is ignored if the stopkeyvalue parameter is null.
@exception standardexception standard exception policy.
**/
void reopenscan
datavaluedescriptor   startkeyvalue
int                     startsearchoperator
qualifier               qualifier
datavaluedescriptor   stopkeyvalue
int                     stopsearchoperator
throws standardexception
/**
reposition the current scan.  this call is semantically the same as if
the current scan had been closed and a openscan() had been called instead.
the scan is reopened against the same conglomerate, and the scan
is reopened with the same "scan column list", "hold" and "forupdate"
parameters passed in the original openscan.
<p>
the statistics gathered by the scan are not reset to 0 by a reopenscan(),
rather they continue to accumulate.
<p>
note that this operation is currently only supported on heap conglomerates.
also note that order of rows within are heap are not guaranteed, so for
instance positioning at a rowlocation in the "middle" of a heap, then
inserting more data, then continuing the scan is not guaranteed to see
the new rows - they may be put in the "beginning" of the heap.
@param startrowlocation  an existing rowlocation within the conglomerate,
at which to position the start of the scan.  the scan will begin at this
location and continue forward until the end of the conglomerate.
positioning at a non-existent rowlocation (ie. an invalid one or one that
had been deleted), will result in an exception being thrown when the
first next operation is attempted.
@param qualifier an array of qualifiers which, applied
to each key, restrict the rows returned by the scan.  rows
for which any one of the qualifiers returns false are not
returned by the scan. if null, all rows are returned.
@exception standardexception standard exception policy.
**/
void reopenscanbyrowlocation
rowlocation startrowlocation
qualifier qualifier
throws standardexception