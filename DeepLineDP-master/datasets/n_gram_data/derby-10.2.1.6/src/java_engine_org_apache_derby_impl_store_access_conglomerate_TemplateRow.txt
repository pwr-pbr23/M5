/*
derby - class org.apache.derby.impl.store.access.conglomerate.templaterow
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl store access conglomerate
import org apache derby iapi reference sqlstate
import org apache derby iapi services monitor monitor
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi services io storable
import org apache derby iapi error standardexception
import org apache derby iapi store access rowutil
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi types sqllongint
import org apache derby iapi services io formatablebitset
public final class templaterow
/*
** constructors of templaterow
*/
private templaterow
/* private/protected methods of this class: */
/**
* allocate new objects to array based on format id's and column_list.
* <p>
*
* @param num_cols_to_allocate  the number of columns to allocate for array.
* @param column_list           description of partial set of columns to
*                              built as described in rowutil.  if null do
*                              all the columns.
* @param format_ids            an array of format ids representing every
*                              column in the table.  column_list describes
*                              which of these columns to populate into the
*                              columns array.
*
* @exception  standardexception  standard exception policy.
**/
private static datavaluedescriptor allocate_objects
int                 num_cols_to_allocate
formatablebitset    column_list
int               format_ids
throws standardexception
int         dest_pos   0
datavaluedescriptor ret_row
new datavaluedescriptor
int         num_cols
column_list    null ? format_ids length   column_list size
for  int i   0  i < num_cols  i
// does caller want this column?
if   column_list    null       column_list get i
// no - column should be skipped.
else
// yes - create the column
// get empty instance of object identified by the format id.
ret_row    datavaluedescriptor
monitor newinstancefromidentifier format_ids
if  sanitymanager debug
datavaluedescriptor o   ret_row
if  o    null
sanitymanager throwassert
i
i
num_cols
format_ids length
if      o instanceof storable
sanitymanager throwassert
o getclass        o
return ret_row
/* public methods of this class: */
/**
constuctor for creating a template row which stores n sqllongint's
**/
public static datavaluedescriptor newu8row int nkeys
datavaluedescriptor columns   new datavaluedescriptor
for  int i   0  i < columns length  i
columns   new sqllongint long min_value
return columns
/**
* generate an "empty" row to match the format id specification.
* <p>
* generate an array of new'd objects matching the format id specification
* passed in.  this routine is mostly used by the btree code to generate
* temporary rows needed during operations like split.  it is more
* efficient to allocate new objects based on the old object vs. calling
* the monitor.
* <p>
*
*
* @param template      an array which represents a row as described in
*                      rowutil.
*
* @exception  standardexception  standard exception policy.
*
* @return the new row.
*
* @see rowutil
**/
public static datavaluedescriptor newrow
datavaluedescriptor    template
throws standardexception
datavaluedescriptor columns
new datavaluedescriptor
try
for  int i   template length  i   > 0
// get empty instance of object identified by the format id.
columns
datavaluedescriptor  template getclass   newinstance
catch  throwable t
// resolve - dan is investigating ways to change the monitor
// so that it provides the functionality required here, when
// that happens i will just all the monitor and let any
// standarderror that come back just go on up.
throw standardexception newexception
sqlstate conglomerate_template_create_error
return columns
/**
* generate an "empty" row to match the format id specification.
* <p>
* generate an array of new'd objects matching the format id specification
* passed in.  this routine is mostly used by the btree code to generate
* temporary rows needed during operations like split.
* <p>
*
* @return the new row.
*
* @param format_ids an array of format id's, one per column in row.
*
* @exception  standardexception  standard exception policy.
**/
public static datavaluedescriptor newrow
formatablebitset     column_list
int        format_ids
throws standardexception
return allocate_objects format_ids length  column_list  format_ids
/**
* generate an "empty" row to match the format id + coluumn specification.
* <p>
* generate an array of new'd objects matching the format id specification
* passed in, and the column passed in.  the new row is first made up of
* columns matching the format ids, and then followed by one other column
* matching the column passed in.  this routine is mostly used by the
* btree code to generate temporary branch rows needed during operations
* like split.
* <p>
*
* @return the new row.
*
* @param format_ids an array of format id's, one per column in row.
* @param page_ptr   the object to place in the last column of the template.
*
* @exception  standardexception  standard exception policy.
**/
public static datavaluedescriptor newbranchrow
int               format_ids
datavaluedescriptor page_ptr
throws standardexception
// allocate an object array with the number of columns in the template
// row (ie. number of columns in the leaf row) + one column to hold
// the page pointer in the branch row.
datavaluedescriptor columns
allocate_objects
format_ids length   1   formatablebitset  null  format_ids
// tack on the page pointer to the extra column allocated onto the
// end of the row built from a leafrow template.
columns   page_ptr
return columns
/**
* check that columns in the row conform to a set of format id's,
* both in number and type.
*
* @return boolean indicating if template matches format id's
*
* @param format_ids array of format ids which are the types of cols in row
* @param row        the array of columns that make up the row.
*
* @exception  standardexception  standard exception policy.
**/
static public boolean checkcolumntypes
int                   format_ids
datavaluedescriptor   row
throws standardexception
boolean ret_val   true
while  true
int ncols   row length
if  format_ids length    row length
if  sanitymanager debug
sanitymanager throwassert
format_ids length
row length
ret_val   false
break
if  sanitymanager debug
object  column
object  column_template
for  int colid   0  colid < ncols  colid
column   row
if  column    null
sanitymanager throwassert
colid
column_template
monitor newinstancefromidentifier format_ids
// is this the right check?
if  column getclass      column_template getclass
sanitymanager debug_print
rowutil tostring row
sanitymanager throwassert
colid     column getclass
column_template getclass
column
row
break
return ret_val
/**
* check that columns in the row conform to a set of format id's,
* both in number and type.
*
* @return boolean indicating if template matches format id's
*
* @param format_ids array of format ids which are the types of cols in row
* @param row        the array of columns that make up the row.
*
* @exception  standardexception  standard exception policy.
**/
static public boolean checkpartialcolumntypes
int                   format_ids
formatablebitset                 validcolumns
int                   fieldstates
datavaluedescriptor   row
throws standardexception
boolean ret_val   true
return ret_val