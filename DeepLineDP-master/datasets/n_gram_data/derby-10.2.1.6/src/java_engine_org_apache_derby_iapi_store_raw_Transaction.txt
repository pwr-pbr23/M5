/*
derby - class org.apache.derby.iapi.store.raw.transaction
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby iapi store raw
import org apache derby iapi services daemon serviceable
import org apache derby iapi error standardexception
import org apache derby iapi store raw log loginstant
import org apache derby iapi store access fileresource
import org apache derby iapi store access rowsource
import org apache derby iapi store access transactioncontroller
import org apache derby iapi services context contextmanager
import java util properties
import org apache derby iapi services property persistentset
import org apache derby iapi error exceptionseverity
/**
*/
public interface transaction
/**
return the context manager this transaction is associated with.
*/
public contextmanager getcontextmanager
/**
* get the compatibility space of the transaction.
* <p>
* returns an object that can be used with the lock manager to provide
* the compatibility space of a transaction.  2 transactions with the
* same compatibility space will not conflict in locks.  the usual case
* is that each transaction has it's own unique compatibility space.
* <p>
*
* @return the compatibility space of the transaction.
**/
object getcompatibilityspace
/**
called after the transaction has been attached to an access manger
transactioncontroller. thus may not be called for all transactions.
purpose is to allow a transaction access to database (service) properties.
will not be called for transactions early in the boot process, ie. before
the property conglomerate is set up.
@exception standardexception  standard cloudscape exception policy
*/
public void setup persistentset set
throws standardexception
/**
return my transaction identifier. transaction identifiers may be
re-used for transactions that do not modify the raw store.
may return null if this transaction has no globalid.
*/
public globaltransactionid getglobalid
/**
get the current default locking policy for all operations within this
transaction. the transaction is initially started with a default
locking policy equivalent to
<pre>
newlockingpolicy(
lockingpolicy.mode_record, lockingpolicy.isolation_serializable, true);
</pre>
this default can be changed by subsequent calls to
setdefaultlockingpolicy(lockingpolicy policy).
@return the current default locking policy in this transaction.
*/
public lockingpolicy getdefaultlockingpolicy
/**
obtain a locking policy for use in opencontainer(). the mode
and isolation must be constants from lockingpolicy. if higherok is true
then the object returned may implement a stricter form of locking than
the one requested.
<br>
a null lockingpolicy reference is identical to a lockingpolicy obtained
by using mode_none which is guaranteed to exist.
@param mode a constant of the form lockingpolicy.mode_*
@param isolation a constant of the form lockingpolicy.isolation_*
@param stricterok true if a stricter level of locking is acceptable,
false if an exact match is required.
@return a object that can be used in an opencontainer call,
null if a matching policy cannot be found.
*/
public lockingpolicy newlockingpolicy int mode  int isolation  boolean stricterok
/**
set the default locking policy for all operations within this
transaction. the transaction is intially started with a default
locking policy equivalent to
<pre>
newlockingpolicy(
lockingpolicy.mode_record, lockingpolicy.isolation_serializable, true);
</pre>
@param policy the lock policy to use, if null then then a no locking
policy will be installed as the default.
*/
public void setdefaultlockingpolicy lockingpolicy policy
/**
commit this transaction. all savepoints within this transaction are
released.
@return the commit instant of this transaction, or null if it
didn't make any changes
@exception standardexception
a transaction level exception is thrown
if the transaction was aborted due to some error. any exceptions that
occur of lower severity than transaction severity are caught, the
transaction is then aborted and then an exception of transaction
severity is thrown nesting the original exception.
@exception standardexception any exception more severe than a
transaction exception is not caught and the transaction is not aborted.
the transaction will be aborted by the standard context mechanism.
*/
public loginstant commit   throws standardexception
/**
"commit" this transaction without sync'ing the log.
everything else is identical to commit(), use this at your own risk.
<br>bits in the commitflag can turn on to fine tuned the "commit":
keep_locks - no locks will be released by the commit and no post commit
processing will be initiated.  if, for some reasons, the locks cannot be
kept even if this flag is set, then the commit will sync the log, i.e.,
it will revert to the normal commit.
@exception standardexception
a transaction level exception is thrown
if the transaction was aborted due to some error. any exceptions that
occur of lower severity than transaction severity are caught, the
transaction is then aborted and then an exception of transaction
severity is thrown nesting the original exception.
@exception standardexception any exception more severe than a
transaction exception is not caught and the transaction is not aborted.
the transaction will be aborted by the standard context mechanism.
*/
public loginstant commitnosync int commitflag  throws standardexception
public final int release_locks   transactioncontroller release_locks
public final int keep_locks   transactioncontroller keep_locks
/**
abort all changes made by this transaction since the last commit, abort
or the point the transaction was started, whichever is the most recent.
all savepoints within this transaction are released.
@exception standardexception only exceptions with severities greater
than exceptionseverity.transaction_severity will be thrown.
*/
public void abort   throws standardexception
/**
close this transaction, the transaction must be idle. this close will
pop the transaction context off the stack that was pushed when the
transaction was started.
@see rawstorefactory#starttransaction
@exception standardexception standard cloudscape error policy
@exception standardexception a transaction level exception is
thrown if the transaction is not idle.
*/
public void close   throws standardexception
/**
if this transaction is not idle, abort it.  after this call close().
@see rawstorefactory#starttransaction
@exception standardexception standard cloudscape error policy
@exception standardexception a transaction level exception is
thrown if the transaction is not idle.
*/
public void destroy   throws standardexception
/**
set a save point in the current transaction. a save point defines a
point in time in the transaction that changes can be rolled back to.
savepoints can be nested and they behave like a stack. setting save
points "one" and "two" and the rolling back "one" will rollback all
the changes made since "one" (including those made since "two") and
release savepoint "two".
@param name     the user provided name of the savepoint
@param	kindofsavepoint	 a null value means it is an internal savepoint (ie not a user defined savepoint)
non null value means it is a user defined savepoint which can be a sql savepoint or a jdbc savepoint
a string value for kindofsavepoint would mean it is sql savepoint
a jdbc savepoint object value for kindofsavepoint would mean it is jdbc savepoint
@return returns total number of savepoints in the stack.
@exception standardexception  standard cloudscape exception policy
@exception standardexception
a statement level exception is thrown if a savepoint already
exists in the current transaction with the same name.
*/
public int setsavepoint string name  object kindofsavepoint  throws standardexception
/**
release the save point of the given name. relasing a savepoint removes
all knowledge from this transaction of the named savepoint and any
savepoints set since the named savepoint was set.
@param name     the user provided name of the savepoint, set by the user
in the setsavepoint() call.
@param	kindofsavepoint	 a null value means it is an internal savepoint (ie not a user defined savepoint)
non null value means it is a user defined savepoint which can be a sql savepoint or a jdbc savepoint
a string value for kindofsavepoint would mean it is sql savepoint
a jdbc savepoint object value for kindofsavepoint would mean it is jdbc savepoint
@return returns total number of savepoints in the stack.
@exception standardexception  standard cloudscape exception policy
@exception standardexception
a statement level exception is thrown if a savepoint already
exists in the current transaction with the same name.
*/
public int releasesavepoint string name  object kindofsavepoint  throws standardexception
/**
rollback all changes made since the named savepoint was set. the named
savepoint is not released, it remains valid within this transaction, and
thus can be named it future rollbacktosavepoint() calls. any savepoints
set since this named savepoint are released (and their changes rolled
back).
@param name     the user provided name of the savepoint, set by the user
in the setsavepoint() call.
@param	kindofsavepoint	 a null value means it is an internal savepoint (ie not a user defined savepoint)
non null value means it is a user defined savepoint which can be a sql savepoint or a jdbc savepoint
a string value for kindofsavepoint would mean it is sql savepoint
a jdbc savepoint object value for kindofsavepoint would mean it is jdbc savepoint
@return returns total number of savepoints in the stack.
@exception standardexception  standard cloudscape exception policy
@exception standardexception
a statement level exception is thrown if no savepoint exists with
the given name.
*/
public int rollbacktosavepoint string name  object kindofsavepoint  throws standardexception
/**
open a container, with the transaction's default locking policy.
<p>
note that if nowait has been specified lock will be
requested with no wait time, and if lock is not granted a
sqlstate.lock_timeout exception will be thrown.
<p>
the release() method of containerhandle will be called when this
transaction is aborted or commited, it may be called explicitly to
release the containerhandle before the end of the transaction.
@return a valid containerhandle or null if the container does not exist.
@exception standardexception  standard cloudscape exception policy
*/
public containerhandle opencontainer containerkey containerid   int mode
throws standardexception
/**
open a container, with the defined locking policy, otherwise
as opencontainer(int containerid,  boolean forupdate).
<p>
calls locking.lockcontainer(this, returnvalue, forupdate) to lock the
container.  note that if nowait has been specified lock will be
requested with no wait time, and if lock is not granted a
sqlstate.lock_timeout exception will be thrown.
@param locking the lock policy to use, if null then then a no locking
policy will be used.
@return a valid containerhandle or null if the container does not exist.
@exception standardexception  standard cloudscape exception policy
*/
public containerhandle opencontainer
containerkey    containerid
lockingpolicy   locking
int             mode
throws standardexception
/**
add a new container to the segment. the new container initially has
one page, page container.first_page_number.
<br>
if pagesize is equal to containerhandle.default_pagesize or invalid
then a default page size will be picked.
<br>
sparespace indicates that percent (0% - 100%) of page space that will
be attempted to be reserved for updates. e.g. with a value of 20 a page
that would normally hold 40 rows will be limited to 32 rows,
actual calculation for the threshold where no more inserts are all
accepted is up to the implementation.  whatever the value of
spacespace an empty page will always accept at least one insert.
if spare space is equal to containerhandle.default_pagesize or invalid
then a default value will be used.
<p><b>synchronisation</b>
<p>
the new container is exclusivly locked by this transaction until
it commits.
@param segmentid    segment to create the container in.
@param containerid  if not equal to 0 then this container id will be
used to create the container, else if set to 0 then
the raw store will assign a number.
@param mode mode description in @see containerhandle.  this mode is
only effective for the duration of the addcontainer call and not stored
persistently for the lifetime of the container.
@param tableproperties implementation-specific properties of the
conglomerate.
@return a container identifer that can be used in opencontainer()
this id is only valid within this rawstorefactory.  returns a negative
number if a container could not be allocated.
@exception standardexception standard cloudscape error policy
*/
public long addcontainer
long        segmentid
long        containerid
int         mode
properties  tableproperties
int         temporaryflag
throws standardexception
/**
drop a container.
<p><b>synchronisation</b>
<p>
this call will mark the container as dropped and then obtain an cx lock
on the container. once a container has been marked as dropped it cannot
be retrieved by any opencontainer() call.
<p>
once the exclusive lock has been obtained the container is removed
and all its pages deallocated. the container will be fully removed
at the commit time of the transaction.
@exception standardexception standard cloudscape error policy
*/
public void dropcontainer containerkey containerid
throws standardexception
/**
add a new stream container to the segment and load the stream container.
this stream container doesn't not have locks, and do not log.
it does not have the concept of a page.
it is used by the external sort only.
<p><b>synchronisation</b>
<p>
this call will mark the container as dropped and then obtain an cx lock
on the container. once a container has been marked as dropped it cannot
be retrieved by any opencontainer() call.
<p>
once the exclusive lock has been obtained the container is removed
and all its pages deallocated. the container will be fully removed
at the commit time of the transaction.
@exception standardexception standard cloudscape error policy
*/
public long addandloadstreamcontainer
long segmentid  properties tableproperties  rowsource rowsource
throws standardexception
/**
open a stream container.
@return a valid streamcontainerhandle or null if the container does not exist.
@exception standardexception  standard cloudscape exception policy
*/
public streamcontainerhandle openstreamcontainer
long    segmentid
long    containerid
boolean hold
throws standardexception
/**
drop a stream container.
<p><b>synchronisation</b>
<p>
this call will remove the container.
@exception standardexception standard cloudscape error policy
*/
public abstract void dropstreamcontainer long segmentid  long containerid
throws standardexception
/**
log an operation and then action it in the context of this transaction.
the loggable operation is logged in the transaction log file and then
its dome method is called to perform the required change. if this
transaction aborts or a rollback is performed of the current savepoint
(if any) then a compensation operation needs to be generated that will
compensate for the change of this operation.
@param operation the operation that is to be applied
@see loggable
@exception standardexception  standard cloudscape exception policy
*/
public void loganddo loggable operation  throws standardexception
/**
add to the list of post commit work that may be processed after this
transaction commits.  if this transaction aborts, then the post commit
work list will be thrown away.  no post commit work will be taken out
on a rollback to save point.
@param work the post commit work that is added
*/
public void addpostcommitwork serviceable work
/**
add to the list of post termination work that may be processed after this
transaction commits or aborts.
@param work the post termination work that is added
*/
public void addpostterminationwork serviceable work
/**
* reveals whether the transaction has ever read or written data.
*
* @return true if the transaction has never read or written data.
**/
public boolean isidle
/**
reveal whether the transaction is in a pristine state, which
means it hasn't done any updates since the last commit.
@return true if so, false otherwise
*/
public boolean ispristine
/**
get an object to handle non-transactional files.
*/
public fileresource getfilehandler
/**
get cache statistics for the specified cache
*/
public abstract long getcachestats string cachename
/**
reset the cache statistics for the specified cache
*/
public abstract void resetcachestats string cachename
/**
return true if any transaction is blocked, even if not by this one.
*/
public  boolean anyoneblocked
/**
* convert a local transaction to a global transaction.
* <p>
* get a transaction controller with which to manipulate data within
* the access manager.  tbis controller allows one to manipulate a
* global xa conforming transaction.
* <p>
* must only be called a previous local transaction was created and exists
* in the context.  can only be called if the current transaction is in
* the idle state.
* <p>
* the (format_id, global_id, branch_id) triplet is meant to come exactly
* from a javax.transaction.xa.xid.  we don't use xid so that the system
* can be delivered on a non-1.2 vm system and not require the javax classes
* in the path.
*
* @param format_id the format id part of the xid - ie. xid.getformatid().
* @param global_id the global transaction identifier part of xid - ie.
*                  xid.getglobaltransactionid().
* @param branch_id the branch qualifier of the xid - ie.
*                  xid.getbranchqaulifier()
*
* @exception standardexception standard exception policy.
**/
void createxatransactionfromlocaltransaction
int                     format_id
byte                  global_id
byte                  branch_id
throws standardexception
/**
* this method is called to commit the current xa global transaction.
* <p>
* resolve - how do we map to the "right" xaexceptions.
* <p>
*
*
* @param onephase if true, the resource manager should use a one-phase
*                 commit protocol to commit the work done on behalf of
*                 current xid.
*
* @exception  standardexception  standard exception policy.
**/
public void xa_commit
boolean onephase
throws standardexception
/**
* this method is called to ask the resource manager to prepare for
* a transaction commit of the transaction specified in xid.
* <p>
*
* @return         a value indicating the resource manager's vote on the
*                 the outcome of the transaction.  the possible values
*                 are:  xa_rdonly or xa_ok.  if the resource manager wants
*                 to roll back the transaction, it should do so by
*                 throwing an appropriate xaexception in the prepare
*                 method.
*
* @exception  standardexception  standard exception policy.
**/
public int xa_prepare
throws standardexception
public static final int xa_rdonly   1
public static final int xa_ok       2
/**
* rollback the current global transaction.
* <p>
* the given transaction is roll'ed back and it's history is not
* maintained in the transaction table or long term log.
* <p>
*
* @exception  standardexception  standard exception policy.
**/
public void xa_rollback
throws standardexception
/**
* get string id of the actual transaction id that will
* be used when transaction is in  active state.
*/
public string getactivestatetxidstring