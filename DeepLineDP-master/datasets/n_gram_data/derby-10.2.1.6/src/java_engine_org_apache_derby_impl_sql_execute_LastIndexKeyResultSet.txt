/*
derby - class org.apache.derby.impl.sql.execute.lastindexkeyresultset
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl sql execute
import org apache derby iapi sql execute cursorresultset
import org apache derby iapi error standardexception
import org apache derby iapi sql resultset
import org apache derby iapi sql execute execrow
import org apache derby iapi sql execute execindexrow
import org apache derby iapi sql execute executioncontext
import org apache derby iapi sql execute noputresultset
import org apache derby iapi sql activation
import org apache derby iapi sql conn languageconnectioncontext
import org apache derby iapi store access conglomeratecontroller
import org apache derby iapi store access genericscancontroller
import org apache derby iapi store access qualifier
import org apache derby iapi store access scancontroller
import org apache derby iapi store access transactioncontroller
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi services stream headerprintwriter
import org apache derby iapi services loader generatedmethod
import org apache derby iapi services io formatablebitset
import java util properties
/**
* return the last key in an index.  used to perform
* max().
*
* @author jamie
*/
class lastindexkeyresultset extends noputresultsetimpl
{
protected	execrow		candidate
// set in constructor and not altered during
// life of object.
protected long conglomid
protected generatedmethod resultrowallocator
protected generatedmethod startkeygetter
protected int startsearchoperator
protected generatedmethod stopkeygetter
protected int stopsearchoperator
protected qualifier qualifiers
public string tablename
public string usersuppliedoptimizeroverrides
public string indexname
protected boolean runtimestatisticson
protected formatablebitset accessedcols
public int isolationlevel
public int lockmode
// run time statistics
public string stoppositionstring
public boolean coarserlock
public boolean returnedrow
/**
* a last index key result set returns the last row from
* the index in question.  it is used as an ajunct to max().
*
* @param activation 		the activation for this result set,
*		which provides the context for the row allocation operation.
* @param resultsetnumber	the resultsetnumber for the resultset
* @param resultrowallocator a reference to a method in the activation
* 						that creates a holder for the result row of the scan.  may
*						be a partial row.  <verbatim>
*		execrow rowallocator() throws standardexception; </verbatim>
* @param conglomid 		the conglomerate of the table to be scanned.
* @param tablename			the full name of the table
* @param usersuppliedoptimizeroverrides		overrides specified by the user on the sql
* @param indexname			the name of the index, if one used to access table.
* @param colrefitem		an saved item for a bitset of columns that
*							are referenced in the underlying table.  -1 if
*							no item.
* @param lockmode			the lock granularity to use (see
*							transactioncontroller in access)
* @param tablelocked		whether or not the table is marked as using table locking
*							(in sys.systables)
* @param isolationlevel	isolation level (specified or not) to use on scans
* @param optimizerestimatedrowcount	estimated total # of rows by
* 										optimizer
* @param optimizerestimatedcost		estimated total cost by optimizer
*
* @exception standardexception thrown when unable to create the
* 				result set
*/
public lastindexkeyresultset
activation activation
int	resultsetnumber
generatedmethod resultrowallocator
long conglomid
string tablename
string usersuppliedoptimizeroverrides
string indexname
int colrefitem
int lockmode
boolean tablelocked
int isolationlevel
double optimizerestimatedrowcount
double optimizerestimatedcost
throws standardexception
{
super activation
resultsetnumber
optimizerestimatedrowcount
optimizerestimatedcost
this conglomid   conglomid
if (sanitymanager.debug)
{
sanitymanager assert  activation  null
sanitymanager assert  resultrowallocator   null
}
this resultrowallocator   resultrowallocator
this tablename   tablename
this usersuppliedoptimizeroverrides   usersuppliedoptimizeroverrides
this indexname   indexname
this lockmode   lockmode
if  colrefitem     1
{
this accessedcols    formatablebitset  activation getpreparedstatement
getsavedobject colrefitem
}
/* isolation level - translate from language to store */
// if not specified, get current isolation level
if  isolationlevel    executioncontext unspecified_isolation_level
{
isolationlevel   lcc getcurrentisolationlevel
}
if  isolationlevel    executioncontext serializable_isolation_level
{
this isolationlevel   transactioncontroller isolation_serializable
}
else
{
/* note: always do row locking on read committed/uncommitted
*       and repeatable read scans unless the table is marked as
*       table locked (in sys.systables).
*
*		 we always get instantaneous locks as we will complete
*		 the scan before returning any rows and we will fully
*		 requalify the row if we need to go to the heap on a next().
*/
if    tablelocked
{
this lockmode   transactioncontroller mode_record
}
if  isolationlevel
executioncontext read_committed_isolation_level
{
this isolationlevel
transactioncontroller isolation_read_committed_noholdlock
}
else if  isolationlevel
executioncontext read_uncommitted_isolation_level
{
this isolationlevel
transactioncontroller isolation_read_uncommitted
}
else if  isolationlevel
executioncontext repeatable_read_isolation_level
{
this isolationlevel
transactioncontroller isolation_repeatable_read
}
}
if (sanitymanager.debug)
{
sanitymanager assert
isolationlevel
executioncontext read_committed_isolation_level
isolationlevel
executioncontext read_uncommitted_isolation_level
isolationlevel
executioncontext repeatable_read_isolation_level
isolationlevel
executioncontext serializable_isolation_level
isolationlevel
}
runtimestatisticson   getlanguageconnectioncontext   getruntimestatisticsmode
/* only call row allocators once */
candidate    execrow  resultrowallocator invoke activation
constructortime    getelapsedmillis begintime
/*
** if scan tracing is turned on, print information about this
** lastindexkeyresultset when it is first opened.
*/
if (sanitymanager.debug)
{
if  sanitymanager debug_on
{
//tracescanparameters();
}
}
activation informofrowcount this  1
}
/////////////////////////////////////////////////////
//
// resultset interface (leftover from noputresultset)
//
/////////////////////////////////////////////////////
/**
* open a scan on the table. scan parameters are evaluated
* at each open, so there is probably some way of altering
* their values...
*
* @exception standardexception thrown on failure to open
*/
public void	opencore   throws standardexception
{
execrow candidatecopy   candidate getclone
begintime   getcurrenttimemillis
if (sanitymanager.debug)
{
sanitymanager assert  isopen
}
isopen   true
transactioncontroller tc   activation gettransactioncontroller
/*
** grab the last row.  note that if there are deletes
** left lying around and no real row to return, then
** the row array gets set even though the scan doesn't
** return a row, so be careful to handle this correctly.
*/
if  tc fetchmaxonbtree
conglomid      conglomerate to open
0  			   open mode
lockmode
isolationlevel
accessedcols
candidatecopy getrowarray
{
currentrow
getcompactrow candidatecopy  accessedcols   formatablebitset  null  true
setcurrentrow currentrow
}
else
{
clearcurrentrow
}
numopens
opentime    getelapsedmillis begintime
}
/**
* return the next row (if any) from the scan (if open).
*
* @exception standardexception thrown on failure to get next row
*/
public execrow getnextrowcore   throws standardexception
{
if  returnedrow     isopen
{
clearcurrentrow
}
else
{
returnedrow   true
}
return currentrow
}
/**
* if the result set has been opened,
* close the open scan.
* @exception standardexception thrown on failure to close
*/
public void	close   throws standardexception
{
begintime   getcurrenttimemillis
if  isopen
{
isopen   false
clearcurrentrow
super close
}
else
{
if (sanitymanager.debug)
{
sanitymanager debug
}
}
closetime    getelapsedmillis begintime
}
/**
* return the total amount of time spent in this resultset
*
* @param type	current_resultset_only - time spent only in this resultset
*				entire_resultset_tree  - time spent in this resultset and below.
*
* @return long		the total amount of time spent (in milliseconds).
*/
public long gettimespent int type
{
long tottime   constructortime   opentime   nexttime   closetime
/* resolve - subtract out store time later, when available */
if  type    noputresultset current_resultset_only
{
return	tottime
}
else
{
return tottime
}
}
/**
* this result set has its row from the last fetch done.
* if the cursor is closed, a null is returned.
*
* @see cursorresultset
*
* @return the last row returned;
* @exception standardexception thrown on failure.
*/
public execrow getcurrentrow   throws standardexception
{
return currentrow
}
/**
* print the parameters that constructed this result set to the
* trace stream.
*/
/*
private final void tracescanparameters()
{
if (sanitymanager.debug)
{
headerprintwriter tracestream = sanitymanager.get_debug_stream();
tracestream.println("");
tracestream.println("lastindexkeyresultset number " +
resultsetnumber +
" parameters:");
tracestream.println("");
tracestream.println("\ttable name: " + tablename);
if (indexname != null)
{
tracestream.println("\tindex name: " + indexname);
}
tracestream.println("");
}
}
*/
}