/*
derby - class org.apache.derby.impl.store.raw.xact.rowlocking3escalate
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl store raw xact
import org apache derby iapi services locks lockfactory
import org apache derby iapi services locks latch
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi store raw containerhandle
import org apache derby iapi store raw containerlock
import org apache derby iapi store raw recordhandle
import org apache derby iapi store raw transaction
import org apache derby iapi error standardexception
/**
a locking policy that implements row level locking with isolation degree 3.
@see org.apache.derby.iapi.store.raw.lockingpolicy
*/
public class rowlocking3escalate extends containerlocking3
protected rowlocking3escalate lockfactory lf
super lf
/**
* escalates row locking 3 to container locking 3.
* <p>
* this call is made by code which tracks the number of locks on a
* container. when the number of locks exceeds the escalate threshold
* the caller creates this new locking policy, calls lockcontainer(),
* and substitues it for the old locking policy.  the lockcontainer call
* determines which table lock to get (s or x), gets that table lock, and
* then releases the row locks on the table.
*
* it is assumed that this is called on a open container for lock only.
* <p>
*
* @param t            transaction to associate lock with.
* @param container    container to lock.
* @param waitforlock  ignored - will never wait for a lock.
* @param forupdate    ignored, mode determined from current lock state.
*
* @return true if the lock was obtained, false if it wasn't.
*   false should only be returned if the waitforlock policy was set to
*  "false," and the lock was unavailable.
*
* @exception  standardexception  standard exception policy.
**/
public boolean lockcontainer
transaction         t
containerhandle     container
boolean             waitforlock
boolean             forupdate
throws standardexception
forupdate   false
// if an ix lock exists then escalate to x table lock, else escalate
// to s table lock.
if  lf islockheld
t getcompatibilityspace    t
container getid    containerlock cix
forupdate   true
// get the new x or s table lock.
boolean gotlock
super lockcontainer t  container  waitforlock  forupdate
if   gotlock
return false
// now remove all matching row locks, this is done using the special
// escalatecontainerkey() class which through the matchable interface
// only matches row locks of this container.
lf unlockgroup
t getcompatibilityspace    t
new escalatecontainerkey container getid
if  sanitymanager debug
sanitymanager assert
lf islockheld
t getcompatibilityspace    t
container getid
forupdate ? containerlock cx   containerlock cs
forupdate ? containerlock cx   containerlock cs
return true