/*
derby - class org.apache.derby.impl.store.raw.data.containeroperation
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl store raw data
import org apache derby iapi services io formatidutil
import org apache derby iapi services io storedformatids
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi store raw compensation
import org apache derby iapi store raw containerhandle
import org apache derby iapi store raw lockingpolicy
import org apache derby iapi store raw transaction
import org apache derby iapi store raw undoable
import org apache derby iapi store raw xact rawtransaction
import org apache derby iapi store raw data rawcontainerhandle
import org apache derby iapi store raw log loginstant
import org apache derby iapi error standardexception
import org apache derby iapi util bytearray
import java io objectoutput
import java io inputstream
import java io objectinput
import java io ioexception
import org apache derby iapi services io limitobjectinput
/**
log operation to create, drop or remove a container.
both the dome or the undome of a create actually caused the container
header to be modified and flushed before the log record is flushed.  this
is necessary for 2 reasons, one is that of ensuring enough disk space, and
the other is because unlike any other operation, the log record create
container is in the log stream before the container is in the container
cache.  what this mean is that if a checkpoint started after the container
operation but before the container is kept or is dirtied in the container
cache, then checkpoint will not know to wait for the container to be kept
or cleaned.  the checkpoint will erroneous assume that the operation does
not need to be redone since its log instant is before the checkpoint but in
fact the change has not been flushed to disk.
a drop or remove container does not have this problem.  the container exist
and is in kept state when the operation is logged so the checkpoint will
not overlook it and it doesn't need to flush the container header.  in the
case of remove, the stub is flushed for a different reason - that of
ensuring disk space.
*/
public class containeroperation extends containerbasicoperation implements undoable
protected byte operation 		   create  drop  or remove
// in previous version of contianeroperation, there may not
// be a createbytearray
transient protected boolean hascreatebytearray   true
protected bytearray createbytearray 	   information necessary to
// recreate the container
protected static final byte create    byte 1
protected static final byte drop    byte 2
protected static final byte remove    byte 4
protected containeroperation rawcontainerhandle hdl  byte operation
throws standardexception
super hdl
this operation   operation
/*
* formatable methods
*/
// no-arg constructor, required by formatable
public containeroperation     super
public void writeexternal objectoutput out  throws ioexception
super writeexternal out
out writebyte operation
if  operation    create
try
createbytearray   containerhdl logcreatecontainerinfo
catch  standardexception se
throw new ioexception se tostring
createbytearray writeexternal out
/**
@exception ioexception cannot read log record from log stream
@exception classnotfoundexception cannot read bytearray object
*/
public void readexternal objectinput in
throws ioexception  classnotfoundexception
super readexternal in
operation   in readbyte
if  operation    create    hascreatebytearray
createbytearray   new bytearray
createbytearray readexternal in
/**
return my format identifier.
*/
public int gettypeformatid
return storedformatids logop_container
/*
* override containerbasicoperation's findcontainerforredorecovery
*/
/**
find container for load tran.
<p>
if we are in load tran, and the operation is a create, the container
may not (should not?) exist yet.  we need to recreate it.
@exception standardexception standard cloudscape policy.
*/
protected rawcontainerhandle findcontainerforredorecovery
rawtransaction xact
throws standardexception
if  sanitymanager debug
sanitymanager assert createbytearray    null
long sid   containerid getsegmentid
long cid   containerid getcontainerid
xact recreatecontainerforredorecovery sid  cid  createbytearray
// now we should be able to open this container
return xact opendroppedcontainer containerid   lockingpolicy null
/**
@exception standardexception standard cloudscape error policy
*/
public final void dome transaction tran  loginstant instant
limitobjectinput in
throws standardexception
switch  operation
case drop
containerhdl dropcontainer instant  true
//
// resolve: if it hasn't been stubbified, even at redo time, we will
// want to earmark this as a post commit work because we know it will
// not be wasted effort.
//
break
case remove
containerhdl removecontainer instant
break
case create
break
// nothing to do with create container, it has already been synced to
// disk.  if the container is subsequently dropped or even removed,
// that's fine too.  don't bother to find it.
releaseresource tran
/**
undo of create, drop or remove
@param tran the transaction that is undoing this operation
@param hdl the container handle.  this is found here during runtime
undo - in which case we made the clr and passed in the containerhdl
found in generateundo and it is passed back to this; or it is found in
the clr's needsredo and is passed in and this operation never found the
container.  either case, release resource at the end is safe
@param clrinstant the log instant of the clr
@param in optional data
@exception standardexception standard cloudscape error policy
*/
public void undome transaction tran  rawcontainerhandle hdl
loginstant clrinstant  limitobjectinput in
throws standardexception
switch operation
case drop
if  sanitymanager debug
sanitymanager assert hdl    null
sanitymanager assert hdl getcontainerstatus      rawcontainerhandle committed_drop
hdl dropcontainer clrinstant  false      not dropped
break
case create
// remove the container
hdl removecontainer clrinstant
break
case remove
if  sanitymanager debug
sanitymanager throwassert
break
releaseresource tran
/**
@see org.apache.derby.iapi.store.raw.undoable
@exception standardexception standard cloudscape error policy
*/
public compensation generateundo transaction tran  limitobjectinput in
throws standardexception
if  operation    remove
return null 		   cannot undo remove
else
rawcontainerhandle undocontainerhandle   findcontainer tran
// mark the container as pre-dirtied so that if a checkpoint
// happens after the log record is sent to the log stream, the
// cache cleaning will wait for this change.
//
// resolve: don't do this now because if undo failed, this
// container will be "stuck" in the predirty state and checkpoint
// will be stuck
// undocontainerhandle.predirty(true);
//
return new containerundooperation undocontainerhandle  this
/** debug */
public string tostring
if  sanitymanager debug
string str   super tostring
switch operation
case create  str        containerid
break
case drop  str        containerid
break
case remove  str        containerid
break
return str
else
return null