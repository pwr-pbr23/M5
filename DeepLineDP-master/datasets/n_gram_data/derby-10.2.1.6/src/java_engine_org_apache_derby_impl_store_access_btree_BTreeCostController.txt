/*
derby - class org.apache.derby.impl.store.access.btree.btreecostcontroller
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl store access btree
import org apache derby iapi reference property
import org apache derby iapi reference sqlstate
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi error standardexception
import org apache derby iapi store access conglomerate conglomerate
import org apache derby iapi store access conglomerate logicalundo
import org apache derby iapi store access conglomerate transactionmanager
import org apache derby iapi store access dynamiccompiledopenconglominfo
import org apache derby iapi store access rowutil
import org apache derby iapi store access scancontroller
import org apache derby iapi store access storecostcontroller
import org apache derby iapi store access storecostresult
import org apache derby iapi store access transactioncontroller
import org apache derby iapi store raw containerhandle
import org apache derby iapi store raw lockingpolicy
import org apache derby iapi store raw rawstorefactory
import org apache derby iapi store raw transaction
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi types rowlocation
import org apache derby iapi services io formatablebitset
import java util properties
/**
the storecostcontroller interface provides methods that an access client
(most likely the system optimizer) can use to get store's estimated cost of
various operations on the conglomerate the storecostcontroller was opened
for.
<p>
it is likely that the implementation of storecostcontroller will open
the conglomerate and will leave the conglomerate open until the
storecostcontroller is closed.  this represents a significant amount of
work, so the caller if possible should attempt to open the storecostcontroller
once per unit of work and rather than close and reopen the controller.  for
instance if the optimizer needs to cost 2 different scans against a single
conglomerate, it should use one instance of the storecostcontroller.
<p>
the locking behavior of the implementation of a storecostcontroller is
undefined, it may or may not get locks on the underlying conglomerate.  it
may or may not hold locks until end of transaction.
an optimal implementation will not get any locks on the underlying
conglomerate, thus allowing concurrent access to the table by a executing
query while another query is optimizing.
<p>
@see transactioncontroller#openstorecost
**/
public class btreecostcontroller extends openbtree
implements storecostcontroller
// 1.5 numbers on mikem old machine:
//
// the magic numbers are based on the following benchmark results:
//
//                                         no col   one int col  all cols
//                                         ------   -----------  --------
//100 byte heap fetch by row loc, cached   0.3625     0.5098     0.6629
//100 byte heap fetch by row loc, uncached 1.3605769  1.5168269  1.5769231
//4 byte   heap fetch by row loc, cached   0.3745     0.4016     0.3766
//4 byte   heap fetch by row loc, uncached 4.1938777  3.5714285  4.4897957
//
//                                 no col    one int col  all cols
//                                 ------    -----------  --------
//int col one level btree
//  fetch by exact key, cached     0.781     1.012         0.42
//  fetch by exact key, sort merge 1.081     1.221         0.851
//  fetch by exact key, uncached   0.0       0.0           0.0
//int col two level btree
//  fetch by exact key, cached     1.062     1.342         0.871
//  fetch by exact key, sort merge 1.893     2.273         1.633
//  fetch by exact key, uncached   5.7238097 5.3428574     4.7714286
//string key one level btree
//  fetch by exact key, cached     1.082     0.811         0.781
//  fetch by exact key, sort merge 1.572     1.683         1.141
//  fetch by exact key, uncached   0.0       0.0           0.0
//string key two level btree
//  fetch by exact key, cached     2.143     2.664         1.953
//  fetch by exact key, sort merge 3.775     4.116         3.505
//  fetch by exact key, uncached   4.639474  5.0052633     4.4289474
// mikem new machine - insane, codeline, non-jit 1.1.7 numbers
//
//                                         no col   one int col  all cols
//                                         ------   -----------  --------
//100 byte heap fetch by row loc, cached   0.1662    0.4597      0.5618
//100 byte heap fetch by row loc, uncached 0.7565947 1.2601918   1.6690648
//4 byte   heap fetch by row loc, cached   0.1702    0.1983      0.1903
//4 byte   heap fetch by row loc, uncached 1.5068493 1.3013699   1.6438357
//
//                                 no col    one int col  all cols
//                                 ------    -----------  --------
// int col one level btree
//   fetch by exact key, cached     0.271    0.511        0.33
//   fetch by exact key, sort merge 0.691    0.921        0.771
//   fetch by exact key, uncached   0.0      0.0          0.0
// int col two level btree
//   fetch by exact key, cached     0.541    0.711        0.561
//   fetch by exact key, sort merge 1.432    1.682        1.533
//   fetch by exact key, uncached   3.142857 3.6285715    3.2380953
// string key one level btree
//   fetch by exact key, cached     0.611    0.851        0.701
//   fetch by exact key, sort merge 1.051    1.272        1.122
//   fetch by exact key, uncached   0.0      0.0          0.0
// string key two level btree
//   fetch by exact key, cached     1.532    1.843        1.622
//   fetch by exact key, sort merge 2.844    3.155        2.984
//   fetch by exact key, uncached   3.4      3.636842     3.531579
//
// the following costs are search costs to find a row on a leaf, use
// the heap costs to determine scan costs, for now ignore qualifier
// application and stop comparisons.
// i used the int key, 2 level numbers divided by 2 to get per level.
private static final double
btree_cached_fetch_by_key_per_level       0 541   2
private static final double
btree_sortmerge_fetch_by_key_per_level    1 432   2
private static final double
btree_uncached_fetch_by_key_per_level     3 143   2
// saved values passed to init().
transactionmanager  init_xact_manager
transaction         init_rawtran
conglomerate        init_conglomerate
/**
* only lookup these estimates from raw store once.
**/
long    num_pages
long    num_rows
long    page_size
int     tree_height
/* constructors for this class: */
public btreecostcontroller
/* private/protected methods of this class: */
/**
* initialize the cost controller.
* <p>
* save initialize parameters away, and open the underlying container.
* <p>
*
* @param xact_manager access manager transaction.
* @param rawtran      raw store transaction.
*
* @exception  standardexception  standard exception policy.
**/
public void init
transactionmanager  xact_manager
btree               conglomerate
transaction         rawtran
throws standardexception
super init
xact_manager
xact_manager
containerhandle  null             open the btree
rawtran
false
containerhandle mode_readonly
transactionmanager mode_none
btreelockingpolicy  null          resolve  mikem    this means
// no locks during costing - will
// that work?????
conglomerate
logicalundo  null                 read only  so no undo necessary
dynamiccompiledopenconglominfo  null
// look up costs from raw store.  for btrees these numbers are out
// of whack as they want to be leaf specific numbers but they include
// every page branch and leafs.
num_pages   this container getestimatedpagecount    unused flag    0
// subtract one row for every page to account for internal control row
// which exists on every page.
num_rows
this container getestimatedrowcount   unused flag   0    num_pages
properties prop   new properties
prop put property page_size_parameter
this container getcontainerproperties prop
page_size
integer parseint prop getproperty property page_size_parameter
tree_height   getheight
return
/* public methods of this class: */
/**
* close the controller.
* <p>
* close the open controller.  this method always succeeds, and never
* throws any exceptions. callers must not use the storecostcontroller
* cost controller after closing it; they are strongly advised to clear
* out the scan controller reference after closing.
* <p>
**/
public void close
throws standardexception
super close
/**
* return the cost of calling conglomeratecontroller.fetch().
* <p>
* return the estimated cost of calling conglomeratecontroller.fetch()
* on the current conglomerate.  this gives the cost of finding a record
* in the conglomerate given the exact rowlocation of the record in
* question.
* <p>
* the validcolumns parameter describes what kind of row
* is being fetched, ie. it may be cheaper to fetch a partial row than a
* complete row.
* <p>
*
*
* @param validcolumns    a description of which columns to return from
*                        row on the page into "templaterow."  templaterow,
*                        and validcolumns work together to
*                        describe the row to be returned by the fetch -
*                        see rowutil for description of how these three
*                        parameters work together to describe a fetched
*                        "row".
*
* @param access_type     describe the type of access the query will be
*                        performing to the conglomeratecontroller.
*
*                        storecost_clustered - the location of one fetch
*                            is likely clustered "close" to the next
*                            fetch.  for instance if the query plan were
*                            to sort the rowlocations of a heap and then
*                            use those rowlocations sequentially to
*                            probe into the heap, then this flag should
*                            be specified.  if this flag is not set then
*                            access to the table is assumed to be
*                            random - ie. the type of access one gets
*                            if you scan an index and probe each row
*                            in turn into the base table is "random".
*
*
* @return the cost of the fetch.
*
* @exception  standardexception  standard exception policy.
*
* @see rowutil
**/
public double getfetchfromrowlocationcost
formatablebitset      validcolumns
int         access_type
throws standardexception
throw standardexception newexception
sqlstate btree_unimplemented_feature
/**
* return the cost of exact key lookup.
* <p>
* return the estimated cost of calling scancontroller.fetch()
* on the current conglomerate, with start and stop positions set such
* that an exact match is expected.
* <p>
* this call returns the cost of a fetchnext() performed on a scan which
* has been positioned with a start position which specifies exact match
* on all keys in the row.
* <p>
* example:
* <p>
* in the case of a btree this call can be used to determine the cost of
* doing an exact probe into btree, giving all key columns.  this cost
* can be used if the client knows it will be doing an exact key probe
* but does not have the key's at optimize time to use to make a call to
* getscancost()
* <p>
*
*
* @param validcolumns    a description of which columns to return from
*                        row on the page into "templaterow."  templaterow,
*                        and validcolumns work together to
*                        describe the row to be returned by the fetch -
*                        see rowutil for description of how these three
*                        parameters work together to describe a fetched
*                        "row".
*
* @param access_type     describe the type of access the query will be
*                        performing to the scancontroller.
*
*                        storecost_clustered - the location of one scan
*                            is likely clustered "close" to the previous
*                            scan.  for instance if the query plan were
*                            to used repeated "reopenscan()'s" to probe
*                            for the next key in an index, then this flag
*                            should be be specified.  if this flag is not
*                            set then each scan will be costed independant
*                            of any other predicted scan access.
*
* @return the cost of the fetch.
*
* @exception  standardexception  standard exception policy.
*
* @see rowutil
**/
public double getfetchfromfullkeycost
formatablebitset      validcolumns
int         access_type
throws standardexception
double ret_cost
if   access_type   storecostcontroller storecost_clustered     0
// uncached fetch
ret_cost   btree_uncached_fetch_by_key_per_level
else
ret_cost   btree_sortmerge_fetch_by_key_per_level
ret_cost    tree_height
return ret_cost
/**
* calculate the cost of a scan.
* <p>
* cause this object to calculate the cost of performing the described
* scan.  the interface is setup such that first a call is made to
* calcualtescancost(), and then subsequent calls to accessor routines
* are made to get various pieces of information about the cost of
* the scan.
* <p>
* for the purposes of costing this routine is going to assume that
* a page will remain in cache between the time one next()/fetchnext()
* call and a subsequent next()/fetchnext() call is made within a scan.
* <p>
* the result of costing the scan is placed in the "cost_result".
* the cost of the scan is stored by calling
* cost_result.setestimatedcost(cost).
* the estimated row count is stored by calling
* cost_result.setestimatedrowcount(row_count).
* <p>
* the estimated cost of the scan assumes the caller will
* execute a fetchnext() loop for every row that qualifies between
* start and stop position.  note that this cost is different than
* execution a next(),fetch() loop; or if the scan is going to be
* terminated by client prior to reaching the stop condition.
* <p>
* the estimated number of rows returned from the scan
* assumes the caller will execute a fetchnext() loop for every
* row that qualifies between start and stop position.
* <p>
*
*
* @param scan_type       the type of scan that will be executed.  there
*                        are currently 2 types:
*                        storecost_scan_normal - scans will be executed
*                        using the standard next/fetch, where each fetch
*                        can retrieve 1 or many rows (if fetchnextgroup()
*                        interface is used).
*
*                        storecost_scan_set - the entire result set will
*                        be retrieved using the the fetchset() interface.
*
* @param row_count       estimated total row count of the table.  the
*                        current system tracks row counts in heaps better
*                        than btree's (btree's have "rows" which are not
*                        user rows - branch rows, control rows), so
*                        if available the client should
*                        pass in the base table's row count into this
*                        routine to be used as the index's row count.
*                        if the caller has no idea, pass in -1.
*
* @param group_size      the number of rows to be returned by a single
*                        fetch call for storecost_scan_normal scans.
*
* @param forupdate       should be true if the caller intends to update
*                        through the scan.
*
* @param scancolumnlist  a description of which columns to return from
*                        every fetch in the scan.  template,
*                        and scancolumnlist work together
*                        to describe the row to be returned by the scan -
*                        see rowutil for description of how these three
*                        parameters work together to describe a "row".
*
* @param template        a prototypical row which the scan may use to
*                        maintain its position in the conglomerate.  not
*                        all access method scan types will require this,
*                        if they don't it's ok to pass in null.
*                        in order to scan a conglomerate one must
*                        allocate 2 separate "row" templates.  the "row"
*                        template passed into openscan is for the private
*                        use of the scan itself, and no access to it
*                        should be made by the caller while the scan is
*                        still open.  because of this the scanner must
*                        allocate another "row" template to hold the
*                        values returned from fetch().  note that this
*                        template must be for the full row, whether a
*                        partial row scan is being executed or not.
*
* @param startkeyvalue   an indexable row which holds a (partial) key
*                        value which, in combination with the
*                        startsearchoperator, defines the starting
*                        position of the scan.  if null, the starting
*                        position of the scan is the first row of the
*                        conglomerate.  the startkeyvalue must only
*                        reference columns included in the scancolumnlist.
*
* @param startsearchoperator
*                        an operator which defines how the startkeyvalue
*                        is to be searched for.  if startsearchoperation
*                        is scancontroller.ge, the scan starts on the
*                        first row which is greater than or equal to the
*                        startkeyvalue.  if startsearchoperation is
*                        scancontroller.gt, the scan starts on the first
*                        row whose key is greater than startkeyvalue.  the
*                        startsearchoperation parameter is ignored if the
*                        startkeyvalue parameter is null.
*
* @param stopkeyvalue    an indexable row which holds a (partial) key
*                        value which, in combination with the
*                        stopsearchoperator, defines the ending position
*                        of the scan.  if null, the ending position of the
*                        scan is the last row of the conglomerate.  the
*                        stopkeyvalue must only reference columns included
*                        in the scancolumnlist.
*
* @param stopsearchoperator
*                        an operator which defines how the stopkeyvalue
*                        is used to determine the scan stopping position.
*                        if stopsearchoperation is scancontroller.ge, the
*                        scan stops just before the first row which is
*                        greater than or equal to the stopkeyvalue.  if
*                        stopsearchoperation is scancontroller.gt, the
*                        scan stops just before the first row whose key
*                        is greater than startkeyvalue.  the
*                        stopsearchoperation parameter is ignored if the
*                        stopkeyvalue parameter is null.
*
*
* @param access_type     describe the type of access the query will be
*                        performing to the scancontroller.
*
*                        storecost_clustered - the location of one scan
*                            is likely clustered "close" to the previous
*                            scan.  for instance if the query plan were
*                            to used repeated "reopenscan()'s" to probe
*                            for the next key in an index, then this flag
*                            should be be specified.  if this flag is not
*                            set then each scan will be costed independant
*                            of any other predicted scan access.
*
*
* @exception  standardexception  standard exception policy.
*
* @see rowutil
**/
public void getscancost
int                     scan_type
long                    row_count
int                     group_size
boolean                 forupdate
formatablebitset                 scancolumnlist
datavaluedescriptor   template
datavaluedescriptor   startkeyvalue
int                     startsearchoperator
datavaluedescriptor   stopkeyvalue
int                     stopsearchoperator
boolean                 reopen_scan
int                     access_type
storecostresult         cost_result
throws standardexception
float       left_of_start
float       left_of_stop
controlrow  control_row   null
long        input_row_count    row_count < 0 ? num_rows   row_count
try
// find the starting page and row slot.
if  startkeyvalue    null
left_of_start   0
else
// search for the starting row.
searchparameters sp   new searchparameters
startkeyvalue
startsearchoperator    scancontroller ge  ?
searchparameters position_left_of_partial_key_match
searchparameters position_right_of_partial_key_match
template  this  true
control_row
controlrow get this  btree rootpageid  search sp
control_row release
control_row   null
left_of_start   sp left_fraction
if  stopkeyvalue    null
left_of_stop   1
else
// search for the stopping row.
searchparameters sp
new searchparameters
stopkeyvalue
stopsearchoperator    scancontroller ge  ?
searchparameters position_left_of_partial_key_match
searchparameters position_right_of_partial_key_match
template  this  true
control_row
controlrow get this  btree rootpageid  search sp
control_row release
control_row   null
left_of_stop   sp left_fraction
// system.out.println(
//   "\n\tleft_of_start = " + left_of_start +
// "\n\tleft_of_stop  = " + left_of_stop);
// what percentage of rows are between start and stop?
float ret_fraction   left_of_stop   left_of_start
// if for some reason the stop position comes before the start
// position, assume 0 rows will return from query.
if  ret_fraction < 0
ret_fraction   0
// never return estimate of more rows than exist, sometimes
// the recursive estimation through the btree may return a number
// like 1.00001.
if  ret_fraction > 1
ret_fraction   1
float estimated_row_count   input_row_count   ret_fraction
// first the base cost of positioning on the first row in the scan.
double cost
getfetchfromfullkeycost scancolumnlist  access_type
// add the base cost of bringing each page for the first time into
// the cache.  this is basically the cost of bringing each leaf
// uncached into the cache and reading the control row off of it.:
cost
num_pages   ret_fraction    base_uncached_row_fetch_cost
// now some magic to try and figure out the cost of doing a
// scan along the leaf level of the tree.  mostly just assume
// the costs are the same as the heap, and ignore qualifier
// processing and stop row comparisons for now.
// the base cost of getting each of the rows from a page assumed
// to already be cached (by the scan fetch) - this is only for all
// rows after the initial row on the page has been accounted for
// under the base_uncached_row_fetch_cost cost.:
long cached_row_count     long  estimated_row_count    num_pages
if  cached_row_count < 0
cached_row_count   0
if  scan_type    storecostcontroller storecost_scan_normal
cost    cached_row_count   base_groupscan_row_cost
else
cost    cached_row_count   base_hashscan_row_fetch_cost
// finally add the cost associated with the number of bytes in row:
long row_size
input_row_count    0  ?
4    num_pages   page_size    input_row_count
cost
estimated_row_count   row_size    base_row_per_bytecost
if  sanitymanager debug
if  cost < 0
sanitymanager throwassert     cost
if  estimated_row_count < 0
sanitymanager throwassert
estimated_row_count
// return the cost
cost_result setestimatedcost cost
// resolve - should we make sure this number is > 0?
cost_result setestimatedrowcount math round estimated_row_count
finally
if  control_row    null
control_row release
// system.out.println("btreecostcontroller.getscancost():" +
//   "\n\t cost = " + cost_result.getestimatedcost() +
// "\n\t rows = " + cost_result.getestimatedrowcount());
return
/**
* return an "empty" row location object of the correct type.
* <p>
*
* @return the empty rowlocation.
*
* @exception  standardexception  standard exception policy.
**/
public rowlocation newrowlocationtemplate
throws standardexception
throw standardexception newexception
sqlstate btree_unimplemented_feature