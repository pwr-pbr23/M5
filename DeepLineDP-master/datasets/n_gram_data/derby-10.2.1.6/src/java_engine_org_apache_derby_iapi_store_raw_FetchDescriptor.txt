/*
derby - class org.apache.derby.iapi.store.raw.fetchdescriptor
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby iapi store raw
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi store access qualifier
import org apache derby iapi services io formatablebitset
/**
fetchdescriptor is used to package up all the arguments necessary to
describe what rows and what row parts should be returned from the store
back to language as part of a fetch.
<p>
the fetchdescriptor may also contain scratch space used to process the
qualifiers passed in the scan.  this scratch space will be used to cache
information about the qualifiers, valid column list, row size so that
calculations need only be done once per scan rather than every iteration.
**/
public final class fetchdescriptor
{
/**************************************************************************
* fields of the class
**************************************************************************
*/
private int             row_length
private formatablebitset         validcolumns
private qualifier   qualifier_list
private int           materialized_cols
private int             maxfetchcolumnid
private static final int zero_fill_length    100
private static final int zero_fill_array   new int
// use int arrays rather than formatablebitset's to get most efficient processing
// in performance critical loop which reads columns from page.
private int           validcolumnsarray
/**************************************************************************
* constructors for this class:
**************************************************************************
*/
fetchdescriptor
{
}
public fetchdescriptor
int             input_row_length
{
row_length        input_row_length
}
public fetchdescriptor
int             input_row_length
int             single_valid_column_number
{
row_length          input_row_length
maxfetchcolumnid    single_valid_column_number
validcolumnsarray   new int
validcolumnsarray   1
}
public fetchdescriptor
int             input_row_length
formatablebitset         input_validcolumns
qualifier   input_qualifier_list
{
row_length        input_row_length
qualifier_list    input_qualifier_list
if  qualifier_list    null
{
materialized_cols             new int
}
setvalidcolumns input_validcolumns
}
/**************************************************************************
* public methods of this class:
**************************************************************************
*/
/**
* return the column list bit map.
* <p>
* a description of which columns to return from every fetch in the scan.
* a row array and a valid column bit map work together to describe the row
* to be returned by the scan - see rowutil for description of how these two
* parameters work together to describe a "row".
*
* @return the column list bit map.
*
* @exception  standardexception  standard exception policy.
**/
public final formatablebitset getvalidcolumns
{
return validcolumns
}
public final int getvalidcolumnsarray
{
return validcolumnsarray
}
public final void setvalidcolumns
formatablebitset   input_validcolumns
{
validcolumns   input_validcolumns
setmaxfetchcolumnid
if  validcolumns    null
{
validcolumnsarray   new int
for  int i   maxfetchcolumnid  i >  0  i
{
validcolumnsarray     validcolumns isset i   ? 1   0
}
}
}
/**
* return the qualifier array.
* <p>
* return the array of qualifiers in this fetchdescriptor.  the array of
* qualifiers which, applied to each key, restricts the rows returned by
* the scan.  rows for which any one of the qualifiers returns false are
* not returned by the scan. if null, all rows are returned.  qualifiers
* can only reference columns which are included in the scancolumnlist.
* the column id that a qualifier returns in the column id the table, not
* the column id in the partial row being returned.
* <p>
* a null qualifier array means there are no qualifiers.
*
* @return the qualifier array, it may be null.
*
* @exception  standardexception  standard exception policy.
**/
public final qualifier getqualifierlist
{
return qualifier_list
}
/**
* internal to store.
**/
public final int getmaterializedcolumns
{
return materialized_cols
}
/**
* internal to store.
**/
public final int getmaxfetchcolumnid
{
return maxfetchcolumnid
}
private final void setmaxfetchcolumnid
{
maxfetchcolumnid   row_length   1
if  validcolumns    null
{
int vcol_length   validcolumns getlength
if  vcol_length < maxfetchcolumnid   1
maxfetchcolumnid   vcol_length   1
for    maxfetchcolumnid >  0  maxfetchcolumnid
{
if  validcolumns isset maxfetchcolumnid
break
}
}
}
/**
* internal to store.
**/
public final void reset
{
int   cols   materialized_cols
if  cols    null
{
// new row, clear the array map.
/*
* this was too slow.
for (int i = cols.length - 1; i >= 0;)
{
cols[i--] = 0;
}
*/
if  cols length <  zero_fill_length
{
// fast path the usual case.
system arraycopy
zero_fill_array    0
cols  0
cols length
}
else
{
int offset    0
int howmany   cols length
while  howmany > 0
{
int count
howmany > zero_fill_array length ?
zero_fill_array length   howmany
system arraycopy
zero_fill_array  0  cols  offset  count
howmany    count
offset     count
}
}
}
}
}