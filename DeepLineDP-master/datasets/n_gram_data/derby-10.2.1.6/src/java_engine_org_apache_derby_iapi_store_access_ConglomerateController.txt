/*
derby - class org.apache.derby.iapi.store.access.conglomeratecontroller
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby iapi store access
import org apache derby iapi store access rowutil
import org apache derby iapi services io storable
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi types rowlocation
import org apache derby iapi error standardexception
import org apache derby iapi services io formatablebitset
import java util properties
/**
a conglomerate is an abstract storage structure (they
correspond to access methods).  the conglomeratecontroller interface
is the interface that access manager clients can use to manipulate
the contents of the underlying conglomerate.
<p>
each conglomerate holds a set of rows.  each row has a row location.
the conglomerate provides methods for:
<ul>
<li>
inserting rows,
<li>
fetching, deleting, and replacing entire rows by row location, and
<li>
fetching and updating individual columns of a row identified by row
location.
</ul>
<p>
conglomerates do not provide any mechanism for associative access to
rows within the conglomerate; this type of access is provided by scans
via the scancontroller interface.
<p>
although all conglomerates have the same interface, they have different
implementations.  the implementation of a conglomerate determines some
of its user-visible semantics; for example whether the rows are ordered
or what the types of the rows' columns must be.  the implementation is
specified by an implementation id.  currently there are two implementations,
"heap", and "btree".  the details of their behavior are specified in their
implementation documentation.  (currently, only "heap" is implemented).
<p>
all conglomerate operations are subject to the transactional isolation
of the transaction they were opened from.  transaction rollback will
close all conglomerates.  transaction commit will close all non-held
conglomerates.
<p>
scans are opened from a transactioncontroller.
<p>
a conglomeratecontroller can handle partial rows. partial rows
are described in rowutil.
@see transactioncontroller#openconglomerate
@see rowutil
*/
public interface conglomeratecontroller extends conglompropertyqueryable
public static final int rowisduplicate   1
/**
* close the conglomerate controller.
* <p>
* close the conglomerate controller.  callers must not use
* the conglomerate controller after calling close.  it is
* strongly recommended that callers clear out the reference
* after closing, e.g.,
* <p>
* <blockquote><pre>
* conglomeratecontroller cc;
* cc.close;
* cc = null;
* </pre></blockquote>
*
* @exception  standardexception  standard exception policy.
**/
public void close
throws standardexception;
/**
* close conglomerate controller as part of terminating a transaction.
* <p>
* use this call to close the conglomerate controller resources as part of
* committing or aborting a transaction.  the normal close() routine may
* do some cleanup that is either unnecessary, or not correct due to the
* unknown condition of the controller following a transaction ending error.
* use this call when closing all controllers as part of an abort of a
* transaction.
* <p)
* this call is meant to only be used internally by the storage system,
* clients of the storage system should use the simple close() interface.
* <p>
* resolve (mikem) - move this call to conglomeratemanager so it is
* obvious that non-access clients should not call this.
*
* @param closeheldscan           if true, means to close controller even if
*                                it has been opened to be kept opened
*                                across commit.  this is
*                                used to close these controllers on abort.
*
* @return boolean indicating that the close has resulted in a real close
*                 of the controller.  a held scan will return false if
*                 called by closeforendtransaction(false), otherwise it
*                 will return true.  a non-held scan will always return
*                 true.
*
* @exception  standardexception  standard exception policy.
**/
boolean closeforendtransaction boolean closeheldscan
throws standardexception;
/**
check consistency of a conglomerate.
checks the consistency of the data within a given conglomerate, does not
check consistency external to the conglomerate (ie. does not check that
base table row pointed at by a secondary index actually exists).
raises a standardexception on first consistency problem.
@exception standardexception standard exception policy.
**/
void checkconsistency
throws standardexception;
/**
delete a row from the conglomerate.
@return returns true if delete was successful, false if the record pointed
at no longer represents a valid record.
@exception standardexception standard exception policy.
**/
boolean delete rowlocation loc
throws standardexception;
/**
* fetch the (partial) row at the given location.
* <p>
*
* @param loc             the "rowlocation" which describes the exact row
*                        to fetch from the table.
* @param destrow         the row to read the data into.
* @param validcolumns    a description of which columns to return from
*                        row on the page into "destrow."  destrow
*                        and validcolumns work together to
*                        describe the row to be returned by the fetch -
*                        see rowutil for description of how these three
*                        parameters work together to describe a fetched
*                        "row".
*
* @return returns true if fetch was successful, false if the record
*         pointed at no longer represents a valid record.
*
* @exception  standardexception  standard exception policy.
*
* @see rowutil
**/
boolean fetch(
rowlocation             loc,
datavaluedescriptor[]   destrow,
formatablebitset                 validcolumns
throws standardexception;
/**
* fetch the (partial) row at the given location.
* <p>
*
* @param loc             the "rowlocation" which describes the exact row
*                        to fetch from the table.
* @param destrow         the row to read the data into.
* @param validcolumns    a description of which columns to return from
*                        row on the page into "destrow."  destrow
*                        and validcolumns work together to
*                        describe the row to be returned by the fetch -
*                        see rowutil for description of how these three
*                        parameters work together to describe a fetched
*                        "row".
* @param waitforlock     if false, then the call will throw a lock timeout
*                        exception immediately, if the lock can not be
*                        granted without waiting.  if true call will
*                        act exactly as fetch() interface with no
*                        waitforlock parameter.
*
* @return returns true if fetch was successful, false if the record
*         pointed at no longer represents a valid record.
*
* @exception  standardexception  standard exception policy.
*
* @see rowutil
**/
boolean fetch(
rowlocation loc
datavaluedescriptor[]   destrow,
formatablebitset     validcolumns
boolean     waitforlock
throws standardexception;
/**
* fetch the (partial) row at the given location.
* <p>
* resolve - interface not supported yet!!!!!
*
* @param loc             the "rowlocation" which describes the exact row
*                        to fetch from the table.
* @param destrow         the row to read the data into.
* @param validcolumns    a description of which columns to return from
*                        row on the page into "destrow."  destrow,
*                        and validcolumns work together to
*                        describe the row to be returned by the fetch -
*                        see rowutil for description of how these three
*                        parameters work together to describe a fetched
*                        "row".
* @param qualifier       an array of qualifiers which,
*                        applied to each key, restrict the rows returned
*                        by the scan.  rows for which any one of the
*                        qualifiers returns false are not returned by
*                        the scan. if null, all rows are returned.
*                        qualifiers can only reference columns which are
*                        included in the scancolumnlist.  the column id
*                        that a qualifier returns in the column id the
*                        table, not the column id in the partial row being
*                        returned.  see openscan() for description of how
*                        qualifiers are applied.
*
* @return returns true if fetch was successful, false if the record
*         pointed at no longer represents a valid record.
*
* @exception  standardexception  standard exception policy.
*
* @see rowutil
**/
/*
boolean fetch(
rowlocation             loc,
datavaluedescriptor[]   destrow,
formatablebitset                 validcolumns,
qualifier[][]           qualifier)
throws standardexception;
*/
/**
insert a row into the conglomerate.
@param row the row to insert into the conglomerate.  the stored
representations of the row's columns are copied into a new row
somewhere in the conglomerate.
@return returns 0 if insert succeeded.  returns
conglomeratecontroller.rowisduplicate if conglomerate supports uniqueness
checks and has been created to disallow duplicates, and the row inserted
had key columns which were duplicate of a row already in the table.  other
insert failures will raise standardexception's.
@exception standardexception standard exception policy.
@see rowutil
**/
int insert datavaluedescriptor    row
throws standardexception;
/**
* insert row and fetch it's row location in one operation.
* <p>
* insert a row into the conglomerate, and store its location in
* the provided destination row location.  the row location must be of the
* correct type for this conglomerate (a new row location of the correct
* type can be obtained from newrowlocationtemplate()).
*
* @param row           the row to insert into the conglomerate.  the
*                      stored representations of the row's columns are
*                      copied into a new row somewhere in the conglomerate.
*
* @param destrowlocation the rowlocation to read the inserted row location
*                      into.
*
* @exception  standardexception  standard exception policy.
*
* @see rowutil
**/
void insertandfetchlocation
datavaluedescriptor   row
rowlocation             destrowlocation
throws standardexception;
/**
return whether this is a keyed conglomerate.
**/
boolean iskeyed
public static final int lock_read            0x00000000
public static final int lock_upd             0x00000001
public static final int lock_ins             0x00000002
public static final int lock_ins_prevkey     0x00000004
public static final int lock_update_locks    0x00000008
/**
* lock the given row location.
* <p>
* should only be called by access.
* <p>
* this call can be made on a conglomeratecontroller that was opened
* for locking only.
* <p>
* resolve (mikem) - move this call to conglomeratemanager so it is
* obvious that non-access clients should not call this.
*
* @return true if lock was granted, only can be false if wait was false.
*
* @param loc           the "rowlocation" of the exact row to lock.
* @param lock_oper     for what operation are we requesting the lock, this
*                      should be one of the following 4 options:
*                      lock_read [read lock],
*                      (lock_ins | lock_upd) [ lock for insert],
*                      (lock_insert_prevkey | lock_upd) [lock for
*                      previous key to insert],
*                      (lock_upd) [lock for delete or replace]
*                      (lock_upd | lock_update_locks) [lock scan for
*                          update, will upgrade lock later if actual update
*                          is take place]
* @param wait          should the lock call wait to be granted?
* @param lock_duration if set to transactionmanager.lock_instant_duration,
*                      then lock will be released immediately after being
*                      granted.
*
* @exception  standardexception  standard exception policy.
**/
boolean lockrow
rowlocation     loc
int             lock_oper
boolean         wait
int             lock_duration
throws standardexception;
/**
* lock the given record id/page num pair.
* <p>
* should only be called by access, to lock "special" locks formed from
* the recordhandle.* reserved constants for page specific locks.
* <p>
* this call can be made on a conglomeratecontroller that was opened
* for locking only.
* <p>
* resolve (mikem) - move this call to conglomeratemanager so it is
* obvious that non-access clients should not call this.
*
* @return true if lock was granted, only can be false if wait was false.
*
* @param page_num      page number of record to lock.
* @param record_id     record id of record to lock.
* @param lock_oper     for what operation are we requesting the lock, this
*                      should be one of the following 4 options:
*                      lock_read [read lock],
*                      (lock_ins | lock_upd) [ lock for insert],
*                      (lock_insert_prevkey | lock_upd) [lock for
*                      previous key to insert],
*                      (lock_upd) [lock for delete or replace]
*                      (lock_upd | lock_update_locks) [lock scan for
*                          update, will upgrade lock later if actual update
*                          is take place]
* @param wait          should the lock call wait to be granted?
* @param lock_duration if set to transactionmanager.lock_instant_duration,
*                      then lock will be released immediately after being
*                      granted.
*
* @exception  standardexception  standard exception policy.
**/
boolean lockrow
long            page_num
int             record_id
int             lock_oper
boolean         wait
int             lock_duration
throws standardexception;
/**
* unlock the given row location.
* <p>
* should only be called by access.
* <p>
* this call can be made on a conglomeratecontroller that was opened
* for locking only.
* <p>
* resolve (mikem) - move this call to conglomeratemanager so it is
* obvious that non-access clients should not call this.
*
* @param loc           the "rowlocation" which describes the row to unlock.
* @param forupdate     row was locked for read or update.
* @param row_qualified row was qualified and returned to the user.
*
* @exception  standardexception  standard exception policy.
**/
public void unlockrowafterread
rowlocation     loc
boolean         forupdate
boolean         row_qualified
throws standardexception;
/**
return a row location object of the correct type to be
used in calls to insertandfetchlocation.
@exception standardexception standard exception policy.
**/
rowlocation newrowlocationtemplate
throws standardexception;
/**
replace the (partial) row at the given location.
@return true if update was successful, returns false if the update
fails because the record pointed at no longer represents a valid record.
@exception standardexception standard exception policy.
@see rowutil
**/
boolean replace
rowlocation             loc,
datavaluedescriptor   row
formatablebitset                 validcolumns
throws standardexception;
/**
get information about space used by the conglomerate.
**/
spaceinfo getspaceinfo
throws standardexception;
/**
* dump debugging output to error log.
* <p>
* dump information about the conglomerate to error log.
* this is only for debugging purposes, does nothing in a delivered
* system, currently.
*
* @exception  standardexception  standard exception policy.
**/
void debugconglomerate
throws standardexception;