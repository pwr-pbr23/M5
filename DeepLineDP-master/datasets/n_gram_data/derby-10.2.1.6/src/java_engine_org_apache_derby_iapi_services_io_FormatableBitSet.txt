/*
derby - class org.apache.derby.iapi.services.io.formatablebitset
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby iapi services io
import org apache derby iapi services sanity sanitymanager
import java io inputstream
import java io objectoutput
import java io objectinput
import java io ioexception
/**
* formatablebitset is implemented as a packed array of bytes.
*
* @author jamie -- originally coded by jeff
*/
public final class formatablebitset implements formatable  cloneable
/********************************************************
**
**	this class implements formatable. that means that it
**	can write itself to and from a formatted stream. if
**	you add more fields to this class, make sure that you
**	also write/read them with the writeexternal()/readexternal()
**	methods.
**
**	if, inbetween releases, you add more fields to this class,
**	then you should bump the version number emitted by the gettypeformatid()
**	method.
**
********************************************************/
/**
** bits are stored as an array of bytes.
** bits are numbered starting at 0.  bits
** 0..7 go in byte[0], 8..15 in byte[1] and so on.
** the number of bytes is tracked as part
** of the byte array.  the number of bits
** being used is derived by the number of
** bytes being used and the number of bits
** being used by the last byte.  the partially
** unused byte is always byte[byte.length] with the
** lowest bits being unused.
**
** zero length bits are stored using a
** zero length byte array, with all bits
** marked as unused.
*/
private byte	value
private	short	bitsinlastbyte
private transient int	lengthasbits
/**
* niladic constructor
*/
public formatablebitset
/**
* constructs a bit with the initial number of bits
*/
public formatablebitset int numbits
initializebits numbits
private void initializebits int numbits
int numbytes   numbytesfrombits numbits
// the byte array is zero'ed out by the new operator
value   new byte
bitsinlastbyte   numbitsinlastbyte numbits
lengthasbits   numbits
/**
* constructs a bit from an array of bytes.  assume
* bytes are all being used.
*
* @param newvalue	the array of bytes to make up the new bit
*/
public formatablebitset byte newvalue
value   newvalue
bitsinlastbyte   8
lengthasbits   calculatelength newvalue length
/**
* constructs a bit from an array of bytes.
*
* @param newvalue	the array of bytes to make up the new bit
* @param numbits	the number of bits
*/
public formatablebitset byte newvalue  int numbits
bitsinlastbyte   numbitsinlastbyte numbits
lengthasbits   numbits
int leninbytes   numbytesfrombits numbits
if  leninbytes    newvalue length
value   newvalue
else
value   new byte
system arraycopy newvalue  0  value  0  newvalue length
/**
* copy constructor
*
* @param original the formatablebitset to make a copy from
*/
public formatablebitset  formatablebitset original
if  sanitymanager debug
sanitymanager assert
original    null
bitsinlastbyte   original bitsinlastbyte
lengthasbits   original lengthasbits
int leninbytes   formatablebitset numbytesfrombits original lengthasbits
value   new byte
if  leninbytes > 0
system arraycopy original value  0  value  0  leninbytes
/*
* cloneable
*/
public object clone
return new formatablebitset this
/**
* get the length in bytes of a bit value
*
* @return	the length in bytes of this value
*/
public int getlengthinbytes
if  value    null
return 0
return formatablebitset numbytesfrombits lengthasbits
/**
** get the length in bits
**
** @return the length in bits for this value
**
** note: could possibly be changed to a long.  as is
** we are restricted to 2^(31-3) -> 256meg instead
** of 2^31 (integer.max_value) like other datatypes
** (or 2 gig).  if it is ever changed to a long
** be sure to change read/writeexternal which write
** out the length in bits.
*/
public int getlength
return lengthasbits
private int calculatelength int realbytelength
if  realbytelength    0
return 0
return   realbytelength   1    8    bitsinlastbyte
/**
* get the length in bits -- alias for getlength()
*
* @return the length in bits for this value
*/
public int size
return getlength
/**
* get the value of the byte array
*
* @return	the value of the byte array
*/
public byte getbytearray
if  value    null
return null
// in some cases the array is bigger than the actual number
// of valid bytes.
int realbytelength   getlengthinbytes
// currently the case is that the return from this
// call only includes the valid bytes.
if  value length    realbytelength
byte data   new byte
system arraycopy value  0  data  0  realbytelength
value   data
return value
/**
* set the value of the byte array
*
* @return	the value of the byte array
*/
public boolean isnull
return this value    null
/**
* grow (widen) a formatablebitset to n bis
*
* @param n	the number of bits you want.  the bits are
*			always added as 0 and are appended to the
*			least significant end of the bit array.
*
* assumptions: that all extra bits in the last byte
* are zero.
*/
public void grow int n
if  n <  this getlength
return
if  value    null
initializebits n
return
int delta   n   this getlength
int oldnumbytes   getlengthinbytes
/*
** if we have enough space in the left over bits,
** then all we need to do is change the modulo.
*/
if   oldnumbytes    0
8   this bitsinlastbyte  >  delta
this bitsinlastbyte    delta
lengthasbits   n
return
int newnumbytes   formatablebitset numbytesfrombits n
// is there enough room in the existing array
if  newnumbytes <  value length
// ensure the bits are zeroed
for  int i   oldnumbytes  i <  newnumbytes  i
value   0
else
/*
** we didn't have enough bytes in value, so we need
** to create a bigger byte array and use that.
*/
byte newvalue   new byte
system arraycopy value  0  newvalue  0  oldnumbytes
value   newvalue
bitsinlastbyte   numbitsinlastbyte n
lengthasbits   n
/**
* shrink (narrow) a formatablebitset to n bits
*
* @param n	the number of bits the caller wants.  the
* 			bits are always removed from the
*			least significant end of the bit array.
*/
public formatablebitset shrink int n
int		numbytes
int		lastbytenum
/*
** sanity check: we shouldn't shrink down to
** nothing.
*/
if  sanitymanager debug
if  value    null
sanitymanager throwassert
return null
if  n >  this getlength
return this
lastbytenum   numbytesfrombits n    1
bitsinlastbyte   numbitsinlastbyte n
lengthasbits   n
/*
** mask out any left over bits in the
** last byte.  retain the highest bits.
*/
if  bitsinlastbyte    8
value    0xff00 >> bitsinlastbyte
return this
/*
** some of the operators required by sql.  these could alternatively
** be in sqlbit, but since they are so tightly bound to the implementation
** rather than return something that undermines the encapsulation
** of this type, i have chosen to put them in here.
*/
/**
* bit equivalence.  compare this with other.
* if the length is different, then cannot be
* equal so short circuit.  otherwise, rely on
* compare().  note that two zero length bits are
* considered equal.
*
* @param other	the other bit to compare to
*
* @return true|false
*/
public boolean equals formatablebitset other
if  this getlength      other getlength
return false
return  this compare other     0
/**
* bit comparison.  compare this with other.
* will always do a byte by byte compare.
*
* given 2 similar bits of unequal lengths (x and y),
* where x.getlength() < y.getlength() but where:
*
*	 x[0..x.getlength()] == y[0..x.getlength()]
*
* then x < y.
*
*
* @param other the other bit to compare to
*
* @return -1	- if other <  this
*			0	- if other == this
*			1	- if other >  this
*
*/
public int compare formatablebitset other
int		othercount  thiscount
int		otherlen  thislen
byte	otherb
otherb   other value
/*
** by convention, nulls sort low, and null == null
*/
if  this value    null    otherb    null
if  this value    null 	   otherb    null
return 1
if  otherb    null 		   this value    null
return  1
return 0 				   both null
otherlen   other getlengthinbytes
thislen   getlengthinbytes
for  othercount   0  thiscount   0
othercount < otherlen    thiscount < thislen
othercount    thiscount
if  otherb    this value
break
/*
** '==' if byte by byte comparison is identical and
** exact same length in bits (not bytes).
*/
if   othercount    otherlen      thiscount    thislen
if  this getlength      other getlength
return 0
/*
** if subset of bits is identical, return 1
** if other.getlength() > this.getlength(); otherwise,
** -1
*/
return  other getlength   < this getlength    ? 1    1
if  othercount    otherlen
return 1
else if  thiscount    thislen
return  1
else
/*
** ok, we have a difference somewhere.  now
** we have to go to the trouble of converting
** to a int and masking out the sign to get
** a valid comparision because bytes are signed.
*/
int otherint  thisint
otherint    int otherb
otherint     0x100   1
thisint    int this value
thisint     0x100   1
return  thisint > otherint  ? 1    1
/**
* bit concatenation.
*
* @param other 	the other bit to append to this
*
* @return bit -- the newly concatenated bit
*
*/
public formatablebitset concatenate formatablebitset other
int		newlen
int		otherlen
int		prevlen
int		prevlenbytes
int		newlenbytes
int     otherlenbytes
int		i  j
byte	newvalue
byte	othervalue
int		shiftbits
int		inbyte
prevlen   this getlength
prevlenbytes   this getlengthinbytes
otherlen   other getlength
othervalue   other getbytearray
otherlenbytes   other getlengthinbytes
newlen   prevlen   otherlen
newlenbytes   numbytesfrombits newlen
newvalue   new byte
/*
** copy over the entire array in this.value
** to newlenbytes.
*/
for  i   0  i < prevlenbytes  i
newvalue   this value
/*
** now if we have any bits left over
** we need to shift them, and keep
** shifting everything down.  be careful
** to handle the case where the bit
** used to have length 0.
*/
shiftbits    prevlen    0  ? 8   this bitsinlastbyte
for  j   0  j < otherlenbytes  j    i
if  shiftbits    8
newvalue   othervalue
else
/*
** convert to an int because it will get converted
** on the shift anyway.
*/
inbyte    int othervalue
/*
** mask off the high bits in case they are now
** turned on if we had the sign bit on.
*/
inbyte     0x100   1
/*
** use the high order bits to finish off
** the last byte
*/
newvalue     inbyte >>> shiftbits
/*
** start the next one with whatever is left, unless
** there is nothing left.
*/
if  i < newlenbytes
newvalue     inbyte <<  8   shiftbits
return new formatablebitset newvalue  newlen
/**
* produce a hash code by putting the value bytes into an int, exclusive or'ing
* if there are more than 4 bytes.
*
* @return the hash code
*/
public int hashcode
if  null    value
return 0
int code   0
int i
int shift   0
int bytelength   getlengthinbytes
for  i   0  i < bytelength  i
code ^   value   0xff <<shift
shift    8
if  32 <  shift
shift   0
return code
/**
* bit isset
*
* @param position	the bit to check
*
*/
public final boolean isset int position
if  sanitymanager debug
if  position >  this getlength
sanitymanager throwassert
position
this getlength
try
int bytepos   position   8
int bitpos   7    position % 8
return   value    1 << bitpos      0
catch  arrayindexoutofboundsexception e
// should not happen, handle it just in case not all cases are tested
// by insane server.
return false
/**
* bit get -- alias for isset()
*
* @param position	the bit to check
*
*/
public final boolean get int position
return isset position
/**
* bit set
*
* @param position	the bit to set
*
*/
public void set int position
if  sanitymanager debug
if  position >  this getlength
sanitymanager throwassert
this getlength
// should not happen, handle it just in case not all cases are tested
// by insane server.
if  position >  getlength
grow position
int bytepos   position   8
int bitpos   7    position % 8
value     1 << bitpos
/**
* bit clear
*
* @param position	the bit to clear
*
*/
public void clear int position
int	bytepos
int	bitpos
if  sanitymanager debug
if  position >  this getlength
sanitymanager throwassert
this getlength
// should not happen, handle it just in case not all cases are tested
// by insane server.
if  position >  getlength
grow position
bytepos   position   8
bitpos   7    position % 8
value    ~ 1 << bitpos
/**
clear all the bits in this formatablebitset
*/
public void clear
if  value    null
return
int bytelength   getlengthinbytes
for  int ix 0  ix < bytelength  ix
value   0
/**
* figure out how many bytes are needed to
* store the input number of bits.
*
* @param bits	bits
*
* @return	the number of bytes
*/
protected static int
numbytesfrombits int bits
return  bits    0  ? 0     bits   1    8    1
/**
* figure out how many bits are in the last
* byte from the total number of bits.
*
* @param	bits	bits
*
* @return	the number of bits
*/
private static short
numbitsinlastbyte int bits
int modulo   bits % 8
return  short   modulo    0  ?
bits    0  ? 0   8
modulo
/**
* translate a hex character to a byte.
*
* @param hexchar	a character with the value [0-9a-fa-f].
*
* @return	a byte with the numeric value corresponding to the hex character
*/
private static byte
hexchartobyte char hexchar
byte	bytevalue
switch  hexchar
case
bytevalue   0
break
case
bytevalue   1
break
case
bytevalue   2
break
case
bytevalue   3
break
case
bytevalue   4
break
case
bytevalue   5
break
case
bytevalue   6
break
case
bytevalue   7
break
case
bytevalue   8
break
case
bytevalue   9
break
case
case
bytevalue   0xa
break
case
case
bytevalue   0xb
break
case
case
bytevalue   0xc
break
case
case
bytevalue   0xd
break
case
case
bytevalue   0xe
break
case
case
bytevalue   0xf
break
default
if  sanitymanager debug
sanitymanager throwassert     hexchar
throw new illegalargumentexception
return bytevalue
private static char decodearray
/**
* format the string into bitset format: {0, 2, 4, 8} if bits 0, 2, 4, 8
* are set.
*
* @return a new string containing the formatted bit value
*/
public string tostring
char	outchars
int		inposition
int		outposition
int 	inbyte
if  value    null
return null
// give it a reasonable size
stringbuffer str   new stringbuffer getlength   8 3
str append
boolean first   true
for  inposition   0  inposition < getlength    inposition
if  isset inposition
if   first
str append
first   false
str append inposition
str append
return new string str
/**
* statically calculates how many bits can fit into the number of
* bytes if this bit object is externalized.  only valid for this
* implementation of bit.
*/
public static int maxbitsforspace int numbytes
return  numbytes   4  8
/**
* if any bit is set, return the bit number of a bit that is set.
* if no bit is set, return -1;
*
* @return the bit number of a bit that is set, or -1 if no bit is set
*/
public int anysetbit
int numbytes   getlengthinbytes
int bitpos
for  int i   0  i < numbytes 1  i
if  value    0
for  int j   0  j < 8  j
bitpos   7 j
if    1 << bitpos    value     0
return   i 8  j
// only the top part of the last byte is relevant
byte mask    byte  0xff <<  8 bitsinlastbyte
if   value   mask     0
for  int j   0  j < bitsinlastbyte  j
bitpos   7 j
if    1 << bitpos    value     0
return   numbytes 1  8  j
return  1
/**
* like anysetbit(), but return any set bit whose number is bigger than
* beyondbit. if no bit is set after beyondbit, -1 is returned.
* by using anysetbit() and anysetbit(beyondbit), one can quickly go
* thru the entire bit array to return all set bit.
*
* @param beyondbit only look at bit that is greater than this bit number
* @return the bit number of a bit that is set, or -1 if no bit after
* beyondbit is set
*/
public int anysetbit int beyondbit
if  sanitymanager debug
if  beyondbit >  this getlength
sanitymanager throwassert
this getlength
int startingbit    beyondbit 1
// we have seen the last bit.
if  startingbit >  this getlength
return  1
int numbytes   getlengthinbytes
int startingbyte   startingbit   8
int startingbitpos   startingbit % 8
int bitpos
byte mask
// see if any bits in this byte is set, only the bottom part of the
// first byte is relevant
mask    byte  0xff >> startingbitpos
if  startingbyte    numbytes 1 	   starting byte    last byte
mask     byte  0xff <<  8 bitsinlastbyte
if   value   mask      0
// i know we will see the bit before bitsinlastbyte even if we are
// at the last byte, no harm in going up to 8 in the loop
for  int j   startingbitpos  j < 8  j
if  sanitymanager debug
if  startingbyte    numbytes 1
sanitymanager assert j < bitsinlastbyte
bitpos   7 j
if    1 << bitpos    value     0
return  startingbyte 8 j
for  int i    startingbyte 1   i < numbytes 1  i
if  value    0
for  int j   0  j < 8  j
bitpos   7 j
if    1 << bitpos    value     0
return   i 8  j
// last byte if there are more than one bytes.  only the top part of
// the last byte is relevant
if  startingbyte    numbytes 1
mask    byte  0xff <<  8 bitsinlastbyte
if   value   mask     0
for  int j   0  j < bitsinlastbyte  j
bitpos   7 j
if    1 << bitpos    value     0
return   numbytes 1  8  j
return  1
/**
* bitwise or this bit with another bit.
*
* @param otherbit the other bit
*/
public void or formatablebitset otherbit
if  otherbit    null    otherbit getlength      0
return
int otherlength   otherbit getlength
if  otherlength > getlength
grow otherlength      expand this bit
if  otherbit instanceof formatablebitset
// we know the bit ordering, optimize this
formatablebitset ob    formatablebitset otherbit
int obbytelen   ob getlengthinbytes
for  int i   0  i < obbytelen 1  i
value    ob value
// do the last byte bit by bit
for  int i    obbytelen 1  8  i < otherlength  i
if  otherbit isset i
set i
else
// we don't know the bit ordering, call thru the interface and go
// thru bit by bit
// this bit impl's length >= other bit's length
for  int i   0  i < otherlength  i
if  otherbit isset i
set i
/**
* bitwise and this bit with another bit.
*
* @param otherbit the other bit
*/
public void and formatablebitset otherbit
if  sanitymanager debug
sanitymanager assert otherbit    null
int otherlength   otherbit getlength
// supposedly cannot happen, but handle it just in case.
if  otherlength > getlength
grow otherlength      expand this bit
if  otherlength < getlength
// clear all bits that are not in the other bit
int startingbyte    otherlength   8    1
int len   getlengthinbytes
for  int i   startingbyte  i < len  i
value   0
for  int i   otherlength  i < startingbyte 8  i
if  i < getlength
clear i
else
break
if  otherlength    0
return
int length   otherbit getlengthinbytes   < getlengthinbytes   ?
otherbit getlengthinbytes     getlengthinbytes
for  int i   0  i < length  i
value    otherbit value
/**
* logically xors this formatablebitset with the specified formatablebitset.
* @param set	the formatablebitset to be xored with.
*/
public void xor formatablebitset set
if  sanitymanager debug
if  getlength      set getlength
sanitymanager throwassert     getlength
set getlength
int setlength   set getlength
for  int i   setlength  i   > 0
if  isset i     set isset i
clear i
else if  isset i     set isset i
set i
/**
* get a count of the number of bits that are set.
*
* @return the number of bits that are set.
*/
public int getnumbitsset
int count   0
for  int index   getlength     1  index >  0  index
if  isset index
count
return count
/////////////////////////////////////////////////////////
//
// externalizable
//
/////////////////////////////////////////////////////////
/**
* format: <ul>
*		<li>int		length in bits  </li>
*		<li>byte[]					</li></ul>
*
* @see java.io.externalizable#writeexternal
*/
public void writeexternal objectoutput out  throws ioexception
// never called when value is null
if  sanitymanager debug
sanitymanager assert value    null
out writeint getlength
int bytelen   getlengthinbytes
if  bytelen > 0
out write value  0  bytelen
/**
* note: gracefully handles zero length
* bits -- will create a zero length array
* with no bits being used.  fortunately
* in.read() is ok with a zero length array
* so no special code.
* <p>
* warning: this method cannot be changed w/o
* changing sqlbit because sqlbit calls this
* directly w/o calling read/writeobject(), so
* the format id is not stored in that case.
*
* @see java.io.externalizable#readexternal
*/
public void readexternal objectinput in  throws ioexception
int leninbits
int leninbytes
leninbits   in readint
leninbytes   formatablebitset numbytesfrombits leninbits
/*
** how can leninbytes be zero?  the implication is
** that leninbits is zero.  well, the reason this can
** happen is that the store will reset our stream
** out from underneath us if we are a bit column that
** overflows onto another page because it assumes that
** we want to stream it in specially.  because of this warped
** api, our readint() will return 0 even though our
** writeexternal() did a writeint(xxx).  the upshot
** is that you should leave the following alone.
*/
value   new byte
in readfully value
bitsinlastbyte   numbitsinlastbyte leninbits
lengthasbits   leninbits
public void readexternalfromarray arrayinputstream in  throws ioexception
int leninbits   in readint
int leninbytes   formatablebitset numbytesfrombits leninbits
value   new byte
in readfully value
bitsinlastbyte   numbitsinlastbyte leninbits
lengthasbits   leninbits
/**
* get the formatid which corresponds to this class.
*
*	@return	the formatid of this class
*/
public	int	gettypeformatid  	  return storedformatids bitimpl_v01_id