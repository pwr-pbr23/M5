/*
derby - class org.apache.derby.impl.sql.execute.jarutil
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl sql execute
import org apache derby iapi reference property
import org apache derby iapi util idutil
import org apache derby impl sql execute jarddl
import org apache derby iapi services property propertyutil
import org apache derby iapi services loader classfactory
import org apache derby iapi services context contextservice
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi error standardexception
import org apache derby iapi sql conn languageconnectioncontext
import org apache derby iapi sql dictionary datadescriptorgenerator
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi sql dictionary fileinfodescriptor
import org apache derby iapi sql dictionary schemadescriptor
import org apache derby iapi sql depend dependencymanager
import org apache derby iapi reference sqlstate
import org apache derby iapi store access fileresource
import org apache derby catalog uuid
import org apache derby iapi services io fileutil
import org apache derby io storagefile
import java io ioexception
import java io inputstream
import java sql callablestatement
import java sql connection
import java sql sqlexception
public class jarutil
public static final string add_jar_ddl
public static final string drop_jar_ddl
public static final string replace_jar_ddl
public static final string read_jar
//
//state passed in by the caller
private uuid id    for add null means create a new id
private string schemaname
private string sqlname
//derived state
private languageconnectioncontext lcc
private fileresource fr
private datadictionary dd
private datadescriptorgenerator ddg
//
//state derived from the caller's context
public jarutil uuid id  string schemaname  string sqlname
throws standardexception
this id   id
this schemaname   schemaname
this sqlname   sqlname
lcc    languageconnectioncontext
contextservice getcontext languageconnectioncontext context_id
fr   lcc gettransactionexecute   getfilehandler
dd   lcc getdatadictionary
ddg   dd getdatadescriptorgenerator
/**
add a jar file to the current connection's database.
@param id the id for the jar file we add. if null this makes up a new id.
@param schemaname the name for the schema that holds the jar file.
@param sqlname the sql name for the jar file.
@param externalpath the path for the jar file to add.
@return the generationid for the jar file we add.
@exception standardexception opps
*/
static public long
add uuid id  string schemaname  string sqlname  string externalpath
throws standardexception
jarutil jutil   new jarutil id  schemaname  sqlname
inputstream is   null
try
is   fileutil getinputstream externalpath  0
return jutil add is
catch  java io ioexception fnfe
throw standardexception newexception sqlstate sqlj_invalid_jar  fnfe  externalpath
finally
try  if  is    null  is close
catch  ioexception ioe
/**
add a jar file to the current connection's database.
<p> the reason for adding the jar file in this private instance
method is that it allows us to share set up logic with drop and
replace.
@param is a stream for reading the content of the file to add.
@exception standardexception opps
*/
public long add inputstream is  throws standardexception
//
//like create table we say we are writing before we read the dd
dd startwriting lcc
fileinfodescriptor fid   getinfo
if  fid    null
throw
standardexception newexception sqlstate lang_object_already_exists_in_object
fid getdescriptortype    sqlname  fid getschemadescriptor   getdescriptortype    schemaname
try
notifyloader false
dd invalidateallspsplans
long generationid   fr add jarddl mkexternalname schemaname  sqlname  fr getseparatorchar    is
schemadescriptor sd   dd getschemadescriptor schemaname  null  true
fid   ddg newfileinfodescriptor id  sd
sqlname  generationid
dd adddescriptor fid  sd  datadictionary sysfiles_catalog_num
false  lcc gettransactionexecute
return generationid
finally
notifyloader true
/**
drop a jar file from the current connection's database.
@param id the id for the jar file we drop. ignored if null.
@param schemaname the name for the schema that holds the jar file.
@param sqlname the sql name for the jar file.
@param purgeoncommit true means purge the old jar file on commit. false
means leave it around for use by replication.
@exception standardexception opps
*/
static public void
drop uuid id  string schemaname  string sqlname boolean purgeoncommit
throws standardexception
jarutil jutil   new jarutil id  schemaname sqlname
jutil drop purgeoncommit
/**
drop a jar file from the current connection's database.
<p> the reason for dropping  the jar file in this private instance
method is that it allows us to share set up logic with add and
replace.
@param purgeoncommit true means purge the old jar file on commit. false
means leave it around for use by replication.
@exception standardexception opps
*/
public void drop boolean purgeoncommit  throws standardexception
//
//like create table we say we are writing before we read the dd
dd startwriting lcc
fileinfodescriptor fid   getinfo
if  fid    null
throw standardexception newexception sqlstate lang_file_does_not_exist  sqlname schemaname
if  sanitymanager debug
if  id    null     fid getuuid   equals id
sanitymanager throwassert   id
fid getuuid
string dbcp_s   propertyutil getserviceproperty lcc gettransactionexecute   property database_classpath
if  dbcp_s    null
stringdbcp  idutil parsedbclasspath dbcp_s
lcc getidentifiercasing      lcc anti_ansi_casing
boolean found   false
//
//look for the jar we are dropping on our database classpath.
//we don't concern ourselves with 3 part names since they may
//refer to a jar file in another database and may not occur in
//a database classpath that is stored in the propert congomerate.
for  int ix 0 ix<dbcp length ix
if  dbcp length    2
dbcp equals schemaname     dbcp equals sqlname
found   true
if  found
throw standardexception newexception sqlstate lang_cant_drop_jar_on_db_class_path_during_execution
idutil mkqualifiedname schemaname sqlname
dbcp_s
try
notifyloader false
dd invalidateallspsplans
dependencymanager dm   dd getdependencymanager
dm invalidatefor fid  dependencymanager drop_jar  lcc
dd dropfileinfodescriptor fid
fr remove jarddl mkexternalname schemaname  sqlname  fr getseparatorchar
fid getgenerationid    true   purgeoncommit
finally
notifyloader true
/**
replace a jar file from the current connection's database with the content of an
external file.
@param id the id for the jar file we add. ignored if null.
@param schemaname the name for the schema that holds the jar file.
@param sqlname the sql name for the jar file.
@param externalpath the path for the jar file to add.
@param purgeoncommit true means purge the old jar file on commit. false
means leave it around for use by replication.
@return the new generationid for the jar file we replace.
@exception standardexception opps
*/
static public long
replace uuid id string schemaname  string sqlname
string externalpath boolean purgeoncommit
throws standardexception
jarutil jutil   new jarutil id schemaname sqlname
inputstream is   null
try
is   fileutil getinputstream externalpath  0
return jutil replace is purgeoncommit
catch  java io ioexception fnfe
throw standardexception newexception sqlstate sqlj_invalid_jar  fnfe  externalpath
finally
try  if  is    null  is close
catch  ioexception ioe
/**
replace a jar file in the current connection's database with the
content of an external file.
<p> the reason for adding the jar file in this private instance
method is that it allows us to share set up logic with add and
drop.
@param is an input stream for reading the new content of the jar file.
@param purgeoncommit true means purge the old jar file on commit. false
means leave it around for use by replication.
@exception standardexception opps
*/
public long replace inputstream is boolean purgeoncommit  throws standardexception
//
//like create table we say we are writing before we read the dd
dd startwriting lcc
//
//temporarily drop the fileinfodescriptor from the data dictionary.
fileinfodescriptor fid   getinfo
if  fid    null
throw standardexception newexception sqlstate lang_file_does_not_exist  sqlname schemaname
if  sanitymanager debug
if  id    null     fid getuuid   equals id
sanitymanager throwassert
id   fid getuuid
try
// disable loads from this jar
notifyloader false
dd invalidateallspsplans
dd dropfileinfodescriptor fid
//
//replace the file.
long generationid
fr replace jarddl mkexternalname schemaname  sqlname  fr getseparatorchar
fid getgenerationid    is  purgeoncommit
//
//re-add the descriptor to the data dictionary.
fileinfodescriptor fid2
ddg newfileinfodescriptor fid getuuid   fid getschemadescriptor
sqlname generationid
dd adddescriptor fid2  fid getschemadescriptor
datadictionary sysfiles_catalog_num  false  lcc gettransactionexecute
return generationid
finally
// reenable class loading from this jar
notifyloader true
/**
get the fileinfodescriptor for a jar file from the current connection's database or
null if it does not exist.
@param schemaname the name for the schema that holds the jar file.
@param sqlname the sql name for the jar file.
@return the fileinfodescriptor.
@exception standardexception opps
*/
public static fileinfodescriptor getinfo string schemaname  string sqlname  string statementtype
throws standardexception
jarutil jutil   new jarutil null schemaname sqlname
return jutil getinfo
/**
get the fileinfodescriptor for the jar file or null if it does not exist.
@exception standardexception ooops
*/
private fileinfodescriptor getinfo
throws standardexception
schemadescriptor sd   dd getschemadescriptor schemaname  null  true
return dd getfileinfodescriptor sd sqlname
// get the current version of the jar file as a file or inputstream
public static object getasobject string schemaname  string sqlname
throws standardexception
jarutil jutil   new jarutil null schemaname sqlname
fileinfodescriptor fid   jutil getinfo
if  fid    null
throw standardexception newexception sqlstate lang_file_does_not_exist  sqlname schemaname
long generationid   fid getgenerationid
storagefile f   jutil getasfile generationid
if  f    null
return f
return jutil getasstream generationid
private storagefile getasfile long generationid
return fr getasfile jarddl mkexternalname schemaname  sqlname  fr getseparatorchar     generationid
public static inputstream getasstream string schemaname  string sqlname
long generationid  throws standardexception
jarutil jutil   new jarutil null schemaname sqlname
return jutil getasstream generationid
private inputstream getasstream long generationid  throws standardexception
try
return fr getasstream jarddl mkexternalname schemaname  sqlname  fr getseparatorchar     generationid
catch  ioexception ioe
throw standardexception newexception sqlstate lang_file_error  ioe  ioe tostring
private void notifyloader boolean reload  throws standardexception
classfactory cf   lcc getlanguageconnectionfactory   getclassfactory
cf notifymodifyjar reload