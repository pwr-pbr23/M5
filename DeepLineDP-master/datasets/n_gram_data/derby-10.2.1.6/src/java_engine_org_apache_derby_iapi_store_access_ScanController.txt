/*
derby - class org.apache.derby.iapi.store.access.scancontroller
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby iapi store access
import org apache derby iapi services io storable
import org apache derby iapi error standardexception
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi types rowlocation
import org apache derby iapi services io formatablebitset
/**
a scan is the mechanism for iterating over the rows in a conglomerate,
the scan controller is the interface through which access clients
control the underlying scan.  an instance of a scan controller can
be thought of as an open scan.
<p>
scans are opened from a transactioncontroller.
<p>
a scancontroller can handle partial rows. partial rows
are described in rowutil.
<br>
a scan controller is opened with a formatablebitset that describes the
columns that need to be returned on a fetch call. this formatablebitset
need not include any columns referenced in the qualifers, start
and/or stop keys.
@see transactioncontroller#openscan
@see genericscancontroller
@see rowcountable
@see rowutil
**/
public interface scancontroller extends genericscancontroller
/**
ge is used to position a scan at values greater than or or equal to the
given key in the scan.  this positioning argument refers to the order
within the scan (not necessarily actual compare calls on the datatypes).
"greater" than is interpreted in terms of the
current conglomerate and scan.  for instance, a btree may be ordered
ascending on an int, in that case a 2 is "greater" than 1 in a forward
scan on that index, and 1 is "greater" than 2 in a backward scan.
if the btree was ordered descending on an int then 1 is "greater" than
2 in a forward scan on that index, and 2 is "greater" than 1 in a backward
scan.
@see transactioncontroller#openscan
*/
/* the value of this must be the same value returned by the orderable
* interface when a key is > than another key.
*/
public static final int ge   1
/**
gt is used to position a scan at values greater than the given key.
this positioning argument refers to the order
within the scan (not necessarily actual compare calls on the datatypes).
"greater" than is interpreted in terms of the
current conglomerate and scan.  for instance, a btree may be ordered
ascending on an int, in that case a 2 is "greater" than 1 in a forward
scan on that index, and 1 is "greater" than 2 in a backward scan.
if the btree was ordered descending on an int then 1 is "greater" than
2 in a forward scan on that index, and 2 is "greater" than 1 in a backward
scan.
@see transactioncontroller#openscan
*/
/* the value of this must be the same value returned by the orderable
* interface when a key is < than another key.
*/
public static final int gt    1
/**
na - argument is unused in call.  for some scans the key is set to null
to indicate no start or stop position, in those cases the position
operator is ignored.
@see transactioncontroller#openscan
*/
/* the value of this must be the same value returned by the orderable
* interface when a key is < than another key.
*/
public static final int na   0
/**
delete the row at the current position of the scan.
@return true if the delete was successful,
false if the current position is no longer valid (ie. if it was already
deleted).
@exception standardexception standard exception policy.
**/
boolean delete
throws standardexception
/**
* a call to allow client to indicate that current row does not qualify.
* <p>
* indicates to the scancontroller that the current row does not
* qualify for the scan.  if the isolation level of the scan allows,
* this may result in the scan releasing the lock on this row.
* <p>
* note that some scan implimentations may not support releasing locks on
* non-qualifying rows, or may delay releasing the lock until sometime
* later in the scan (ie. it may be necessary to keep the lock until
* either the scan is repositioned on the next row or page).
* <p>
* this call should only be made while the scan is positioned on a current
* valid row.
*
* @exception  standardexception  standard exception policy.
**/
void didnotqualify   throws standardexception
/**
returns true if the current position of the scan still qualifies
under the set of qualifiers passed to the openscan().  when called
this routine will reapply all qualifiers against the row currently
positioned and return true if the row still qualifies.  if the row
has been deleted or no longer passes the qualifiers then this routine
will return false.
this case can come about if the current scan
or another scan on the same table in the same transaction
deleted the row or changed columns referenced by the qualifier after
the next() call which positioned the scan at this row.
note that for comglomerates which don't support update, like btree's,
there is no need to recheck the qualifiers.
the results of a fetch() performed on a scan positioned on
a deleted row are undefined, note that this can happen even if next()
has returned true (for instance the client can delete the row, or if
using read uncommitted another thread can delete the row after the
next() call but before the fetch).
@exception standardexception standard exception policy.
**/
boolean doescurrentpositionqualify
throws standardexception
/**
fetch the (partial) row at the current position of the scan.
the value in the destrow storable row is replaced
with the value of the row at the current scan
position.  the columns of the destrow row must
be of the same type as the actual columns in the
underlying conglomerate. the number of elements in
fetch must be compatible with the number of scan columns
requested at the openscan call time.
<br>
a fetch can return a sub-set of the scan columns reqested
at scan open time by supplying a destrow will less elements
than the number of requested columns. in this case the n leftmost
of the requested columns are fetched, where n = destrow.length.
in the case where all columns are rested and n = 2 then columns 0 and 1
are returned. in the case where the openscan formatablebitset requested columns
1, 4 and 7, then columns 1 and 4 would be fetched when n = 2.
<br>
the results of a fetch() performed on a scan after next() has returned
false are undefined.
a fetch() performed on a scan positioned on
a deleted row will throw a standardexception with
state = sqlstate.am_record_not_found.  note that this can happen even if
next() has returned true (for instance the client can delete the row, or if
using read uncommitted another thread can delete the row after the
next() call but before the fetch).
@param destrow the row into which the value of the current
position in the scan is to be stored.
@exception standardexception standard exception policy.
@see rowutil
**/
void fetch datavaluedescriptor destrow
throws standardexception
/**
the same as fetch, except that the qualifiers passed to the openscan()
will not be applied. destrow will contain the current row even if it
has been changed and no longer qualifies.
@param destrow the row into which the value of the current
position in the scan is to be stored.
@exception standardexception standard exception policy.
*/
void fetchwithoutqualify datavaluedescriptor destrow
throws standardexception
/**
fetch the (partial) row at the next position of the scan.
if there is a valid next position in the scan then
the value in the destrow storable row is replaced
with the value of the row at the current scan
position.  the columns of the destrow row must
be of the same type as the actual columns in the
underlying conglomerate.
the resulting contents of destrow after a fetchnext()
which returns false is undefined.
the result of calling fetchnext(row) is exactly logically
equivalent to making a next() call followed by a fetch(row)
call.  this interface allows implementations to optimize
the 2 calls if possible.
@param destrow the destrow row into which the value
of the next position in the scan is to be stored.
@return true if there is a next position in the scan,
false if there isn't.
@exception standardexception standard exception policy.
@see scancontroller#fetch
@see rowutil
**/
boolean fetchnext datavaluedescriptor destrow
throws standardexception
/**
fetch the location of the current position in the scan.
the destination location is replaced with the location
corresponding to the current position in the scan.
the destination location must be of the correct actual
type to accept a location from the underlying conglomerate
location.
the results of a fetchlocation() performed on a scan after next() has
returned false are undefined.
the results of a fetchlocation() performed on a scan positioned on
a deleted row are undefined, note that this can happen even if next()
has returned true (for instance the client can delete the row, or if
using read uncommitted another thread can delete the row after the
next() call but before the fetchlocation).
@exception standardexception standard exception policy.
**/
void fetchlocation rowlocation destrowlocation
throws standardexception
/**
returns true if the current position of the scan is at a
deleted row.  this case can come about if the current scan
or another scan on the same table in the same transaction
deleted the row after the next() call which positioned the
scan at this row.
the results of a fetch() performed on a scan positioned on
a deleted row are undefined.
@exception standardexception standard exception policy.
**/
boolean iscurrentpositiondeleted
throws standardexception
/**
move to the next position in the scan.  if this is the first
call to next(), the position is set to the first row.
returns false if there is not a next row to move to.
it is possible, but not guaranteed, that this method could return
true again, after returning false, if some other operation in the same
transaction appended a row to the underlying conglomerate.
@return true if there is a next position in the scan,
false if there isn't.
@exception standardexception standard exception policy.
**/
boolean next
throws standardexception
/**
* positions the scan at row location and locks the row.
* if the scan is not opened, it will be reopened if this is a holdable
* scan and there has not been any operations which causes rowlocations
* to be invalidated.
* @param rl rowlocation for the new position for the scan. the
*           rowlocation submitted should be a rowlocation which has
*           previously been returned by this scancontroller.
* @return true if the scan has been positioned at the rowlocation.
*         false if the scan could not be positioned.
*
* @exception standardexception standard exception policy.
*
*/
boolean positionatrowlocation rowlocation rl
throws standardexception
/**
replace the (partial) row at the current position of the scan.
@return true if the replace was successful,
false if the current position is no longer valid (ie. if it was deleted).
@exception standardexception standard exception policy.
@see rowutil
**/
boolean replace datavaluedescriptor row  formatablebitset validcolumns
throws standardexception