/*
derby - class org.apache.derby.impl.sql.execute.droptableconstantaction
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl sql execute
import org apache derby iapi sql execute constantaction
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi error standardexception
import org apache derby iapi sql conn languageconnectioncontext
import org apache derby iapi sql statementtype
import org apache derby iapi sql dictionary columndescriptor
import org apache derby iapi sql dictionary columndescriptorlist
import org apache derby iapi sql dictionary conglomeratedescriptor
import org apache derby iapi sql dictionary constraintdescriptor
import org apache derby iapi sql dictionary constraintdescriptorlist
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi sql dictionary defaultdescriptor
import org apache derby iapi sql dictionary genericdescriptorlist
import org apache derby iapi sql dictionary referencedkeyconstraintdescriptor
import org apache derby iapi sql dictionary schemadescriptor
import org apache derby iapi sql dictionary tabledescriptor
import org apache derby iapi sql dictionary triggerdescriptor
import org apache derby iapi sql depend dependencymanager
import org apache derby iapi reference sqlstate
import org apache derby iapi sql activation
import org apache derby iapi store access transactioncontroller
import org apache derby catalog uuid
import java util enumeration
/**
*	this class  describes actions that are always performed for a
*	drop table statement at execution time.
*
*	@author rick hillegas	extracted code from droptableresultset.
*/
class droptableconstantaction extends ddlsingletableconstantaction
private final long				conglomeratenumber
private final string				fulltablename
private final string				tablename
private final schemadescriptor	sd
private final boolean 	cascade
// constructors
/**
*	make the constantaction for a drop table statement.
*
*
*	@param	fulltablename		fully qualified table name
*	@param	tablename			table name.
*	@param	sd					schema that table lives in.
*  @param  conglomeratenumber	conglomerate number for heap
*  @param  tableid				uuid for table
*  @param  behavior			drop behavior: restrict, cascade or default
*
*/
droptableconstantaction
string				fulltablename
string				tablename
schemadescriptor	sd
long				conglomeratenumber
uuid				tableid
int					behavior
super tableid
this fulltablename   fulltablename
this tablename   tablename
this sd   sd
this conglomeratenumber   conglomeratenumber
this cascade    behavior    statementtype drop_cascade
if  sanitymanager debug
sanitymanager assert sd    null
// object methods
public	string	tostring
// do not put this under sanitymanager.debug - it is needed for
// error reporting.
return     fulltablename
// interface methods
/**
*	this is the guts of the execution-time logic for drop table.
*
*	@see constantaction#executeconstantaction
*
* @exception standardexception		thrown on failure
*/
public void	executeconstantaction  activation activation
throws standardexception
tabledescriptor td
uuid tableid
conglomeratedescriptor cds
languageconnectioncontext lcc   activation getlanguageconnectioncontext
datadictionary dd   lcc getdatadictionary
dependencymanager dm   dd getdependencymanager
transactioncontroller tc   lcc gettransactionexecute
if   sd    null     sd getschemaname   equals schemadescriptor std_declared_global_temporary_tables_schema_name
td   lcc gettabledescriptorfordeclaredglobaltemptable tablename     check if this is a temp table before checking data dictionary
if  td    null    td null here means it is not a temporary table  look for table in physical session schema
td   dd gettabledescriptor tablename  sd
if  td    null    td null means tablename is not a temp table and it is not a physical table in session schema
throw standardexception newexception sqlstate lang_table_not_found_during_execution  fulltablename
if  td gettabletype       tabledescriptor global_temporary_table_type
dm invalidatefor td  dependencymanager drop_table  lcc
tc dropconglomerate td getheapconglomerateid
lcc dropdeclaredglobaltemptable tablename
return
/* lock the table before we access the data dictionary
* to prevent deadlocks.
*
* note that for drop table replayed at targets during refresh,
* the conglomeratenumber will be 0. that's ok. during refresh,
* we don't need to lock the conglomerate.
*/
if   conglomeratenumber    0     locktableforddl tc  conglomeratenumber  true
/*
** inform the data dictionary that we are about to write to it.
** there are several calls to data dictionary "get" methods here
** that might be done in "read" mode in the data dictionary, but
** it seemed safer to do this whole operation in "write" mode.
**
** we tell the data dictionary we're done writing at the end of
** the transaction.
*/
dd startwriting lcc
/* get the table descriptor. */
td   dd gettabledescriptor tableid
if  td    null
throw standardexception newexception sqlstate lang_table_not_found_during_execution  fulltablename
/* get an exclusive table lock on the table. */
long heapid   td getheapconglomerateid
locktableforddl tc  heapid  true
/* drop the triggers */
genericdescriptorlist tdl   dd gettriggerdescriptors td
enumeration descs   tdl elements
while  descs hasmoreelements
triggerdescriptor trd    triggerdescriptor  descs nextelement
droptriggerconstantaction droptriggerdescriptor lcc  dm  dd  tc  trd  activation
/* drop all defaults */
columndescriptorlist cdl   td getcolumndescriptorlist
int					 cdlsize   cdl size
for  int index   0  index < cdlsize  index
columndescriptor cd    columndescriptor  cdl elementat index
// if column has a default we drop the default and
// any dependencies
if  cd getdefaultinfo      null
defaultdescriptor defaultdesc   cd getdefaultdescriptor dd
dm cleardependencies lcc  defaultdesc
/* drop the columns */
dd dropallcolumndescriptors tableid  tc
/* drop all table and column permission descriptors */
dd dropalltableandcolpermdescriptors tableid  tc
/* drop the constraints */
dropallconstraintdescriptors td  activation
/*
** drop all the conglomerates.  drop the heap last, because the
** store needs it for locking the indexes when they are dropped.
*/
cds   td getconglomeratedescriptors
long dropped   new long
int numdropped   0
for  int index   0  index < cds length  index
conglomeratedescriptor cd   cds
/* if it's for an index, since similar indexes share one
* conglomerate, we only drop the conglomerate once
*/
if  cd getconglomeratenumber      heapid
long thisconglom   cd getconglomeratenumber
int i
for  i   0  i < numdropped  i
if  dropped    thisconglom
break
if  i    numdropped 	   not dropped
dropped   thisconglom
tc dropconglomerate thisconglom
dd dropstatisticsdescriptors td getuuid    cd getuuid    tc
/* prepare all dependents to invalidate.  (this is there chance
* to say that they can't be invalidated.  for example, an open
* cursor referencing a table/view that the user is attempting to
* drop.) if no one objects, then invalidate any dependent objects.
* we check for invalidation before we drop the table descriptor
* since the table descriptor may be looked up as part of
* decoding tuples in sysdepends.
*/
dm invalidatefor td  dependencymanager drop_table  lcc
/* drop the table */
dd droptabledescriptor td  sd  tc
/* drop the conglomerate descriptors */
dd dropallconglomeratedescriptors td  tc
/* drop the store element at last, to prevent dangling reference
* for open cursor, beetle 4393.
*/
tc dropconglomerate heapid
private void dropallconstraintdescriptors tabledescriptor td  activation activation
throws standardexception
constraintdescriptor				cd
constraintdescriptorlist 			cdl
constraintdescriptor 				fkcd
constraintdescriptorlist 			fkcdl
languageconnectioncontext			lcc   activation getlanguageconnectioncontext
datadictionary dd   lcc getdatadictionary
dependencymanager dm   dd getdependencymanager
transactioncontroller tc   lcc gettransactionexecute
cdl   dd getconstraintdescriptors td
/*
** first go, don't drop unique or primary keys.
** this will ensure that self-referential constraints
** will work ok, even if not cascading.
*/
/* the current element will be deleted underneath
* the loop, so we only increment the counter when
* skipping an element. (hack!)
*/
for int index   0  index < cdl size
cd   cdl elementat index
if  cd instanceof referencedkeyconstraintdescriptor
index
continue
dm invalidatefor cd  dependencymanager drop_constraint  lcc
dropconstraintconstantaction dropconstraintandindex dm  td  dd  cd
tc  lcc  true
/*
** referenced keys (unique or pk) constraints only
*/
/* the current element will be deleted underneath
* the loop. (hack!)
*/
while  cdl size   > 0
cd   cdl elementat 0
if  sanitymanager debug
if    cd instanceof referencedkeyconstraintdescriptor
sanitymanager throwassert
cd getclass   getname
/*
** drop the referenced constraint (after we got
** the primary keys) now.  do this prior to
** droping the referenced keys to avoid performing
** a lot of extra work updating the referencedcount
** field of sys.sysconstraints.
**
** pass in false to dropconstraintsandindex so it
** doesn't clear dependencies, we'll do that ourselves.
*/
dropconstraintconstantaction dropconstraintandindex dm  td  dd  cd
tc  lcc  false
/*
** if we are going to cascade, get all the
** referencing foreign keys and zap them first.
*/
if  cascade
/*
** go to the system tables to get the foreign keys
** to be safe
*/
fkcdl   dd getforeignkeys cd getuuid
/*
** for each fk that references this key, drop
** it.
*/
for int inner   0  inner < fkcdl size    inner
fkcd    constraintdescriptor  fkcdl elementat inner
dm invalidatefor fkcd  dependencymanager drop_constraint  lcc
dropconstraintconstantaction dropconstraintandindex
dm  fkcd gettabledescriptor    dd  fkcd
tc  lcc  true
activation addwarning
standardexception newwarning sqlstate lang_constraint_dropped
fkcd getconstraintname
fkcd gettabledescriptor   getname
/*
** now that we got rid of the fks (if we were cascading), it is
** ok to do an invalidate for.
*/
dm invalidatefor cd  dependencymanager drop_constraint  lcc
dm cleardependencies lcc  cd