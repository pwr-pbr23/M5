/*
derby - class org.apache.derby.iapi.store.raw.rawstorefactory
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby iapi store raw
import org apache derby iapi services daemon daemonservice
import org apache derby iapi services context contextmanager
import org apache derby iapi services locks lockfactory
import org apache derby iapi services property persistentset
import org apache derby iapi store access transactioninfo
import org apache derby iapi store raw xact transactionfactory
import org apache derby iapi store raw log loginstant
import org apache derby iapi error standardexception
import org apache derby catalog uuid
import org apache derby iapi store access databaseinstant
import org apache derby iapi error exceptionseverity
import java util properties
import java io serializable
import java io file
/**
rawstorefactory implements a single unit of transactional
storage. a rawstorefactory contains segments and segments
contain containers.
<p>
segments are identified
by integer identifiers that are unique within a rawstorefactory.
<p>
containers are also identified by unique integer identifiers
within a rawstorefactory, but will overlap with segment identifiers.
<p><b>limits</b><br>
this is a list of (hopefully) all limits within the raw store. where a size
has more than one limit all are documented (rather than just the most
restrictive) so that the correct limit can be found if the most restictive
is every removed.
<ul>
<li>field -
<ul>
<li>max length 2^31 - 1  (2147483647) -
</ul>
<li>record -
<ul>
<li>max number of fields 2^31 - 1  (2147483647) - from use of object[]
array to represent row, which can "only" have int sized number of array
members.
</ul>
<li>page -
<li>container -
<li>segment -
<li>raw store -
</ul>
<p>
access and rawstore work together to provide the acid properties of
transactions. on a high level, rawstore deals with anything that directly
impacts persistency. on a more detailed level, rawstore provides
logging, rollback and recovery, data management on page, page allocation
and deallocation, container allocation and deallocation.
<p>
rawstore is organized as 3 branches, transaction, data, and
logging.  these branches each have its own "factory", the transaction
factory hands out transactions, the data factory hands out containers,
and the log factory hands out logger (or log buffers) for transactions to
write on.  for a more detailed description on these factories, please see
their corresponding javadocs.
mt - thread safe
@see containerhandle */
public interface rawstorefactory extends corruptable
/** store engine version numbers indicating the database must be upgraded to
* or created at the current engine level
*/
/** derby store minor version (1) **/
public static final int derby_store_minor_version_1      1
/** derby store minor version (2) **/
public static final int derby_store_minor_version_2      2
/** derby 10 store major version */
public static final int derby_store_major_version_10     10
/**
default value for page_size_parameter (4096).
*/
public static final int page_size_default   4096
/**
minimum page size we will accept (1024).
*/
public static final int page_size_minimum   1024
public static final string page_size_string
/** property name for the page cache size to be used in the storage area.
equal to 'derby.storage.pagecachesize'
*/
public static final string page_cache_size_parameter
/**
default value for page_cache_size_parameter (1000).
*/
public static final int page_cache_size_default   1000
/**
minimum page cache size we will accept (40).
*/
public static final int page_cache_size_minimum   40
/**
maximum page cache size we will accept (maxint).
*/
public static final int page_cache_size_maximum   integer max_value
/**
maximum number of initial pages when a container is created
*/
public static final short max_container_initial_pages   1000
/** property name for the default minimum record size to be used in the
storage area. minimum record size is the minimum number of bytes that a
record will reserve on disk.
*/
public static final string minimum_record_size_parameter
/**
default value for minimum_record_size_parameter	for heap tables that
allow overflow.  by setting minimumrecordsize to 12 bytes, we
guarantee there is enough space to update the row even there is not
enough space on the page.  the 12 bytes will guarantee there is room
for an overflow pointer (page + id).
*/
public static final int minimum_record_size_default   12
/**
minimum value for minimum_record_size_parameter (1).
*/
public static final int minimum_record_size_minimum   1
/** property name for percentage of space to leave free on page for updates.
*/
public static final string page_reserved_space_parameter
public static final string page_reserved_zero_space_string
/** property name for the number of pages we try to pre-allocate in one
/** synchronous i/o
*/
public static final string pre_allocate_page
/**
property name for container which reuses recordid when a page is
reused.  defaults to false, which means recordid is never reused.
this property should not be set by the end user, only access should set
it for special conglomerates which does not count on permanant unique
recordids for all records.
*/
public static final string page_reusable_record_id
/**
property name for buffer size to be used in the stream file container.
equal to 'derby.storage.streamfilebuffersize'
*/
public static final string stream_file_buffer_size_parameter
/**
default value for stream_file_buffer_size_parameter (16384).
*/
public static final int stream_file_buffer_size_default   16384
/**
minimum stream file buffer size we will accept (1024).
*/
public static final int stream_file_buffer_size_minimum   1024
/**
maximum stream file buffer size we will accept (maxint).
*/
public static final int stream_file_buffer_size_maximum
integer max_value
/**
property name for container which attempts to be created with an
initial size of this many pages.  defaults to 1 page.
<br>all containers are guarenteed to be created with at least 1 page,
if this property is set, it will attempt to allocate
container_initial_pages, but with no guarentee.
contaienr_initial_pages legally ranges from 1 to
max_container_initial_pages.  values < 1 will
be set to 1 and values > max_container_initial_pages will be set to
max_container_initial_pages
this property should only be set in the properties list in a create
table or create index statement.  the global setting of this property
has no effect.
*/
public static final string container_initial_pages
/**
encryption alignment requirement.
*/
public static final int encryption_alignment   8
/**
default encryption block size
in old existing databases (ie 5.1.x), the default
encryption block size used is 8. do not change this value unless you
account for downgrade issues
*/
public static final int default_encryption_blocksize   8
/**
encryption block size used during creation of encrypted database
this property is not set by the user; it is set by the engine when
rawstore boots up during creation of an encrypted database
*/
public static final string encryption_blocksize
/**
this variable is used to store the encryption scheme to allow
for any future changes in encryption schemes of data
this property has been introduced in version 10
value starts at 1
*/
public static final string data_encrypt_algorithm_version
/**
store the encryption scheme used for logging
this will allow for any future changes in encryption schemes of logs
this variable has been introduced in version 10 and value starts at 1.
*/
public static final string log_encrypt_algorithm_version
/**
if dataencryption is true, store the encrypted key in
services.properties file. it is really the encrypted
key, but the property key is called the encryptedbootpassword.
*/
public static final string encrypted_key
/**
* when the datbase is getting re-encrypted old encrypted key is
* stored in the service.properties until re-encyrption
* successfully completes or rolled back. it is really the old
* encryptedkey, but the property key is called the
* oldencryptedbootpassword.
*/
public static final string old_encrypted_key
/*
* following property is used to track the status of the (re)encryption,
* required to bring the database back to state it was before the
* (re) encryption started, id (re) encryption of the database
* is aborted.
*/
public static final string db_encryption_status
/* (re)encryption is in progress, if a crash
*  occurs after this flag is set,
* (re)encryption needs to  be undone.
*/
public static final int db_encryption_in_progress     1
/* this flag is used to track crash during undo
of (re) encryption during recovery .
*/
public static final int db_encryption_in_undo         2
/*
* cleanup any (re) encryption related resources.
*/
public static final int  db_encryption_in_cleanup     3
/**
a file used to save the old copy of the verify key
(attribute.crypto_external_key_verify_file) file during
re-encryption of the database.
*/
string crypto_old_external_key_verify_file
/**
*  for debugging, keep all transaction logs intact.
*/
public static final string keep_transaction_log
/**
* the following is a to enable patch for databases with recovery
* errors during redo of initpage. if this property is set and
* the page on the disk is corrupted and is getting exceptions like
* invalid page format ids, we cook up the page during the recovery time.
* we have seen this kind of problem with 1.5.1 databases from
* customer tridium ( bug no: 3813).
* this patch needs to be kept unless we find the problem is during
* recovery process. if we discover this problem is actaully happening
* at the recovery then this patch should be backed out.
**/
public static final string patch_initpage_recover_error
/** module name */
public static final string module
/**
is the store read-only.
*/
public boolean isreadonly
/**
get the lockfactory to use with this store.
*/
public lockfactory getlockfactory
/**
create a user transaction, almost all work within the raw store is
performed in the context of a transaction.
<p>
starting a transaction always performs the following steps.
<ol>
<li>create an raw store transaction context
<li>create a new idle transaction and then link it to the context.
</ul>
only one user transaction and one nested user transaction can be active
in a context at any one time.
after a commit the transaction may be re-used.
<p>
<b>raw store transaction context behaviour</b>
<br>
the cleanuponerror() method of this context behaves as follows:
<ul>
<li>
if error is an instance of standardexception that
has a severity less than exceptionseverity.transaction_severity then
no action is taken.
<li>
if error is an instance of standardexception that
has a severity equal to exceptionseverity.transaction_severity then
the context's transaction is aborted, and the transaction returned to
the idle state.
<li>
if error is an instance of standardexception that
has a severity greater than  exceptionseverity.transaction_severity
then the context's transaction is aborted, the transaction closed, and
the context is popped off the stack.
<li>
if error is not an instance of standardexception then the context's
transaction is aborted, the transaction closed, and the
context is popped off the stack.
</ul>
@param contextmgr is the context manager to use.  an exception will be
thrown if context is not the current context.
@param transname is the name of the transaction. thsi name will be displayed
by the transactiontable vti.
@exception standardexception standard cloudscape error policy
@see transaction
@see org.apache.derby.iapi.services.context.context
@see standardexception
*/
public transaction starttransaction
contextmanager contextmgr
string transname
throws standardexception
/**
create a global user transaction, almost all work within the raw store
is performed in the context of a transaction.
<p>
the (format_id, global_id, branch_id) triplet is meant to come exactly
from a javax.transaction.xa.xid.  we don't use xid so that the system
can be delivered on a non-1.2 vm system and not require the javax
classes in the path.
<p>
starting a transaction always performs the following steps.
<ol>
<li>create an raw store transaction context
<li>create a new idle transaction and then link it to the context.
</ul>
only one user transaction can be active in a context at any one time.
after a commit the transaction may be re-used.
<p>
<b>raw store transaction context behaviour</b>
<br>
the cleanuponerror() method of this context behaves as follows:
<ul>
<li>
if error is an instance of standardexception that
has a severity less than exceptionseverity.transaction_severity then
no action is taken.
<li>
if error is an instance of standardexception that
has a severity equal to exceptionseverity.transaction_severity then
the context's transaction is aborted, and the transaction returned to
the idle state.
<li>
if error is an instance of standardexception that
has a severity greater than  exceptionseverity.transaction_severity
then the context's transaction is aborted, the transaction closed, and
the context is popped off the stack.
<li>
if error is not an instance of standardexception then the context's
transaction is aborted, the transaction closed, and the
context is popped off the stack.
</ul>
@param contextmgr is the context manager to use.  an exception will be
thrown if context is not the current context.
@param format_id  the format id part of the xid - ie. xid.getformatid().
@param global_id  the global transaction identifier part of xid - ie.
xid.getglobaltransactionid().
@param local_id   the branch qualifier of the xid - ie.
xid.getbranchqaulifier()
@exception standardexception standard cloudscape error policy
@see transaction
@see org.apache.derby.iapi.services.context.context
@see standardexception
*/
public transaction startglobaltransaction
contextmanager contextmgr
int            format_id
byte         global_id
byte         local_id
throws standardexception
/**
find a user transaction in the context manager, which must be the
current context manager.  if a user transaction does not already exist,
then create one @see #starttransaction
@param contextmgr the context manager to use.  an exception will be
thrown if context is not the current context.
@param transname  if a new transaction is started, it will be given
this name.
the name is displayed in the transactiontable vti.
@exception standardexception standard cloudscape error policy
@see #starttransaction
*/
public transaction findusertransaction
contextmanager contextmgr
string transname  throws standardexception
/**
create an internal transaction.
<p>
starting an internal transaction always performs the following steps.
<ol>
<li>create an raw store internal transaction context
<li>create a new idle internal transaction and then link it to the
context.
</ul>
<p>
an internal transaction is identical to a user transaction with the
exception that
<ul>
<li> logical operations are not supported
<li> savepoints are not supported
<li> containers are not closed when commit() is called.
<li> pages are not unlatched (since containers are not closed) when
commit() is called.
<li> during recovery time internal transactions are rolled back before
user transactions.
</ul>
only one internal transaction can be active in a context at any one time.
after a commit the transaction may be re-used.
<p>
<b>raw store internal transaction context behaviour</b>
<br>
the cleanuponerror() method of this context behaves as follows:
<ul>
<li>
if error is an instance of standardexception that
has a severity less than exceptionseverity.transaction_severity then
the internal transaction is aborted, the internal transaction is closed,        the context is popped off the stack, and an exception of severity
transaction exception is re-thrown.
<li>
if error is an instance of standardexception that has a severity
greater than or equal to exceptionseverity.transaction_severity then
the context's internal transaction is aborted, the internal
transaction is closed and the context is popped off the stack.
<li>
if error is not an instance of standardexception then the context's
internal transaction is aborted, the internal transaction is closed
and the context is popped off the stack.
</ul>
@exception standardexception standard cloudscape error policy
@see transaction
@see org.apache.derby.iapi.services.context.context
@see standardexception
*/
public transaction startinternaltransaction contextmanager contextmgr  throws standardexception
/**
create a nested user transaction, almost all work within the raw store
is performed in the context of a transaction.
<p>
a nested user transaction is exactly the same as a user transaction,
except that one can specify a compatibility space to associate with
the transaction.
starting a transaction always performs the following steps.
<ol>
<li>create an raw store transaction context
<li>create a new idle transaction and then link it to the context.
</ul>
only one user transaction and one nested user transaction can be active
in a context at any one time.
after a commit the transaction may be re-used.
<p>
<b>raw store transaction context behaviour</b>
<br>
the cleanuponerror() method of this context behaves as follows:
<ul>
<li>
if error is an instance of standardexception that
has a severity less than exceptionseverity.transaction_severity then
no action is taken.
<li>
if error is an instance of standardexception that
has a severity equal to exceptionseverity.transaction_severity then
the context's transaction is aborted, and the transaction returned to
the idle state.  if a user transaction exists on the context stack
then that transaction is aborted also.
<li>
if error is an instance of standardexception that
has a severity greater than  exceptionseverity.transaction_severity
then the context's transaction is aborted, the transaction closed, and
the context is popped off the stack.
<li>
if error is not an instance of standardexception then the context's
transaction is aborted, the transaction closed, and the
context is popped off the stack.
</ul>
@param compatibilityspace compatibility space to use for locks.
@param contextmgr is the context manager to use.  an exception will be
thrown if context is not the current context.
@param transname is the name of the transaction. this name will be
displayed by the transactiontable vti.
@exception standardexception standard cloudscape error policy
@see transaction
@see org.apache.derby.iapi.services.context.context
@see standardexception
*/
public transaction startnestedreadonlyusertransaction
object         compatibilityspace
contextmanager contextmgr
string         transname
throws standardexception
/**
create a nested user transaction, almost all work within the raw store
is performed in the context of a transaction.
<p>
a nested user transaction is exactly the same as a user transaction,
except that one can specify a compatibility space to associate with
the transaction.
starting a transaction always performs the following steps.
<ol>
<li>create an raw store transaction context
<li>create a new idle transaction and then link it to the context.
</ul>
only one user transaction and one nested user transaction can be active
in a context at any one time.
after a commit the transaction may be re-used.
<p>
<b>raw store transaction context behaviour</b>
<br>
the cleanuponerror() method of this context behaves as follows:
<ul>
<li>
if error is an instance of standardexception that
has a severity less than exceptionseverity.transaction_severity then
no action is taken.
<li>
if error is an instance of standardexception that
has a severity equal to exceptionseverity.transaction_severity then
the context's transaction is aborted, and the transaction returned to
the idle state.  if a user transaction exists on the context stack
then that transaction is aborted also.
<li>
if error is an instance of standardexception that
has a severity greater than  exceptionseverity.transaction_severity
then the context's transaction is aborted, the transaction closed, and
the context is popped off the stack.
<li>
if error is not an instance of standardexception then the context's
transaction is aborted, the transaction closed, and the
context is popped off the stack.
</ul>
@param contextmgr is the context manager to use.  an exception will be
thrown if context is not the current context.
@param transname is the name of the transaction. this name will be
displayed by the transactiontable vti.
@exception standardexception standard cloudscape error policy
@see transaction
@see org.apache.derby.iapi.services.context.context
@see standardexception
*/
public transaction startnestedupdateusertransaction
contextmanager contextmgr
string         transname
throws standardexception
/**
@see org.apache.derby.iapi.store.access.accessfactory#gettransactioninfo
*/
public transactioninfo gettransactioninfo
/**
* freeze the database temporarily so a backup can be taken.
* <p>please see cloudscape on line documentation on backup and restore.
*
* @exception standardexception thrown on error
*/
public void freeze   throws standardexception
/**
* unfreeze the database after a backup has been taken.
* <p>please see cloudscape on line documentation on backup and restore.
*
* @exception standardexception thrown on error
*/
public void unfreeze   throws standardexception
/**
* backup the database to backupdir.
* <p>please see cloudscape on line documentation on backup and restore.
*
* @param backupdir the name of the directory where the backup should be
*                  stored.
* @param wait      if <tt>true</tt>, waits for  all the backup blocking
*                  operations in progress to finish.
*
* @exception standardexception thrown on error
*/
public void backup
string backupdir
boolean wait  throws standardexception
/**
* backup the database to a backup directory and enable the log archive
* mode that will keep the archived log files required for roll-forward
* from this version backup.
*
* @param backupdir                     the directory name where the
*                                      database backup should go.  this
*                                      directory will be created if not it
*                                      does not exist.
*
* @param deleteonlinearchivedlogfiles  if true deletes online archived log
*                                      files that exist before this backup,
*                                      delete will occur only after backup
*                                      is complete.
*
* @param wait if <tt>true</tt>, waits for  all the backup blocking
*             operations in progress to finish.
*
* @exception standardexception thrown on error
*/
public void backupandenablelogarchivemode
string  backupdir
boolean deleteonlinearchivedlogfiles
boolean wait
throws standardexception
/**
* disables the log archival process, i.e no old log files
* will be kept around for a roll-forward recovery.
*
* @param deleteonlinearchivedlogfiles  if true deletes all online archived
*                                      log files that exist before this
*                                      call immediately; only restore that
*                                      can be performed after disabling
*                                      log archive mode is version
*                                      recovery.
*
* @exception standardexception thrown on error
*/
public void disablelogarchivemode boolean deleteonlinearchivedlogfiles
throws standardexception
/**
try to checkpoint the database to minimize recovery time.
the raw store does not guarentee that a checkpoint will indeed have
happened by the time this routine returns.
@exception standardexception standard cloudscape error policy
*/
public void checkpoint   throws standardexception
/**
idle the raw store as much as possible.
@exception standardexception standard cloudscape error policy
*/
public void idle   throws standardexception
/**
get a flushed scan.
@param start the instant for the beginning of the scan.
@param groupsiwant log record groups the caller wants to scan.
@exception standardexception standardcloudscape error policy
*/
scanhandle openflushedscan databaseinstant start  int groupsiwant
throws standardexception
/**
if this raw store has a daemon that services its need, return the
daemon.  if not, return null
*/
public daemonservice getdaemon
/*
* return the transaction factory module
*/
public string gettransactionfactorymodule
/*
* return the data factory module
*/
public string getdatafactorymodule
/*
* return the log factory module
*/
public string getlogfactorymodule
/*
* return the module providing xaresource interface to the transaction
* table.
*
* @exception standardexception standard cloudscape exception policy.
*/
public    xaresourcemanager    object getxaresourcemanager
throws standardexception
/*
* the database creation phase is finished
* @exception standardexception standard cloudscape exception policy.
*/
public void createfinished   throws standardexception
/**
* get jbms properties relavent to raw store
*
* @exception standardexception standard cloudscape exception policy.
*/
public void getrawstoreproperties persistentset tc
throws standardexception
/**
*  backup / restore support
*/
/**
* freeze the database from altering any persistent storage.
*
* @exception standardexception standard cloudscape exception policy.
*/
public void freezepersistentstore   throws standardexception
/**
* unfreeze the database, persistent storage can now be altered.
*
* @exception standardexception standard cloudscape exception policy.
*/
public void unfreezepersistentstore   throws standardexception
/**
encrypt cleartext into ciphertext.
@see org.apache.derby.iapi.services.crypto.cipherprovider#encrypt
@exception standardexception standard cloudscape error policy
*/
public int encrypt byte cleartext  int offset  int length
byte ciphertext  int outputoffset
boolean newengine
throws standardexception
/**
decrypt cleartext from ciphertext.
@see org.apache.derby.iapi.services.crypto.cipherprovider#decrypt
@exception standardexception standard cloudscape error policy
*/
public int decrypt byte ciphertext  int offset  int length
byte cleartext  int outputoffset
throws standardexception
/**
returns the encryption block size used during creation of the encrypted database
*/
public int getencryptionblocksize
/**
returns a secure random number for this raw store - if database is not
encrypted, returns 0.
*/
public int random
/**
change the boot password.  return the encrypted form of the secret key.
the new value must be a string of the form: oldbootpassword, newbootpassword
@exception standardexception standard cloudscape error policy
*/
public serializable changebootpassword properties properties  serializable changepassword
throws standardexception
/**
* return an id which can be used to create a container.
* <p>
* return an id number with is greater than any existing container
* in the current database.  caller will use this to allocate future
* container numbers - most likely caching the value and then incrementing
* it as it is used.
* <p>
*
* @return the an id which can be used to create a container.
*
* @exception  standardexception  standard exception policy.
**/
long getmaxcontainerid
throws standardexception
/**
get the transaction factory to use with this store.
*/
public transactionfactory getxactfactory