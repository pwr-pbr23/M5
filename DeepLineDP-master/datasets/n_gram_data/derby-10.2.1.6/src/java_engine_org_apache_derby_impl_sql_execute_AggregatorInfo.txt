/*
derby - class org.apache.derby.impl.sql.execute.aggregatorinfo
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl sql execute
import org apache derby iapi sql resultdescription
import org apache derby iapi services io storedformatids
import org apache derby iapi services io formatidutil
import org apache derby iapi services io formatable
import org apache derby iapi services sanity sanitymanager
import java io objectoutput
import java io objectinput
import java io ioexception
/**
* this is a simple class used to store the run time information
* needed to invoke an aggregator.  this class is serializable
* because it is stored with the plan.  it is serializable rather
* than externalizable because it isn't particularly complicated
* and presumbably we don't need version control on plans.
*
* @author jamie
*/
public class aggregatorinfo implements formatable
/********************************************************
**
**	this class implements formatable. that means that it
**	can write itself to and from a formatted stream. if
**	you add more fields to this class, make sure that you
**	also write/read them with the writeexternal()/readexternal()
**	methods.
**
**	if, inbetween releases, you add more fields to this class,
**	then you should bump the version number emitted by the gettypeformatid()
**	method.  or, since this is something that is used
**	in stored prepared statements, it is ok to change it
**	if you make sure that stored prepared statements are
**	invalidated across releases.
**
********************************************************/
/*
** see the constructor for the meaning of these fields
*/
string	aggregatename
int		inputcolumn
int		outputcolumn
int		aggregatorcolumn
string	aggregatorclassname
boolean	isdistinct
resultdescription	rd
/**
* niladic constructor for formattable
*/
public aggregatorinfo
/**
* consructor
*
* @param aggregatename	the name of the aggregate.  not
*		actually used anywhere except diagnostics.  should
*		be the names as found in the language (e.g. max).
* @param aggregatorclassname	the name of the aggregator
*		used to process this aggregate.  aggregator expected
*		to have a null arg constructor and implement
*		aggregator.
* @param inputcolnum	the input column number
* @param outputcolnum	the output column number
* @param aggregatorcolnum	the column number in which the
*		aggregator is stored.
* @param isdistinct	if it is a distinct aggregate
* @param rd	the result description
*
*/
public aggregatorinfo
string 				aggregatename
string				aggregatorclassname
int					inputcolnum
int					outputcolnum
int					aggregatorcolnum
boolean				isdistinct
resultdescription	rd
this aggregatename	  aggregatename
this aggregatorclassname   aggregatorclassname
this inputcolumn	  inputcolnum
this outputcolumn	  outputcolnum
this aggregatorcolumn   aggregatorcolnum
this isdistinct 	  isdistinct
this rd 			  rd
/**
* get the name of the aggergate (e.g. max)
*
* @return the aggeregate name
*/
public string getaggregatename
return aggregatename
/**
* get the name of the class that implements the user
* aggregator for this class.
*
* @return the aggeregator class name
*/
public string getaggregatorclassname
return aggregatorclassname
/**
* get the column number for the aggregator
* column.
*
* @return the aggeregator colid
*/
public int getaggregatorcolnum
return aggregatorcolumn
/**
* get the column number for the input
* (addend) column.
*
* @return the aggeregator colid
*/
public int getinputcolnum
return inputcolumn
/**
* get the column number for the output
* (result) column.
*
* @return the aggeregator colid
*/
public int getoutputcolnum
return outputcolumn
/**
* is the aggergate distinct
*
* @return whether it is distinct
*/
public boolean isdistinct
return isdistinct
/**
* get the result description for the input value
* to this aggregate.
*
* @return the rd
*/
public resultdescription getresultdescription
return rd
/**
* get a string for the object
*
* @return string
*/
public string tostring
if  sanitymanager debug
return    aggregatename
aggregatorclassname
inputcolumn
outputcolumn
aggregatorcolumn
isdistinct
rd
else
return
//////////////////////////////////////////////
//
// formatable
//
//////////////////////////////////////////////
/**
* write this object out
*
* @param out write bytes here
*
* @exception ioexception thrown on error
*/
public void writeexternal objectoutput out  throws ioexception
out writeobject aggregatename
out writeint inputcolumn
out writeint outputcolumn
out writeint aggregatorcolumn
out writeobject aggregatorclassname
out writeboolean isdistinct
out writeobject rd
/**
* read this object from a stream of stored objects.
*
* @param in read this.
*
* @exception ioexception					thrown on error
* @exception classnotfoundexception		thrown on error
*/
public void readexternal objectinput in
throws ioexception  classnotfoundexception
aggregatename    string in readobject
inputcolumn   in readint
outputcolumn   in readint
aggregatorcolumn   in readint
aggregatorclassname    string in readobject
isdistinct   in readboolean
rd    resultdescription in readobject
/**
* get the formatid which corresponds to this class.
*
*	@return	the formatid of this class
*/
public int	gettypeformatid  	  return storedformatids agg_info_v01_id