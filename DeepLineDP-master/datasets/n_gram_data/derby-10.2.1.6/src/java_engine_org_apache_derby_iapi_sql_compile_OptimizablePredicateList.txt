/*
derby - class org.apache.derby.iapi.sql.compile.optimizablepredicatelist
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby iapi sql compile
import org apache derby iapi sql dictionary conglomeratedescriptor
import org apache derby iapi services compiler methodbuilder
import org apache derby iapi error standardexception
import org apache derby iapi util jbitset
/**
* optimizablepredicatelist provides services for optimizing a table in a query.
* resolve - the methods for this interface need to get defined.
*/
public interface optimizablepredicatelist
/**
*  return the number of optimizablepredicates in the list.
*
*  @return integer		the number of optimizablepredicates in the list.
*/
public int size
/**
*  return the nth optimizablepredicate in the list.
*
*  @param n				"index" (0 based) into the list.
*
*  @return optimizablepredicate		the nth optimizablepredicate in the list.
*/
public optimizablepredicate getoptpredicate int n
/**
* remove the optimizablepredicate at the specified index (0-based) from the list.
*
* @param predctr	the index.
*
* @exception standardexception		thrown on error
*/
void removeoptpredicate int predctr  throws standardexception
/**
* add the given optimizablepredicate to the end of this list.
*
* @param optpredicate	the predicate to add
*/
void addoptpredicate optimizablepredicate optpredicate
/**
* return true if this predicate list is useful for limiting the scan on
* the given table using the given conglomerate.
*
* @param opttable an optimizable for the table in question
* @param cd a conglomeratedescriptor for the conglomerate in question
*
* @return	true if this predicate list can limit the scan
* @exception standardexception		thrown on error
*/
boolean useful optimizable opttable  conglomeratedescriptor cd
throws standardexception
/**
* determine which predicates in this list are useful for limiting
* the scan on the given table using its best conglomerate.  remove
* those predicates from this list and push them down to the given
* optimizable table.  the predicates are pushed down in the order of
* the index columns that they qualify.  also, the predicates are
* "marked" as start predicates, stop predicates, or qualifier
* predicates.  finally, the start and stop operators are set in
* the given optimizable.
*
* @param opttable	an optimizable for the table in question
*
* @exception standardexception		thrown on error
*/
void pushusefulpredicates optimizable opttable
throws standardexception
/**
* classify the predicates in this list according to the given
* table and conglomerate.  each predicate can be a start key, stop key,
* and/or qualifier, or it can be none of the above.  this method
* also orders the predicates to match the order of the columns
* in a keyed conglomerate.  no ordering is done for heaps.
*
* @param opttable	the optimizable table for which to classify
*					the predicates in this list.
* @param cd	the conglomeratedescriptor for which to classify
*				the predicates in this list.
*
* @exception standardexception		thrown on error
*/
void classify optimizable opttable  conglomeratedescriptor cd
throws standardexception
/**
* mark all of the predicates as qualifiers and set the numberofqualifiers
* to reflect this.  this is useful for hash joins where all of the
* predicates in the list to be evaluated during the probe into the
* hash table on a next are qualifiers.
*/
public void markallpredicatesqualifiers
/**
* is there an optimizable equality predicate on the specified column?
*
* @param opttable		the optimizable the column comes from.
* @param columnnumber	the column number within the base table.
* @param isnullokay	boolean, whether or not the is null operator
*						satisfies the search
*
* @return whether or not there is an optimizable equality predicate on the specified column.
*
* @exception standardexception		thrown on error
*/
boolean hasoptimizableequalitypredicate optimizable opttable
int columnnumber
boolean isnullokay
throws standardexception
/**
* is there an optimizable equijoin on the specified column?
*
* @param opttable		the optimizable the column comes from.
* @param columnnumber	the column number within the base table.
*
* @return whether or not there is an optimizable equijoin on the specified column.
*
* @exception standardexception		thrown on error
*/
boolean hasoptimizableequijoin optimizable opttable
int columnnumber
throws standardexception
/**
* find the optimizable equality predicate on the specified column and make
* it the first predicate in this list.  this is useful for hash joins where
* qualifier[0] is assumed to be on the hash key.
*
* @param opttable		the optimizable the column comes from.
* @param columnnumber	the column number within the base table.
*
* @exception standardexception		thrown on error
*/
void putoptimizableequalitypredicatefirst optimizable opttable
int columnnumber
throws standardexception
/**
* transfer the predicates whose referenced set is contained by the
* specified referencedtablemap from this list to the other list.
* this is useful when splitting out a set of predicates from a larger
* set, like when generating a hashscanresultset.
*
* @param otherlist				the predicatelist to xfer to
* @param referencedtablemap	the table map to check against
* @param table					the table to order the new predicates
*								against
*
* @exception standardexception		thrown on error
*/
public void transferpredicates optimizablepredicatelist otherlist
jbitset referencedtablemap
optimizable table
throws standardexception
/**
* transfer all the predicates from this list to the given list.
*
* @exception standardexception		thrown on error
*/
public void transferallpredicates optimizablepredicatelist otherlist
throws standardexception
/**
* non-destructive copy of all of the predicates from this list to the
* other list.
*
* this is useful when splitting out a set of predicates from a larger
* set, like when generating a hashscanresultset.
*
* @param otherlist				the predicatelist to xfer to
*
* @exception standardexception		thrown on error
*/
public void copypredicatestootherlist optimizablepredicatelist otherlist
throws standardexception
/**
* sets the given list to have the same elements as this one, and
* the same properties as this one (number of qualifiers and start
* and stop predicates.
*
* @param otherlist		the list to set the same as this one.
*
* @exception standardexception		thrown on error
*/
public void setpredicatesandproperties optimizablepredicatelist otherlist
throws standardexception
/**
* return whether or not the specified entry in the list is a redundant
* predicate. this is useful for selectivity calculations because we
* do not want redundant predicates included in the selectivity calculation.
*
* @param prednum	the entry in the list
*
* @return whether or not the specified entry in the list is a redundant predicate.
*/
public boolean isredundantpredicate int prednum
/**
* get the start operator for the given optimizable for a heap or
* index scan.
*/
int startoperator optimizable opttable
/**
* get the stop operator for the given optimizable for a heap or
* index scan.
*/
int stopoperator optimizable opttable
/**
* generate the qualifiers for a scan.  this method generates an array
* of qualifiers, and fills them in with calls to the factory method
* for generating qualifiers in the constructor for the activation.
* it stores the array of qualifiers in a field in the activation, and
* returns a reference to that field.
*
* if there are no qualifiers, it initializes the array of qualifiers
* to null.
*
* @param acb	the expressionclassbuilderinterface for the class we are building
* @param mb	the method the generated code is going into
* @param opttable	the optimizable table the qualifiers are on
* @param absolute	generate absolute column positions if true,
*					else relative column positions (within the underlying
*					row)
*
*
* @exception standardexception		thrown on error
*/
void generatequalifiers expressionclassbuilderinterface acb
methodbuilder mb
optimizable opttable
boolean absolute
throws standardexception
/**
* generate the start key for a heap or index scan.
*
* @param acb	the expressionclassbuilderinterface for the class we're building
* @param mb	the method the generated code is to go into
* @param opttable	the optimizable table the start key is for
*
* @exception standardexception		thrown on error
*/
void generatestartkey expressionclassbuilderinterface acb
methodbuilder mb
optimizable opttable
throws standardexception
/**
* generate the stop key for a heap or index scan.
*
* @param acb	the expressionclassbuilderinterface for the class we're building
* @param mb	the method the generated code is to go into
* @param opttable	the optimizable table the stop key is for
*
* @exception standardexception		thrown on error
*/
void generatestopkey expressionclassbuilderinterface acb
methodbuilder mb
optimizable opttable
throws standardexception
/**
* can we use the same key for both the start and stop key.
* this is possible when doing an exact match on an index
* where there are no other sargable predicates.
*
* @return whether or not we can use the same key for both the start and stop key.
*
* @exception standardexception		thrown on error
*/
public boolean samestartstopposition
throws standardexception
/**
* calculate the selectivity for a set of predicates.
* if statistics exist for the predicates this method uses the
* statistics. if statistics do not exist, then simply call
* selectivity for each of the predicates and return the result.
*
* @param opttable	the optimizable that the predicate list restricts.
*/
public double selectivity optimizable opttable  throws standardexception