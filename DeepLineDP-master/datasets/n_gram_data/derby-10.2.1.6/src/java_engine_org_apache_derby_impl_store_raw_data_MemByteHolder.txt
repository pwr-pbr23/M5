/*
derby - class org.apache.derby.impl.store.raw.data.membyteholder
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl store raw data
import org apache derby iapi services sanity sanitymanager
import java io ioexception
import java io inputstream
import java io outputstream
import java util vector
/**
a byteholder that stores all its bytes in memory.
*/
public class membyteholder
implements byteholder
int bufsize
boolean writing   true
vector bufv
int curbufveleat
byte curbuf
int curbufpos
//
//we use this to determine when we have reached the end
//of the current buffer whild reading. for the last
//buffer this may be less than bufsize.
int curbufdatabytes
//
//we use these to remember the location of the last byte
//of data we have stored. the read methods use these to
//avoid reading more bytes than we have stored. these
//values are set by startreading.
int lastbufveleat   0
int lastbufdatabytes   0
/**
create a new membyteholder. store bytes as a list of buffers
of size 'bufsize'.
*/
public membyteholder int bufsize
this bufsize   bufsize
this curbuf   new byte
this curbufpos   0
this bufv   new vector 128
bufv addelement curbuf
this curbufveleat   0
/**
@see byteholder#write
@exception ioexception		thrown on error
*/
public void write int b  throws ioexception
if  sanitymanager debug
sanitymanager assert writing    true
if curbufpos> curbuf length
getnextbuffer_w
curbuf    byte b
/**
@see byteholder#write
@exception ioexception		thrown on error
*/
public void write byte data  int offset  int len  throws ioexception
if  sanitymanager debug
sanitymanager assert writing    true
while len > 0
if curbufpos> curbuf length
getnextbuffer_w
int bytestocopythistime   len
int bytesincurbuf   curbuf length   curbufpos
if  bytestocopythistime > bytesincurbuf
bytestocopythistime   bytesincurbuf
system arraycopy data offset curbuf curbufpos bytestocopythistime
offset    bytestocopythistime
curbufpos    bytestocopythistime
len    bytestocopythistime
/**
@see byteholder#write
@exception ioexception		thrown on error
*/
public long write inputstream is  long count  throws ioexception
long bytestotransfer   count
int bytestransferredthistime   0
do
if curbufpos> curbuf length
getnextbuffer_w
int bytestotransferthistime
int bytesincurbuf   curbuf length   curbufpos
if  bytestotransfer >  bytesincurbuf
bytestotransferthistime   bytesincurbuf
else
bytestotransferthistime    int bytestotransfer
//
//note read should never return 0. thus we keep looping
//transferring bytes from the stream to our buffer until
//we transfer count bytes or reach the end of the stream.
//
bytestransferredthistime
is read curbuf curbufpos bytestotransferthistime
if  bytestransferredthistime > 0
if  sanitymanager debug
sanitymanager assert
writing    true
bytestotransfer    bytestransferredthistime
curbufpos    bytestransferredthistime
while  bytestotransfer > 0
bytestransferredthistime > 0
return count   bytestotransfer
/**
@see byteholder#clear
@exception ioexception		thrown on error
*/
public void clear   throws ioexception
writing   true
curbuf    byte bufv elementat 0
this curbufveleat   0
this curbufpos   0
lastbufveleat   0
lastbufdatabytes   0
/**
@see byteholder#startreading
*/
public void startreading
throws ioexception
if  writing    true
//enter read mode.
writing   false
lastbufdatabytes   curbufpos
lastbufveleat   curbufveleat
//
//reposition so reads start from the first
//byte.
curbuf    byte bufv elementat 0
this curbufveleat   0
this curbufpos   0
if  curbufveleat    lastbufveleat
curbufdatabytes   lastbufdatabytes
else
curbufdatabytes   bufsize
/**
@see byteholder#read
@exception ioexception	thrown on error
*/
public int read   throws ioexception
if  sanitymanager debug
sanitymanager assert writing    false
if  curbufpos >  curbufdatabytes
getnextbuffer_r
if  curbufpos >  curbufdatabytes
return  1
else
return 0xff   curbuf
/**
@see byteholder#read
@exception ioexception	thrown on error
*/
public int read byte b
int off
int len
throws ioexception
return  read b  off   outputstream  null  len
/**
@see byteholder#read
@exception ioexception	thrown on error
*/
public int read outputstream out
int len
throws ioexception
return read  byte   null  0  out  len
/**
@see byteholder#read
@exception ioexception	thrown on error
*/
public int read byte b
int off
outputstream out
int len
throws ioexception
int bytesiread   0
boolean eof   false
if  sanitymanager debug
sanitymanager assert writing    false
if  curbufpos >  curbufdatabytes
eof   getnextbuffer_r
if  eof  return  1
while  len > 0     eof
int bytesincurbuf   curbufdatabytes   curbufpos
int bytesireadthistime
if  len >  bytesincurbuf
bytesireadthistime   bytesincurbuf
else
bytesireadthistime   len
if  out    null
// write the data to the byte array
system arraycopy curbuf curbufpos b off bytesireadthistime
else
// write the data to the output stream
out write curbuf  curbufpos  bytesireadthistime
off  bytesireadthistime
curbufpos  bytesireadthistime
len    bytesireadthistime
bytesiread  bytesireadthistime
if  curbufpos >  curbufdatabytes
eof   getnextbuffer_r
return bytesiread
/**
@see byteholder#shifttofront
@exception ioexception	thrown on error
*/
public int shifttofront   throws ioexception
int remainingbytes   available
remainingbytes   remainingbytes > 0 ? remainingbytes     1    remainingbytes
byte b   new byte
int bytesread   read b  0  remainingbytes
// clear the buffer
clear
// put the bytes at the beginning of the buffer
writing   true
write b  0  bytesread
curbufdatabytes   0
return bytesread
/**
@see byteholder#available
*/
public int available
//if (sanitymanager.debug)
//	sanitymanager.assert(writing == false,
//						 "reading should be true 3");
int curbufavailable   curbufdatabytes   curbufpos
int lastbufavailable   0
int middlebuffers   0
if  curbufveleat    lastbufveleat
middlebuffers   lastbufveleat   curbufveleat   1
lastbufavailable   lastbufdatabytes
int availablebytes
curbufavailable
lastbufavailable
middlebuffers   bufsize
return availablebytes
/**
return the number of bytes that have been saved to this byte holder.
this result is different from available() as it is unaffected by the
current read position on the byteholder.
@see byteholder#numbytessaved
*/
public int numbytessaved
int ret_val
if  writing
// still writing, so use the cur* variables
if  sanitymanager debug
sanitymanager assert
lastbufveleat    0    lastbufdatabytes    0
ret_val    curbufveleat   bufsize    curbufpos
else
ret_val    lastbufveleat   bufsize    lastbufdatabytes
return ret_val
/**
@see byteholder#skip
@exception ioexception	thrown on error
*/
public long skip long count  throws ioexception
long bytesiskipped   0
boolean eof   false
if  sanitymanager debug
sanitymanager assert writing    false
if  curbufpos >  curbufdatabytes
eof   getnextbuffer_r
while  count > 0     eof
int bytesincurbuf   curbufdatabytes   curbufpos
int bytesiskippedthistime
if  count >  bytesincurbuf
bytesiskippedthistime   bytesincurbuf
else
bytesiskippedthistime    int count
curbufpos  bytesiskippedthistime
count    bytesiskippedthistime
bytesiskipped  bytesiskippedthistime
if  count > 0
eof   getnextbuffer_r
return bytesiskipped
/**
@see byteholder#writingmode
*/
public boolean writingmode
return writing
/**
get the next buffer for writing bytes.
@exception ioexception	thrown on error
*/
protected void getnextbuffer_w   throws ioexception
if  sanitymanager debug
getnextbuffer_w_sanity
curbufveleat
if  bufv size   <  curbufveleat
curbuf   new byte
bufv addelement curbuf
else
curbuf    byte bufv elementat curbufveleat
initbuffer_w
/** do sanity checking when getting the next write buffer */
protected void getnextbuffer_w_sanity
if  sanitymanager debug
sanitymanager assert curbufpos    curbuf length
sanitymanager assert writing    true
/** initialize a buffer for writing */
protected void initbuffer_w
curbufpos   0
if  sanitymanager debug
sanitymanager assert curbuf length    bufsize
curbuf length
/**
get the next buffer for reading bytes.
@return true if the user has read all the bytes
in this byteholder.
@exception ioexception		thrown on error
*/
protected boolean getnextbuffer_r   throws ioexception
if  sanitymanager debug
sanitymanager assert writing    false
if  curbufveleat >  lastbufveleat  return true
curbuf    byte bufv elementat   curbufveleat
curbufpos   0
if  curbufveleat    lastbufveleat
curbufdatabytes   lastbufdatabytes
else
curbufdatabytes   bufsize
return false
/**
create a string representation of an internal buffer of bytes.
this is useful during debugging.
*/
private string dumpbuf int bufveleat
stringbuffer sb   new stringbuffer 100
byte buf    byte bufv elementat bufveleat
sb append
for  int ix   0 ix<buf length ix
sb append buf
sb append
return sb tostring
/**
produce a string describing the state of this byteholder.
this is mainly for debugging.
*/
public string tostring
return
writing
curbufveleat
curbufpos
curbufdatabytes
lastbufveleat
lastbufdatabytes
dumpbuf curbufveleat