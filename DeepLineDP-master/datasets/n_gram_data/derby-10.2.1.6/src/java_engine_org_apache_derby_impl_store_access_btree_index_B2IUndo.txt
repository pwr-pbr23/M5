/*
derby - class org.apache.derby.impl.store.access.btree.index.b2iundo
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl store access btree index
import org apache derby iapi reference sqlstate
import org apache derby iapi services io arrayinputstream
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi services io formatable
import org apache derby iapi services io formatidutil
import org apache derby iapi services io storedformatids
import org apache derby iapi error standardexception
import org apache derby iapi store access conglomerate logicalundo
import org apache derby iapi store access conglomerate transactionmanager
import org apache derby iapi store access rowutil
import org apache derby iapi store access dynamiccompiledopenconglominfo
import org apache derby iapi store access qualifier
import org apache derby iapi store access scancontroller
import org apache derby iapi store access transactioncontroller
import org apache derby iapi store raw containerhandle
import org apache derby iapi store raw fetchdescriptor
import org apache derby iapi store raw lockingpolicy
import org apache derby iapi store raw logicalundoable
import org apache derby iapi store raw page
import org apache derby iapi store raw recordhandle
import org apache derby iapi store raw transaction
import org apache derby iapi types datavaluedescriptor
// imports of inherited impl's
import org apache derby impl store access btree btree
import org apache derby impl store access btree btreelockingpolicy
import org apache derby impl store access btree controlrow
import org apache derby impl store access btree openbtree
import org apache derby impl store access btree searchparameters
import java io objectinput
import java io ioexception
import java io objectoutput
import org apache derby iapi services io limitobjectinput
import org apache derby iapi services io formatablebitset
/**
* @format_id access_b2iundo_v1_id
*
* @purpose   implements the logicalundo and formatable interfaces, basically
*            providing a way for raw store recovery to "call back" access code
*            to provide logical undo ability.
*
* @upgrade   resolve.
*
* @disk_layout
*     no state associated with this format.
*
**/
/**
the b2iundo interface packages up the routines which the rawstore needs
to call to perform logical undo of a record in a b2i.  the rawstore will
determine that a page has changed since the record was written, and if it
has it will call the findundo() interface, to find the page where the record
exists (as it may have moved).
<p>
this class must not contain any persistent state, as this class is stored
in the log record of the insert/delete.
@see org.apache.derby.iapi.store.raw.logicalundoable
@see org.apache.derby.iapi.store.raw.undoable#generateundo
**/
public class b2iundo implements logicalundo  formatable
/**
* find the page and record to undo.  if no logical undo is necessary,
* i.e., row has not moved, then just return the latched page where undo
* should go.  if the record has moved, it has a new recordid on the new
* page, this routine needs to call pageop.resetrecord with the new
* recordhandle so that the logging system can update the compensation
* operation with the new location.
*
* @param rawtran   the transaction doing the rollback
* @param pageop    the page operation that supports logical undo.  this
* 		            logicalundo function pointer is a field of that
* 		            pageoperation
* @param in        data stored in the log stream that contains the record
*                  data necessary to restore the row.
*
* @exception standardexception standard cloudscape error policy
* @exception ioexception method may read from inputstream
*
*/
public page findundo
transaction         rawtran
logicalundoable     pageop
limitobjectinput    in
throws standardexception  ioexception
controlrow            root                        null
controlrow            control_row                 null
datavaluedescriptor logged_index_row_template   null
datavaluedescriptor template                    null
page                  ret_page                    null
containerhandle       container                   pageop getcontainer
recordhandle          rechandle                   pageop getrecordhandle
boolean               ok_exit                     false
int                   compare_result              1
b2i                   btree                       null
// open the btree to associate the open contain handle, thus the
// current xact with all subsequent operations during undo.
try
// need conglomerate to create templates - get from the root page.
root   controlrow get container  btree rootpageid
if  sanitymanager debug
sanitymanager assert root getpage   islatched
btree    b2i  root getconglom b2i format_number
if  sanitymanager debug
sanitymanager assert btree instanceof b2i
// create a template for the logged index row from the conglomerate.
logged_index_row_template   btree createtemplate
// create a template for the page index row from the conglomerate.
template                    btree createtemplate
finally
if  root    null
root release
// get logged row from record.
pageop restoreloggedrow logged_index_row_template  in
// resolve (mikem) - currently restoreloggedrow() may latch and unlatch
// a page in the container (see st059).
// now get the page where the record used to be.
ok_exit   false
try
// "open" the btree, using recovery's already opened container
openbtree open_btree   new openbtree
open_btree init
transactionmanager  null      current user xact   not needed
transactionmanager  null      current xact        not needed
pageop getcontainer            recovery already opened container
rawtran
false
containerhandle mode_forupdate
// open_mode not used - container is
// already opened.
transactionmanager mode_none
btreelockingpolicy  null      don't get locks during undo
btree
logicalundo  null             no logical undo necessary  as
// this code only does read.
dynamiccompiledopenconglominfo  null
// system.out.println(
//   "calling logical undo, recordhandle = " + rechandle);
// system.out.println("calling logical undo, record= " +
//    logged_index_row_template);
// get the page where the record was originally, before splits
// could have possibly moved it.
control_row   controlrow get open_btree  rechandle getpagenumber
// init compare_result, if record doesn't exist do the search
compare_result   1
if  control_row getpage   recordexists rechandle  true
if  sanitymanager debug
sanitymanager assert
control_row getpage   fetchnumfields rechandle
logged_index_row_template length
// create template for the page index row from the conglomerate.
recordhandle ret_rechandle
control_row getpage   fetchfromslot
recordhandle  null
control_row getpage   getslotnumber rechandle
template
fetchdescriptor  null
true
// compare the 2 rows, and if they are the same then the raw
// store has the right page and record and there is no work to
// be done (this is usual case).
compare_result   controlrow compareindexrowtokey
template  logged_index_row_template
logged_index_row_template length  1
open_btree getcolumnsortorderinfo
if  compare_result    0
ret_page   control_row getpage
else
// if the 2 don't compare equal, search the btree from the root
// for the logged row, find the leaf, reset the row for the raw
// store, and return the new page latched.
// create the objects needed for the insert.
searchparameters sp   new searchparameters
logged_index_row_template  scancontroller ge
template  open_btree  false
control_row release
control_row   null
control_row
controlrow get open_btree  btree rootpageid  search sp
if   sp resultexact
if  sanitymanager debug
sanitymanager throwassert
rowutil tostring logged_index_row_template
sp
control_row
control_row debugpage open_btree
control_row getpage
throw standardexception newexception
sqlstate btree_row_not_found_during_undo
else
recordhandle rh
control_row getpage   fetchfromslot
recordhandle  null
sp resultslot  new datavaluedescriptor
fetchdescriptor  null
true
pageop resetrecordhandle rh
ret_page   control_row getpage
ok_exit   true
finally
//system.out.println("b2iundo returning with rec handle: " +
//                   pageop.getrecordhandle());
if    ok_exit      control_row    null
control_row release
return ret_page
/**
return my format identifier.
@see org.apache.derby.iapi.services.io.typedformat#gettypeformatid
*/
public int gettypeformatid
return storedformatids access_b2iundo_v1_id
/**
this object has no state, so nothing to write.*/
public void writeexternal objectoutput out  throws ioexception
return
/**
restore the in-memory representation from the stream.
this object has no state, so nothing to restore.
@exception classnotfoundexception thrown if the stored representation is
serialized and a class named in the stream could not be found.
@see java.io.externalizable#readexternal
*/
public void readexternal objectinput in
throws ioexception  classnotfoundexception
return
public void readexternal arrayinputstream in
throws ioexception  classnotfoundexception
return