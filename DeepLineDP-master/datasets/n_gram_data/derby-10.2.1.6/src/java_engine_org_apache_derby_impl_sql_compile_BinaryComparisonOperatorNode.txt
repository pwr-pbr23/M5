/*
derby - class org.apache.derby.impl.sql.compile.binarycomparisonoperatornode
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package	org apache derby impl sql compile
import org apache derby iapi sql compile c_nodetypes
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi sql compile typecompiler
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi types typeid
import org apache derby iapi types datatypedescriptor
import org apache derby iapi reference sqlstate
import org apache derby iapi reference classname
import org apache derby iapi error standardexception
import org apache derby iapi services sanity sanitymanager
import org apache derby impl sql compile activationclassbuilder
import java util vector
import java sql types
/**
* this node is the superclass  for all binary comparison operators, such as =,
* <>, <, etc.
*
* @author jeff lichtman
*/
public abstract class binarycomparisonoperatornode extends binaryoperatornode
// use between selectivity?
private boolean forqueryrewrite
private boolean betweenselectivity
/**
* initializer for a binarycomparisonoperatornode
*
* @param leftoperand	the left operand of the comparison
* @param rightoperand	the right operand of the comparison
* @param operator		the name of the operator
* @param methodname	the name of the method to call in the generated
*						class
*/
public void init
object	leftoperand
object	rightoperand
object		operator
object		methodname
super init leftoperand  rightoperand  operator  methodname
classname datavaluedescriptor  classname datavaluedescriptor
/**
* this node was generated as part of a query rewrite. bypass the
* normal comparability checks.
* @param val  true if this was for a query rewrite
*/
public void setforqueryrewrite boolean val
forqueryrewrite val
/**
* was this node generated in a query rewrite?
*
* @return  true if it was generated in a query rewrite.
*/
public boolean getforqueryrewrite
return forqueryrewrite
/**
* use between selectivity when calculating the selectivity.
*/
void setbetweenselectivity
betweenselectivity   true
/**
* return whether or not to use the between selectivity for this node.
*
* @return whether or not to use the between selectivity for this node.
*/
boolean getbetweenselectivity
return betweenselectivity
/**
* bind this comparison operator.  all that has to be done for binding
* a comparison operator is to bind the operands, check the compatibility
* of the types, and set the result type to sqlboolean.
*
* @param fromlist			the query's from list
* @param subquerylist		the subquery list being built as we find subquerynodes
* @param aggregatevector	the aggregate vector being built as we find aggregatenodes
*
* @return	the new top of the expression tree.
*
* @exception standardexception		thrown on error
*/
public valuenode bindexpression
fromlist fromlist  subquerylist subquerylist
vector	aggregatevector
throws standardexception
super bindexpression fromlist  subquerylist  aggregatevector
//resolvelocalize - convert constants to national constants
typecompiler lefttc   leftoperand gettypecompiler
typecompiler righttc   rightoperand gettypecompiler
typeid lefttypeid   leftoperand gettypeid
typeid righttypeid   rightoperand gettypeid
/*
* if we are comparing a non-string with a string type, then we
* must prevent the non-string value from being used to probe into
* an index on a string column. this is because the string types
* are all of low precedence, so the comparison rules of the non-string
* value are used, so it may not find values in a string index because
* it will be in the wrong order. so, cast the string value to its
* own type. this is easier than casting it to the non-string type,
* because we would have to figure out the right length to cast it to.
*/
if    lefttypeid isstringtypeid      righttypeid isstringtypeid
datatypedescriptor righttypeservices   rightoperand gettypeservices
rightoperand     valuenode
getnodefactory   getnode
c_nodetypes cast_node
rightoperand
new datatypedescriptor
righttypeid
true
righttypeservices getmaximumwidth
getcontextmanager
castnode  rightoperand  bindcastnodeonly
else if    righttypeid isstringtypeid      lefttypeid isstringtypeid
datatypedescriptor lefttypeservices   leftoperand gettypeservices
leftoperand     valuenode
getnodefactory   getnode
c_nodetypes cast_node
leftoperand
new datatypedescriptor
lefttypeid
true
lefttypeservices getmaximumwidth
getcontextmanager
castnode  leftoperand  bindcastnodeonly
/* if we are comparing a char with a national char then
* we need to generate a cast to the appropriate national
* char above the char operand.
*/
else if    lefttypeid isnationalstringtypeid
righttypeid isnationalstringtypeid
leftoperand     valuenode
getnodefactory   getnode
c_nodetypes cast_node
leftoperand
datatypedescriptor getbuiltindatatypedescriptor lefttc getmatchingnationalchartypename
lefttc getcasttocharwidth
leftoperand gettypeservices
getcontextmanager
castnode  leftoperand  bindcastnodeonly
else if    righttypeid isnationalstringtypeid
lefttypeid isnationalstringtypeid
rightoperand     valuenode
getnodefactory   getnode
c_nodetypes cast_node
rightoperand
datatypedescriptor getbuiltindatatypedescriptor righttc getmatchingnationalchartypename
righttc getcasttocharwidth
rightoperand gettypeservices
getcontextmanager
castnode  rightoperand  bindcastnodeonly
/* test type compatability and set type info for this node */
bindcomparisonoperator
return this
/**
* test the type compatability of the operands and set the type info
* for this node.  this method is useful both during binding and
* when we generate nodes within the language module outside of the parser.
*
* @exception standardexception		thrown on error
*/
public void bindcomparisonoperator
throws standardexception
typeid	lefttype
typeid	righttype
boolean				nullableresult
lefttype   leftoperand gettypeid
righttype   rightoperand gettypeid
/*
** can the types be compared to each other?  if not, throw an
** exception.
*/
boolean forequals   operator equals       operator equals
boolean cmp   leftoperand gettypecompiler   comparable righttype
forequals
getclassfactory
// bypass the comparable check if this is a rewrite from the
// optimizer.  we will assume mr. optimizer knows what he is doing.
if   cmp     forqueryrewrite
throw standardexception newexception sqlstate lang_not_comparable
lefttype getsqltypename
righttype getsqltypename
/*
** set the result type of this comparison operator based on the
** operands.  the result type is always sqlboolean - the only question
** is whether it is nullable or not.  if either of the operands is
** nullable, the result of the comparison must be nullable, too, so
** we can represent the unknown truth value.
*/
nullableresult   leftoperand gettypeservices   isnullable
rightoperand gettypeservices   isnullable
settype new datatypedescriptor typeid boolean_id  nullableresult
/**
* preprocess an expression tree.  we do a number of transformations
* here (including subqueries, in lists, like and between) plus
* subquery flattening.
* note: this is done before the outer resultsetnode is preprocessed.
*
* @param	numtables			number of tables in the dml statement
* @param	outerfromlist		fromlist from outer query block
* @param	outersubquerylist	subquerylist from outer query block
* @param	outerpredicatelist	predicatelist from outer query block
*
* @return		the modified expression
*
* @exception standardexception		thrown on error
*/
public valuenode preprocess int numtables
fromlist outerfromlist
subquerylist outersubquerylist
predicatelist outerpredicatelist
throws standardexception
leftoperand   leftoperand preprocess numtables
outerfromlist  outersubquerylist
outerpredicatelist
/* this is where we start to consider flattening expression subqueries based
* on a uniqueness condition.  if the right child is a subquerynode then
* it is a potentially flattenable expression subquery.  if we flatten the
* subquery then we at least need to change the right operand of this
* comparison.  however, we may want to push the comparison into the subquery
* itself and replace this outer comparison with true in the tree.  thus we
* return rightoperand.preprocess() if the rightoperand is a subquerynode.
* note: subquerynode.preprocess() is smart enough to return this node
* if it is not flattenable.
* note: we only do this if the subquery has not yet been preprocessed.
* (a subquery can get preprocessed multiple times if it is a child node
* in an expression that gets transformed, like between.  the subquery
* remembers whether or not it has been preprocessed and simply returns if
* it has already been preprocessed.  the return returns the subquerynode,
* so an invalid tree is returned if we set the parent comparison operator
* when the subquery has already been preprocessed.)
*/
if   rightoperand instanceof subquerynode
subquerynode  rightoperand  getpreprocessed
subquerynode  rightoperand  setparentcomparisonoperator this
return rightoperand preprocess numtables
outerfromlist  outersubquerylist
outerpredicatelist
else
rightoperand   rightoperand preprocess numtables
outerfromlist  outersubquerylist
outerpredicatelist
return this
/**
* eliminate notnodes in the current query block.  we traverse the tree,
* inverting ands and ors and eliminating nots as we go.  we stop at
* comparisonoperators and boolean expressions.  we invert
* comparisonoperators and replace boolean expressions with
* boolean expression = false.
* note: since we do not recurse under comparisonoperators, there
* still could be notnodes left in the tree.
*
* @param	undernotnode		whether or not we are under a notnode.
*
*
* @return		the modified expression
*
* @exception standardexception		thrown on error
*/
valuenode eliminatenots boolean undernotnode
throws standardexception
if    undernotnode
return this
/* convert the binarycomparison operator to its negation */
return getnegation leftoperand  rightoperand
/**
* negate the comparison.
*
* @param leftoperand	the left operand of the comparison operator
* @param rightoperand	the right operand of the comparison operator
*
* @return binaryoperatornode	the negated expression
*
* @exception standardexception		thrown on error
*/
binaryoperatornode getnegation valuenode leftoperand
valuenode rightoperand
throws standardexception
/* keep the compiler happy - this method should never be called.
* we should always be calling the method in a sub-class.
*/
if  sanitymanager debug
sanitymanager assert false
getclass   tostring
return this
/**
* finish putting an expression into conjunctive normal
* form.  an expression tree in conjunctive normal form meets
* the following criteria:
*		o  if the expression tree is not null,
*		   the top level will be a chain of andnodes terminating
*		   in a true booleanconstantnode.
*		o  the left child of an andnode will never be an andnode.
*		o  any right-linked chain that includes an andnode will
*		   be entirely composed of andnodes terminated by a true booleanconstantnode.
*		o  the left child of an ornode will never be an ornode.
*		o  any right-linked chain that includes an ornode will
*		   be entirely composed of ornodes terminated by a false booleanconstantnode.
*		o  valuenodes other than andnodes and ornodes are considered
*		   leaf nodes for purposes of expression normalization.
*		   in other words, we won't do any normalization under
*		   those nodes.
*
* in addition, we track whether or not we are under a top level andnode.
* subquerynodes need to know this for subquery flattening.
*
* @param	undertopandnode		whether or not we are under a top level andnode.
*
*
* @return		the modified expression
*
* @exception standardexception		thrown on error
*/
public valuenode changetocnf boolean undertopandnode
throws standardexception
/* if our right child is a subquery and we are under a top and node
* then we want to mark the subquery as under a top and node.
* that will allow us to consider flattening it.
*/
if  undertopandnode     rightoperand instanceof subquerynode
rightoperand   rightoperand changetocnf undertopandnode
return this
/** @see binaryoperatornode#gensqljavasqltree */
public valuenode gensqljavasqltree   throws standardexception
typeid lefttypeid   leftoperand gettypeid
/* if i have java types, i need only add java->sql->java if the types
* are not comparable
*/
if  lefttypeid usertype
if  leftoperand gettypecompiler   comparable lefttypeid  false
getclassfactory
return this
leftoperand   leftoperand gensqljavasqltree
typeid righttypeid   rightoperand gettypeid
if  righttypeid usertype
if  rightoperand gettypecompiler   comparable righttypeid  false
getclassfactory
return this
rightoperand   rightoperand gensqljavasqltree
return this