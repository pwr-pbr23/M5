/*
derby - class org.apache.derby.iapi.services.diag.diagnosticutil
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby iapi services diag
/**
the diagnostic framework is meant to provide a way to include as much
diagnostic capability within the distributed release of the cloudscape
product without adversely affecting the runtime speed or foot print of
a running configuration that needs not use this information.
in order to decrease the class size of running objects diagnostic information
should be put in "helper" classes.  so to provide diagnostic capabiility
on the implementation of class foo.java create a class d_foo.java.  class
d_foo must implement the diagnosticable interface.
this class provide utility functions to get at the information provided by
the d_* helper class:
finddiagnostic() - given and object "obj", get an instance of d_obj.
todiagstring()   - return the "best" diagnostic string available about
a given object.
**/
public class diagnosticutil
/* constructors for this class: */
private diagnosticutil
/* private/protected methods of this class: */
/**
* given an object return instance of the diagnostic object for this class.
* <p>
* given an object this routine will determine the classname of the object
* and then try to instantiate a new instance of the diagnostic object
* for this class by prepending on "d_" to the last element of theclassname.
if no matching class is found then the same lookup is made on the super-class
of the object, looking all the way up the hierachy until a diagnostic class
is found.
* <br>
this routine will call "init(ref)" on the new instance and then return the new instance.
*
* @return a new instance of the diagnostic object for input object, or
*         null if one could not be found for some reason.
*
* @param ref   the object which to build the diagnostic object for.
**/
public static diagnosticable finddiagnostic object ref
class refclass   ref getclass
for
try
string classname   refclass getname
int lastdot   classname lastindexof      1
string          diagclassname
classname substring 0  lastdot
classname substring lastdot
class diagclass
try
diagclass   class forname diagclassname
catch  classnotfoundexception cnfe
// try the super-class of the object
refclass   refclass getsuperclass
if  refclass    null
return null
continue
diagnosticable diag_obj    diagnosticable  diagclass newinstance
diag_obj init ref
return diag_obj
catch  exception e
return null
/**
* return a diagnostic string associated with an object.
* <p>
* a utility interface to use if you just want to print a single string
* that represents the object in question.  in following order this routine
* will deliver the string to use:
*
*     1) find diagnostic help class, and use class.diag()
*     2) else just use class.tostring()
*
* <p>
*
* @return the string describing the class input.
*
* @param obj the object to print out.
*
**/
public static string todiagstring object obj
string ret_string   null
if  obj    null  return
try
diagnosticable diag   diagnosticutil finddiagnostic obj
if  diag    null
ret_string   diag diag
catch  throwable t
// do nothing, ret_string should still be null on error
if  ret_string    null
ret_string   obj tostring
return ret_string
/* public methods of this class: */
/* public methods of xxxx class: */