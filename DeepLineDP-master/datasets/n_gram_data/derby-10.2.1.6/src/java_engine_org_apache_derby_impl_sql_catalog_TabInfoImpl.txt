/*
derby - class org.apache.derby.impl.sql.catalog.tabinfoimpl
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl sql catalog
import org apache derby iapi services io formatablebitset
import org apache derby iapi services context contextservice
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi services io streamstorable
import org apache derby iapi error standardexception
import org apache derby iapi sql conn languageconnectioncontext
import org apache derby iapi sql dictionary catalogrowfactory
import org apache derby iapi sql dictionary conglomeratedescriptor
import org apache derby iapi sql dictionary indexrowgenerator
import org apache derby iapi sql execute execindexrow
import org apache derby iapi sql execute execrow
import org apache derby iapi sql execute executioncontext
import org apache derby iapi sql execute executionfactory
import org apache derby iapi sql execute rowchanger
import org apache derby iapi sql execute tuplefilter
import org apache derby iapi sql activation
import org apache derby iapi store access conglomeratecontroller
import org apache derby iapi store access dynamiccompiledopenconglominfo
import org apache derby iapi store access qualifier
import org apache derby iapi store access scancontroller
import org apache derby iapi store access staticcompiledopenconglominfo
import org apache derby iapi store access transactioncontroller
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi types datavaluefactory
import org apache derby iapi types rowlocation
import org apache derby catalog uuid
import java util enumeration
import java util properties
/**
* a poor mans structure used in datadictionaryimpl.java.
* used to save heapid, name pairs for non core tables.
*
* @author jamie
*/
class tabinfoimpl
/**
* rownotduplicate is out of range for a row
* number.  if a return code does not equal
* this value, then it refers to the row
* that is a duplicate.
*/
static  final   int     rownotduplicate    1
private indexinfoimpl				indexes
private long						heapconglomerate
private int							numindexesset
private boolean						heapset
private final catalogrowfactory			crf
/**
* constructor
*
* @param crf				the associated catalogrowfactory
*/
tabinfoimpl catalogrowfactory crf
this heapconglomerate    1
this crf   crf
int numindexes   crf getnumindexes
if  numindexes > 0
indexes   new indexinfoimpl
/* init indexes */
for  int indexctr   0  indexctr < numindexes  indexctr
indexes   new indexinfoimpl
indexctr
crf
/**
* get the conglomerate for the heap.
*
* @return long     the conglomerate for the heap.
*/
long getheapconglomerate
return heapconglomerate
/**
* set the heap conglomerate for this.
*
* @param heapconglomerate  the new heap conglomerate.
*/
void setheapconglomerate long heapconglomerate
this heapconglomerate   heapconglomerate
heapset   true
/**
* get the conglomerate for the specified index.
*
* @return long     the conglomerate for the specified index.
*/
long getindexconglomerate int indexid
if  sanitymanager debug
sanitymanager assert indexes    null
if  indexid >  indexes length
sanitymanager throwassert
indexid
indexes length
return indexes getconglomeratenumber
/**
* set the index conglomerate for the table.
*
* @param index             index number for index for table
* @param indexconglomerate the conglomerate for that index
*/
void setindexconglomerate int index  long indexconglomerate
/* index names must be set before conglomerates.
* also verify that we are not setting the same conglomerate
* twice.
*/
if  sanitymanager debug
sanitymanager assert indexes    null
sanitymanager assert indexes getconglomeratenumber       1
indexes setconglomeratenumber indexconglomerate
/* we are completely initialized when all indexes have
* their conglomerates initialized
*/
numindexesset
/**
* set the index conglomerate for the table.
*
* @param cd    the conglomeratedescriptor for one of the index
*              for this table.
*/
void setindexconglomerate conglomeratedescriptor cd
int		index
string	indexname   cd getconglomeratename
if  sanitymanager debug
sanitymanager assert indexes    null
for  index   0  index < indexes length  index
/* all index names expected to be set before
* any conglomerate is set.
*/
if  sanitymanager debug
sanitymanager assert indexes    null
sanitymanager assert indexes getindexname      null
/* do we have a match? */
if  indexes getindexname   equals indexname
indexes setconglomeratenumber cd getconglomeratenumber
break
if  sanitymanager debug
if  index    indexes length
sanitymanager throwassert     indexname
/* we are completely initialized when all indexids are initialized */
numindexesset
/**
* get the table name.
*
* @return string   the table name.
*/
string gettablename
return crf getcatalogname
/**
* get the index name.
*
* @param indexid   index number for index for table
*
* @return string   the index name.
*/
string getindexname int indexid
return indexes getindexname
/**
* get the catalogrowfactory for this.
*
* @return catalogrowfactory    the catalogrowfactory for this.
*/
catalogrowfactory getcatalogrowfactory
return crf
/**
* is this fully initialized.
* (i.e., is all conglomerate info initialized)
*
* @return boolean  whether or not this is fully initialized.
*/
boolean iscomplete
/* we are complete when heap conglomerate and all
* index conglomerates are set.
*/
if    heapset
return false
return  indexes    null   	indexes length    numindexesset
/**
* get the column count for the specified index number.
*
* @param indexnumber   the index number.
*
* @return int          the column count for the specified index.
*/
int getindexcolumncount int indexnumber
if  sanitymanager debug
sanitymanager assert indexes    null
if    indexnumber < indexes length
sanitymanager throwassert     indexnumber
indexes length
return indexes getcolumncount
/**
* get the indexrowgenerator for the specified index number.
*
* @param indexnumber   the index number.
*
* @return indexrowgenerator    the irg for the specified index number.
*/
indexrowgenerator getindexrowgenerator int indexnumber
if  sanitymanager debug
sanitymanager assert indexes    null
if  indexnumber >  indexes length
sanitymanager throwassert
indexnumber
indexes length
return indexes getindexrowgenerator
/**
* set the indexrowgenerator for the specified index number.
*
* @param indexnumber   the index number.
* @param irg           the indexrowgenerator for the specified index number.
*/
void setindexrowgenerator int indexnumber  indexrowgenerator irg
if  sanitymanager debug
sanitymanager assert indexes    null
if  indexnumber >  indexes length
sanitymanager throwassert
indexnumber
indexes length
indexes setindexrowgenerator irg
/**
* get the number of indexes on this catalog.
*
* @return int  the number of indexes on this catalog.
*/
int getnumberofindexes
if  indexes    null
return 0
else
return indexes length
/**
* get the base column position for a column within a catalog
* given the (0-based) index number for this catalog and the
* (0-based) column number for the column within the index.
*
* @param indexnumber   the index number
* @param colnumber     the column number within the index
*
* @return int      the base column position for the column.
*/
int getbasecolumnposition int indexnumber  int colnumber
if  sanitymanager debug
sanitymanager assert indexes    null
if  indexnumber >  indexes length
sanitymanager throwassert     indexnumber
indexes length
return indexes getbasecolumnposition colnumber
/**
* return whether or not this index is declared unique
*
* @param indexnumber   the index number
*
* @return boolean      whether or not this index is declared unique
*/
boolean isindexunique int indexnumber
if  sanitymanager debug
sanitymanager assert indexes    null
if  indexnumber >  indexes length
sanitymanager throwassert     indexnumber
indexes length
return indexes isindexunique
/**
* inserts a base row into a catalog and inserts all the corresponding
* index rows.
*
*	@param	row			row to insert
*	@param	tc			transaction
*	@param	wait		to wait on lock or quickly timeout
*	@return	row number (>= 0) if duplicate row inserted into an index
*			rownotduplicate otherwise
*
* @exception standardexception		thrown on failure
*/
int insertrow  execrow row  transactioncontroller tc  boolean wait
throws standardexception
rowlocation 			notused   new rowlocation
return insertrowlistimpl new execrow  row  tc notused  wait
/**
* inserts a list of base rows into a catalog and inserts all the corresponding
* index rows.
*
*	@param	rowlist		list of rows to insert
*	@param	tc			transaction controller
*
*
*	@return	row  number (>= 0) if duplicate row inserted into an index
*			rownotduplicate otherwise
*
* @exception standardexception		thrown on failure
*/
int insertrowlist execrow rowlist  transactioncontroller tc
throws standardexception
rowlocation 			notused   new rowlocation
return insertrowlistimpl rowlist tc notused  true
/**
insert logic to insert a list of rows into a table. this logic has two
odd features.
<ol>
<li>returns an indication if any returned row was a duplicate.
<li>returns the rowlocation of the last row inserted.
</ol>
@param rowlist the list of rows to insert
@param tc	transaction controller
@param rowlocationout on output rowlocationout[0] is set to the
last rowlocation inserted.
@param wait   to wait on lock or quickly timeout
@return row number (>= 0) if duplicate row inserted into an index
rownotduplicate otherwise
*/
private int insertrowlistimpl execrow rowlist  transactioncontroller tc  rowlocation rowlocationout
boolean wait
throws standardexception
conglomeratecontroller		heapcontroller
rowlocation					heaplocation
execindexrow				indexablerow
int							insertretcode
int							retcode   rownotduplicate
int							indexcount   crf getnumindexes
conglomeratecontroller	indexcontrollers   new conglomeratecontroller
// open the conglomerates
heapcontroller
tc openconglomerate
getheapconglomerate
false
transactioncontroller openmode_forupdate
wait  ? 0   transactioncontroller openmode_lock_nowait
transactioncontroller mode_record
transactioncontroller isolation_repeatable_read
/* note: due to the lovely problem of trying to add
* a new column to syscolumns and an index on that
* column during upgrade, we have to deal with the
* issue of the index not existing yet.  so, it's okay
* if the index doesn't exist yet.  (it will magically
* get created at a later point during upgrade.)
*/
for   int ictr   0  ictr < indexcount  ictr
long conglomnumber   getindexconglomerate ictr
if  conglomnumber >  1
indexcontrollers
tc openconglomerate
conglomnumber
false
transactioncontroller openmode_forupdate
wait  ? 0   transactioncontroller openmode_lock_nowait
transactioncontroller mode_record
transactioncontroller isolation_repeatable_read
heaplocation   heapcontroller newrowlocationtemplate
rowlocationout heaplocation
// loop through rows on this list, inserting them into system table
for  int rownumber   0  rownumber < rowlist length  rownumber
execrow row   rowlist
// insert the base row and get its new location
heapcontroller insertandfetchlocation row getrowarray    heaplocation
for   int ictr   0  ictr < indexcount  ictr
if  indexcontrollers    null
continue
// get an index row based on the base row
indexablerow   getindexrowfromheaprow  getindexrowgenerator ictr
heaplocation
row
insertretcode
indexcontrollers insert indexablerow getrowarray
if   insertretcode    conglomeratecontroller rowisduplicate
retcode   rownumber
end loop through rows on list
// close the open conglomerates
for   int ictr   0  ictr < indexcount  ictr
if  indexcontrollers    null
continue
indexcontrollers close
heapcontroller close
return	retcode
/**
* given a key row, delete all matching heap rows and their index
* rows.
* <p>
* locking: row locking if there is a key; otherwise,
* table locking.
*
* @param  tc          transaction controller
* @param  key         key to delete by.
* @param  indexnumber key is appropriate for this index.
* @return the number of rows deleted. if key is not unique,
*         this may be more than one.
* @exception standardexception        thrown on failure
*/
int deleterow  transactioncontroller tc  execindexrow key  int indexnumber
throws standardexception
// always row locking
return  deleterows tc
key
scancontroller ge


key
scancontroller gt
indexnumber
true
int deleterow  transactioncontroller tc  execindexrow key
int indexnumber  boolean wait
throws standardexception
//  always row locking
return  deleterows tc
key
scancontroller ge


key
scancontroller gt
indexnumber
wait
/**
* delete the set of rows defined by a scan on an index
* from the table. most of the parameters are simply passed
* to transactioncontroller.openscan. please refer to the
* transactioncontroller documentation for details.
* <p>
* locking: row locking if there is a start and a stop
* key; otherwise, table locking
*
* @param  tc          transaction controller
* @param  startkey    key to start the scan.
* @param  startop     operation to start the scan.
* @param  stopkey     key to start the scan.
* @param  qualifier   a qualifier for the scan.
* @param  filter      filter on base rows
* @param  stopop      operation to start the scan.
* @param  indexnumber key is appropriate for this index.
* @return the number of rows deleted.
* @exception standardexception        thrown on failure
* @see transactioncontroller#openscan
*/
int deleterows transactioncontroller tc
execindexrow startkey
int startop
qualifier qualifier
tuplefilter filter
execindexrow stopkey
int stopop
int indexnumber  throws standardexception
return  deleterows tc
startkey
startop
qualifier
filter
stopkey
stopop
indexnumber
true
/**
* @inheritdoc
*/
private int deleterows transactioncontroller tc
execindexrow startkey
int startop
qualifier qualifier
tuplefilter filter
execindexrow stopkey
int stopop
int indexnumber
boolean wait
throws standardexception
conglomeratecontroller		heapcc
scancontroller				drivingscan
execindexrow	 			drivingindexrow
rowlocation					baserowlocation
rowchanger 					rc
execrow						baserow   crf makeemptyrow
int                         rowsdeleted   0
boolean						passedfilter   true
rc   getrowchanger  tc   int null baserow
/*
** if we have a start and a stop key, then we are going to
** get row locks, otherwise, we are getting table locks.
** this may be excessive locking for the case where there
** is a start key and no stop key or vice versa.
*/
int lockmode     startkey    null      stopkey    null   ?
tc mode_record
tc mode_table
/*
** don't use level 3 if we have the same start/stop key.
*/
int isolation
startkey    null      stopkey    null      startkey    stopkey   ?
transactioncontroller isolation_repeatable_read
transactioncontroller isolation_serializable
// row level locking
rc open lockmode  wait
datavaluedescriptor startkeyrow
startkey    null ? null   startkey getrowarray
datavaluedescriptor stopkeyrow
stopkey    null  ? null   stopkey getrowarray
/* open the heap conglomerate */
heapcc   tc openconglomerate
getheapconglomerate
false
transactioncontroller openmode_forupdate
wait  ? 0   transactioncontroller openmode_lock_nowait
lockmode
transactioncontroller isolation_repeatable_read
drivingscan   tc openscan
getindexconglomerate indexnumber       conglomerate to open
false     don't hold open across commit
transactioncontroller openmode_forupdate
wait  ? 0   transactioncontroller openmode_lock_nowait
lockmode
isolation
formatablebitset  null     all fields as objects
startkeyrow       start position   first row
startop          startsearchoperation
qualifier    scanqualifier
stopkeyrow       stop position   through last row
stopop          stopsearchoperation
// get an index row based on the base row
drivingindexrow   getindexrowfromheaprow
getindexrowgenerator  indexnumber
heapcc newrowlocationtemplate
crf makeemptyrow
while  drivingscan fetchnext drivingindexrow getrowarray
baserowlocation    rowlocation
drivingindexrow getcolumn drivingindexrow ncolumns
boolean base_row_exists
heapcc fetch
baserowlocation  baserow getrowarray     formatablebitset  null
if  sanitymanager debug
// it can not be possible for heap row to disappear while
// holding scan cursor on index at isolation_repeatable_read.
sanitymanager assert base_row_exists
// only delete rows which pass the base-row filter
if   filter    null     passedfilter   filter execute  baserow   equals  true
if   passedfilter
rc deleterow  baserow  baserowlocation
rowsdeleted
heapcc close
drivingscan close
rc close
return rowsdeleted
/**
* given a key row, return the first matching heap row.
* <p>
* locking: shared row locking.
*
* @param  tc          transaction controller
* @param  key         key to read by.
* @param  indexnumber key is appropriate for this index.
* @exception standardexception        thrown on failure
*/
execrow getrow  transactioncontroller tc
execindexrow key
int indexnumber
throws standardexception
conglomeratecontroller		heapcc
/* open the heap conglomerate */
heapcc   tc openconglomerate
getheapconglomerate
false
0  						   for read only
transactioncontroller mode_record
transactioncontroller isolation_repeatable_read
try   return getrow  tc  heapcc  key  indexnumber
finally   heapcc close
/**
* given an index row and index number return the rowlocation
* in the heap of the first matching row.
* used by the autoincrement code to get the rowlocation in
* syscolumns given a <tablename, columname> pair.
*
* @see datadictionaryimpl#computerowlocation(transactioncontroller, tabledescriptor, string)
*
* @param tc		  transaction controller to use.
* @param key		  index row to search in the index.
* @param indexnumber identifies the index to use.
*
* @exception		  standardexception thrown on failure.
*/
rowlocation getrowlocation transactioncontroller tc
execindexrow key
int indexnumber
throws standardexception
conglomeratecontroller		heapcc
heapcc   tc openconglomerate
getheapconglomerate
false
0  						   for read only
transactioncontroller mode_record
transactioncontroller isolation_repeatable_read
try
rowlocation rl   new rowlocation
execrow notused   getrowinternal tc  heapcc  key  indexnumber  rl
return rl
finally
heapcc close
/**
* given a key row, return the first matching heap row.
* <p>
* locking: shared row locking.
*
* @param  tc          transaction controller
* @param  heapcc      heap to look in
* @param  key         key to read by.
* @param  indexnumber key is appropriate for this index.
* @exception standardexception        thrown on failure
*/
execrow getrow  transactioncontroller tc
conglomeratecontroller heapcc
execindexrow key
int indexnumber
throws standardexception
rowlocation rl   new rowlocation
return getrowinternal tc  heapcc  key  indexnumber  rl
/**
* @exception standardexception		thrown on failure
*/
private execrow getrowinternal  transactioncontroller tc
conglomeratecontroller heapcc
execindexrow key
int indexnumber
rowlocation rl
throws standardexception
scancontroller				drivingscan
execindexrow	 			drivingindexrow
rowlocation					baserowlocation
execrow						baserow   crf makeemptyrow
drivingscan   tc openscan
getindexconglomerate indexnumber
// conglomerate to open
false                   don't hold open across commit
0                       open for read
transactioncontroller mode_record
transactioncontroller isolation_repeatable_read
formatablebitset  null          all fields as objects
key getrowarray         start position   first row
scancontroller ge       startsearchoperation
null                   scanqualifier
key getrowarray         stop position   through last row
scancontroller gt       stopsearchoperation
// get an index row based on the base row
drivingindexrow   getindexrowfromheaprow
getindexrowgenerator  indexnumber
heapcc newrowlocationtemplate
crf makeemptyrow
try
if  drivingscan fetchnext drivingindexrow getrowarray
rl   baserowlocation    rowlocation
drivingindexrow getcolumn drivingindexrow ncolumns
boolean base_row_exists
heapcc fetch
baserowlocation  baserow getrowarray     formatablebitset  null
if  sanitymanager debug
// it can not be possible for heap row to disappear while
// holding scan cursor on index at isolation_repeatable_read.
sanitymanager assert base_row_exists
return baserow
else
return null
finally
drivingscan close
/**
* updates a base row in a catalog and updates all the corresponding
* index rows.
*
*	@param	key			key row
*	@param	newrow		new version of the row
*	@param	indexnumber	index that key operates
*	@param	indicestoupdate	array of booleans, one for each index on the catalog.
*							if a boolean is true, that means we must update the
*							corresponding index because changes in the newrow
*							affect it.
*	@param  colstoupdate	array of ints indicating which columns (1 based)
*							to update.  if null, do all.
*	@param	tc			transaction controller
*
* @exception standardexception		thrown on failure
*/
void updaterow  execindexrow				key
execrow					newrow
int						indexnumber
boolean				indicestoupdate
int					colstoupdate
transactioncontroller	tc
throws standardexception
updaterow key  newrow  indexnumber  indicestoupdate  colstoupdate  tc  true
/**
* updates a base row in a catalog and updates all the corresponding
* index rows.
*
*	@param	key			key row
*	@param	newrow		new version of the row
*	@param	indexnumber	index that key operates
*	@param	indicestoupdate	array of booleans, one for each index on the catalog.
*							if a boolean is true, that means we must update the
*							corresponding index because changes in the newrow
*							affect it.
*	@param  colstoupdate	array of ints indicating which columns (1 based)
*							to update.  if null, do all.
*	@param	tc			transaction controller
*	@param wait		if true, then the caller wants to wait for locks. false will be
*	when we using a nested user xaction - we want to timeout right away if the parent
*	holds the lock.  (bug 4821)
*
* @exception standardexception		thrown on failure
*/
void updaterow  execindexrow				key
execrow					newrow
int						indexnumber
boolean				indicestoupdate
int					colstoupdate
transactioncontroller	tc
boolean	wait
throws standardexception
execrow newrows   new execrow
newrows   newrow
updaterow key  newrows  indexnumber  indicestoupdate  colstoupdate  tc  wait
/**
* updates a set of base rows in a catalog with the same key on an index
* and updates all the corresponding index rows.
*
*	@param	key			key row
*	@param	newrows		new version of the array of rows
*	@param	indexnumber	index that key operates
*	@param	indicestoupdate	array of booleans, one for each index on the catalog.
*							if a boolean is true, that means we must update the
*							corresponding index because changes in the newrow
*							affect it.
*	@param  colstoupdate	array of ints indicating which columns (1 based)
*							to update.  if null, do all.
*	@param	tc			transaction controller
*
* @exception standardexception		thrown on failure
*/
void updaterow  execindexrow				key
execrow				newrows
int						indexnumber
boolean				indicestoupdate
int					colstoupdate
transactioncontroller	tc
throws standardexception
updaterow key  newrows  indexnumber  indicestoupdate  colstoupdate  tc  true
/**
* updates a set of base rows in a catalog with the same key on an index
* and updates all the corresponding index rows. if parameter wait is true,
* then the caller wants to wait for locks. when using a nested user xaction
* we want to timeout right away if the parent holds the lock.
*
*	@param	key			key row
*	@param	newrows		new version of the array of rows
*	@param	indexnumber	index that key operates
*	@param	indicestoupdate	array of booleans, one for each index on the catalog.
*							if a boolean is true, that means we must update the
*							corresponding index because changes in the newrow
*							affect it.
*	@param  colstoupdate	array of ints indicating which columns (1 based)
*							to update.  if null, do all.
*	@param	tc			transaction controller
*	@param wait		if true, then the caller wants to wait for locks. when
*							using a nested user xaction we want to timeout right away
*							if the parent holds the lock. (bug 4821)
*
* @exception standardexception		thrown on failure
*/
private void updaterow  execindexrow				key
execrow				newrows
int						indexnumber
boolean				indicestoupdate
int					colstoupdate
transactioncontroller	tc
boolean wait
throws standardexception
conglomeratecontroller		heapcc
scancontroller				drivingscan
execindexrow	 			drivingindexrow
rowlocation					baserowlocation
execindexrow				templaterow
execrow						baserow   crf makeemptyrow
if  sanitymanager debug
sanitymanager assert  indicestoupdate length    crf getnumindexes
rowchanger 					rc    getrowchanger  tc  colstoupdate baserow
// row level locking
rc openforupdate indicestoupdate  transactioncontroller mode_record  wait
/* open the heap conglomerate */
heapcc   tc openconglomerate
getheapconglomerate
false
transactioncontroller openmode_forupdate
wait  ? 0   transactioncontroller openmode_lock_nowait
transactioncontroller mode_record
transactioncontroller isolation_repeatable_read
drivingscan   tc openscan
getindexconglomerate indexnumber       conglomerate to open
false     don't hold open across commit
transactioncontroller openmode_forupdate
wait  ? 0   transactioncontroller openmode_lock_nowait
transactioncontroller mode_record
transactioncontroller isolation_repeatable_read
formatablebitset  null         all fields as objects
key getrowarray         start position   first row
scancontroller ge          startsearchoperation
null    scanqualifier
key getrowarray         stop position   through last row
scancontroller gt          stopsearchoperation
// get an index row based on the base row
drivingindexrow   getindexrowfromheaprow
getindexrowgenerator  indexnumber
heapcc newrowlocationtemplate
crf makeemptyrow
int rownum   0
while  drivingscan fetchnext drivingindexrow getrowarray
baserowlocation    rowlocation
drivingindexrow getcolumn drivingindexrow ncolumns
boolean base_row_exists
heapcc fetch
baserowlocation  baserow getrowarray     formatablebitset  null
if  sanitymanager debug
// it can not be possible for heap row to disappear while
// holding scan cursor on index at isolation_repeatable_read.
sanitymanager assert base_row_exists
rc updaterow baserow   rownum    newrows length   1  ?
newrows   newrows  baserowlocation
rc finish
heapcc close
drivingscan close
rc close
/**
* get the properties associated with creating the heap.
*
* @return the properties associated with creating the heap.
*/
properties getcreateheapproperties
return crf getcreateheapproperties
/**
* get the properties associated with creating the specified index.
*
* @param indexnumber	the specified index number.
*
* @return the properties associated with creating the specified index.
*/
properties getcreateindexproperties int indexnumber
return crf getcreateindexproperties indexnumber
/**
*	gets a row changer for this catalog.
*
*	@param	tc	transaction controller
*	@param	changedcols	the columns to change (1 based), may be null
* @param  baserow used to detemine column types at creation time
*         only. the row changer does ***not*** keep a referance to
*         this row or change it in any way.
*
*	@return	a row changer for this catalog.
* @exception standardexception		thrown on failure
*/
private	rowchanger	getrowchanger  transactioncontroller tc
int changedcols
execrow baserow
throws standardexception
rowchanger 					rc
int							indexcount   crf getnumindexes
indexrowgenerator			irgs   new indexrowgenerator
long						cids   new long
if  sanitymanager debug
if  changedcols    null
for  int i   changedcols length   1  i >  0  i
sanitymanager assert changedcols    0
for   int ictr   0  ictr < indexcount  ictr
irgs   getindexrowgenerator ictr
cids   getindexconglomerate ictr
rc   crf getexecutionfactory   getrowchanger getheapconglomerate
staticcompiledopenconglominfo  null
dynamiccompiledopenconglominfo  null
irgs
cids
staticcompiledopenconglominfo  null
dynamiccompiledopenconglominfo  null
crf getheapcolumncount
tc
changedcols
getstreamstorableheapcolids baserow
activation  null
return	rc
private boolean computedstreamstorableheapcolids   false
private int streamstorableheapcolids
private int getstreamstorableheapcolids execrow baserow  throws standardexception
if   computedstreamstorableheapcolids
int sshcidlen   0
//
//compute the length of streamstorableheapcolids
//one entry for each column id.
datavaluedescriptor ra   baserow getrowarray
for int ix 0 ix<ra length ix
if  ra instanceof streamstorable  sshcidlen
//
//if we have some streamstorableheapcolids we
//allocate an array to remember them and fill in
//the array with the 0 based column ids. if we
//have none leave streamstorableheapcolids null.
if  sshcidlen > 0
streamstorableheapcolids   new int
int sshcidoffset 0
for int ix 0 ix<ra length ix
if  ra instanceof streamstorable
streamstorableheapcolids   ix
computedstreamstorableheapcolids   true
return streamstorableheapcolids
/**
* get an index row based on a row from the heap.
*
* @param irg		indexrowgenerator to use
* @param rl		rowlocation for heap
* @param heaprow	row from the heap
*
* @return execindexrow	index row.
*
* @exception standardexception		thrown on error
*/
private execindexrow getindexrowfromheaprow indexrowgenerator irg
rowlocation rl
execrow heaprow
throws standardexception
execindexrow		indexrow
indexrow   irg getindexrowtemplate
// get an index row based on the base row
irg getindexrow heaprow  rl  indexrow   formatablebitset  null
return indexrow
public string tostring
if  sanitymanager debug
return     this gettablename
heapconglomerate
indexes    null  ? indexes length   0
numindexesset
heapset
else
return