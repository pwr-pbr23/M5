/*
derby - class org.apache.derby.impl.store.raw.xact.rowlocking3
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl store raw xact
import org apache derby iapi services locks lockfactory
import org apache derby iapi services locks c_lockfactory
import org apache derby iapi services locks latch
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi store raw containerhandle
import org apache derby iapi store raw containerlock
import org apache derby iapi store raw recordhandle
import org apache derby iapi store raw rowlock
import org apache derby iapi store raw transaction
import org apache derby iapi store raw lockingpolicy
import org apache derby iapi error standardexception
/**
a locking policy that implements row level locking with isolation degree 3.
@see org.apache.derby.iapi.store.raw.lockingpolicy
*/
public class rowlocking3 extends nolocking
// no locking has no state, so it's safe to hold
// it as a static
private static final lockingpolicy no_lock   new nolocking
protected final lockfactory	lf
protected rowlocking3 lockfactory lf
this lf   lf
/**
* get type of lock to get while reading data.
* <p>
* this routine is provided so that class's like rowlockingrr can
* override just this routine to get rs2 locks vs rs3 locks, and still
* reuse all the other code in this class.
* <p>
*
* @return the lock type of a shared lock for this locking policy.
**/
protected rowlock getreadlocktype
return rowlock rs3
/**
* get type of lock to get while requesting "update" lock.
* <p>
* this routine is provided so that class's like rowlockingrr can
* override just this routine to get ru2 locks vs ru3 locks, and still
* reuse all the other code in this class.
* <p>
*
* @return the lock type of a shared lock for this locking policy.
**/
protected rowlock getupdatelocktype
return rowlock ru3
/**
* get type of lock to get while writing data.
* <p>
* this routine is provided so that class's like rowlockingrr can
* override just this routine to get rx2 locks vs rx3 locks, and still
* reuse all the other code in this class.
* <p>
*
* @return the lock type of a shared lock for this locking policy.
**/
protected rowlock getwritelocktype
return rowlock rx3
/**
* obtain container level intent lock.
* <p>
* this implementation of row locking is 2 level, ie. table and row locking.
* it will interact correctly with tables opened with containerlocking3
* locking mode.
* <p>
* updater's will get table level ix locks, and x row locks.
* <p>
* reader's will get table level is locks, and s row locks.
*
* @param t            transaction to associate lock with.
* @param container    container to lock.
* @param waitforlock  should lock request wait until granted?
* @param forupdate    should container be locked for update, or read?
*
* @return true if the lock was obtained, false if it wasn't.
*   false should only be returned if the waitforlock policy was set to
*  "false," and the lock was unavailable.
*
* @exception  standardexception  standard exception policy.
**/
public boolean lockcontainer
transaction         t
containerhandle     container
boolean             waitforlock
boolean             forupdate
throws standardexception
object qualifier   forupdate ? containerlock cix   containerlock cis
boolean gotlock
lf lockobject
t getcompatibilityspace    t  container getid    qualifier
waitforlock ? c_lockfactory timed_wait   c_lockfactory no_wait
if  gotlock
// look for covering table locks
// cis is covered by cx or cs
// cix is covered by cx
if  lf islockheld t getcompatibilityspace    t  container getid    containerlock cx
forupdate     lf islockheld t getcompatibilityspace    t  container getid    containerlock cs
container setlockingpolicy no_lock
return gotlock
/**
* obtain lock on record being read.
* <p>
* assumes that a table level is has been acquired.  will acquire a shared
* or update lock on the row, depending on the "forupdate" parameter.
* <p>
*
* @param t             the transaction to associate the lock with.
* @param record        the record to be locked.
* @param waitforlock   should lock request wait until granted?
* @param forupdate     whether to open for read or write access.
*
* @return true if the lock was granted, false if waitforlock was false
*              and the lock could not be granted.
*
* @exception  standardexception  standard exception policy.
**/
public boolean lockrecordforread
transaction     t
containerhandle container_handle
recordhandle    record
boolean         waitforlock
boolean         forupdate
throws standardexception
// resolve - did i do the right thing with the "forupdate" variable.
// for now just lock the row in shared mode.
object qualifier   forupdate ? getupdatelocktype     getreadlocktype
return
lf lockobject
t getcompatibilityspace    t  record  qualifier
waitforlock ?
c_lockfactory timed_wait   c_lockfactory no_wait
/**
* obtain lock on record being read while holding a latch.
* <p>
* assumes that a table level is has been acquired.  will acquire a shared
* or update lock on the row, depending on the "forupdate" parameter.
* <p>
*
* @param latch         the latch being held.
* @param record        the record to be locked.
* @param forupdate     whether to open for read or write access.
*
* @exception  standardexception  standard exception policy.
**/
public void lockrecordforread
latch			latch
recordhandle    record
boolean         forupdate
throws standardexception
// resolve - did i do the right thing with the "forupdate" variable.
// for now just lock the row in shared mode.
object qualifier   forupdate ? getupdatelocktype     getreadlocktype
lf lockobject
latch getcompatabilityspace    record  qualifier
c_lockfactory timed_wait  latch
/**
* obtain lock on record being written.
* <p>
* assumes that a table level ix has been acquired.  will acquire an
* exclusive (x) lock on the row.
* <p>
*
* @param t                        transaction to associate the lock with.
* @param record                   the record to be locked.
* @param lockforinsertpreviouskey lock is for a previous key of a insert.
* @param waitforlock              should lock request wait until granted?
*
* @return true if the lock was granted, false if waitforlock was false
*              and the lock could not be granted.
*
* @exception  standardexception  standard exception policy.
**/
public boolean zerodurationlockrecordforwrite
transaction     t
recordhandle    record
boolean         lockforinsertpreviouskey
boolean         waitforlock
throws standardexception
return lf zerodurationlockobject
t getcompatibilityspace    record
lockforinsertpreviouskey ? rowlock rip   getwritelocktype
waitforlock ? c_lockfactory timed_wait   c_lockfactory no_wait
/**
* obtain lock on record being written.
* <p>
* assumes that a table level ix has been acquired.  will acquire an
* exclusive (x) lock on the row.
* <p>
*
* @param t             the transaction to associate the lock with.
* @param record        the record to be locked.
* @param lockforinsert lock is for an insert.
* @param waitforlock   should lock request wait until granted?
*
* @return true if the lock was granted, false if waitforlock was false
*              and the lock could not be granted.
*
* @exception  standardexception  standard exception policy.
**/
public boolean lockrecordforwrite
transaction     t
recordhandle    record
boolean         lockforinsert
boolean         waitforlock
throws standardexception
return lf lockobject
t getcompatibilityspace    t  record
lockforinsert ? rowlock ri   getwritelocktype
waitforlock   ? c_lockfactory timed_wait   c_lockfactory no_wait
/**
* obtain lock on record being written while holding a latch.
* <p>
* assumes that a table level ix has been acquired.  will acquire an
* exclusive (x) lock on the row.
* <p>
*
* @param latch         the latch being held
* @param record        the record to be locked.
*
* @exception  standardexception  standard exception policy.
**/
public void lockrecordforwrite
latch		    latch
recordhandle    record
throws standardexception
lf lockobject
latch getcompatabilityspace
record
getwritelocktype
c_lockfactory timed_wait
latch
public int getmode
return mode_record
/*
** we can inherit all the others methods of nolocking since we hold the
** container lock and row locks until the end of transaction.
*/