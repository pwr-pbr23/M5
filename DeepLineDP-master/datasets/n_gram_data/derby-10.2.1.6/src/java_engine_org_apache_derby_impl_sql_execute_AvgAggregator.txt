/*
derby - class org.apache.derby.impl.sql.execute.avgaggregator
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl sql execute
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi types numberdatavalue
import org apache derby iapi error standardexception
import org apache derby iapi sql execute execaggregator
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi types typeid
import org apache derby iapi services io storedformatids
import org apache derby iapi reference sqlstate
import java io objectoutput
import java io objectinput
import java io ioexception
/**
aggregator for avg(). extends the sumaggregator and
implements a count. result is then sum()/count().
to handle overflow we catch the exception for
value out of range, then we swap the holder for
the current sum to one that can handle a larger
range. eventually a sum may end up in a sqldecimal
which can handle an infinite range. once this
type promotion has happened, it will not revert back
to the original type, even if the sum would fit in
a lesser type.
*/
public final class avgaggregator extends sumaggregator
private long count
private int scale
protected void accumulate datavaluedescriptor addend
throws standardexception
if  count    0
string typename   addend gettypename
if     typename equals typeid tinyint_name
typename equals typeid smallint_name
typename equals typeid integer_name
typename equals typeid longint_name
scale   0
else if     typename equals typeid real_name
typename equals typeid double_name
scale   typeid decimal_scale
else
// decimal
scale     numberdatavalue  addend  getdecimalvaluescale
if  scale < numberdatavalue min_decimal_divide_scale
scale   numberdatavalue min_decimal_divide_scale
try
super accumulate addend
count
return
catch  standardexception se
if   se getmessageid   equals sqlstate lang_outside_range_for_datatype
throw se
/*
sum is out of range so promote
tinyint,smallint -->> integer
integer -->> bigint
real -->> double precision
others -->> decimal
*/
// this code creates data type objects directly, it is anticipating
// the time they move into the defined api of the type system. (djd).
string typename   value gettypename
datavaluedescriptor newvalue
if  typename equals typeid integer_name
newvalue   new org apache derby iapi types sqllongint
else if  typename equals typeid tinyint_name
typename equals typeid smallint_name
newvalue   new org apache derby iapi types sqlinteger
else if  typename equals typeid real_name
newvalue   new org apache derby iapi types sqldouble
else
typeid decimaltypeid   typeid getbuiltintypeid java sql types decimal
newvalue   decimaltypeid getnull
newvalue setvalue value
value   newvalue
accumulate addend
public void merge execaggregator addend
throws standardexception
avgaggregator otheravg    avgaggregator  addend
// if i haven't been used take the other.
if  count    0
count   otheravg count
value   otheravg value
scale   otheravg scale
return
// don't bother merging if the other is a null value aggregate.
/* note:beetle:5346 fix change the sort to be high, that makes
* the neccessary for the null check because after the change
* addend could have a  null value even on distincts unlike when
* nulls were sort order  low, because by  sorting nulls low
* they  happens to be always first row which makes it as
* aggreagte result object instead of addends.
* query that will fail without the following check:
* select avg(a) , count(distinct a) from t1;
*/
if otheravg value    null
// subtract one here as the accumulate will add one back in
count     otheravg count   1
accumulate otheravg value
/**
* return the result of the aggregation.  if the count
* is zero, then we haven't averaged anything yet, so
* we return null.  otherwise, return the running
* average as a double.
*
* @return null or the average as double
*/
public datavaluedescriptor getresult   throws standardexception
if  count    0
return null
numberdatavalue sum    numberdatavalue  value
numberdatavalue avg    numberdatavalue  value getnewnull
if  count >  long  integer max_value
// tinyint, smallint, integer implement arithmetic using integers
// if the sum is still represented as a tinyint, smallint or integer
// we cannot let their int based arithmetic handle it, since they
// will perform a getint() on the long value which will truncate the long value.
// one solution would be to promote the sum to a sqllongint, but its value
// will be less than or equal to integer.max_value, so the average will be 0.
string typename   sum gettypename
if  typename equals typeid integer_name
typename equals typeid tinyint_name
typename equals typeid smallint_name
avg setvalue 0
return avg
numberdatavalue countv   new org apache derby iapi types sqllongint count
sum divide sum  countv  avg  scale
return avg
/**
*/
public execaggregator newaggregator
return new avgaggregator
/////////////////////////////////////////////////////////////
//
// externalizable interface
//
/////////////////////////////////////////////////////////////
/**
*
* @exception ioexception on error
*/
public void writeexternal objectoutput out  throws ioexception
super writeexternal out
out writelong count
out writeint scale
/**
* @see java.io.externalizable#readexternal
*
* @exception ioexception on error
*/
public void readexternal objectinput in
throws ioexception  classnotfoundexception
super readexternal in
count   in readlong
scale   in readint
/////////////////////////////////////////////////////////////
//
// formatable interface
//
/////////////////////////////////////////////////////////////
/**
* get the formatid which corresponds to this class.
*
*	@return	the formatid of this class
*/
public	int	gettypeformatid  	  return storedformatids agg_avg_v01_id