/*
derby - class org.apache.derby.impl.store.raw.data.recordid
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl store raw data
import org apache derby iapi store raw containerkey
import org apache derby iapi store raw pagekey
import org apache derby iapi services locks latch
import org apache derby iapi store raw rowlock
import org apache derby iapi store raw recordhandle
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi services locks virtuallocktable
import org apache derby catalog uuid
import java util hashtable
/**
implementation of recordhandle.
<br>
mt - mutable - immutable identity : thread aware -
<br>the methods of recordhandle only access the identity
of the object and so the object appears immutable to them, as required.
<br>the methods of lockable  are single thread required.
*/
public final class recordid implements recordhandle
/**
page the record lives in.
mt - immutable
*/
private final pagekey pageid
/**
the actual record id.
mt - immutable
*/
private final int recordid
/**
last slot number this record id was at.
*/
transient private int slotnumberhint
public recordid containerkey container  long pagenumber  int recordid
this pageid   new pagekey container  pagenumber
this recordid   recordid
// first_slot_number guaranteed to be zero
// this.slotnumberhint = page.first_slot_number;
public recordid pagekey pageid  int recordid
this pageid   pageid
this recordid   recordid
// first_slot_number guaranteed to be zero
// this.slotnumberhint = page.first_slot_number;
public recordid pagekey pageid  int recordid  int current_slot
this pageid   pageid
this recordid   recordid
this slotnumberhint   current_slot
/*
**	methods of recordhandle
*/
/**
get my record id.
<br>
mt - thread safe
@see recordhandle#getid
*/
public int	getid
return recordid
/**
get my page number.
<br>
mt - thread safe
@see recordhandle#getpagenumber
*/
public long getpagenumber
return pageid getpagenumber
public object getpageid
return pageid
public containerkey getcontainerid
return pageid getcontainerid
/**
* what slot number might the record be at?
* <p>
* the raw store guarantees that the record handle of a record will not
* change, but its slot number may.  when a recordid is constructed the
* caller could have provided a slot number, if so return that slot number
* hint here.  if a hint was not provided then the default
* page.first_slot_number will be returned.
*
* @return the slot number the record handle may be at.
**/
public int getslotnumberhint
return slotnumberhint
/*
** methods of lockable (from recordhandle)
*/
/**
lock me.
<br>
mt - single thread required (methods of lockable)
@see org.apache.derby.iapi.services.locks.lockable#lockevent
*/
public void lockevent latch lockinfo
/**
determine if this request can be granted.
<p)
implements the grant/wait lock logic for row locks.  see the
table in rowlock for more information.
<br>
mt - single thread required (methods of lockable)
@see org.apache.derby.iapi.services.locks.lockable#requestcompatible
*/
public boolean requestcompatible
object requestedqualifier
object grantedqualifier
if  sanitymanager debug
sanitymanager assert  requestedqualifier    rowlock rs2
requestedqualifier    rowlock rs3
requestedqualifier    rowlock ru2
requestedqualifier    rowlock ru3
requestedqualifier    rowlock rip
requestedqualifier    rowlock ri
requestedqualifier    rowlock rx2
requestedqualifier    rowlock rx3
sanitymanager assert  grantedqualifier    rowlock rs2
grantedqualifier    rowlock rs3
grantedqualifier    rowlock ru2
grantedqualifier    rowlock ru3
grantedqualifier    rowlock rip
grantedqualifier    rowlock ri
grantedqualifier    rowlock rx2
grantedqualifier    rowlock rx3
rowlock rlrequested    rowlock  requestedqualifier
rowlock rlgranted     rowlock  grantedqualifier
return rlrequested iscompatible rlgranted
/**
is a caller that holds a lock compatible with themselves?
<p>
row locks held in the same transaction are always compatible with
themselves.
<br>
mt - single thread required (methods of lockable)
@see org.apache.derby.iapi.services.locks.lockable#lockeralwayscompatible
*/
public boolean lockeralwayscompatible
return true
/**
unlock me.
<br>
mt - single thread required (methods of lockable)
@see org.apache.derby.iapi.services.locks.lockable#unlockevent
*/
public void unlockevent latch lockinfo
/*
**		methods of object
*/
/**
implement value equality.
<br>
mt - thread safe
*/
public boolean equals object ref
if    ref instanceof recordid
return false
recordid other    recordid  ref
return   recordid    other recordid
pageid equals other pageid
/**
return a hashcode based on value.
<br>
mt - thread safe
*/
public int hashcode
return  int  recordid ^ pageid hashcode
public string tostring
if  sanitymanager debug
return     recordid       pageid tostring
else
return null
/**
this lockable wants to participate in the virtual lock table.
*/
public boolean lockattributes int flag  hashtable attributes
if  sanitymanager debug
sanitymanager assert attributes    null
sanitymanager assert pageid    null
if   flag   virtuallocktable table_and_rowlock     0
return false
attributes put virtuallocktable containerid
new long pageid getcontainerid   getcontainerid
attributes put virtuallocktable lockname
pageid getpagenumber         recordid
attributes put virtuallocktable locktype
// don't new unnecessary things for now
// attributes.put(virtuallocktable.segmentid, new long(pageid.getcontainerid().getsegmentid()));
// attributes.put(virtuallocktable.pagenum, new long(pageid.getpagenumber()));
// attributes.put(virtuallocktable.pagenum, new long(pageid.getpagenumber()));
// attributes.put(virtuallocktable.recid, new integer(getid()));
return true