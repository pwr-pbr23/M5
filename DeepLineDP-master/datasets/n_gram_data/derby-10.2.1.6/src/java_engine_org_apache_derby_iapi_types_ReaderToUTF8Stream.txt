/*
derby - class org.apache.derby.iapi.types.readertoutf8stream
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby iapi types
import java io inputstream
import java io ioexception
import java io eofexception
import java io reader
import java io utfdataformatexception
import org apache derby iapi reference sqlstate
import org apache derby iapi services i18n messageservice
import org apache derby iapi services io derbyioexception
import org apache derby iapi services io limitreader
import org apache derby iapi types typeid
/**
converts a java.io.reader to the on-disk utf8 format used by derby
for character types.
*/
public final class readertoutf8stream
extends inputstream
/**
* application's reader wrapped in a limitreader.
*/
private limitreader reader
private byte buffer
private int boff
private int blen
private boolean eof
private boolean multiplebuffer
// buffer to hold the data read from stream
// and converted to utf8 format
private final static int bufsize   32768
/** number of characters to truncate from this stream
the sql standard allows for truncation of trailing spaces
for clobs,varchar,char.
if zero, no characters are truncated.
*/
private final int charstotruncate
private static final char space
/**
* length of the final value, after truncation if any,
* in characters.
this stream needs to fit into a column of colwidth
if truncation error happens ,then the error message includes
information about the column width.
*/
private final int valuelength
/** the maximum allowed length of the stream. */
private final int maximumlength
/** the type name for the column data is inserted into. */
private final string typename
/**
* create a stream that will truncate trailing blanks if required/allowed.
*
* if the stream must be truncated, the number of blanks to truncate
* is specified to allow the stream to be checked for exact length, as
* required by jdbc 3.0. if the stream is shorter or longer than specified,
* an exception is thrown during read.
*
* @param appreader application reader
* @param valuelength the length of the reader in characters
* @param numcharstotruncate the number of trailing blanks to truncate
* @param typename type name of the column data is inserted into
*/
public readertoutf8stream reader appreader
int valuelength
int numcharstotruncate
string typename
this reader   new limitreader appreader
reader setlimit valuelength
buffer   new byte
blen    1
this charstotruncate   numcharstotruncate
this valuelength   valuelength
this maximumlength    1
this typename   typename
/**
* create a utf-8 stream for a length less application reader.
*
* a limit is placed on the length of the reader. if the reader exceeds
* the maximum length, truncation of trailing blanks is attempted. if
* truncation fails, an exception is thrown.
*
* @param appreader application reader
* @param maximumlength maximum allowed length in number of characters for
*      the reader
* @param typename type name of the column data is inserted into
* @throws illegalargumentexception if maximum length is negative, or type
*      name is <code>null<code>
*/
public readertoutf8stream reader appreader
int maximumlength
string typename
if  maximumlength < 0
throw new illegalargumentexception
maximumlength
if  typename    null
throw new illegalargumentexception
this reader   new limitreader appreader
reader setlimit maximumlength
buffer   new byte
blen    1
this maximumlength   maximumlength
this typename   typename
this charstotruncate    1
this valuelength    1
/**
* read from stream; characters converted to utf-8 derby specific encoding.
* if stream has been read, and eof reached, in that case any subsequent
* read will throw an eofexception
* @see java.io.inputstream#read()
*/
public int read   throws ioexception
// when stream has been read and eof reached, stream is closed
// and buffer is set to null ( see close() method)
// since stream cannot be re-used, check if stream is closed and
// if so throw an eofexception
if   buffer    null
throw new eofexception messageservice gettextmessage sqlstate stream_eof
// first read
if  blen < 0
fillbuffer 2
while  boff    blen
// reached end of buffer, read more?
if  eof
// we have reached the end of this stream
// cleanup here and return -1 indicating
// eof of stream
close
return  1
fillbuffer 0
return buffer   0xff
public int read byte b  int off  int len  throws ioexception
// when stream has been read and eof reached, stream is closed
// and buffer is set to null ( see close() method)
// since stream cannot be re-used, check if stream is closed and
// if so throw an eofexception
if   buffer    null
throw new eofexception messageservice gettextmessage
sqlstate stream_eof
// first read
if  blen < 0
fillbuffer 2
int readcount   0
while  len > 0
int copybytes   blen   boff
// buffer empty?
if  copybytes    0
if  eof
if  readcount > 0
return readcount
else
// we have reached the eof, so close the stream
close
return  1
fillbuffer 0
continue
if  len < copybytes
copybytes   len
system arraycopy buffer  boff  b  off  copybytes
boff    copybytes
len    copybytes
readcount    copybytes
off    copybytes
return readcount
private void fillbuffer int startingoffset  throws ioexception
int off   boff   startingoffset
if  off    0
multiplebuffer   true
// 6! need to leave room for a three byte utf8 encoding
// and 3 bytes for our special end of file marker.
for    off <  buffer length   6
int c   reader read
if  c < 0
eof   true
break
if   c >  0x0001      c <  0x007f
buffer    byte  c
else if  c > 0x07ff
buffer    byte   0xe0     c >> 12    0x0f
buffer    byte   0x80     c >>  6    0x3f
buffer    byte   0x80     c >>  0    0x3f
else
buffer    byte   0xc0     c >>  6    0x1f
buffer    byte   0x80     c >>  0    0x3f
blen   off
boff   0
if  eof
checksufficientdata
/**
* validate the length of the stream, take corrective action if allowed.
*
* jdbc 3.0 (from tutorial book) requires that an input stream has the
* correct number of bytes in the stream.
* if the stream is too long, trailing blank truncation is attempted if
* allowed. if truncation fails, or is disallowed, an exception is thrown.
*
* @throws ioexception if an errors occurs in the application stream
* @throws derbyioexception if derby finds a problem with the stream;
*      stream is too long and cannot be truncated, or the stream length
*      does not match the specified length
*/
private void checksufficientdata   throws ioexception
// now that we finished reading from the stream; the amount
// of data that we can insert,start check for trailing spaces
if  charstotruncate > 0
reader setlimit charstotruncate
truncate
// a length less stream that is capped, will return 0 even if there
// are more bytes in the application stream.
int remainingbytes   reader clearlimit
if  remainingbytes > 0    valuelength > 0
// if we had a specified length, throw exception.
throw new derbyioexception
messageservice gettextmessage
sqlstate set_stream_inexact_length_data
sqlstate set_stream_inexact_length_data
// if we had a limit try reading one more character.
// jdbc 3.0 states the stream must have the correct number of
// characters in it.
if  remainingbytes    0    reader read   >  0
if  valuelength >  1
throw new derbyioexception
messageservice gettextmessage
sqlstate set_stream_inexact_length_data
sqlstate set_stream_inexact_length_data
else
// stream was capped (length less) and too long.
// try to truncate if allowed, or else throw exception.
if  cantruncate
truncate
else
throw new derbyioexception
messageservice gettextmessage
sqlstate lang_string_truncation
sqlstate lang_string_truncation
// can put the correct length into the stream.
if   multiplebuffer
int utflen   blen   2
buffer    byte    utflen >>> 8    0xff
buffer    byte    utflen >>> 0    0xff
else
buffer    byte  0xe0
buffer    byte  0x00
buffer    byte  0x00
/**
* determine if trailing blank truncation is allowed.
*/
private boolean cantruncate
// only a few types can be truncated, default is to not allow.
if  typename equals typeid clob_name
return true
else if  typename equals typeid varchar_name
return true
return false
/**
* attempt to truncate the stream by removing trailing blanks.
*/
private void truncate
throws ioexception
int c   0
for
c   reader read
if  c < 0
break
else if  c    space
throw new derbyioexception
messageservice gettextmessage
sqlstate lang_string_truncation
typename
string valueof valuelength
sqlstate lang_string_truncation
/**
* return resources
*/
public void close   throws ioexception
// since stream has been read and eof reached, return buffer back to
// the vm.
// instead of using another variable to indicate stream is closed
// a check on (buffer==null) is used instead.
buffer   null
/**
* return an optimized version of bytes available to read from
* the stream
* note, it is not exactly per java.io.inputstream#available()
*/
public final int available
int remainingbytes   reader getlimit
// this object buffers bufsize bytes that can be read
// and when that is finished it reads the next available bytes
// from the reader object
// reader.getlimit() returns the remaining bytes available
// on this stream
return  bufsize > remainingbytes ? remainingbytes   bufsize