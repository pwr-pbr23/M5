/*
derby - class org.apache.derby.iapi.sql.dictionary.statementcolumnpermission
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby iapi sql dictionary
import org apache derby iapi error standardexception
import org apache derby catalog uuid
import org apache derby iapi sql conn authorizer
import org apache derby iapi reference sqlstate
import org apache derby iapi services io formatablebitset
import org apache derby iapi sql conn languageconnectioncontext
/**
* this class describes a column permission used (required) by a statement.
*/
public class statementcolumnpermission extends statementtablepermission
private formatablebitset columns
/**
* constructor for statementcolumnpermission. creates an instance of column permission requested
* for the given access.
*
* @param tableuuid	uuid of the table
* @param privtype	access privilege requested
* @param columns	list of columns
*
*/
public statementcolumnpermission uuid tableuuid  int privtype  formatablebitset columns
super  tableuuid  privtype
this columns   columns
/**
* return list of columns that need access
*
* @return	formatablebitset of columns
*/
public formatablebitset getcolumns
return columns
/**
* method to check if another instance of column access descriptor matches this.
* used to ensure only one access descriptor for a table/columns of given privilege is created.
*
* @param obj	another instance of statementpermission
*
* @return	true if match
*/
public boolean equals  object obj
if  obj instanceof statementcolumnpermission
statementcolumnpermission other    statementcolumnpermission  obj
if    columns equals  other columns
return false
return super equals  obj
return false
/**
* @see statementpermission#check
*/
public void check  languageconnectioncontext lcc
string authorizationid
boolean forgrant
throws standardexception
datadictionary dd   lcc getdatadictionary
if  haspermissionontable dd  authorizationid  forgrant
return
formatablebitset permittedcolumns   null
if    forgrant
permittedcolumns   addpermittedcolumns  dd
false    non grantable permissions
authorizer public_authorization_id
permittedcolumns
permittedcolumns   addpermittedcolumns  dd
false    non grantable permissions
authorizationid
permittedcolumns
permittedcolumns   addpermittedcolumns  dd
true    grantable permissions
authorizer public_authorization_id
permittedcolumns
permittedcolumns   addpermittedcolumns  dd
true    grantable permissions
authorizationid
permittedcolumns
for  int i   columns anysetbit    i >  0  i   columns anysetbit  i
if  permittedcolumns    null    permittedcolumns get i
continue
// no permission on this column.
tabledescriptor td   gettabledescriptor  dd
columndescriptor cd   td getcolumndescriptor  i   1
if  cd    null
throw standardexception newexception  sqlstate auth_internal_bad_uuid
throw standardexception newexception  forgrant ? sqlstate auth_no_column_permission_for_grant
sqlstate auth_no_column_permission
authorizationid
getprivname
cd getcolumnname
td getschemaname
td getname
end of check
/**
* add one user's set of permitted columns to a list of permitted columns.
*/
private formatablebitset addpermittedcolumns  datadictionary dd
boolean forgrant
string authorizationid
formatablebitset permittedcolumns
throws standardexception
if  permittedcolumns    null    permittedcolumns getnumbitsset      permittedcolumns size
return permittedcolumns
colpermsdescriptor perms   dd getcolumnpermissions  tableuuid  privtype  false  authorizationid
if  perms    null
if  permittedcolumns    null
return perms getcolumns
permittedcolumns or  perms getcolumns
return permittedcolumns
end of addpermittedcolumns
/**
* @see statementpermission#getpermissiondescriptor
*/
public permissionsdescriptor getpermissiondescriptor string authid  datadictionary dd
throws standardexception
//if table permission found for authorizationid, then simply return that
if  oneauthhaspermissionontable  dd  authid  false
return dd gettablepermissions tableuuid  authid
//if table permission found for public, then simply return that
if  oneauthhaspermissionontable  dd  authorizer public_authorization_id  false
return dd gettablepermissions tableuuid  authorizer public_authorization_id
//if table level permission not found, then we have to find permissions
//at column level. look for column level permission for the passed
//authorizer. if found any of the required column level permissions,
//return the permission descriptor for it.
colpermsdescriptor colspermsdesc   dd getcolumnpermissions tableuuid  privtype  false  authid
if  colspermsdesc    null
if  colspermsdesc getcolumns      null
formatablebitset permittedcolumns   colspermsdesc getcolumns
for  int i   columns anysetbit    i >  0  i   columns anysetbit  i
if permittedcolumns get i
return colspermsdesc
return null
/**
* this method gets called in execution phase after it is established that
* all the required privileges exist for the given sql. this method gets
* called by create view/trigger/constraint to record their dependency on
* various privileges.
* special code is required to track column level privileges.
* it is possible that some column level privileges are available to the
* passed authorizer id but the rest required column level privileges
* are available at public level. in this method, we check if all the
* required column level privileges are found for the passed authorizer.
* if yes, then simply return null, indicating that no dependency is
* required at public level, because all the required privileges were found
* at the user level. but if some column level privileges are not
* available at user level, then they have to exist at the public
* level when this method gets called.
*/
public permissionsdescriptor getpubliclevelcolpermsdescriptor string authid  datadictionary dd
throws standardexception
colpermsdescriptor colspermsdesc   dd getcolumnpermissions tableuuid  privtype  false  authid
formatablebitset permittedcolumns   colspermsdesc getcolumns
boolean allcolumnscoveredbyuserlevelprivilege   true
for  int i   columns anysetbit    i >  0    allcolumnscoveredbyuserlevelprivilege  i   columns anysetbit  i
if permittedcolumns get i
continue
else
allcolumnscoveredbyuserlevelprivilege   false
if  allcolumnscoveredbyuserlevelprivilege
return null
else
return  dd getcolumnpermissions tableuuid  privtype  false  authorizer public_authorization_id