/*
derby - class org.apache.derby.iapi.sql.conn.languageconnectioncontext
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby iapi sql conn
import org apache derby iapi services context context
import org apache derby iapi services context contextmanager
import org apache derby iapi db database
import org apache derby iapi error standardexception
import org apache derby iapi sql compile compilercontext
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi sql dictionary tabledescriptor
import org apache derby iapi sql dictionary schemadescriptor
import org apache derby iapi sql compile optimizerfactory
import org apache derby iapi types datavaluefactory
import org apache derby iapi sql depend provider
import org apache derby iapi sql execute constantaction
import org apache derby iapi sql execute cursoractivation
import org apache derby iapi sql execute execpreparedstatement
import org apache derby iapi sql execute executioncontext
import org apache derby iapi sql execute executionstmtvalidator
import org apache derby iapi sql activation
import org apache derby iapi sql languagefactory
import org apache derby iapi sql preparedstatement
import org apache derby iapi sql resultset
import org apache derby iapi sql parametervalueset
import org apache derby iapi store access transactioncontroller
import org apache derby iapi store access accessfactory
import org apache derby iapi db triggerexecutioncontext
import org apache derby iapi services i18n localefinder
import org apache derby iapi sql execute runtimestatistics
import org apache derby catalog uuid
import java util locale
import java util hashtable
import java util vector
/**
* languageconnectioncontext keeps the result sets,
* and activations in use by the current connection.
* <p>
* more stable items, like other factories, are accessible through
* the languageconnectionfactory or the languagefactory.
*
* @see languageconnectionfactory
* @see org.apache.derby.iapi.sql.languagefactory
*/
public interface languageconnectioncontext extends context
/**
* this is the id we expect these contexts
* to be stored into a context manager under.
*/
public static final string context_id   org apache derby iapi reference contextid lang_connection
public	static	final	int	outermost_statement   1
// constants describing how this connection handles schemas
public static final int sql92_schemas   0
public static final int user_name_schema   1     user names are schema names
public static final int no_schemas   2     schemas not implemented
/* string for logstatementtext output */
public static final string xidstr
public static final string lccstr
public static final string dbnamestr
public static final string drdastr
// lock management
public	static	final	int	single_transaction_lock   1
public	static	final	int	multi_transaction_lock   2
// controls casing of non-delimited identifiers. ansi casing forces all
// non-delimited identifiers to be lower case.
public	static	final	int	unknown_casing    1
public	static	final	int	ansi_casing   0
public	static	final	int	anti_ansi_casing   1
/**
* initialize. for use after pushing the contexts that initialization needs.
*
* @param sqlconnection	whether or not this is called from a sql connection.
*
* @exception standardexception thrown if something goes wrong
*/
void initialize boolean sqlconnection  throws standardexception
/**
* get value of logstatementtext.
* (whether or not to write info on currently
* executing statement to error log.)
*
* @return value of logstatementtext
*/
public boolean getlogstatementtext
/**
* set value of logstatementtext
* (whether or not to write info on currently
* executing statement to error log.)
*
* @param logstatementtext	whether or not logstatementtext property is set.
*/
public void setlogstatementtext boolean logstatementtext
/**
* get value of logqueryplan.
* (whether or not to write query plan info on currently
* executing statement to error log.)
*
* @return value of logqueryplan
*/
public boolean getlogqueryplan
/**
* get the lock escalation threshold to use with this connection.
*/
int getlockescalationthreshold
/**
* add the activation to those known about by this connection.
*
*/
void addactivation activation a
throws standardexception
/**
* make a note that some activations are marked unused
*/
void notifyunusedactivation
/**
* remove the activation from those known about by this connection.
*
* @exception standardexception thrown if something goes wrong
*/
void removeactivation activation a
throws standardexception
/**
* return the number of activation known for this connection.
*
*/
int getactivationcount
/**
* see if a given cursor is available for use.  this is used
* to locate the cursor during its execution.
*
* @return the activation for the given cursor, null if none exists.
*/
cursoractivation lookupcursoractivation string cursorname
/**
* return the last activation added
* this is used to find the drop activation in dropviewcascade
* so we can add warning messages to the activation
*
*/
public activation getlastactivation
/**
get a connection unique system generated name for a cursor.
*/
public string getuniquecursorname
/**
get a connection unique system generated name for an unnamed savepoint.
*/
public string getuniquesavepointname
/**
get a connection unique system generated id for an unnamed savepoint.
*/
public int getuniquesavepointid
/**
* check if there are any global temporary tables declared for this connection.
* @return true if there are declared temp tables for this connectoin else false
*
*/
public boolean checkifanydeclaredglobaltemptablesforthisconnection
/**
* mark the passed temporary table as modified in the current unit of work. that information will be used at rollback time
* the compile phase will generate code to call this method if the dml is on a temporary table
*
* @param tablename mark the passed temporary table name as modified
*/
public void marktemptableasmodifiedinunitofwork string tablename
/**
* add the declared global temporary table to the list of temporary tables known by this connection.
* @param td corresponding to the temporary table
*
*/
public void adddeclaredglobaltemptable tabledescriptor td  throws standardexception
/**
* drop (mark the declared global temporary table for dropping) from the list of temporary tables known by this connection.
* @param tablename look for this table name in the saved list and drop it if found
* @return true if dropped the temporary table. false if no such temporary table exists.
*
* @see org.apache.derby.impl.sql.conn.temptableinfo
*/
public boolean dropdeclaredglobaltemptable string tablename
/**
* get table descriptor for the declared global temporary table from the list of temporary
* tables known by this connection.
* @param tablename get table descriptor for the passed table name
* @return tabledescriptor if found the temporary table. else return null
*
*/
public tabledescriptor gettabledescriptorfordeclaredglobaltemptable string tablename
/**
reset the connection before it is returned (indirectly) by
a pooledconnection object. see embeddedconnection.
*/
public void resetfrompool
throws standardexception
/**
do a commit, as internally needed by cloudscape.  e.g.
a commit for sync, or a commit for autocommit.  skips
checks that a user isn't doing something bad like issuing
a commit in a nested xact.
@param	commitstore	true if we should commit the store transaction
@exception standardexception thrown if something goes wrong
*/
void internalcommit  boolean commitstore
throws standardexception
/**
similar to internalcommit() but has logic for an unsynchronized commit
@param	commitflag	the flags to pass to commitnosync in the store's
transactioncontroller
@exception standardexception	thrown if something goes wrong
*/
void internalcommitnosync int commitflag  throws standardexception
/**
do a commit, as issued directly by a user (e.g. via connection.commit()
or the jsql 'commit' statement.
@exception standardexception thrown if something goes wrong
*/
void usercommit   throws standardexception
/**
commit a distrubuted transaction.
@param onephase if true, allow it to commit without first going thru a
prepared state.
@exception standardexception	thrown if something goes wrong
*/
void xacommit boolean onephase  throws standardexception
/**
do a rollback, as internally needed by cloudscape.  e.g.
a rollback for sync, or a rollback for an internal error.  skips
checks that a user isn't doing something bad like issuing
a rollback in a nested xact.
@exception standardexception thrown if something goes wrong
*/
void internalrollback   throws standardexception
/**
do a rollback, as issued directly by a user (e.g. via connection.rollback()
or the jsql 'rollback' statement.
@exception standardexception thrown if something goes wrong
*/
void userrollback   throws standardexception
/**
* let the context deal with a rollback to savepoint
*
* @param	savepointname	name of the savepoint that needs to be rolled back
* @param	refreshstyle	boolean indicating whether or not the controller should close
* open conglomerates and scans. also used to determine if language should close
* open activations.
* @param	kindofsavepoint	 a null value means it is an internal savepoint (ie not a user defined savepoint)
* non null value means it is a user defined savepoint which can be a sql savepoint or a jdbc savepoint
*   a string value for kindofsavepoint would mean it is sql savepoint
*   a jdbc savepoint object value for kindofsavepoint would mean it is jdbc savepoint
*
* @exception standardexception thrown if something goes wrong
*/
void internalrollbacktosavepoint
string savepointname  boolean refreshstyle  object kindofsavepoint   throws standardexception
/**
* let the context deal with a release of a savepoint
*
* @param	savepointname	name of the savepoint that needs to be released
* @param	kindofsavepoint	 a null value means it is an internal savepoint (ie not a user defined savepoint)
* non null value means it is a user defined savepoint which can be a sql savepoint or a jdbc savepoint
*   a string value for kindofsavepoint would mean it is sql savepoint
*   a jdbc savepoint object value for kindofsavepoint would mean it is jdbc savepoint
*
* @exception standardexception thrown if something goes wrong
*/
void releasesavepoint   string savepointname  object kindofsavepoint   throws standardexception
/**
roll back a distrubuted transaction.
@exception standardexception	thrown if something goes wrong
*/
void xarollback   throws standardexception
/**
sets a savepoint. causes the store to set a savepoint.
@param	savepointname	name of savepoint
@param	kindofsavepoint	 a null value means it is an internal savepoint (ie not a user defined savepoint)
non null value means it is a user defined savepoint which can be a sql savepoint or a jdbc savepoint
a string value for kindofsavepoint would mean it is sql savepoint
a jdbc savepoint object value for kindofsavepoint would mean it is jdbc savepoint
@exception standardexception thrown if something goes wrong
*/
void	languagesetsavepoint  string savepointname  object kindofsavepoint    throws standardexception
/**
returns true if any transaction is blocked (even if not by this one)
*/
boolean anyoneblocked
/**
sets the transaction controller to use with this language connection
context.
@param	tran	the transaction to use with this language connection context
*/
void settransaction  transactioncontroller tran
/**
* begin a nested transaction.
*
* @param readonly the nested transaction would be read only if param value true
*
* @exception standardexception on error.
* @see transactioncontroller#startnestedusertransaction
*/
void beginnestedtransaction boolean readonly  throws standardexception
/**
* commit a nested transaction.
* we do not provide a abortnestedtransaction.
* if a nested xaction is aborted, then this results in the parent xaction
* also being aborted. this is not what we need for releasing
* compile time locks or autoincrement-- hence we do not provide
* abortnestedtransaction.
*
* @exception standardexception thrown on erro
*
* @see transactioncontroller#startnestedusertransaction
*/
void commitnestedtransaction   throws standardexception
/**
get the transaction controller to use with this language connection
context at compile time.
*/
transactioncontroller gettransactioncompile
/**
get the transaction controller to use with this language connection
context during execute time.
*/
transactioncontroller gettransactionexecute
/**
* get the system schema name.
*
* @return a string containing the system schema name.
*/
public string getsystemschemaname   throws standardexception
/**
* get the sysibm schema name.
*
* @return a string containing the sysibm schema name.
*/
public string getsysibmschemaname   throws standardexception
/**
* get the syscs_diag schema name.
*
* @return a string containing the sysibm schema name.
*/
public string getsystemdiagschemaname   throws standardexception
/**
* get the syscs_util schema name.
*
* @return a string containing the sysibm schema name.
*/
public string getsystemutilschemaname   throws standardexception
/**
get the data dictionary
@return the data dictionary
*/
public datadictionary getdatadictionary
/**
get the data value factory to use with this language connection
context.
*/
datavaluefactory getdatavaluefactory
/**
get the language factory to use with this language connection
context.
*/
languagefactory getlanguagefactory
/**
* get the optimizer factory to use with this language connection context.
*/
optimizerfactory getoptimizerfactory
/**
get the language connection factory to use with this language connection
context.
*/
languageconnectionfactory getlanguageconnectionfactory
/**
*	get the authorization id
*
* @return string	the authorization id
*/
public string getauthorizationid
/**
* get the declared global temporary tables schema name.
*
* @return a string containing the declared global temporary tables schema name.
*/
public string getdeclaredglobaltemporarytablesschemaname   throws standardexception
/**
*	get the current default schema
*
* @return schemadescriptor	the current schema
*/
public schemadescriptor getdefaultschema
/**
*	set the current default schema
*
* @param sd the new default schema
*
* @exception standardexception thrown on failure
*/
public void setdefaultschema schemadescriptor sd
throws standardexception
/**
*	get the current schema name
*
* @return schemadescriptor	the current schema
*/
public string getcurrentschemaname
/**
* get the identity column value most recently generated.
*
* @return the generated identity column value
*/
public long getidentityvalue
/**
* set the field of most recently generated identity column value.
*
* @param val the generated identity column value
*/
public void setidentityvalue long val
/**
* verify that there are no activations with open result sets
* on the specified prepared statement.
*
* @param pstmt		the prepared statement
* @param provider	the object precipitating a possible invalidation
* @param action	the action causing the possible invalidation
*
* @return nothing.
*
* @exception standardexception thrown on failure
*/
boolean verifynoopenresultsets preparedstatement pstmt  provider provider
int action
throws standardexception
/**
* verify that there are no activations with open held result sets.
*
* @return boolean  found no open resultsets.
*
* @exception standardexception thrown on failure
*/
public boolean verifyallheldresultsetsareclosed
throws standardexception
/**
* push a compilercontext on the context stack with
* the current default schema as the default schema
* which we compile against.
*
* @return the compiler context
*
* @exception standardexception thrown on failure
*/
public	compilercontext pushcompilercontext
/**
* push a compilercontext on the context stack with
* the passed in default schema as the default schema
* we compile against.
*
* @param sd the default schema
*
* @return the compiler context
*
* @exception standardexception thrown on failure
*/
public	compilercontext pushcompilercontext schemadescriptor sd
/**
* pop a compilercontext off the context stack.
*
* @param compilercontext  the compiler context.
*
* @exception standardexception thrown on failure
*/
public void popcompilercontext compilercontext compilercontext
/**
* push a statementcontext on the context stack.
*
* @param isatomic whether a commit/rollback is permitted
*	from a nested connection under this statement
*
* @param stmttext the text of the statement.  needed for any language
* 	statement (currently, for any statement that can cause a trigger
* 	to fire).  please set this unless you are some funky jdbc setxxx
*	method or something.
*
* @param pvs parameter value set, if it has one
*
* @param rollbackparentcontext true if 1) the statement context is
* 	not a top-level context, and 2) in the event of a statement-level
*	exception, the parent context needs to be rolled back, too.
*
* @param timeoutmillis timeout value for this statement, in milliseconds.
*  zero means no timeout.
*
* @return statementcontext	the statement context.
*
*/
statementcontext pushstatementcontext boolean isatomic  boolean isforreadonly  string stmttext
parametervalueset pvs  boolean rollbackparentcontext  long timeoutmillis
/**
* pop a statementcontext of the context stack.
*
* @param statementcontext  the statement context.
* @param error				the error, if any  (only relevant for debug)
*/
public void popstatementcontext statementcontext statementcontext
throwable error
/**
* push a new execution statement validator.  an execution statement
* validator is an object that validates the current statement to
* ensure that it is permitted given the current execution context.
* an example of a validator a trigger executionstmtvalidator that
* doesn't allow ddl on the trigger target table.
* <p>
* multiple executionstmtvalidators may be active at any given time.
* this mirrors the way there can be multiple connection nestings
* at a single time.  the validation is performed by calling each
* validator's validatestatement() method.  this yields the union
* of all validations.
*
* @param validator the validator to add
*/
public void pushexecutionstmtvalidator executionstmtvalidator validator
/**
* remove the validator.  does an object identity (validator == validator)
* comparison.  asserts that the validator is found.
*
* @param validator the validator to remove
*
* @exception standardexception on error
*/
public void popexecutionstmtvalidator executionstmtvalidator validator
throws standardexception
/**
* validate a statement.  does so by stepping through all the validators
* and executing them.  if a validator throws and exception, then the
* checking is stopped and the exception is passed up.
*
* @param constantaction the constantaction that is about to be executed (and
*	should be validated
*
* @exception standardexception on validation failure
*/
public void validatestmtexecution constantaction constantaction
throws standardexception
/**
* push a new trigger execution context.
* <p>
* multiple triggerexecutioncontexts may be active at any given time.
*
* @param tec the trigger execution context
*
* @exception standardexception on trigger recursion error
*/
public void pushtriggerexecutioncontext triggerexecutioncontext tec
throws standardexception
/**
* remove the tec.  does an object identity (tec == tec)
* comparison.  asserts that the tec is found.
*
* @param tec the tec to remove
*
* @exception standardexception on error
*/
public void poptriggerexecutioncontext triggerexecutioncontext tec
throws standardexception
/**
* get the topmost tec.
*
* @return the tec
*/
public triggerexecutioncontext gettriggerexecutioncontext
/**
* set the trigger table descriptor.  used to compile
* statements that may special trigger pseudo tables.
*
* @param td the table that the trigger is
* defined upon
*
*/
public void pushtriggertable tabledescriptor td
/**
* remove the trigger table descriptor.
*
* @param td the table to remove from the stack.
*/
public void poptriggertable tabledescriptor td
/**
* get the topmost trigger table descriptor
*
* @return the table descriptor, or null if we
* aren't in the middle of compiling a create
* trigger.
*/
public tabledescriptor gettriggertable
/**
* increment the datadictionary bind count.  this is for keeping track
* of nested binding, which can happen if sql statements are bound from
* within static initializers.
*
* @return	the new bind count
*/
int incrementbindcount
/**
* decrement the datadictionary bind count.
*
* @return	the new bind count
*/
int decrementbindcount
/**
* get the datadictionary bind count.
*
* @return	the current bind count.
*/
int getbindcount
/**
* remember that the datadictionary is in write mode, so we can take
* it out of write mode at the end of the transaction.
*/
void setdatadictionarywritemode
/**
* return true if the data dictionary is in write mode (that is, this
* context was informed that is is in write mode by the method call
* setdatadictionarywritemode().
*/
boolean datadictionaryinwritemode
/**
* turn runtimestatistics  on or off.
*/
public void setruntimestatisticsmode boolean onoroff
/**
* get the runtimestatistics mode.
*/
public boolean getruntimestatisticsmode
/**
* turn statistics timing on or off.
*/
public void setstatisticstiming boolean onoroff
/**
* get the statistics timing mode.
*/
public boolean getstatisticstiming
/**
* set the runtimestatistics object.
*/
public void setruntimestatisticsobject runtimestatistics runtimestatisticsobject
/**
* get the runtimestatistics object.
*/
public runtimestatistics getruntimestatisticsobject
/**
*	reports how many statement levels deep we are.
*
*	@return	a statement level >= outermost_statement
*/
public	int		getstatementdepth
/**
returns the database of this connection.
*/
public database getdatabase
/**
* returns true if isolation level has been set using jdbc/sql.
*/
public boolean isisolationlevelsetusingsqlorjdbc
/**
* reset the isolation level flag used to keep correct isolation level
* state in brokeredconnection. this resetting will happen at the start
* and end of a global transaction, after the brokeredconection's
* isolation level state is brought upto date with the embedconnection's
* isolation state.
* the flag gets set to true when isolation level is set using jdbc/sql.
*/
public void resetisolationlevelflagusedforsqlandjdbc
/**
* set current isolation level.
*
* @param isolationlevel	the new isolationlevel.
*/
public void setisolationlevel int isolationlevel  throws standardexception
/**
* get the current isolation level.
*
* @return the current isolation level.
*/
public int getcurrentisolationlevel
/**
* get the current isolation level in db2 format.
*
* @return the current isolation level as a 2 character string.
*/
public string getcurrentisolationlevelstr
public void setprepareisolationlevel int isolationlevel
/**
* get the prepare isolation level.
* if the isolation level has been explicitly set with a sql statement or
* embedded call to settransactionisolation, this will return
* executioncontext.unspecified_isolation_level
* set isolation always takes priority.
*
*/
public int getprepareisolationlevel
/**
* set the readonly status for the current connection. this can
* only be called when the current transaction has not done
* any work.
*
* @param onoroff true sets the connection to be readonly and
*                false sets it to readwrite.
*
* @exception standardexception the call failed and the readonly
*                status has not changed.
*/
public void setreadonly boolean onoroff  throws standardexception
/**
* get the readonly status for the current connection.
*/
public boolean isreadonly
/**
* get an authorizer for this connection.
*/
public authorizer getauthorizer
/**
*	get the current executioncontext.
*/
executioncontext getexecutioncontext
/**
*	get the current statementcontext.
*/
statementcontext getstatementcontext
/** get the accessfactory cached in this languageconnectioncontext */
accessfactory getaccessfactory
/**
* return a preparedstatement object for the query.
* this method first tries to locate the preparedstatement object from a statement
* cache.  if the statement is not found in the cache, the query will be compiled and
* put into the cache.
* @param compilationschema schema
* @param sqltext sql query string
* @param isforreadonly read only status for resultset. set to true if the concurrency mode for the resultset
*                      is concur_read_only
* @param allowinternalsyntax if true, then this query is allowed to use internal
*                      sql syntax. one instance where this will be true is if a
*                      metadata query is getting executed.
*/
public preparedstatement prepareinternalstatement schemadescriptor compilationschema
string sqltext  boolean isforreadonly  boolean allowinternalsyntax
throws standardexception
/**
* return a preparedstatement object for the query.
* this method first tries to locate the preparedstatement object from a statement
* cache.  if the statement is not found in the cache, the query will be compiled and
* put into the cache.
* the schema used when compiling the statement is the same schema as returned by
* getdefaultschema().  for internal statements, the read only status is set to
* true.
* calling this method is equivalent to calling
* prepareexternalstatement(lcc.getdefaultschema(), sqltext, true);
*
* @param sqltext sql query string
*/
public preparedstatement prepareinternalstatement string sqltext
throws standardexception
/**
* control whether or not optimizer trace is on.
*
* @param onoroff    whether to turn optimizer trace on (true) or off (false).
*
* @return whether or not the call was successful.  (false will be returned when optimizer tracing is not supported.)
*/
public boolean setoptimizertrace boolean onoroff
/**
* get whether or not optimizer trace is on.
*
* @return whether or not optimizer trace is on.
*/
public boolean getoptimizertrace
/**
* control whether or not optimizer trace is generated in html.
*
* @param onoroff    whether or not optimizer trace will be in html (true) or not (false).
*
* @return whether or not the call was successful.  (false will be returned when optimizer tracing is not supported.)
*/
public boolean setoptimizertracehtml boolean onoroff
/**
* get whether or not optimizer trace html is on.
*
* @return whether or not optimizer trace html is on.
*/
public boolean getoptimizertracehtml
/**
* get the optimizer trace output for the last optimized query as a string.  if optimizer trace
* html is on, then the string will contain the html tags.
*
* @return the optimizer trace output for the last optimized query as a string.
*    null will be returned if optimizer trace output is off or not supported
*    or no trace output was found or an exception occurred.
*/
public string getoptimizertraceoutput
/**
* set the optimizer trace output to the specified string.
* (done at the beginning of each statement.)
*/
public void setoptimizertraceoutput string startingtext
/**
* append the latest output to the optimizer trace output.
*/
public void appendoptimizertraceoutput string output
/**
*	reports whether there is any outstanding work in the transaction.
*
*	@return		true if there is outstanding work in the transaction
*				false otherwise
*/
public	boolean	istransactionpristine
/**
*	get the lock handle for the current transaction.
*
*	@param	lockscope	single_transaction_lock or multi_transaction_lock
*
*	@return	the current lock handle
*
* @exception standardexception thrown if something goes wrong
*/
public	object	getlockobject  int lockscope   throws standardexception
/**
*	get casing for delimited identifiers. this feature is here to
*	support the plugin.
*
*	@return	ansi_casing or anti_ansi_casing.
*
* @exception standardexception thrown if something goes wrong
*/
public	int	getidentifiercasing   throws standardexception
/**
* convert an identifier to the proper case for this connection. this method
* is here to support the plugin.
*
* @param id an identifier string
* @return  the string converted to upper or lower case, as appropriate
*
* @exception standardexception thrown if something goes wrong
*/
public	string convertidentifiercase  string id  throws standardexception
/**
* returns the last autoincrement value inserted by this connection.
* if no values have been inserted into the given column a null value
* is returned.
*
* @param schemaname
* @param tablename
* @param columnname
*/
public long lastautoincrementvalue string schemaname
string tablename
string columnname
/**
* sets autoincrementupdate-- this variable allows updates to autoincrement
* columns if it is set to true. the default is ofcourse false; i.e
* ai columns cannot be directly modified by the user. this is set to
* true by altertableconstantaction, when a new ai column is being added
* to an existing table.
*
* @param flag 	the value for autoincrementupdate (true or false)
* @see org.apache.derby.impl.sql.execute.altertableconstantaction#updatenewautoincrementcolumn
*
*/
public void setautoincrementupdate boolean flag
/**
* returns the current value of autoincrementupdate.
*
* @return true if updates to autoincrement columns is permitted.
*/
public boolean getautoincrementupdate
/**
* copy a hashtable of autoincrement key value pairs into the cache of
* ai values stored in the language connection context.
*/
public void copyhashtabletoaiht hashtable from
/**
* returns the <b>next</b> value to be inserted into an autoincrement col.
* this is used internally by the system to generate autoincrement values
* which are going to be inserted into a autoincrement column. this is
* used when as autoincrement column is added to a table by an alter
* table statemenet and during bulk insert.
*
* @param schemaname
* @param tablename
* @param columnname identify the column uniquely in the system.
*
* @exception standardexception on error.
*/
public long nextautoincrementvalue string schemaname  string tablename
string columnname
throws standardexception
/**
* flush the cache of autoincrement values being kept by the lcc.
* this will result in the autoincrement values being written to the
* syscolumns table as well as the mapping used by lastautoincrementvalue
*
* @param tableuuid the table which is being flushed; we need this value to
* identify the table for which the autoincrement counter is being
* maintained.
*
* @exception standardexception thrown on error.
*
* @see languageconnectioncontext#lastautoincrementvalue
* @see org.apache.derby.impl.sql.conn.genericlanguageconnectioncontext#lastautoincrementvalue
* @see org.apache.derby.iapi.db.connectioninfo#lastautoincrementvalue
*/
public void autoincrementflushcache uuid tableuuid
throws standardexception
/**
* create an autoincrement counter to be used on behalf of a sql-j
* statement. the counter is identified by (schemaname, tablename,
* columnname). the counter must be freed up by calling
* autoincrementflushcache at the end of the statement. it is expected
* that a ai-counter with the same signaure doesn't exist when the
* method is called.
*
* @param 		s					schemaname
* @param		t					tablename
* @param		c					columnname
* @param		initialvalue		initial value of the counter.
* @param		increment			increment for the counter.
* @param		position			column position (1-based).
*/
public void autoincrementcreatecounter string s  string t  string c
long initialvalue  long increment
int position
/**
* get the instance number of this lcc.
*
* @return instance number of this lcc.
*/
public int getinstancenumber
/**
* get the drda id of this lcc.
*
* @return drda id this lcc.
*/
public string getdrdaid
/**
* set the drda id of this lcc.
*
* @param drdaid drda id.
*/
public void setdrdaid string drdaid
/**
* get the database name of this lcc.
*
* @return database name of this lcc.
*/
public string getdbname
/**
* check if in sql standard mode, with support for grant & revoke
*
* @return true if sql standard permissions are being used
*/
public boolean usessqlauthorization