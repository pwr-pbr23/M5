/*
derby - class org.apache.derby.iapi.services.info.productversionholder
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby iapi services info
import java io inputstream
import java io ioexception
import java util properties
/**
class to hold a cloudscape product version.
this class includes the following product version features.
<ol>
<li>save the product version information this holds as a string. we call
the string a 'product version string'.
<li>construct a productversionholder from a valid 'product version string'.
<li>determine if two product versions are feature compatible. this means
products of these versions may interoperate with ***no*** compatibility
problems.
<li>determine if two product versions are the same. this is a stronger
test than the test for feature compatibility.
</ol>
cloudscape 5.1 and older versions used the majorversion, minorversion, maintversion versions
directly. that is a three part version number, majorversion.minorversion.maintversion, e.g. 5.1.21.
for cloudscape 5.2 onwards a four part name is required.
majorversion.minorversion.fixpack.bugversion e.g. 5.2.1.2
this follows the ibm standard and allows us to state that a fix pack will be 5.2.3 without worrying
about how many maintence fixes there are between fix packs.
we implement this using the existing format of productversionholder to reduce disruption to the
code, however we make the maintversion encode the {fixpack.bugversion}. since the maintversion
is represented by a int (2g values) we have plenty of room for encoding. if we assign a given
majorversion.minorversion.fixpack a 10 year life, then we about the maximum number of individual releases
it can have is 10 years * 365 days/year = 3650. thus with the pre 5.2 scheme we would not expect a
5.1.x to have an x > 3650 (approximately). usually the rate of point releases has been much less than
one per day, 5.1.31 is released about 225 days after ga which makes around a point release every 7 days.
but in the encoding we need to be conservative. with fix packs the maximum is about 2 per year and fix
packs are only made to the current release, thus with a yearly minor release cycle we would imagine
only 2 fixpacks per major.minor. however like other ibm products or release cycle may be extended thus
we can expect up to a handful of fix packs.
thus we might imagine releases like
5.2.0.12
5.2.0.234
5.2.1.34
5.2.4.2445
but highly unlikey to have
5.2.2.59321
5.2.23.1
the encoding number must continue to increase so that the
encodedmaintb > encodedmainta
if (fixpackb > fixpacka) || ((fixpackb == fixpacka) && (bugb > buga))
selected encoding
encodedmaint = (fixpack * 1,000,000) + (bugversion);
handles many many fixpacks and upto one million bug fixes per fix pack and remains somewhat human readable.
special fix packs
fixpack == 0 = alpha (version off main codeline)
fixpack == 1 = first release of major.minor (may be marked with beta)
fixpack == 2 = first fix pack (displayed as 1)
the drdamaintversion is sent in the network server prdid. it never displays
but may be used by the client for version specific behaviour. it should be
reset to 0 with each minor release.
the product version string has the form:
<pre>
productvendorname - productname - majorversion.minorversion.maintversion [beta] - (buildnumber)
</pre>
*/
public final class productversionholder implements java security privilegedaction
//
//used as an invalid value for numbers. this works because all
//the numbers in a product version must be non-negative.
private static final int bad_number    1
private static final string alpha
private static final string beta
private final static int	maint_encoding   1000000
private string productvendorname
private string productname
private string producttechnologyname
private int majorversion   bad_number
private int minorversion   bad_number
private int maintversion   bad_number
private int drdamaintversion   bad_number
private string buildnumber
private boolean isbeta
private productversionholder
/**
create a productversionholder
<p>please see the documentation for the varient of getproductvesionholder
that takes the same parameters as this for a description of the parameters.
*/
private productversionholder string productvendorname
string productname
string producttechnologyname
int majorversion
int minorversion
int maintversion
int drdamaintversion
string buildnumber
boolean isbeta
if  productvendorname    null
this productvendorname   productvendorname trim
if  productname    null
this productname   productname trim
if  producttechnologyname    null
this producttechnologyname   producttechnologyname trim
this majorversion   majorversion
this minorversion   minorversion
this maintversion   maintversion
this drdamaintversion   drdamaintversion
this buildnumber   buildnumber
this isbeta   isbeta
/**
create a valid productversionholder. if any of the
parameters provided is invalid, this returns null.
@param productname the name of the product. productname.length()
must be greater than 0. the syntax for a product name is
'productgenus[:productspecies]'.
@param majorversion the most significant portion of a 3
part product version.  must be non-negative.
@param minorversion the second portion of a 3 part
product version. must be non-negative.
@param maintversion the least significant portion of a 3 part
product version. must be non-negative.
@param drdamaintversion the protocol modification number for minor release.
@param buildnumber the buildnumber for a product.
@param isbeta true iff the product is beta.
@return a valid productversionholder of null if any of the parameters
provided are not valid.
*/
public static productversionholder
getproductversionholder
string productvendorname
string productname
string producttechnologyname
int majorversion
int minorversion
int maintversion
int drdamaintversion
string buildnumber
boolean isbeta
productversionholder pvh
new productversionholder productvendorname
productname
producttechnologyname
majorversion
minorversion
maintversion
drdamaintversion
buildnumber
isbeta
return pvh
/**
get a productversionholder for a product of a given genus,
that is available in the caller's environment.
even though this uses a priv bock, it may stil fail when
the jar the version is being fetched from, is different to the
one that loaded this class, and the jars are in different security contexts.
@param productgenus the genus for the product.
@return the productversionholder or null if
a product with the given genus is not available in the
caller's environment.
*/
public static productversionholder
getproductversionholderfrommyenv string productgenus
productversionholder temppvh   new productversionholder
temppvh productgenus   productgenus
properties p    properties  java security accesscontroller doprivileged temppvh
if  p    null
return null
return getproductversionholder p
/**
load the version info from the already opened properties files.
we need to do this because if the jar files (e.g. db2jtools and db2j)
are in different security contexts (entries in the policy files) then
we cannot load the version information for one of them correctly.
this is because the this class will either have been loaded from
only one of the jars and hence can only access the resource in its own jar.
by making code specific to the jar open the resource we are guaranteed it will work.
*/
public static productversionholder
getproductversionholderfrommyenv inputstream propertiesstream
if  propertiesstream    null
return null
properties p   new properties
try
p load propertiesstream
catch  ioexception ioe
system out println     ioe getmessage
//
//this case is a bit ugly. if we get an ioexception, we return
//null. though this correctly reflects that the product is not
//available for use, it may be confusing to users that we swallow
//the io error here.
return null
finally
try
propertiesstream close
catch  ioexception ioe2
return getproductversionholder p
/**
get a productversionholder based on the information in
the properties object provided.
@param p the properties object that holds the productversion
information.
@return the productversionholder or null if
a product with the given genus is not available in the
caller's environment.
*/
public static productversionholder
getproductversionholder properties p
string pvn   p getproperty propertynames product_vendor_name
string pn   p getproperty propertynames product_external_name
string ptn   p getproperty propertynames product_technology_name
int v1   parseint p getproperty propertynames product_major_version
int v2   parseint p getproperty propertynames product_minor_version
int v3   parseint p getproperty propertynames product_maint_version
int v4   parseint p getproperty propertynames product_drda_maint_version
string bn   p getproperty propertynames product_build_number
boolean isbeta
boolean valueof p getproperty propertynames product_beta_version
return 	getproductversionholder pvn pn ptn v1 v2 v3 v4 bn isbeta
/**
return the product vendor name.
*/
public string getproductvendorname
return productvendorname
/**
return the external product name.
*/
public string getproductname
return productname
public string getproducttechnologyname
return producttechnologyname
/**
return the major version number.
*/
public int getmajorversion    return majorversion
/**
return the minor version number.
*/
public int getminorversion    return minorversion
/**
return the <b>encoded</b> maintainence version number.
*/
public int getmaintversion    return maintversion
/**
return the drda protocol maintenance version for this minor release.
starts at 0 for each minor release and only incremented
when client behaviour changes based on the server version.
**/
public int getdrdamaintversion    return drdamaintversion
/**
return the fix pack version from the maintence encoding.
*/
public int getfixpackversion     return maintversion   maint_encoding
/**
return true if this is a beta product.
*/
public boolean isbeta    return isbeta booleanvalue
/**
return true if this is a alpha product.
*/
public boolean isalpha
return	    majorversion >  5
minorversion > 2
maintversion   maint_encoding     0
/**
return the build number for this product.
*/
public string getbuildnumber    return buildnumber
/**
* return the build number as an integer if possible,
* mapping from the svn number.
* nnnnn -> returns nnnnn
* nnnnnm -> returns -nnnnn indicates a modified code base
* nnnnn:mmmmm -> returns -nnnnn
* anything else -> returns -1
*/
public int getbuildnumberasint
if  buildnumber    null
return  1
boolean dubiouscode   false
int offset   buildnumber indexof
if  offset     1
offset   buildnumber indexof
else
dubiouscode   true
if  offset     1
offset   buildnumber length
else
dubiouscode   true
try
int bnai   integer parseint buildnumber substring 0  offset
if  dubiouscode
bnai    bnai
return bnai
catch  numberformatexception nfe
return  1
/**
parse a string containing a non-negative integer. return
a negative integer is the string is invalid.
@param s a string with a non-negative integer (a sequence
of decimal digits.)
@return the integer or a negative number if s is invalid.
*/
private static int parseint string s
//system.out.println("parsing integer: "+s);
int result   bad_number
try
if  s  null
result   integer parseint s
catch  numberformatexception nfe
if  result < 0  result   bad_number
return result
/**
return  a string representation of this productversion. the
difference between this and createproductversionstring, is
that this method retruns a string when this productversionholder
holds invalid version information.
*/
public string tostring
stringbuffer sb   new stringbuffer
sb append getproductvendorname
sb append
sb append getproductname
sb append
sb append getversionbuildstring true
return sb tostring
/**
return the feature version string, ie. major.minor. (e.g. 5.2)
*/
public string getsimpleversionstring
return productversionholder simpleversionstring majorversion  minorversion  isbeta
/**
convert a major and minor number with beta status into a string.
*/
public static string simpleversionstring int major  int minor  boolean isbeta
stringbuffer sb   new stringbuffer
sb append major
sb append
sb append minor
if  isbeta
sb append
sb append beta
return sb tostring
public static string fullversionstring int major  int minor  int maint  boolean isbeta  string build
stringbuffer sb   new stringbuffer
sb append major
sb append
sb append minor
sb append
string prerelease   null
if  major    5    minor <  2    maint < maint_encoding
sb append maint
if  isbeta
prerelease   beta
else
int fixpack   maint   maint_encoding
int bugversion   maint % maint_encoding
sb append fixpack
sb append
sb append bugversion
if  fixpack    0
prerelease   alpha
else if  isbeta
prerelease   beta
if  prerelease    null
sb append
sb append prerelease
if  build    null
sb append
sb append build
sb append
return sb tostring
/**
returns a short-hand value for the product version string.
used by sysinfo.
includes the optional <beta> designation
*/
public string getversionbuildstring boolean withbuild
return productversionholder fullversionstring majorversion  minorversion  maintversion  isbeta
withbuild ? buildnumber   null
/*
** security related methods
*/
private string productgenus
public final object run
// security permission - ip4
return loadproperties this productgenus
// security permission - ip4
private properties loadproperties string productgenus
string resourcename       productgenus
inputstream is   getclass   getresourceasstream resourcename
if  is  null
return null
properties p   new properties
try
p load is
return p
catch  ioexception ioe
//
//this case is a bit ugly. if we get an ioexception, we return
//null. though this correctly reflects that the product is not
//available for use, it may be confusing to users that we swallow
//the io error here.
return null