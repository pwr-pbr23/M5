/*
derby - class org.apache.derby.iapi.sql.compile.accesspath
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby iapi sql compile
import org apache derby iapi sql dictionary conglomeratedescriptor
import org apache derby iapi sql dictionary tabledescriptor
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi error standardexception
/**
* accesspath represents a proposed access path for an optimizable.
* an optimizable may have more than one proposed accesspath.
*/
public interface accesspath
/**
* set the conglomerate descriptor for this access path.
*
* @param cd	a conglomeratedescriptor
*/
void setconglomeratedescriptor conglomeratedescriptor cd
/**
* get whatever was last set as the conglomerate descriptor.
* returns null if nothing was set since the last call to startoptimizing()
*/
conglomeratedescriptor getconglomeratedescriptor
/**
* set the given cost estimate in this accesspath.  generally, this will
* be the costestimate for the plan currently under consideration.
*/
public void setcostestimate costestimate costestimate
/**
* get the cost estimate for this accesspath.  this is the last one
* set by setcostestimate.
*/
public costestimate getcostestimate
/**
* set whether or not to consider a covering index scan on the optimizable.
*/
public void setcoveringindexscan boolean coveringindexscan
/**
* return whether or not the optimizer is considering a covering index
* scan on this accesspath.
*
* @return boolean		whether or not the optimizer chose a covering
*						index scan.
*/
public boolean getcoveringindexscan
/**
* set whether or not to consider a non-matching index scan on this
* accesspath.
*/
public void setnonmatchingindexscan boolean nonmatchingindexscan
/**
* return whether or not the optimizer is considering a non-matching
* index scan on this accesspath. we expect to call this during
* generation, after access path selection is complete.
*
* @return boolean		whether or not the optimizer is considering
*						a non-matching index scan.
*/
public boolean getnonmatchingindexscan
/**
* remember the given join strategy
*
* @param joinstrategy	the best join strategy
*/
public void setjoinstrategy joinstrategy joinstrategy
/**
* get the join strategy, as set by setjoinstrategy().
*/
public joinstrategy getjoinstrategy
/**
* set the lock mode
*/
public void setlockmode int lockmode
/**
* get the lock mode, as last set in setlockmode().
*/
public int getlockmode
/**
* copy all information from the given accesspath to this one.
*/
public void copy accesspath copyfrom
/**
* get the optimizer associated with this access path.
*
* @return	the optimizer associated with this access path.
*/
public optimizer getoptimizer
/**
* sets the "name" of the access path. if the access path represents an
* index then set the name to the name of the index. if it is an index
* created for a constraint, use the constraint name. this is called only
* for base tables.
*
* @param 	td		tabledescriptor of the base table.
* @param 	dd		datadictionary.
*
* @exception standardexception 	on error.
*/
public void initializeaccesspathname datadictionary dd  tabledescriptor td
throws standardexception