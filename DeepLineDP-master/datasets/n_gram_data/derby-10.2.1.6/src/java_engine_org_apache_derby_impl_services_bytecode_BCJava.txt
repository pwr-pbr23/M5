/*
derby - class org.apache.derby.impl.services.bytecode.bcjava
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl services bytecode
import org apache derby iapi services compiler javafactory
import org apache derby iapi services compiler classbuilder
import org apache derby iapi services compiler methodbuilder
import org apache derby iapi services loader classfactory
import org apache derby iapi services classfile classholder
import org apache derby iapi services cache cacheable
import org apache derby iapi services cache cacheablefactory
import org apache derby iapi services cache cachefactory
import org apache derby iapi services cache cachemanager
import org apache derby iapi services monitor monitor
import org apache derby iapi services monitor modulecontrol
import org apache derby iapi error standardexception
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi services classfile vmdescriptor
import java util properties
import java util hashtable
/**
<p>
<b>debugging problems with generated classes</b>
<p>
when the code has been generated incorrectly, all sorts of
odd things can go wrong.  this is one recommended approach to
finding the problem.
<p>
first, turn on bytecodegeninstr and dumpclassfile. look
for missing files (right now they are consecutively numbered
by the activation class builder; later on they won't be, but
bytcodegeninstr dumps messages about the classes it has).
look at the log to make sure that all "gen starting class/method"
messages are paired with a "gen ending class/method" message.
if a file is missing or the pairing is missing, then something
went wrong when the system tried to generate the bytecodes.
resort to your favorite debugging tool to step through
the faulty statement.
<p>
if you get class files but the system crashes on you (i had
an os segmentation fault once) or you get funny messages like
jdbc excpetion: ac5 where ac5 is just the name of a generated
class, then one of the following is likely:
<ul>
<li> you are calling invokevirtual when
you are supposed to call invokeinterface
<li> you have an inexact match on a method argument or
return type.
<li> you are trying to get to a superclass's field using
a subclass.
</ul>
the best way to locate the problem here is to do this (replace
ac5.class with the name of your class file):
<ol>
<li> javap -c -v ac5 >ac5.gp<br>
if javap reports "class not found", and the file ac5.class does
exist in the current directory, then the .class file is probably
corrupt.  try running mocha on it to see if that works. the
problem will be in the code that generates the entries for
the class file -- most likely the constantpool is bad, an
attribute got created incorrectly, or
perhaps the instruction streams are goofed up.
<li> java mocha.decompiler ac5.class<br>
if mocha cannot create good java source, then you really
need to go back and examine the calls creating the java
constructs; a parameter might have been null when it should
have, a call to turn an expression into a statement may be
missing, or something else may be wrong.
<li> mv ac5.mocha ac5.java
<li> vi ac5.java ; you will have to fix any new sqlboolean(1, ...)
calls to be new sqlboolean(true, ...).  also mocha
occasionally messes up other stuff too.  just iterate on it
until it builds or you figure out what is wrong with
the generated code.
<li> javac ac5.java
<li> javap -v -c ac5 >ac5.jp
<li> sed '1,$s/#[0-9]* </# </' ac5.gp > ac5.gn
<li> sed '1,$s/#[0-9]* </# </' ac5.jp > ac5.jn<br>
these seds are to get rid of constant pool entry numbers,
which will be wildly different on the two files.
<li> vdiff32 ac5.gn ac5.jn<br>
this tool shows you side-by-side diffs.  if you change
to the window that interleaves the diffs, you can see the
length of the line.  look for places where there are
invokevirtual vs. invokeinterface differences, differences
in the class name of a field, differences in the class name
of a method parameter or return type.  the generated code
*will* have some unavoidable differences from the
compiled code, such as:
<ul>
<li> it will have goto's at the end of try blocks
rather than return's.
<li> it will do a getstatic on a static final field
rather than inlining the static final field's value
<li> it will have more checkcast's in it, since it
doesn't see if the checkcast will always succeed
and thus remove it.
</ul>
once you find a diff, you need to track down where
the call was generated and modify it appropriately:
change newmethodcall to newinterfacemethodcall;
add newcastexpression to get a argument into the right
type for the parameter; ensure the return type given for
the method is its declared return type.
</ol>
@see org.apache.derby.iapi.services.compiler.javafactory
@author ames
*/
public class bcjava implements javafactory  cacheablefactory  modulecontrol
//////////////////////////////////////////////////////////////
//
//	members
//
//////////////////////////////////////////////////////////////
/* cache of java class names versus vm type names */
private cachemanager	vmtypeidcache
//
// class interface
//
public bcjava
//
// modulecontrol interface
//
/**
start this module. we need a read/write version of the class utilities
@exception standardexception standard cloudscape policy
*/
public void boot boolean create  properties properties  throws standardexception
cachefactory cf
cachefactory  monitor startsystemmodule org apache derby iapi reference module cachefactory
/*
** the initial and maximum cache sizes are based on experiments
** that i did with some of the language tests.  i found that
** the size quickly grew to about 40, then continued to grow
** slowly after that.
**
**			-	jeff
*/
vmtypeidcache
cf newcachemanager
this
64
256
/**
stop this module.  in this case, nothing needs to be done.
*/
public void stop
//
// javafactory interface
//
/**
* a class.  once it is created, fields, methods,
* interfaces, static initialization code,
* and constructors can be added to it.
* <verbatim>
java: package #packagename;
#modifiers #classname extends #superclass { }
// modifiers is the | of the jvm constants for
// the modifiers such as static, public, etc.
</verbatim>
*
* see java.lang.reflect.modifiers
* @param packagename the name of the package the class is in.
*	null if it is in the default package.
* @param modifiers the | of the modifiers
*	constants representing the visibility and control of this
*	method.
* @param classname the name of the class or interface
* @param superclass the name of the superclass or superinterface
*
* @return the class builder.
*/
public classbuilder newclassbuilder classfactory cf  string packagename
int modifiers  string classname  string superclass
return new bcclass cf  packagename  modifiers  classname  superclass  this
/*
** cacheablefactory interface
*/
public cacheable newcacheable cachemanager cm
return new vmtypeidcacheable
///////////////////////////////////////////
//
// utilities specific to this implementation
//
////////////////////////////////////////////
/**
* get the vm type id that corresponds with the given java type name.
* this uses the cache of vm type ids.
*
* @param javatype	the java type name to translate to a java vm type id
*
* @return		the java vm type id
*/
type type string javatype
type retval
try
vmtypeidcacheable vtic    vmtypeidcacheable  vmtypeidcache find javatype
retval    type  vtic descriptor
vmtypeidcache release vtic
return retval
catch  standardexception se
if  sanitymanager debug
sanitymanager throwassert     se  se
/*
** if we're running a sane server, let's act as if the
** exception didn't happen, and just get the vmtypeid the
** slow way, without caching.
*/
retval   new type javatype  classholder converttointernaldescriptor javatype
return retval
string vmtype bcmethoddescriptor md
string retval
try
vmtypeidcacheable vtic    vmtypeidcacheable  vmtypeidcache find md
retval   vtic descriptor   tostring
vmtypeidcache release vtic
catch  standardexception se
if  sanitymanager debug
sanitymanager throwassert     se  se
/*
** if we're running a sane server, let's act as if the
** exception didn't happen, and just get the vmtypeid the
** slow way, without caching.
*/
retval   md buildmethoddescriptor
return retval
/**
* map vm types as strings to vm types as the vm
* handles, with int ids. used in mapping opcodes
* based on type of operand/stack entry available.
*/
static short vmtypeid string vmtypes
char vmtypec   vmtypes charat 0
switch vmtypec
case vmdescriptor c_class   return bcexpr vm_reference
case vmdescriptor c_byte   return bcexpr vm_byte
case vmdescriptor c_char   return bcexpr vm_char
case vmdescriptor c_double   return bcexpr vm_double
case vmdescriptor c_float   return bcexpr vm_float
case vmdescriptor c_int   return bcexpr vm_int
case vmdescriptor c_long   return bcexpr vm_long
case vmdescriptor c_short   return bcexpr vm_short
case vmdescriptor c_boolean   return bcexpr vm_int
case vmdescriptor c_array   return bcexpr vm_reference
case vmdescriptor c_void   return bcexpr vm_void
default
if  sanitymanager debug
sanitymanager throwassert   vmtypes
return bcexpr vm_void