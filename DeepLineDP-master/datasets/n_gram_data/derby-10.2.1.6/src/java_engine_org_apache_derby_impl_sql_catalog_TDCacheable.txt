/*
derby - class org.apache.derby.impl.sql.catalog.tdcacheable
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl sql catalog
import org apache derby iapi services cache cacheable
import org apache derby iapi services cache cachemanager
import org apache derby iapi services monitor monitor
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi services stream headerprintwriter
import org apache derby iapi error standardexception
import org apache derby iapi sql dictionary tabledescriptor
/**
* this class implements a cacheable for a datadictionary cache of
* table descriptors.  it is an abstract class - there is more than
* one cache of table descriptors per data dictionary, and this class
* provides the implementation that's common to all of them.  the lookup
* key for the cache (the "identity" of the cache item) is provided by
* the subclass.
*
* another design alternative was to make the table descriptors themselves
* the cacheable objects.  this was rejected because: we would have only
* one way of caching table descriptors, and we need at least two (by uuid
* and by name); the contents of a table descriptor would have to be
* split out into a separate class, so it could be used as the createparameter
* to the createidentity() method; the releasing of the cacheable would
* have to be done when at the end of compilation by traversing the tree -
* by creating a separate cacheable object, we can release the object within
* the gettabledescriptor() method after getting the table descriptor out
* of it.
*/
abstract class tdcacheable implements cacheable
protected tabledescriptor	td
protected final datadictionaryimpl	dd
tdcacheable datadictionaryimpl dd
this dd   dd
/* cacheable interface */
/** @see cacheable#clean */
public void clean boolean forremove
return
/** @see cacheable#isdirty */
public boolean isdirty
return false
/**
* get the table descriptor that is associated with this cacheable
*/
public tabledescriptor gettabledescriptor
return td
/**
* check the consistency of the table descriptor held by this tdcacheable
* versus an uncached table descriptor.
*
* @param uncachedtd	the uncached descriptor to compare to
* @param identity		the identity of the table descriptor
* @param reportinconsistent	a headerprintwriter to send complaints to
*
* @return	true if the descriptors are the same, false if they're different
*
* @exception standardexception		thrown on error
*/
protected boolean checkconsistency tabledescriptor uncachedtd
object identity
headerprintwriter reportinconsistent
throws standardexception
boolean	retval   true
if  sanitymanager debug
if  uncachedtd    null
reportinconsistent println
identity
retval   false
else
if
uncachedtd getheapconglomerateid
td getheapconglomerateid
uncachedtd getuuid   equals td getuuid
uncachedtd getschemaname   equals td getschemaname
uncachedtd getname   equals td getname
uncachedtd gettabletype      td gettabletype
reportinconsistent println
identity
td
uncachedtd
retval   false
return retval