/*
derby - class org.apache.derby.impl.store.access.sort.sortscan
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl store access sort
import org apache derby iapi reference sqlstate
import org apache derby iapi services io formatablebitset
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi services io storable
import org apache derby iapi error standardexception
import org apache derby iapi store access conglomerate transactionmanager
import org apache derby iapi store access rowutil
import org apache derby iapi store access scancontroller
import org apache derby iapi types datavaluedescriptor
/**
abstract base class for merge sort scans.
**/
public abstract class sortscan extends scan
/**
the sort that this class is scanning.
**/
protected mergesort sort   null
/**
the transactionmanager that opened this scan.
**/
protected transactionmanager tran   null
/**
the row at the current position of the scan, from which
fetch will return values.
**/
protected datavaluedescriptor current
/**
the row at the current position of the scan, from which
fetch will return values.
**/
protected boolean hold
/*
* constructors
*/
sortscan mergesort sort  transactionmanager tran  boolean hold
super
this sort   sort
this tran   tran
this hold   hold
/*
* abstract methods of scan
*/
/**
fetch the row at the next position of the scan.
if there is a valid next position in the scan then
the value in the template storable row is replaced
with the value of the row at the current scan
position.  the columns of the template row must
be of the same type as the actual columns in the
underlying conglomerate.
the resulting contents of templaterow after a fetchnext()
which returns false is undefined.
the result of calling fetchnext(row) is exactly logically
equivalent to making a next() call followed by a fetch(row)
call.  this interface allows implementations to optimize
the 2 calls if possible.
resolve (mikem - 2/24/98) - come back to this and see if
coding this differently saves in sort scans, as did the
heap recoding.
@param row the template row into which the value
of the next position in the scan is to be stored.
@return true if there is a next position in the scan,
false if there isn't.
@exception standardexception standard exception policy.
**/
public final boolean fetchnext datavaluedescriptor row
throws standardexception
boolean ret_val   next
if  ret_val
fetch row
return ret_val
/**
fetch the row at the current position of the scan.
@see scancontroller#fetch
**/
public final void fetch datavaluedescriptor result
throws standardexception
if  sanitymanager debug
sanitymanager assert sort    null
if  current    null
throw standardexception newexception
sqlstate sort_scan_not_positioned
// make sure the passed in template row is of the correct type.
sort checkcolumntypes result
// resolve
// note that fetch() basically throws away the object's passed in.
// we should figure out how to allow callers in this situation to
// not go through the work of allocating objects in the first place.
// sort has allocated objects for this row, and will not
// reference them any more.  so just pass the objects out
// to the caller instead of copying them into the provided
// objects.
system arraycopy current  0  result  0  result length
/**
fetch the row at the current position of the scan and does not apply the
qualifiers.
this method will always throw an exception.
(sqlstate.sort_improper_scan_method)
@see scancontroller#fetchwithoutqualify
**/
public final void fetchwithoutqualify datavaluedescriptor result
throws standardexception
throw standardexception newexception
sqlstate sort_improper_scan_method
/**
close the scan.	@see scancontroller#close
**/
public void close
sort   null
current   null
tran closeme this
/*
* methods of sortscan.  arranged alphabetically.
*/