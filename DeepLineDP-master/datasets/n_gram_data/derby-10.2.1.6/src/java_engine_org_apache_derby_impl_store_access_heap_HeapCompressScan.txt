/*
derby - class org.apache.derby.impl.store.access.heap.heapscan
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl store access heap
/**
a heap scan object represents an instance of an scan on a heap conglomerate.
**/
import org apache derby iapi reference sqlstate
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi services io storable
import org apache derby iapi error standardexception
import org apache derby iapi store access conglomerate conglomerate
import org apache derby iapi store access conglomerate logicalundo
import org apache derby iapi store access conglomerate scanmanager
import org apache derby iapi store access conglomerate transactionmanager
import org apache derby iapi store access conglomeratecontroller
import org apache derby iapi store access dynamiccompiledopenconglominfo
import org apache derby iapi store access qualifier
import org apache derby iapi store access rowutil
import org apache derby iapi store access scaninfo
import org apache derby iapi store access scancontroller
import org apache derby iapi store access spaceinfo
import org apache derby iapi store access transactioncontroller
import org apache derby iapi types rowlocation
import org apache derby iapi store raw containerhandle
import org apache derby iapi store raw lockingpolicy
import org apache derby iapi store raw transaction
import org apache derby iapi store raw page
import org apache derby iapi store raw recordhandle
import org apache derby iapi types datavaluedescriptor
import org apache derby impl store access conglomerate conglomerateutil
import org apache derby impl store access conglomerate genericscancontroller
import org apache derby impl store access conglomerate rowposition
import org apache derby iapi store access backingstorehashtable
import org apache derby iapi services io formatablebitset
import java util hashtable
import java util vector
class heapcompressscan
extends heapscan
/**************************************************************************
* constants of heapscan
**************************************************************************
*/
/**************************************************************************
* fields of heapscan
**************************************************************************
*/
private long pagenum_to_start_moving_rows    1
/**************************************************************************
* constructors for this class:
**************************************************************************
*/
/**
** the only constructor for a heapcompressscan returns a scan in the
** closed state, the caller must call open.
**/
public heapcompressscan
/**************************************************************************
* protected override implementation of routines in
*     genericcontroller class:
**************************************************************************
*/
public int fetchnextgroup
datavaluedescriptor row_array
rowlocation           old_rowloc_array
rowlocation           new_rowloc_array
throws standardexception
return fetchrowsforcompress
row_array  old_rowloc_array  new_rowloc_array
/**
* fetch the next n rows from the table.
* <p>
* utility routine used by both fetchset() and fetchnextgroup().
*
* @exception  standardexception  standard exception policy.
**/
private int fetchrowsforcompress
datavaluedescriptor row_array
rowlocation           oldrowloc_array
rowlocation           newrowloc_array
throws standardexception
int                     ret_row_count             0
datavaluedescriptor   fetch_row                 null
if  sanitymanager debug
sanitymanager assert row_array    null
sanitymanager assert row_array    null
if  getscanstate      scan_inprogress
positionatresumescan scan_position
else if  getscanstate      scan_init
// for first implementation of defragment use a conservative
// approach, only move rows from the last "number of free pages"
// of the container.  should always at least be able to empty
// that number of pages.
spaceinfo info
open_conglom getcontainer   getspaceinfo
pagenum_to_start_moving_rows   info getnumallocatedpages
positionatstartforforwardscan scan_position
else if  getscanstate      scan_hold_inprogress
reopenafterendtransaction
if  sanitymanager debug
sanitymanager assert
scan_position current_rh    null  this tostring
// reposition the scan at the row just before the next one to
// return.
// this routine handles the mess of repositioning if the row or
// the page has disappeared. this can happen if a lock was not
// held on the row while not holding the latch.
open_conglom latchpageandrepositionscan scan_position
setscanstate scan_inprogress
else if  getscanstate      scan_hold_init
reopenafterendtransaction
positionatstartforforwardscan scan_position
else
if  sanitymanager debug
sanitymanager assert getscanstate      scan_done
return 0
// at this point:
// scan_position.current_page is latched.
// scan_position.current_slot is the slot on scan_position.current_page
// just before the "next" record this routine should process.
// loop through successive pages and successive slots on those
// pages.  stop when either the last page is reached
// (scan_position.current_page will be null).
// along the way apply qualifiers to skip rows which don't qualify.
while  scan_position current_page    null
while   scan_position current_slot   1  <
scan_position current_page recordcount
// allocate a new row to read the row into.
if  fetch_row    null
// point at allocated row in array if one exists.
if  row_array    null
row_array
open_conglom getruntimemem   get_row_for_export
fetch_row   row_array
// move scan current position forward.
scan_position positionatnextslot
this stat_numrows_visited
if  scan_position current_page isdeletedatslot
scan_position current_slot
// at this point assume table level lock, and that this
// transcation did not delete the row, so any
// deleted row must be a committed deleted row which can
// be purged.
scan_position current_page purgeatslot
scan_position current_slot  1  false
// raw store shuffles following rows down, so
// postion the scan at previous slot, so next trip
// through loop will pick up correct row.
scan_position positionatprevslot
continue
if  scan_position current_page getpagenumber   >
pagenum_to_start_moving_rows
// give raw store a chance to move the row for compression
recordhandle old_handle   new recordhandle
recordhandle new_handle   new recordhandle
long         new_pageno   new long
if  scan_position current_page moverecordforcompressatslot
scan_position current_slot
fetch_row
old_handle
new_handle     1
// raw store moved the row, so bump the row count but
// postion the scan at previous slot, so next trip
// through loop will pick up correct row.
// the subsequent rows will have been moved forward
// to take place of moved row.
scan_position positionatprevslot
ret_row_count
stat_numrows_qualified
setrowlocationarray
oldrowloc_array  ret_row_count   1  old_handle
setrowlocationarray
newrowloc_array  ret_row_count   1  new_handle
fetch_row   null
this stat_numpages_visited
if  scan_position current_page recordcount      0
// need to set the scan position before removing page
scan_position current_pageno
scan_position current_page getpagenumber
open_conglom getcontainer   removepage
scan_position current_page
// removepage unlatches the page, and page not available
// again until after commit.
scan_position current_page   null
else
positionafterthispage scan_position
scan_position unlatch
if  ret_row_count > 0
// rows were moved on this page, give caller a chance to
// process those and free up access to the table.
return ret_row_count
else
// no rows were moved so go ahead and commit the transaction
// to allow other threads a chance at table.  compress does
// need to sync as long as transaction either completely
// commits or backs out, either is fine.
/*
open_conglom.getxactmgr().commitnosync(
transactioncontroller.release_locks);
open_conglom.reopen();
*/
positionatresumescan scan_position
// reached last page of scan.
positionatdonescan scan_position
// we need to decrement when we stop scan at the end of the table.
this stat_numpages_visited
return ret_row_count
/**
* reposition the scan upon entering the fetchrows loop.
* <p>
* called upon entering fetchrows() while in the scan_inprogress state.
* do work necessary to look at rows in the current page of the scan.
* <p>
* the default implementation uses a record handle to maintain a scan
* position.  it will get the latch again on the current
* scan position and set the slot to the current record handle.
*
* @exception  standardexception  standard exception policy.
**/
protected void positionatresumescan
rowposition pos
throws standardexception
// reposition the scan at the row just before the next one to return.
// this routine handles the mess of repositioning if the row or the
// page has disappeared. this can happen if a lock was not held on the
// row while not holding the latch.
open_conglom latchpageandrepositionscan scan_position
/**
* move the scan from scan_init to scan_inprogress.
* <p>
* this routine is called to move the scan from scan_init to
* scan_inprogress.  upon return from this routine it is expected
* that scan_position is set such that calling the generic
* scan loop will reach the first row of the scan.  note that this
* usually means setting the scan_postion to one before the 1st
* row to be returned.
* <p>
*
* @exception  standardexception  standard exception policy.
**/
protected void positionatstartforforwardscan
rowposition pos
throws standardexception
if  pos current_rh    null
// 1st positioning of scan (delayed from openscan).  do not
// compress the first page, there is no previous page to move
// rows to, and moving the special heap metadata row from the
// first page would cause problems.  setting to next page is
// why this scan overrides generic implementation.
pos current_page
open_conglom getcontainer   getnextpage
containerhandle first_page_number
// set up for scan to continue at beginning of page following
// the first page of the container.
pos current_slot   page first_slot_number   1
else
// 1st positioning of scan following a reopenscanbyrowlocation
// reposition the scan at the row just before the next one to
// return.  this routine handles the mess of repositioning if the
// row or the page has disappeared. this can happen if a lock was
// not held on the row while not holding the latch.
open_conglom latchpageandrepositionscan pos
// set up for scan to at the specified record handle (position one
// before it so that the loop increment and find it).
pos current_slot    1
pos current_rh                null
this stat_numpages_visited    1
this setscanstate scan_inprogress
/**************************************************************************
* private/protected methods of this class:
**************************************************************************
*/
/**
* set scan position to just after current page.
* <p>
* used to set the position of the scan if a record handle is not
* avaliable.  in this case current_rh will be set to null, and
* current_pageno will be set to the current page number.
* on resume of the scan, the scan will be set to just before the first
* row returned form a getnextpage(current_pageno) call.
* <p>
* a positionatresumescan(scan_position) is necessary to continue the
* scan after this call.
*
* @exception  standardexception  standard exception policy.
**/
private void positionafterthispage
rowposition pos
throws standardexception
pos current_rh   null
pos current_pageno   pos current_page getpagenumber
/*
** methods of scanmanager
*/