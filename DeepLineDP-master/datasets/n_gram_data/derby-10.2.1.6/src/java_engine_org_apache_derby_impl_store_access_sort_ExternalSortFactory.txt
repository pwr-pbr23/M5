/*
derby - class org.apache.derby.impl.store.access.sort.externalsortfactory
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl store access sort
import java util properties
import org apache derby iapi services monitor modulecontrol
import org apache derby iapi services monitor modulesupportable
import org apache derby iapi services monitor monitor
import org apache derby iapi services property propertyutil
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi error standardexception
import org apache derby iapi store access conglomerate methodfactory
import org apache derby iapi store access conglomerate sort
import org apache derby iapi store access conglomerate sortfactory
import org apache derby iapi store access sortobserver
import org apache derby iapi store access sortcostcontroller
import org apache derby iapi store access columnordering
import org apache derby iapi store access transactioncontroller
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi services uuid uuidfactory
import org apache derby catalog uuid
/**
**/
public class externalsortfactory implements
sortfactory  modulecontrol  modulesupportable  sortcostcontroller
private boolean userspecified     did the user specify sortbuffermax
private int defaultsortbuffermax
private int sortbuffermax
private static final string implementationid
private static final string formatuuidstring
private uuid formatuuid   null
private static final int default_sortbuffermax   1024
private static final int minimum_sortbuffermax   4
protected static final int default_mem_use   1024 1024     aim for about 1meg
// how many sort runs to combined into a larger sort run
// (derby-1661)
protected static final int default_max_merge_run   512
// sizeof node + reference to node + 12 bytes tax
private static final int sort_row_overhead   8 4 12
/*
** methods of methodfactory
*/
/**
there are no default properties for the external sort..
@see methodfactory#defaultproperties
**/
public properties defaultproperties
return new properties
/**
@see methodfactory#supportsimplementation
**/
public boolean supportsimplementation string implementationid
return implementationid equals implementationid
/**
@see methodfactory#primaryimplementationtype
**/
public string primaryimplementationtype
return implementationid
/**
@see methodfactory#supportsformat
**/
public boolean supportsformat uuid formatid
return formatid equals formatuuid
/**
@see methodfactory#primaryformat
**/
public uuid primaryformat
return formatuuid
/*
** methods of sortfactory
*/
/**
create a sort.
this method could choose among different sort options,
depending on the properties etc., but currently it always
returns a merge sort.
@see sortfactory#createsort
**/
public sort createsort
transactioncontroller   tran
int                     segment
properties              implparameters
datavaluedescriptor   template
columnordering          columnordering
sortobserver          	sortobserver
boolean                 alreadyinorder
long                    estimatedrows
int                     estimatedrowsize
throws standardexception
mergesort sort   new mergesort
// resolve - mikem change this to use estimatedrows and
// estimatedrowsize to come up with a smarter number for sortbuffermax
// than a fixed number of rows.  at least 2 possibilities:
//     1) add sortbuffermaxmem which would be the amount of memory
//        the sorter could use, and then just pick the number of
//        rows as (sortbuffermaxmem / (estimatedrows * estimatedrowsize)
//     2) add sortbufferusepercentfree.  this would be how much of
//        the current free memory can the current sort use.
//
if   userspecified
// derby.storage.sortbuffermax is not specified by the
// user, use default or try to figure out a reasonable sort
// size.
// if we have some idea on row size, set sort approx 1 meg of
// memory sort.
if  estimatedrowsize > 0
//
// for each column, there is a reference from the key array and
//   the 4 bytes reference to the column object plus 12 bytes
//   tax on the  column object
// for each row, sort_row_overhead is the node and 4 bytes to
// point to the column array and 4 for alignment
//
estimatedrowsize    sort_row_overhead
template length  4 12     8
sortbuffermax   default_mem_use estimatedrowsize
else
sortbuffermax   defaultsortbuffermax
// if there are barely more rows than sortbuffermax, use 2
// smaller runs of similar size instead of one larger run
//
// 10% slush is added to estimated rows to catch the case where
// estimated rows underestimate the actual number of rows by 10%.
//
if  estimatedrows > sortbuffermax
estimatedrows 1 1  < sortbuffermax 2
sortbuffermax    int  estimatedrows 2   estimatedrows 10
// make sure it is at least the minimum sort buffer size
if  sortbuffermax < minimum_sortbuffermax
sortbuffermax   minimum_sortbuffermax
else
// if user specified derby.storage.sortbuffermax, use it.
sortbuffermax   defaultsortbuffermax
if  sanitymanager debug
if  sanitymanager debug_on
sanitymanager debug
sortbuffermax
estimatedrows
estimatedrowsize
defaultsortbuffermax
sort initialize
template  columnordering  sortobserver
alreadyinorder  estimatedrows  sortbuffermax
return sort
/**
* return an open sortcostcontroller.
* <p>
* return an open sortcostcontroller which can be used to ask about
* the estimated costs of sortcontroller() operations.
* <p>
*
* @return the open sortcostcontroller.
*
* @exception  standardexception  standard exception policy.
*
* @see sortcostcontroller
**/
public sortcostcontroller opensortcostcontroller
throws standardexception
return this
/*
** methods of sortcostcontroller
*/
public void close
// nothing to do.
/**
* short one line description of routine.
* <p>
* the sort algorithm is a n * log(n) algorithm.  the following numbers
* on a pii, 400 mhz machine, jdk117 with jit, insane.zip.  this test
* is a simple "select * from table order by first_int_column.  i then
* subtracted the time it takes to do "select * from table" from the
* result.
*
* number of rows       elaspsed time in seconds
* --------------       -----------------------------
* 1000                  0.20
* 10000                10.5
* 100000               80.0
*
* we assume that the formula for sort performance is of the form:
* performance = k * n * log(n).  solving the equation for the 1000
* and 100000 case we come up with:
*
* performance = 1 + 0.08 n ln(n)
*
* note: apparently, these measurements were done on a faster machine
* than was used for other performance measurements used by the optimizer.
* experiments show that the 0.8 multiplier is off by a factor of 4
* with respect to other measurements (such as the time it takes to
* scan a conglomerate).  i am correcting the formula to use 0.32
* rather than 0.08.
*
*					-	jeff
*
* <p>
* resolve (mikem) - this formula is very crude at the moment and will be
* refined later.  known problems:
* 1) internal vs. external sort - we know that the performance of sort
*    is discontinuous when we go from an internal to an external sort.
*    a better model is probably a different set of contants for internal
*    vs. external sort and some way to guess when this is going to happen.
* 2) current row size is never considered but is critical to performance.
* 3) estimatedexportrows is not used.  this is a critical number to know
*    if an internal vs. an external sort will happen.
*
* <p>
*
* @return the identifier to be used to open the conglomerate later.
*
*
* @exception  standardexception  standard exception policy.
**/
public double getsortcost
datavaluedescriptor   template
columnordering          columnordering
boolean                 alreadyinorder
long                    estimatedinputrows
long                    estimatedexportrows
int                     estimatedrowsize
throws standardexception
/* avoid taking the log of 0 */
if  estimatedinputrows    0
return 0 0
// resolve - come up with some real benchmark.  for now the cost
// of sort is 3 times the cost of scanning the data.
if  sanitymanager debug
sanitymanager assert estimatedinputrows  >  0
sanitymanager assert estimatedexportrows >  0
double ret_val
1
0 32     estimatedinputrows    math log estimatedinputrows
return ret_val
/*
** methods of modulecontrol.
*/
public boolean cansupport properties startparams
if  startparams    null
return false
string impl   startparams getproperty
if  impl    null
return false
return supportsimplementation impl
public void	boot boolean create  properties startparams
throws standardexception
// find the uuid factory.
uuidfactory uuidfactory   monitor getmonitor   getuuidfactory
// make a uuid that identifies this sort's format.
formatuuid   uuidfactory recreateuuid formatuuidstring
// see if there's a new maximum sort buffer size.
defaultsortbuffermax   propertyutil getsystemint
0  integer max_value  0
// if defaultsortbuffermax is 0, the user did not specify
// sortbuffermax, then just set it to default_sortbuffermax.
// if defaultsortbuffermax is not 0, the user specified sortbuffermax,
// do not override it.
if  defaultsortbuffermax    0
userspecified   false
defaultsortbuffermax   default_sortbuffermax
else
userspecified   true
if  defaultsortbuffermax < minimum_sortbuffermax
defaultsortbuffermax   minimum_sortbuffermax
public void	stop