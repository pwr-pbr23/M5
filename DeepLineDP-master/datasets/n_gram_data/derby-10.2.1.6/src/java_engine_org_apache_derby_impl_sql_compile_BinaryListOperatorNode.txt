/*
derby - class org.apache.derby.impl.sql.compile.binarylistoperatornode
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package	org apache derby impl sql compile
import org apache derby iapi error standardexception
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi reference sqlstate
import org apache derby iapi types datatypedescriptor
import org apache derby iapi types typeid
import org apache derby iapi sql compile visitor
import org apache derby iapi sql compile visitable
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi store access qualifier
import org apache derby iapi util jbitset
import java util vector
/**
* a binarylistoperatornode represents a built-in "binary" operator with a single
* operand on the left of the operator and a list of operands on the right.
* this covers operators such as in and between.
*
* @author jerry brenner
*/
public abstract class binarylistoperatornode extends valuenode
string	methodname
/* operator used for error messages */
string	operator
string		leftinterfacetype
string		rightinterfacetype
valuenode		receiver     used in generation
valuenode		leftoperand
valuenodelist	rightoperandlist
/**
* initializer for a binarylistoperatornode
*
* @param leftoperand		the left operand of the node
* @param rightoperandlist	the right operand list of the node
* @param operator			string representation of operator
*/
public void init object leftoperand  object rightoperandlist
object operator  object methodname
this leftoperand    valuenode  leftoperand
this rightoperandlist    valuenodelist  rightoperandlist
this operator    string  operator
this methodname    string  methodname
/**
* convert this object to a string.  see comments in querytreenode.java
* for how this should be done for tree printing.
*
* @return	this object as a string
*/
public string tostring
if  sanitymanager debug
return     operator
methodname
super tostring
else
return
/**
* prints the sub-nodes of this object.  see querytreenode.java for
* how tree printing is supposed to work.
*
* @param depth		the depth of this node in the tree
*/
public void printsubnodes int depth
if  sanitymanager debug
super printsubnodes depth
if  leftoperand    null
printlabel depth
leftoperand treeprint depth   1
if  rightoperandlist    null
printlabel depth
rightoperandlist treeprint depth   1
/**
* set the clause that this node appears in.
*
* @param clause	the clause that this node appears in.
*/
public void setclause int clause
super setclause clause
leftoperand setclause clause
rightoperandlist setclause clause
/**
* bind this expression.  this means binding the sub-expressions,
* as well as figuring out what the return type is for this expression.
*
* @param fromlist		the from list for the query this
*				expression is in, for binding columns.
* @param subquerylist		the subquery list being built as we find subquerynodes
* @param aggregatevector	the aggregate vector being built as we find aggregatenodes
*
* @return	the new top of the expression tree.
*
* @exception standardexception		thrown on error
*/
public valuenode bindexpression
fromlist fromlist  subquerylist subquerylist
vector	aggregatevector
throws standardexception
leftoperand   leftoperand bindexpression fromlist  subquerylist  aggregatevector
rightoperandlist bindexpression fromlist  subquerylist  aggregatevector
/* is there a ? parameter on the left? */
if  leftoperand requirestypefromcontext
valuenode rightoperand    valuenode  rightoperandlist elementat 0
/*
** it's an error if both operands are all ? parameters.
*/
if  rightoperandlist containsallparameternodes
throw standardexception newexception sqlstate lang_binary_operands_both_parms
operator
/* set the left operand to the type of right parameter. */
leftoperand settype rightoperandlist gettypeservices
/* is there a ? parameter on the right? */
if  rightoperandlist containsparameternode
/* set the right operand to the type of the left parameter. */
rightoperandlist setparameterdescriptor leftoperand gettypeservices
/* if the left operand is not a built-in type, then generate a conversion
* tree to a built-in type.
*/
if  leftoperand gettypeid   usertype
leftoperand   leftoperand gensqljavasqltree
/* generate bound conversion trees for those elements in the rightoperandlist
* that are not built-in types.
*/
rightoperandlist gensqljavasqltrees
/* test type compatability and set type info for this node */
bindcomparisonoperator
return this
/**
* test the type compatability of the operands and set the type info
* for this node.  this method is useful both during binding and
* when we generate nodes within the language module outside of the parser.
*
* @exception standardexception		thrown on error
*/
public void bindcomparisonoperator
throws standardexception
boolean				nullableresult
/* can the types be compared to each other? */
rightoperandlist comparable leftoperand
/*
** set the result type of this comparison operator based on the
** operands.  the result type is always sqlboolean - the only question
** is whether it is nullable or not.  if either the leftoperand or
** any of the elements in the rightoperandlist is
** nullable, the result of the comparison must be nullable, too, so
** we can represent the unknown truth value.
*/
nullableresult   leftoperand gettypeservices   isnullable
rightoperandlist isnullable
settype new datatypedescriptor typeid boolean_id  nullableresult
/**
* preprocess an expression tree.  we do a number of transformations
* here (including subqueries, in lists, like and between) plus
* subquery flattening.
* note: this is done before the outer resultsetnode is preprocessed.
*
* @param	numtables			number of tables in the dml statement
* @param	outerfromlist		fromlist from outer query block
* @param	outersubquerylist	subquerylist from outer query block
* @param	outerpredicatelist	predicatelist from outer query block
*
* @return		the modified expression
*
* @exception standardexception		thrown on error
*/
public valuenode preprocess int numtables
fromlist outerfromlist
subquerylist outersubquerylist
predicatelist outerpredicatelist
throws standardexception
leftoperand   leftoperand preprocess numtables
outerfromlist  outersubquerylist
outerpredicatelist
rightoperandlist preprocess numtables
outerfromlist  outersubquerylist
outerpredicatelist
return this
/**
* set the leftoperand to the specified valuenode
*
* @param newleftoperand	the new leftoperand
*/
public void setleftoperand valuenode newleftoperand
leftoperand   newleftoperand
/**
* get the leftoperand
*
* @return the current leftoperand.
*/
public valuenode getleftoperand
return leftoperand
/**
* set the rightoperandlist to the specified valuenodelist
*
* @param newrightoperandlist	the new rightoperandlist
*
*/
public void setrightoperandlist valuenodelist newrightoperandlist
rightoperandlist   newrightoperandlist
/**
* get the rightoperandlist
*
* @return the current rightoperandlist.
*/
public valuenodelist getrightoperandlist
return rightoperandlist
/**
* categorize this predicate.  initially, this means
* building a bit map of the referenced tables for each predicate.
* if the source of this columnreference (at the next underlying level)
* is not a columnreference or a virtualcolumnnode then this predicate
* will not be pushed down.
*
* for example, in:
*		select * from (select 1 from s) a (x) where x = 1
* we will not push down x = 1.
* note: it would be easy to handle the case of a constant, but if the
* inner select returns an arbitrary expression, then we would have to copy
* that tree into the pushed predicate, and that tree could contain
* subqueries and method calls.
* resolve - revisit this issue once we have views.
*
* @param referencedtabs	jbitset with bit map of referenced fromtables
* @param simplepredsonly	whether or not to consider method
*							calls, field references and conditional nodes
*							when building bit map
*
* @return boolean		whether or not source.expression is a columnreference
*						or a virtualcolumnnode.
* @exception standardexception			thrown on error
*/
public boolean categorize jbitset referencedtabs  boolean simplepredsonly
throws standardexception
boolean pushable
pushable   leftoperand categorize referencedtabs  simplepredsonly
pushable    rightoperandlist categorize referencedtabs  simplepredsonly     pushable
return pushable
/**
* remap all columnreferences in this tree to be clones of the
* underlying expression.
*
* @return valuenode			the remapped expression tree.
*
* @exception standardexception			thrown on error
*/
public valuenode remapcolumnreferencestoexpressions
throws standardexception
// we need to assign back because a new object may be returned, beetle 4983
leftoperand   leftoperand remapcolumnreferencestoexpressions
rightoperandlist remapcolumnreferencestoexpressions
return this
/**
* return whether or not this expression tree represents a constant expression.
*
* @return	whether or not this expression tree represents a constant expression.
*/
public boolean isconstantexpression
return  leftoperand isconstantexpression
rightoperandlist isconstantexpression
/** @see valuenode#constantexpression */
public boolean constantexpression predicatelist whereclause
return  leftoperand constantexpression whereclause
rightoperandlist constantexpression whereclause
/**
* return the variant type for the underlying expression.
* the variant type can be:
*		variant				- variant within a scan
*							  (method calls and non-static field access)
*		scan_invariant		- invariant within a scan
*							  (column references from outer tables)
*		query_invariant		- invariant within the life of a query
*		constant			- immutable
*
* @return	the variant type for the underlying expression.
* @exception standardexception	thrown on error
*/
protected int getorderablevarianttype   throws standardexception
int lefttype   leftoperand getorderablevarianttype
int righttype   rightoperandlist getorderablevarianttype
return math min lefttype  righttype
/**
* accept a visitor, and call v.visit()
* on child nodes as necessary.
*
* @param v the visitor
*
* @exception standardexception on error
*/
public visitable accept visitor v
throws standardexception
visitable		returnnode   v visit this
if  v skipchildren this
return returnnode
if  leftoperand    null     v stoptraversal
leftoperand    valuenode leftoperand accept v
if  rightoperandlist    null     v stoptraversal
rightoperandlist    valuenodelist rightoperandlist accept v
return returnnode
/**
* @inheritdoc
*/
protected boolean isequivalent valuenode o  throws standardexception
if   issamenodetype o
return false
binarylistoperatornode other    binarylistoperatornode o
if   operator equals other operator
leftoperand isequivalent other getleftoperand
return false
int sz   getrightoperandlist   size
if  sz    other rightoperandlist size
return false
for  int i   0  i < sz  i
valuenode e    valuenode rightoperandlist elementat i
if   e isequivalent  valuenode other rightoperandlist elementat i
return false
return true