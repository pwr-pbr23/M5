/*
derby - class org.apache.derby.iapi.sql.compile.optimizer
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby iapi sql compile
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi sql dictionary tabledescriptor
import org apache derby iapi sql dictionary conglomeratedescriptor
import org apache derby iapi error standardexception
import org apache derby iapi util jbitset
/**
* optimizer provides services for optimizing a query.
* resolve:
*	o  need to figure out what to do about subqueries, figuring out
*	   their attachment points and how to communicate them back to the
*	   caller.
*/
public interface optimizer
/**
module name for the monitor's module locating system.
*/
string module
/**
property name for controlling whether to do join order optimization.
*/
string join_order_optimization
/**
property name for controlling whether to do rule-based optimization,
as opposed to cost-based optimization.
*/
string rule_based_optimization
/**
property name for controlling whether the optimizer ever times out
while optimizing a query and goes with the best plan so far.
*/
string no_timeout
/**
property name for controlling the maximum size of memory (in kb)
the optimizer can use for each table.  if an access path takes
memory larger than that size for a table, the access path is skipped.
default is 1024 (kb).
*/
string max_memory_per_table
/**
maximum size of dynamically created materialized rows. caching large results
use lot of memory and can cause stack overflow. see derby-634
*/
int max_dynamic_materialized_rows   512
/**
property name for disabling statistics use for all queries.
*/
string use_statistics
/** indicates a "normal" plan that is not optimized to do sort avoidance */
int normal_plan   1
/** indicates a sort-avoidance plan */
int sort_avoidance_plan   2
// optimizer trace
public static final int started   1
public static final int time_exceeded  2
public static final int no_tables   3
public static final int complete_join_order   4
public static final int cost_of_sorting   5
public static final int no_best_plan   6
public static final int modifying_access_paths   7
public static final int short_circuiting   8
public static final int skipping_join_order   9
public static final int illegal_user_join_order   10
public static final int user_join_order_optimized   11
public static final int considering_join_order   12
public static final int total_cost_non_sa_plan   13
public static final int total_cost_sa_plan   14
public static final int total_cost_with_sorting   15
public static final int current_plan_is_sa_plan   16
public static final int cheapest_plan_so_far   17
public static final int plan_type   18
public static final int cost_of_cheapest_plan_so_far   19
public static final int sort_needed_for_ordering   20
public static final int remembering_best_join_order   21
public static final int skipping_due_to_excess_memory   22
public static final int cost_of_n_scans   23
public static final int hj_skip_not_materializable   24
public static final int hj_skip_no_join_columns   25
public static final int hj_hash_key_columns   26
public static final int calling_on_join_node   27
public static final int considering_join_strategy   28
public static final int remembering_best_access_path   29
public static final int no_more_conglomerates   30
public static final int considering_conglomerate   31
public static final int scanning_heap_full_match_on_unique_key   32
public static final int adding_unordered_optimizable   33
public static final int changing_access_path_for_table   34
public static final int table_lock_no_start_stop   35
public static final int non_covering_index_cost   36
public static final int row_lock_all_constant_start_stop   37
public static final int estimating_cost_of_conglomerate   38
public static final int looking_for_specified_index   39
public static final int match_single_row_cost   40
public static final int cost_including_extra_1st_col_selectivity   41
public static final int calling_next_access_path   42
public static final int table_lock_over_threshold   43
public static final int row_lock_under_threshold   44
public static final int cost_including_extra_start_stop   45
public static final int cost_including_extra_qualifier_selectivity   46
public static final int cost_including_extra_nonqualifier_selectivity   47
public static final int cost_of_noncovering_index   48
public static final int remembering_join_strategy   49
public static final int remembering_best_access_path_substring   50
public static final int remembering_best_sort_avoidance_access_path_substring   51
public static final int remembering_best_unknown_access_path_substring   52
public static final int cost_of_conglomerate_scan1   53
public static final int cost_of_conglomerate_scan2   54
public static final int cost_of_conglomerate_scan3   55
public static final int cost_of_conglomerate_scan4   56
public static final int cost_of_conglomerate_scan5   57
public static final int cost_of_conglomerate_scan6   58
public static final int cost_of_conglomerate_scan7   59
public static final int cost_including_composite_sel_from_stats  60
public static final int composite_sel_from_stats   61
public static final int cost_including_stats_for_index   62
/**
* iterate through the permutations, returning false when the permutations
* are exhausted.
* note - implementers are responsible for hiding tree pruning of permutations
* behind this method call.
*
* @return boolean	true - an optimizable permutation remains.
*					false - permutations are exhausted.
*
* @exception standardexception		thrown on error
*/
public boolean getnextpermutation   throws standardexception
/**
* iterate through the "decorated permutations", returning false when they
* are exhausted.
* note - implementers are responsible for hiding tree pruning of access
* methods behind this method call.
*
* @return boolean	true - an optimizable decorated permutation remains.
*					false - decorated permutations are exhausted.
*
* @exception standardexception		thrown on error
*/
public boolean getnextdecoratedpermutation   throws standardexception
/**
* cost the current permutation.
* caller is responsible for pushing all predicates which can be evaluated
* prior to costing.
*
* @exception standardexception		thrown on error
*/
public void costpermutation   throws standardexception
/**
* cost the current optimizable with the specified opl.
* caller is responsible for pushing all predicates which can be evaluated
* prior to costing.
*
* @param optimizable	the optimizable
* @param td			tabledescriptor of the optimizable
* @param cd			the conglomeratedescriptor for the conglom to cost
*						(this should change to an object to represent
*						access paths, but for now this is ok).
* @param predlist		the optimizablepredicatelist to apply
* @param outercost		the cost of the tables outer to the one being
*						optimizer - tells how many outer rows there are.
*
* @exception standardexception		thrown on error
*/
public void	costoptimizable optimizable optimizable
tabledescriptor td
conglomeratedescriptor cd
optimizablepredicatelist predlist
costestimate outercost
throws standardexception
/**
* consider the cost of the given optimizable.  this method is like
* costoptimizable, above, but it is used when the optimizable does
* not need help from the optimizer in costing the optimizable (in practice,
* all optimizables except frombasetable use this method.
*
* caller is responsible for pushing all predicates which can be evaluated
* prior to costing.
*
* @param optimizable	the optimizable
* @param predlist		the optimizablepredicatelist to apply
* @param estimatedcost	the estimated cost of the given optimizable
* @param outercost		the cost of the tables outer to the one being
*						optimizer - tells how many outer rows there are.
*
* @exception standardexception		thrown on error
*/
public void	considercost optimizable optimizable
optimizablepredicatelist predlist
costestimate estimatedcost
costestimate outercost
throws standardexception
/**
* return the datadictionary that the optimizer is using.
* this is useful when an optimizable needs to call optimize() on
* a child resultsetnode.
*
* @return datadictionary	datadictionary that the optimizer is using.
*/
public datadictionary getdatadictionary
/**
* modify the access path for each optimizable, as necessary.  this includes
* things like adding result sets to translate from index rows to base rows.
*
* @exception standardexception		thrown on error
*/
public void modifyaccesspaths   throws standardexception
/** get a new costestimate object */
public costestimate newcostestimate
/** get the estimated cost of the optimized query */
public costestimate getoptimizedcost
/**
* get the final estimated cost of the optimized query.  this
* should be the cost that corresponds to the best overall join
* order chosen by the optimizer, and thus this method should
* only be called after optimization is complete (i.e. when
* modifying access paths).
*/
public costestimate getfinalcost
/**
* prepare for another round of optimization.
*
* this method is called before every "round" of optimization, where
* we define a "round" to be the period between the last time a call to
* getoptimizer() (on either a resultsetnode or an optimizerfactory)
* returned _this_ optimizer and the time a call to this optimizer's
* getnextpermutation() method returns false.  any re-initialization
* of state that is required before each round should be done in this
* method.
*/
public void prepfornextround
/**
* set the estimated number of outer rows - good for optimizing nested
* optimizables like subqueries and join nodes.
*/
public void setouterrows double outerrowcount
/**
* get the number of join strategies supported by this optimizer.
*/
public int getnumberofjoinstrategies
/**
* get the maximum number of estimated rows touched in a table before
* we decide to open the table with table locking (as opposed to row
* locking.
*/
public int tablelockthreshold
/**
* gets a join strategy by number (zero-based).
*/
joinstrategy getjoinstrategy int whichstrategy
/**
* gets a join strategy by name.  returns null if not found.
* the look-up is case-insensitive.
*/
joinstrategy getjoinstrategy string whichstrategy
/**
* optimizer trace.
*/
public void trace int traceflag  int intparam1  int intparam2
double doubleparam  object objectparam1
/**
* get the level of this optimizer.
*
* @return the level of this optimizer.
*/
public int getlevel
/**
* tells whether any of the tables outer to the current one
* has a uniqueness condition on the given predicate list,
* and if so, how many times each unique key can be seen by
* the current table.
*
* @param predlist		the predicate list to check
*
* @return	<= 0 means there is no uniqueness condition
*			> 0 means there is a uniqueness condition on an
*			outer table, and the return value is the reciprocal of
*			the maximum number of times the optimizer estimates that each
*			unique key will be returned. for example, 0.5 means the
*			optimizer thinks each distinct join key will be returned
*			at most twice.
*
* @exception standardexception		thrown on error
*/
double uniquejoinwithoutertable optimizablepredicatelist predlist
throws standardexception
/**
* if statistics should be considered by the optimizer while optimizing
* a query. the user may disable the use of statistics by setting the
* property derby.optimizer.usestatistics or by using the property
* usestatistics in a query.
*
* @see #use_statistics
*/
public boolean usestatistics
/**
* @return the maximum number of bytes to be used per table.
*/
public int getmaxmemorypertable