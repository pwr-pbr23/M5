/*
derby - class org.apache.derby.impl.store.raw.data.basecontainerhandle
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl store raw data
import org apache derby iapi reference sqlstate
import org apache derby iapi services locks lockable
import org apache derby iapi services locks virtuallocktable
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi error standardexception
import org apache derby iapi store access spaceinfo
import org apache derby iapi store raw containerhandle
import org apache derby iapi store raw containerlock
import org apache derby iapi store raw lockingpolicy
import org apache derby iapi store raw page
import org apache derby iapi store raw pagekey
import org apache derby iapi store raw pagetimestamp
import org apache derby iapi store raw recordhandle
import org apache derby iapi store raw containerkey
import org apache derby iapi store raw data rawcontainerhandle
import org apache derby iapi store raw xact rawtransaction
import org apache derby iapi store raw log loginstant
import org apache derby iapi util bytearray
import org apache derby catalog uuid
import java util hashtable
import java util observable
import java util observer
import java util properties
/**
a handle to an open container, implememts rawcontainerhandle.
<p>
this class is an observer to observe rawtransactions
and is also a observable to
handle the list of pages accessed thorough this handle.
<br>
this class implements lockable (defined to be containerhandle) and is
the object used to logically lock the container.
<br> mt - mutable - immutable identity - thread aware
*/
public class basecontainerhandle extends observable
implements rawcontainerhandle  observer
/*
** fields
*/
/**
container identifier
<br> mt - immutable
*/
protected   final   containerkey		identity
/**
is this containerhandle active.
<br> mt - mutable : scoped
*/
protected boolean				active
/**
the actual container we are accessing. only valid when active is true.
<br> mt - mutable : scoped
*/
protected basecontainer		container
/**
the locking policy we opened the container with.
only valid when active is true.
<br> mt - mutable : scoped
*/
private	lockingpolicy		locking
/**
our transaction. only valid when active is true.
<br> mt - mutable : scoped
*/
protected	rawtransaction		xact
/**
are we going to update?
<br> mt - immutable after container handle becomes active
*/
private	boolean		forupdate
protected int mode 	   mode the container was opened in
protected pageactions		actionsset
protected allocationactions allocactionsset
/*
** constructor
*/
/**
create an object that is only used for locking the container.
*/
public basecontainerhandle uuid rawstoreid  rawtransaction xact
containerkey identity  lockingpolicy locking  int mode
this identity   identity
this xact   xact
this locking   locking
this mode   mode
this forupdate    mode   mode_forupdate     mode_forupdate
/**
create a container handle that is used to actually access the container.
*/
public basecontainerhandle
uuid                rawstoreid
rawtransaction      xact
pageactions         actionsset
allocationactions   allocactionsset
lockingpolicy       locking
basecontainer       container
int                 mode
this rawstoreid  xact
containerkey  container getidentity    locking  mode
this actionsset        actionsset
this allocactionsset   allocactionsset
this container         container
// we are inactive until usecontainer is called.
/*
** methods from containerhandle
*/
/**
add a page to the container
the page returned will be observing me.
@see basecontainer#addpage
@see containerhandle#addpage
@exception standardexception standard cloudscape error policy
*/
public page addpage   throws standardexception
checkupdateopen
page page   container addpage this  false    not an overflow page
return page
/**
release free space to the os.
<p>
as is possible release any free space to the operating system.  this
will usually mean releasing any free pages located at the end of the
file using the java truncate() interface.
@exception standardexception	standard cloudscape error policy
*/
public void compresscontainer   throws standardexception
checkupdateopen
container compresscontainer this
/**
* get the reusable recordid sequence number.
* @return version sequence number
* @exception standardexception	standard derby error policy
* @see containerhandle#getreusablerecordidsequencenumber
*/
public long getreusablerecordidsequencenumber   throws standardexception
checkopen
return container getreusablerecordidsequencenumber
/**
add a page to the container, if flag == containerhandle.add_page_bulk,
tell the container about it.
the page returned will be observing me.
@see basecontainer#addpage
@see containerhandle#addpage
@exception standardexception standard cloudscape error policy
*/
public page addpage int flag  throws standardexception
if   flag   containerhandle add_page_bulk     0    active    forupdate
// start preallocating immediatelly, don't wait for the
// preallocation threshold to be crossed.  don't go wild and
// preallocate a bunch of pages either, use preallocate for that.
container clearpreallocthreshold
return addpage
/**
preallocate numpage if possible.
*/
public void preallocate int numpage
if  numpage > 0    active    forupdate
container prepareforbulkload this  numpage
/**
* request the system properties associated with a container.
* <p>
* request the value of properties that are associated with a container.
* the following properties can be requested:
*     derby.storage.pagesize
*     derby.storage.pagereservedspace
*     derby.storage.minimumrecordsize
* <p>
* to get the value of a particular property add it to the property list,
* and on return the value of the property will be set to it's current
* value.  for example:
*
* get_prop(basecontainerhandle ch)
* {
*     properties prop = new properties();
*     prop.put("derby.storage.pagesize", "");
*     ch.getcontainerproperties(prop);
*
*     system.out.println(
*         "conatainer's page size = " +
*         prop.getproperty("derby.storage.pagesize");
* }
*
* @param prop   property list to fill in.
*
* @exception  standardexception  standard exception policy.
**/
public void getcontainerproperties properties prop
throws standardexception
checkopen
container getcontainerproperties prop
return
/**
remove a page from the container.
@see containerhandle#removepage
@exception standardexception standard cloudscape error policy
*/
public void removepage page page  throws standardexception
if   active
if  page    null
page unlatch
throw standardexception newexception
sqlstate data_container_closed
if   forupdate
if  page    null
page unlatch
throw standardexception newexception
sqlstate data_container_read_only
container removepage this   basepage page
public page getpage long pagenumber  throws standardexception
checkopen
return container getpage this  pagenumber  true
public page getallocpage long pagenumber  throws standardexception
checkopen
return container getallocpage this  pagenumber  true
public page getuserpagenowait long pagenumber
throws standardexception
checkopen
return container getheadpage this  pagenumber  false
public page getuserpagewait long pagenumber
throws standardexception
checkopen
return container getheadpage this  pagenumber  true
public page getpagenowait long pagenumber
throws standardexception
checkopen
return container getpage this  pagenumber  false
public page getfirstpage   throws standardexception
checkopen
return container getfirstpage this
public page getnextpage long pagenumber  throws standardexception
checkopen
return container getnextpage this  pagenumber
public page getpageforinsert int flag
throws standardexception
checkupdateopen
return container getpageforinsert this  flag
public page getpageforcompress int flag  long pageno
throws standardexception
checkupdateopen
return container getpageforcompress this  flag  pageno
/**
@see containerhandle#isreadonly()
*/
public final boolean isreadonly
return  forupdate
/**
@see containerhandle#close
*/
public void close
if  xact    null
// probably be closed explicitly by a client, after closing
// automatically after an abort.
if  sanitymanager debug
sanitymanager assert  active
return
// notify our observers (pages) that we are closing ...
informobservers
active   false
getlockingpolicy   unlockcontainer xact  this
// let go of the container
if  container    null
container letgo this
container   null
// and remove ourseleves from this transaction
xact deleteobserver this
xact   null
/* cost estimation */
/**
@see containerhandle#getestimatedrowcount
@exception standardexception standard cloudscape error policy
*/
public long getestimatedrowcount int flag  throws standardexception
checkopen
return container getestimatedrowcount flag
/**
@see containerhandle#setestimatedrowcount
@exception standardexception standard cloudscape error policy
*/
public void setestimatedrowcount long count  int flag
throws standardexception
checkopen
container setestimatedrowcount count  flag
/**
@see containerhandle#getestimatedpagecount
@exception standardexception standard cloudscape error policy
*/
public long getestimatedpagecount int flag
throws standardexception
checkopen
return container getestimatedpagecount this  flag
/**
@see containerhandle#flushcontainer
@exception standardexception standard cloudscape error policy
*/
public void flushcontainer
throws standardexception
checkupdateopen
// raw store may override unlog mode when log is archived.
// if ((mode & mode_create_unlogged) == 0)
//	throw standardexception.newexception(
//	    sqlstate.data_not_create_unlogged, identity);
container flushall
/**
@see containerhandle#compactrecord
@exception standardexception standard cloudscape error policy
*/
public void compactrecord recordhandle record
throws standardexception
if   forupdate
throw standardexception newexception
sqlstate data_container_read_only
pagekey pkey    pagekey record getpageid
basepage headpage    basepage getpage pkey getpagenumber
if  headpage    null
// the page could have been null if it was deallocated after the
// row lock is gotten.  we are doing all of these post commit so
// the record may not even be there and we got a lock for nothing.
try
headpage compactrecord record
finally
headpage unlatch
/*
** methods of rawcontainerhandle - methods are called underneath the log
*/
/**
get the container status.
@exception standardexception standard cloudscape error policy
@see rawcontainerhandle#getcontainerstatus
*/
public int getcontainerstatus   throws standardexception
checkopen
return container getcontainerstatus
/**
remove the container
@exception standardexception standard cloudscape error policy
@see rawcontainerhandle#removecontainer
*/
public void removecontainer loginstant instant  throws standardexception
checkupdateopen
// this call can only be issued by within rawstore.
// while the container is dropped, no client of raw store
// should be able to access the container (it is
// exclusively locked).
// then as postcommit processing,
// the container iw
container removecontainer instant  true
/**
@see containerhandle#getid
*/
public containerkey getid
return identity
/**
@see containerhandle#getuniqueid
*/
public object getuniqueid
return this
/**
@exception standardexception  standard cloudscape exception policy
@see rawcontainerhandle#dropcontainer
*/
public void dropcontainer loginstant instant  boolean drop
throws standardexception
checkupdateopen
container dropcontainer instant  drop
/**
@exception standardexception  standard cloudscape exception policy
@see rawcontainerhandle#getcontainerversion
*/
public long getcontainerversion
throws standardexception
checkopen
return container getcontainerversion
/**
get this page with no check - any page type or status is fine.
caller must be prepared to handle freed, deallocated,or alloc page
called by recovery only.
@exception standardexception cloudscape standard error policy
*/
public page getanypage long pagenumber  throws standardexception
checkopen
return container getanypage this  pagenumber  true    wait
/**
* recreate a page for rollforward recovery.
* <p>
* during redo recovery it is possible for the system to try to redo
* the creation of a page (ie. going from non-existence to version 0).
* it first trys to read the page from disk, but a few different types
* of errors can occur:
*     o the page does not exist at all on disk, this can happen during
*       rollforward recovery applied to a backup where the file was
*       copied and the page was added to the file during the time frame
*       of the backup but after the physical file was copied.
*     o space in the file exists, but it was never initalized.  this
*       can happen if you happen to crash at just the right moment during
*       the allocation process.  also
*       on some os's it is possible to read from a part of the file that
*       was not ever written - resulting in garbage from the store's
*       point of view (often the result is all 0's).
*
* all these errors are easy to recover from as the system can easily
* create a version 0 from scratch and write it to disk.
*
* because the system does not sync allocation of data pages, it is also
* possible at this point that whlie writing the version 0 to disk to
* create it we may encounter an out of disk space error (caught in this
* routine as a standardexception from the create() call.  we can't
* recovery from this without help from outside, so the caught exception
* is nested and a new exception thrown which the recovery system will
* output to the user asking them to check their disk for space/errors.
*
* @exception  standardexception  standard exception policy.
**/
public page recreatepageforredorecovery
int     pageformat
long    pagenumber
long    pageoffset
throws standardexception
checkupdateopen
return container recreatepageforredorecovery
this  pageformat  pagenumber  pageoffset
/**
log all information necessary to recreate the container during a load
tran.
@exception standardexception standard cloudscape error policy
*/
public bytearray logcreatecontainerinfo
throws standardexception
checkupdateopen
return container logcreatecontainerinfo
/**
return a record handle that is initialized to the given page number and
record id.
@exception standardexception standard cloudscape exception policy.
@param pagenumber   the page number of the recordhandle.
@param recordid     the record id of the recordhandle.
@see recordhandle
*/
public recordhandle makerecordhandle long pagenumber  int recordid
throws	standardexception
return new recordid identity  pagenumber  recordid
/*
**	methods of observer
*/
/**
called when the transaction is about to complete.
@see observer#update
*/
public void update observable obj  object arg
if  sanitymanager debug
if  arg    null
sanitymanager throwassert     this
// already been removed from the list
if  xact    null
return
if  sanitymanager debug
// just check reference equality
if  obj    xact
sanitymanager throwassert
xact       obj
// close on a commit, abort or drop of this container.
if  arg equals rawtransaction commit
arg equals rawtransaction abort
arg equals identity
// close the container
close
return
if  arg equals rawtransaction savepoint_rollback
// unlatch any pages but remain open
informobservers
// remain open
return
// transaction is notifying us that our container
// has undergone some lock escalation. we re-get
// our table lock which will promote us
// if possible
if  arg equals rawtransaction lock_escalate
// only attempt escalation on rowlocking modes.
if  getlockingpolicy   getmode      lockingpolicy mode_record
return
try
getlockingpolicy   lockcontainer
gettransaction    this  false  forupdate
catch  standardexception se
xact setobserverexception se
/*
** implementation specific methods, these are public so that they can be
** called in other packages that are specific implementations of data, ie.
** a directory at the level
**
** com.ibm.db2j.impl.database.storage.rawstore.data.*
*/
public pageactions getactionset
return actionsset
public allocationactions getallocationactionset
return allocactionsset
/**
attach me to a container. if this method returns false then
i cannot be used anymore, and any reference to me must be discarded.
@param droppedok if true, use this container even if it is dropped,
otherwise, return false if container is dropped.
@param waitforlock if true, wait on lock, otherwise, get lock no wait.
@exception standardexception standard cloudscape error policy
*/
public boolean usecontainer
boolean droppedok
boolean waitforlock
throws standardexception
if  sanitymanager debug
sanitymanager assert  active
boolean gotlock
getlockingpolicy   lockcontainer
gettransaction    this  waitforlock  forupdate
if  gotlock    false
// this is a lockingpolicy error, if waitforlock should either
// return true or throw a deadlock exception
if  sanitymanager debug
sanitymanager assert waitforlock    false
container   null
throw standardexception newexception sqlstate lock_timeout
if   mode   containerhandle mode_open_for_lock_only     0
if  sanitymanager debug
sanitymanager assert container    null
if   container use this  forupdate  droppedok
// if we got a lock, but for some reason we can't open the
// table (like it doesn't exist), then call unlockcontainer().
// in the normal case it would be called when the container
// handle was closed, but in this case the user is never going
// to get an "open" container handle back.  we can't call
// close() here as we haven't done all the "open" stuff.
getlockingpolicy   unlockcontainer xact  this
container   null
return false
active   true
else
// lock only, we only observe the transaction if
// we are performing row level locking.
if  getlockingpolicy   getmode      lockingpolicy mode_record
return true
// watch transaction so we will close handle just before xact completes.
xact addobserver this
// add special objects implementing certain behaviour at commit/rollback
if   mode    containerhandle mode_readonly
containerhandle mode_no_actions_on_commit      0
if   mode   mode_truncate_on_commit     mode_truncate_on_commit
xact addobserver
new truncateoncommit identity  true    always
else if   mode   mode_truncate_on_rollback
mode_truncate_on_rollback
xact addobserver
new truncateoncommit identity  false    rollbacks only
if   mode   mode_drop_on_commit     mode_drop_on_commit
xact addobserver new droponcommit identity
if   mode   mode_flush_on_commit     mode_flush_on_commit
xact addobserver new synconcommit identity
return true
/**
return the rawtransaction i was opened in.
*/
public final rawtransaction gettransaction
return xact
/**
return my locking policy, may be different from the transaction's
default locking policy.
*/
public final lockingpolicy getlockingpolicy
if  sanitymanager debug
sanitymanager assert locking    null
return locking
public final void setlockingpolicy lockingpolicy newlockingpolicy
locking   newlockingpolicy
/**
was i opened for updates?
<p>
<br> mt - thread safe
*/
public final boolean updateok
return forupdate
/**
get the mode i was opened with.
*/
public int getmode
return mode
/**
the container is about to be modified.
loggable actions use this to make sure the container gets cleaned if a
checkpoint is taken after any log record is sent to the log stream but
before the container is actually dirtied.
@exception standardexception standard cloudscape error policy
*/
public void predirty boolean predirtyon  throws standardexception
checkupdateopen
container predirty predirtyon
/**
@see containerhandle#istemporarycontainer
@exception standardexception standard cloudscape error policy
*/
public boolean istemporarycontainer   throws standardexception
checkopen
return  identity    null
identity getsegmentid      containerhandle temporary_segment
/*
** implementation specific methods for myself and my sub-classes
*/
protected void checkopen   throws standardexception
if   active
throw standardexception newexception
sqlstate data_container_closed
private void checkupdateopen   throws standardexception
if   active
throw standardexception newexception
sqlstate data_container_closed
if   forupdate
throw standardexception newexception
sqlstate data_container_read_only
protected void informobservers
// notify our observers (pages) that we are closing,
// or undergoing some state change ...
if  countobservers      0
setchanged
notifyobservers
/**
get information about space used by the container.
**/
public spaceinfo getspaceinfo
throws standardexception
return container getspaceinfo this
/**
* backup the container to the specified path.
* @param backupcontainerpath  location of the backup container.
*  @exception standardexception	standard derby error policy
*/
public void backupcontainer string backupcontainerpath  throws standardexception
checkopen
container backupcontainer this  backupcontainerpath
/**
* create encrypted version of the  container with the
* user specified encryption properties.
* @param newfilepath file to store the new encrypted version of the container
* @exception standardexception	standard derby error policy
*/
public void encryptcontainer string newfilepath  throws standardexception
checkopen
container encryptcontainer this  newfilepath
public string tostring
if  sanitymanager debug
string str   new string
str        identity tostring
return str
else
return super tostring