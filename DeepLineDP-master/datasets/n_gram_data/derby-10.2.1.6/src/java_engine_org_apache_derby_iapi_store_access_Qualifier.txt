/*
derby - class org.apache.derby.iapi.store.access.qualifier
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby iapi store access
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi error standardexception
/**
<p>
a structure which is used to "qualify" a column.  specifies
that the column value in a given column identified by column
id is to be compared via a specific operator to a particular
datavaluedescriptor value.
<p>
the implementation of this interface is provided by the client;
the methods of qualifier are the methods the access code uses to use it.
<p>
arrays of qualifiers are provided to restrict the rows
returned by scans.  a row is returned from a scan if all qualifications
in the array return true.
<p>
a qualification returns true if in the following pseudo-code compare_result
is true.
<p>
<blockquote><pre>
if (qualifier.negatecompareresult())
{
compare_result =
row[(qualifier.getcolumnid())].compare(
qualifier.getoperator(),
qualifier.getorderable(),
qualifier.getorderednulls(),
qualifier.getunknownrv())
if (qualifier.negatecompareresult())
{
compare_result = !(compare_result);
}
}
</blockquote></pre>
<p>
qualifiers are often passed through interfaces as a set of qualifiers,
rather than one at a time, for example see the qualifier argument in
transactioncontroller.openscan().
<p>
to make this consistent the following protocols are to be used when passing
around sets of qualifiers.
<p>
a single dimensional array is to be used to pass around a set of and'd
qualifiers.  thus qualifier[] argument is to be treated as:
<blockquote><pre>
qualifier[0] and qualifer[1] ... and qualifier[qualifer.length - 1]
</blockquote></pre>
<p>
a two dimensional array is to be used to pass around a and's and or's in
conjunctive normal form.  the top slot of the 2 dimensional array is optimized
for the more frequent where no or's are present.  the first array slot is
always a list of and's to be treated as described above for single dimensional
and qualifier arrays.  the subsequent slots are to be treated as and'd arrays
of or's.  thus the 2 dimensional array qual[][] argument is to be treated as
the following, note if qual.length = 1 then only the first array is valid and
it is and an array of and clauses:
<blockquote><pre>
(qual[0][0] and qual[0][0] ... and qual[0][qual[0].length - 1])
and
(qual[1][0] or  qual[1][1] ... or  qual[1][qual[1].length - 1])
and
(qual[2][0] or  qual[2][1] ... or  qual[2][qual[2].length - 1])
...
and (qual[qual.length - 1][0] or  qual[1][1] ... or  qual[1][2])
</blockquote></pre>
<p>
if any of the array's qual[0].length ... qual[qual.length -1] are 0 length
they will be evaluated as true; but they must be not null.  see example 4 for
encoding of (a or b) that takes advantage of this.
<p>
note that any of the arrays qual[0].length ... qual[qual.length -1] may also
be of length 1, thus no guarantee is made the presence of or
predicates if qual.length > 1. see example 1a.
<p>
the following give pseudo-code examples of building qualifier arrays:
<p>
example 1: "a and b and c"
<blockquote><pre>
qualifier = new qualifier[1][3]; // 3 and clauses
qualifier[0][0] = a
qualifier[0][1] = b
qualifier[0][2] = c
</blockquote></pre>
<p>
example 1a "a and b and c" - less efficient than example 1 but legal
<blockquote><pre>
qualifier = new qualifier[3]; // 3 and clauses
qualifier[0] = new qualifier[1];
qualifier[1] = new qualifier[1];
qualifier[2] = new qualifier[1];
qualifier[0][0] = a
qualifier[1][0] = b
qualifier[2][0] = c
</blockquote></pre>
<p>
example 2: "(f) and (a or b) and (c or d or e)"
would be represented by an array that looks like the following:
<blockquote><pre>
qualifier = new qualifier[3]; // 3 and clauses
qualifier[0] = new qualifier[1]; // to be intitialized to f
qualifier[1] = new qualifier[2]; // to be initialized to (a or b)
qualifier[2] = new qualifier[3]; // to be initialized to (c or d or e)
qualifier[0][0] = f
qualifier[1][0] = a
qualifier[1][1] = b
qualifier[2][0] = c
qualifier[2][1] = d
qualifier[2][2] = e
</blockquote></pre>
<p>
example 3: "(a or b) and (c or d) and (e or f)"
<blockquote><pre>
qualifier = new qualifier[3]; // 3 and clauses
qualifier = new qualifier[4]; // 4 and clauses
qualifier[0] = new qualifier[1]; // to be intitialized to true
qualifier[1] = new qualifier[2]; // to be initialized to (a or b)
qualifier[2] = new qualifier[2]; // to be initialized to (c or d)
qualifier[3] = new qualifier[2]; // to be initialized to (e or f)
qualifier[0][0] = true
qualifier[1][0] = a
qualifier[1][1] = b
qualifier[2][0] = c
qualifier[2][1] = d
qualifier[3][0] = e
qualifier[3][1] = f
</blockquote></pre>
<p>
example 4: "(a or b)"
<blockquote><pre>
qualifier = new qualifier[2]; // 2 and clauses
qualifier[0] = new qualifier[0]; // 0 length array is true
qualifier[1] = new qualifier[2]; // to be initialized to (a or b)
qualifier[1][0] = a
qualifier[1][1] = b
</blockquote></pre>
@see scancontroller
@see transactioncontroller#openscan
@see datavaluedescriptor#compare
**/
public interface qualifier
{
/**
* the datavaluedescriptor can be 1 of 4 types:<ul>
*		<li> variant		- cannot be cached as its value can vary
*							  within a scan</li>
*		<li> scan_invariant - can be cached within a scan as its value
*							  will not change within a scan </li>
*		<li> query_invariant- can be cached across the life of the query
*								as its value will never change </li>
*		<li> constant 		- can be cached across executions. </li></ul>
* <p>
* <b>note</b>: the following is guaranteed: <i>
*		variant < scan_invariant < query_invariant < constant
*/
public static final int variant   0
public static final int scan_invariant   1
public static final int query_invariant   2
public static final int constant   3
/**
* get the (zero based) id of the column to be qualified.
* <p>
* this id is the column number of the column in the table, no matter
* whether a partial column set is being retrieved by the actual fetch.
* note that the column being specified in the qualifier must appear in
* the column list being fetched.
**/
int getcolumnid
/**
* get the value that the column is to be compared to.
*
* @exception standardexception		thrown on error
*/
datavaluedescriptor getorderable   throws standardexception
/** get the operator to use in the comparison.
*
*  @see datavaluedescriptor#compare
**/
int getoperator
/** determine if the result from the compare operation should be negated.
*  if true then only rows which fail the compare operation will qualify.
*
*  @see datavaluedescriptor#compare
**/
boolean negatecompareresult
/** get the getorderednulls argument to use in the comparison.
*
*  @see datavaluedescriptor#compare
**/
boolean getorderednulls
/** get the getorderednulls argument to use in the comparison.
*
*  @see datavaluedescriptor#compare
**/
boolean getunknownrv
/** clear the datavaluedescriptor cache, if one exists.
*  (the datavaluedescriptor can be 1 of 3 types:
*		o  variant		  - cannot be cached as its value can
*							vary within a scan
*		o  scan_invariant - can be cached within a scan as its
*							value will not change within a scan
*		o  query_invariant- can be cached across the life of the query
*							as its value will never change
*/
void clearorderablecache
/**
* this method reinitializes all the state of
* the qualifier.  it is used to distinguish between
* resetting something that is query invariant
* and something that is constant over every
* execution of a query.  basically, clearorderablecache()
* will only clear out its cache if it is a variant
* or scan_invariant value.  however, each time a
* query is executed, the query_invariant qualifiers need
* to be reset.
*/
void reinitialize
}