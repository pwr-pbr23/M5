/*
derby - class org.apache.derby.impl.store.access.conglomerate.genericconglomeratecontroller
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl store access conglomerate
import org apache derby iapi reference sqlstate
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi error standardexception
import org apache derby iapi store access conglomerate conglomerate
import org apache derby iapi store access conglomerate logicalundo
import org apache derby iapi store access conglomerate transactionmanager
import org apache derby iapi store access conglomeratecontroller
import org apache derby iapi store access dynamiccompiledopenconglominfo
import org apache derby iapi store access qualifier
import org apache derby iapi store access rowutil
import org apache derby iapi store access spaceinfo
import org apache derby iapi store raw containerhandle
import org apache derby iapi store raw fetchdescriptor
import org apache derby iapi store raw page
import org apache derby iapi store raw recordhandle
import org apache derby iapi store raw transaction
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi types rowlocation
import org apache derby iapi services io formatablebitset
import java util properties
/**
**/
public abstract class genericconglomeratecontroller
extends genericcontroller implements conglomeratecontroller
/**************************************************************************
* fields of the class
**************************************************************************
*/
/**************************************************************************
* constructors for this class:
**************************************************************************
*/
/**************************************************************************
* private/protected methods of this class:
**************************************************************************
*/
/**************************************************************************
* public methods of this class:
**************************************************************************
*/
/**************************************************************************
* public methods implementing conglomeratecontroller which just
*     delegate to openconglomerate:
**************************************************************************
*/
/**************************************************************************
* public methods implementing conglomeratecontroller:
**************************************************************************
*/
/**
* @see conglomeratecontroller#close
**/
public void close
throws standardexception
super close
// if we are closed due to catching an error in the middle of init,
// xact_manager may not be set yet.
if   open_conglom    null      open_conglom getxactmgr      null
open_conglom getxactmgr   closeme this
/**
* close conglomerate controller as part of terminating a transaction.
* <p>
* use this call to close the conglomerate controller resources as part of
* committing or aborting a transaction.  the normal close() routine may
* do some cleanup that is either unnecessary, or not correct due to the
* unknown condition of the controller following a transaction ending error.
* use this call when closing all controllers as part of an abort of a
* transaction.
* <p)
* this call is meant to only be used internally by the storage system,
* clients of the storage system should use the simple close() interface.
* <p>
* resolve (mikem) - move this call to conglomeratemanager so it is
* obvious that non-access clients should not call this.
*
* @param closeheldscan           if true, means to close controller even if
*                                it has been opened to be kept opened
*                                across commit.  this is
*                                used to close these controllers on abort.
*
* @return boolean indicating that the close has resulted in a real close
*                 of the controller.  a held scan will return false if
*                 called by closeforendtransaction(false), otherwise it
*                 will return true.  a non-held scan will always return
*                 true.
*
* @exception  standardexception  standard exception policy.
**/
public boolean closeforendtransaction boolean closeheldscan
throws standardexception
super close
if    open_conglom gethold       closeheldscan
// if we are closed due to catching an error in the middle of init,
// xact_manager may not be set yet.
if   open_conglom    null      open_conglom getxactmgr      null
open_conglom getxactmgr   closeme this
return true
else
return false
/**
* @see conglomeratecontroller#delete
**/
public boolean delete rowlocation loc
throws standardexception
if  open_conglom isclosed
if  open_conglom gethold
if  open_conglom isclosed
open_conglom reopen
else
throw
standardexception newexception
sqlstate heap_is_closed
open_conglom getconglomerate   getid
rowposition pos   new rowposition
getrowpositionfromrowlocation loc  pos
if   open_conglom latchpage pos
return false
open_conglom lockpositionforwrite pos  false    not an insert     true
boolean ret_val   true
// resolve (mikem) - recid - performance could be better if we did not
// have to call isdeletedatslot().
if  pos current_page isdeletedatslot pos current_slot
ret_val   false
else
// delete the row
pos current_page deleteatslot
pos current_slot  true   logicalundo  null
// try to reclaim rows when the page is only full of deleted rows,
// or in the special case of the first page when all rows except the
// "control row" are deleted.  or if the row we just deleted is
// a long row or has a long column.
if  pos current_page shouldreclaimspace
pos current_page getpagenumber      1 ? 1   0
pos current_slot
queuedeletepostcommitwork pos
pos current_page unlatch
return ret_val
/**
* @see conglomeratecontroller#fetch
**/
public boolean fetch
rowlocation             loc
datavaluedescriptor   row
formatablebitset                 validcolumns
throws standardexception
if  open_conglom isclosed
if  open_conglom gethold
if  open_conglom isclosed
open_conglom reopen
else
throw
standardexception newexception
sqlstate heap_is_closed
open_conglom getconglomerate   getid
if  sanitymanager debug
// make sure valid columns are in the list.  the rowutil
// call is too expensive to make in a released system for
// every fetch.
int invalidcolumn
rowutil columnoutofrange
row  validcolumns  open_conglom getformatids   length
if  invalidcolumn >  0
throw standardexception newexception
sqlstate heap_template_mismatch
new long invalidcolumn
new long open_conglom getformatids   length
// get the record handle out of its wrapper.
rowposition pos   new rowposition
getrowpositionfromrowlocation loc  pos
if   open_conglom latchpage pos
return false
// do not get u row lock - only get x or s.  there is no good point
// currently to convert the u lock to an s lock, we don't know when
// the calling code is through with the lock.
// resolve (mikem) - talk to language and see if it is worth it to
//     get u lock and have language call back when we should take
//     appropriate action on the u lock.
if  open_conglom isforupdate
open_conglom lockpositionforwrite
pos  false    not an insert     true
else
open_conglom lockpositionforread
pos   rowposition  null  false  true
// fetch the row.
// resolve (sto061) - don't know whether the fetch is for update or not.
//
// resolve (mikem) - get rid of new here.
boolean ret_val
pos current_page fetchfromslot
pos current_rh  pos current_slot
row
new fetchdescriptor
row length  validcolumns   qualifier  null
false     null
// resolve (mikem) - should be some way to hide this in the unlock call,
// and just always make the unlock call.
if   open_conglom isforupdate
open_conglom unlockpositionafterread pos
pos current_page unlatch
return ret_val
/**
* @see conglomeratecontroller#fetch
**/
public boolean fetch
rowlocation             loc
datavaluedescriptor   row
formatablebitset                 validcolumns
boolean                 waitforlock
throws standardexception
if  open_conglom isclosed
if  open_conglom gethold
if  open_conglom isclosed
open_conglom reopen
else
throw
standardexception newexception
sqlstate heap_is_closed
open_conglom getconglomerate   getid
if  sanitymanager debug
// make sure valid columns are in the list.  the rowutil
// call is too expensive to make in a released system for
// every fetch.
int invalidcolumn
rowutil columnoutofrange
row  validcolumns  open_conglom getformatids   length
if  invalidcolumn >  0
throw standardexception newexception
sqlstate heap_template_mismatch
new long invalidcolumn
new long open_conglom getformatids   length
// get the record handle out of its wrapper.
rowposition pos   new rowposition
getrowpositionfromrowlocation loc  pos
if   open_conglom latchpage pos
return false
// do not get u row lock - only get x or s.  there is not good point
// currently to convert the u lock to an s lock, we don't know when
// the calling code is through with the lock.
// resolve (mikem) - talk to language and see if it is worth it to
//     get u lock and have language call back when we should take
//     appropriate action on the u lock.
if  open_conglom isforupdate
open_conglom lockpositionforwrite
pos  false    not an insert     waitforlock
else
open_conglom lockpositionforread
pos   rowposition  null  false  waitforlock
// fetch the row.
// resolve (sto061) - don't know whether the fetch is for update or not.
//
//
// resolve (mikem) - get rid of new here.
boolean ret_val
pos current_page fetchfromslot
pos current_rh  pos current_slot
row
new fetchdescriptor
row length  validcolumns   qualifier  null
false     null
// resolve (mikem) - should be some way to hide this in the unlock call,
// and just always make the unlock call.
if   open_conglom isforupdate
open_conglom unlockpositionafterread pos
pos current_page unlatch
return ret_val
/**
* @see conglomeratecontroller#replace
**/
public boolean replace
rowlocation             loc
datavaluedescriptor   row
formatablebitset                 validcolumns
throws standardexception
if  open_conglom isclosed
if  open_conglom gethold
if  open_conglom isclosed
open_conglom reopen
else
throw
standardexception newexception
sqlstate heap_is_closed
open_conglom getconglomerate   getid
if  sanitymanager debug
// make sure valid columns are in the list.  the rowutil
// call is too expensive to make in a released system for
// every fetch.
int invalidcolumn
rowutil columnoutofrange
row  validcolumns  open_conglom getformatids   length
if  invalidcolumn >  0
throw standardexception newexception
sqlstate heap_template_mismatch
new long invalidcolumn
new long open_conglom getformatids   length
rowposition pos   new rowposition
getrowpositionfromrowlocation loc  pos
if   open_conglom latchpage pos
return false
open_conglom lockpositionforwrite pos  false  true
boolean ret_val   true
if  pos current_page isdeletedatslot pos current_slot
ret_val   false
else
// update the record.
pos current_page updateatslot pos current_slot  row  validcolumns
pos current_page unlatch
return ret_val