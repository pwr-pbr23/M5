/*
derby - class org.apache.derby.impl.sql.execute.scalaraggregateresultset
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl sql execute
import org apache derby iapi services monitor monitor
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi services stream headerprintwriter
import org apache derby iapi services stream infostreams
import org apache derby iapi services io formatable
import org apache derby iapi sql execute cursorresultset
import org apache derby iapi sql resultset
import org apache derby iapi sql execute execrow
import org apache derby iapi sql execute execindexrow
import org apache derby iapi sql execute noputresultset
import org apache derby iapi sql activation
import org apache derby iapi store access columnordering
import org apache derby iapi store access transactioncontroller
import org apache derby iapi services loader generatedmethod
import org apache derby iapi sql conn languageconnectioncontext
import org apache derby iapi error standardexception
import org apache derby iapi types rowlocation
import org apache derby iapi services io formatablearrayholder
import java util properties
import java util vector
import java util enumeration
/**
* this resultset evaluates scalar, non distinct aggregates.
* it will scan the entire source result set and calculate
* the scalar aggregates when scanning the source during the
* first call to next().
*
* @author jerry (broken out from sortresultset)
*/
class scalaraggregateresultset extends genericaggregateresultset
implements cursorresultset
/* run time statistics variables */
public int rowsinput
// set in constructor and not altered during
// life of object.
public 		boolean 			singleinputrow
protected 	execindexrow 		sorttemplaterow
protected 	boolean 			isinsortedorder 		   true if source results in sorted order
// cache execindexrow for scalar aggregates
protected execindexrow sourceexecindexrow
// remember whether or not a next() has been satisfied
private boolean nextsatisfied
/**
* constructor
*
* @param	s			input result set
* @param	isinsortedorder	true if the source results are in sorted order
* @param	aggregateitem	indicates the number of the
*		savedobject off of the preparedstatement that holds the
*		aggregatorinfolist used by this routine.
* @param	a				activation
* @param	ra				generated method to build an empty
*	 	output row
* @param	resultsetnumber	the resultsetnumber for this result set
*
* @exception standardexception thrown on error
*/
scalaraggregateresultset noputresultset s
boolean isinsortedorder
int	aggregateitem
activation a
generatedmethod ra
int resultsetnumber
boolean singleinputrow
double optimizerestimatedrowcount
double optimizerestimatedcost  throws standardexception
super s  aggregateitem  a  ra  resultsetnumber  optimizerestimatedrowcount  optimizerestimatedcost
this isinsortedorder   isinsortedorder
// source expected to be non-null, mystery stress test bug
// - sometimes get nullpointerexception in opencore().
if  sanitymanager debug
sanitymanager assert source    null
sorttemplaterow   getexecutionfactory   getindexablerow  execrow  rowallocator invoke activation
this singleinputrow   singleinputrow
if  sanitymanager debug
sanitymanager debug
a getpreparedstatement   getsavedobject aggregateitem
constructortime    getelapsedmillis begintime
///////////////////////////////////////////////////////////////////////////////
//
// resultset interface (leftover from noputresultset)
//
///////////////////////////////////////////////////////////////////////////////
/**
* open the scan.  load the sorter and prepare to get
* rows from it.
*
* @exception standardexception thrown if cursor finished.
*/
public void	opencore   throws standardexception
begintime   getcurrenttimemillis
// source expected to be non-null, mystery stress test bug
// - sometimes get nullpointerexception in opencore().
if  sanitymanager debug
sanitymanager assert source    null
sanitymanager assert    isopen
sourceexecindexrow   getexecutionfactory   getindexablerow sorttemplaterow
source opencore
isopen   true
numopens
opentime    getelapsedmillis begintime
protected int countofrows
/* resolve - this next method is overriden in distinctscalarresultset
* beacause of a jit error. there is no other
* reason to override it in distinctscalaraggregateresultset.  the bug was found in
* 1.1.6 with the jit.
*/
/**
* return the next row.  if it is a scalar aggregate scan
*
* @exception standardexception thrown on failure.
* @exception standardexception resultsetnotopen thrown if not yet open.
*
* @return the next row in the result
*/
public execrow	getnextrowcore   throws standardexception
if  nextsatisfied
clearcurrentrow
return null
execindexrow sortresult   null
execrow result   null
execindexrow execindexrow   null
execindexrow aggresult   null
//only care if it is a minagg if we have a singleinputrow, then we know
//we are only looking at one aggregate
boolean minagg    singleinputrow    aggregates agginfo aggregatename equals
begintime   getcurrenttimemillis
if  isopen
/*
** we are dealing with a scalar aggregate.
** zip through each row and accumulate.
** accumulate into the first row.  only
** the first row is cloned.
*/
while   execindexrow   getrowfromresultset false      null
/*
** use a clone of the first row as our result.
** we need to get a clone since we will be reusing
** the original as the wrapper of the source row.
** turn cloning off since we wont be keeping any
** other rows.
*/
if  aggresult    null
/* no need to clone the row when doing the min/max
* optimization for min, since we will not do another
* next on the underlying result set.
*/
aggresult    singleinputrow    minagg  ?
execindexrow
execindexrow  execindexrow getclone
initializescalaraggregation aggresult
else
accumulatescalaraggregation execindexrow  aggresult  false
/* only need to look at first single row if
* min/max optimization is on and operation is min
* or if operation is max first non-null row since null sorts
* as highest in btree
* note only 1 aggregate is allowed in a singleinputrow
* optimization so we only need to look at the first aggregate
*/
if  singleinputrow
minagg
aggresult getcolumn aggregates aggregatorcolumnid  isnull
break
/*
** if we have aggregates, we need to generate a
** value for them now.  only finish the aggregation
** if we haven't yet (i.e. if countofrows == 0).
** if there weren't any input rows, we'll allocate
** one here.
*/
if  countofrows    0
aggresult   finishaggregation aggresult
currentrow   aggresult
setcurrentrow aggresult
countofrows
nextsatisfied   true
nexttime    getelapsedmillis begintime
return aggresult
/**
* if the result set has been opened,
* close the open scan.
*
* @exception standardexception thrown on error
*/
public void	close   throws standardexception
begintime   getcurrenttimemillis
if   isopen
// we don't want to keep around a pointer to the
// row ... so it can be thrown away.
// revisit: does this need to be in a finally
// block, to ensure that it is executed?
clearcurrentrow
countofrows   0
sourceexecindexrow   null
source close
super close
else
if  sanitymanager debug
sanitymanager debug
closetime    getelapsedmillis begintime
nextsatisfied   false
isopen   false
/**
* return the total amount of time spent in this resultset
*
* @param type	current_resultset_only - time spent only in this resultset
*				entire_resultset_tree  - time spent in this resultset and below.
*
* @return long		the total amount of time spent (in milliseconds).
*/
public long gettimespent int type
long tottime   constructortime   opentime   nexttime
closetime
if  type    noputresultset current_resultset_only
return	tottime   originalsource gettimespent entire_resultset_tree
else
return tottime
///////////////////////////////////////////////////////////////////////////////
//
// cursorresultset interface
//
///////////////////////////////////////////////////////////////////////////////
/**
* this result set has its row location from
* the last fetch done. always returns null.
*
* @see cursorresultset
*
* @return the row location of the current cursor row.
* @exception standardexception thrown on failure to get row location
*/
public rowlocation getrowlocation   throws standardexception
return null
/**
* this result set has its row from the last fetch done.
* if the cursor is closed, a null is returned.
*
* @see cursorresultset
*
* @return the last row returned;
* @exception standardexception thrown on failure.
*/
/* resolve - this should return activation.getcurrentrow(resultsetnumber),
* once there is such a method.  (currentrow is redundant)
*/
public execrow getcurrentrow   throws standardexception
if  sanitymanager debug
sanitymanager assert isopen
return currentrow
///////////////////////////////////////////////////////////////////////////////
//
// scan abstraction utilities
//
///////////////////////////////////////////////////////////////////////////////
/**
* get a row from the input result set.
*
* @param doclone - true of the row should be cloned
*
* @exception standardexception thrown on error
*/
public execindexrow getrowfromresultset boolean doclone
throws standardexception
execrow					sourcerow
execindexrow			inputrow   null
if   sourcerow   source getnextrowcore       null
rowsinput
sourceexecindexrow execrowtoexecindexrow
doclone ? sourcerow getclone     sourcerow
inputrow   sourceexecindexrow
return inputrow
/**
* reopen a scan on the table. scan parameters are evaluated
* at each open, so there is probably some way of altering
* their values...
*
* @exception standardexception thrown if cursor finished.
*/
public void	reopencore   throws standardexception
begintime   getcurrenttimemillis
if  sanitymanager debug
sanitymanager assert isopen
source reopencore
numopens
countofrows   0
nextsatisfied   false
opentime    getelapsedmillis begintime
///////////////////////////////////////////////////////////////////////////////
//
// aggregation utilities
//
///////////////////////////////////////////////////////////////////////////////
/**
* run accumulation on every aggregate in this
* row.  this method is useful when draining the source
* or sorter, depending on whether or not there were any
* distinct aggregates.  remember, if there are distinct
* aggregates, then the non-distinct aggregates were
* calculated on the way into the sorter and only the
* distinct aggregates will be accumulated here.
* otherwise, all aggregates will be accumulated here.
*
* @param	inputrow	the input row
* @param	accumulaterow	the row with the accumulator (may be the same as the input row.
* @param	hasdistinctaggregates does this scan have distinct
*			aggregates.  used to figure out whether to merge
*			or accumulate nondistinct aggregates.
*
* @exception standardexception thrown on error
*/
protected void accumulatescalaraggregation
execrow inputrow
execrow accumulaterow
boolean hasdistinctaggregates
throws standardexception
int size   aggregates length
if  sanitymanager debug
sanitymanager assert  inputrow    null      accumulaterow    null
for  int i   0  i < size  i
genericaggregator curraggregate   aggregates
if	 hasdistinctaggregates
curraggregate getaggregatorinfo   isdistinct
curraggregate merge inputrow  accumulaterow
else
curraggregate accumulate inputrow  accumulaterow
///////////////////////////////////////////////////////////////////////////////
//
// class specific
//
///////////////////////////////////////////////////////////////////////////////
/*
** run the aggregator initialization method for
** each aggregator in the row.
**
** @param	row	the row to initialize
**
** @return nothing.
**
** @exception	standard cloudscape exception
*/
private void initializescalaraggregation execrow row
throws standardexception
int size   aggregates length
if  sanitymanager debug
sanitymanager assert row    null
for  int i   0  i < size  i
genericaggregator curraggregate   aggregates
curraggregate initialize row
curraggregate accumulate row  row