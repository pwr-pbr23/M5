/*
derby - class org.apache.derby.client.net.netsqldta
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby client net
public class netsqldta extends netcursor
private netconnection netconnection_
public netsqldta netagent netagent
super netagent
netconnection_   netagent netconnection_
public boolean next   throws org apache derby client am sqlexception
if  allrowsreceivedfromserver
return false
else
setallrowsreceivedfromserver true
return true
protected boolean calculatecolumnoffsetsforrow
int colnullindicator   codepoint nulldata
int length
extdtapositions_ clear        reset positions for this row
// read the da null indicator
if  readfdocaonebyte      0xff
return false
incrementrowsreadevent
// use the arrays defined on the cursor for forward-only cursors.
// can they ever be null
if  columndataposition_    null    columndatacomputedlength_    null    isnull_    null
allocatecolumnoffsetandlengtharrays
// loop through the columns
for  int index   0  index < columns_  index
// if column is nullable, read the 1-byte null indicator.
if  nullable_
// need to pass the column index so all previously calculated offsets can be
// readjusted if the query block splits on a column null indicator.
// null indicators from fd:oca data
// 0 to 127: a data value will flow.
// -1 to -128: no data value will flow.
colnullindicator   readfdocaonebyte
// if non-null column data
if   nullable_     colnullindicator >  0    colnullindicator <  127
isnull_   false
switch  typetouseforcomputingdatalength_
// for variable character string and variable byte string,
// there are 2-byte of length in front of the data
case typdef twobytelength
columndataposition_   position_
length   readfdocatwobytelength
// skip length + the 2-byte length field
if  isgraphic_
columndatacomputedlength_   skipfdocabytes length   2    2
else
columndatacomputedlength_   skipfdocabytes length    2
break
// for short variable character string and short variable byte string,
// there is a 1-byte length in front of the data
case typdef onebytelength
columndataposition_   position_
length   readfdocaonebyte
// skip length + the 1-byte length field
if  isgraphic_
columndatacomputedlength_   skipfdocabytes length   2    1
else
columndatacomputedlength_   skipfdocabytes length    1
break
// for decimal columns, determine the precision, scale, and the representation
case typdef decimallength
columndataposition_   position_
columndatacomputedlength_   skipfdocabytes getdecimallength index
break
case typdef loblength
columndataposition_   position_
columndatacomputedlength_   this skipfdocabytes fdocalength_   0x7fff
break
default
columndataposition_   position_
if  isgraphic_
columndatacomputedlength_   skipfdocabytes fdocalength_   2
else
columndatacomputedlength_   skipfdocabytes fdocalength_
break
else if   colnullindicator   0x80     0x80
// null data. set the isnull indicator to true.
isnull_   true
if   allrowsreceivedfromserver
calculatelobcolumnpositionsforrow
return true     hardwired for now  this means the current row position is a valid position
private int skipfdocabytes int length
position_    length
return length
private int readfdocaonebyte
return databuffer_   0xff
private int readfdocatwobytelength
return
databuffer_   0xff  << 8
databuffer_   0xff  << 0