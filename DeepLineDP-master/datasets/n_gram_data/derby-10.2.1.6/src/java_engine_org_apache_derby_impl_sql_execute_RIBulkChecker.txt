/*
derby - class org.apache.derby.impl.sql.execute.ribulkchecker
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl sql execute
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi error standardexception
import org apache derby iapi sql resultset
import org apache derby iapi types booleandatavalue
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi types rowlocation
import org apache derby iapi sql execute execrow
import org apache derby iapi sql languageproperties
import org apache derby iapi store access conglomeratecontroller
import org apache derby iapi store access genericscancontroller
import org apache derby iapi store access groupfetchscancontroller
import org apache derby iapi store access scancontroller
import org apache derby iapi store access transactioncontroller
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi services io formatablebitset
/**
* do a merge run comparing all the foreign keys from the
* foreign key conglomerate against the referenced keys
* from the primary key conglomerate.  the scancontrollers
* are passed in by the caller (caller controls locking on
* said conglomerates).
* <p>
* the comparision is done via a merge.  consequently,
* it is imperative that the scans are on keyed conglomerates
* (indexes) and that the referencedkeyscan is a unique scan.
* <p>
* performance is no worse than n + m where n is foreign key
* rows and m is primary key rows.
* <p>
* bulk fetch is used to further speed performance.  the
* fetch size is languageproperties.bulk_fetch_default
*
* @see languageproperties
*/
public class ribulkchecker
private static final int equal   0
private static final int greater_than   1
private static final int less_than    1
private fkinfo			fkinfo
private groupfetchscancontroller	referencedkeyscan
private datavaluedescriptor		referencedkeyrowarray
private groupfetchscancontroller	foreignkeyscan
private datavaluedescriptor		foreignkeyrowarray
private conglomeratecontroller	unreferencedcc
private int 			failedcounter
private boolean			quitonfirstfailure
private	int				numcolumns
private	int				currrefrowindex
private	int				currfkrowindex
private int				lastrefrowindex
private int				lastfkrowindex
private execrow			firstrowtofail
/**
* create a ribulkchecker
*
* @param referencedkeyscan		scan of the referenced key's
*								backing index.  must be unique
* @param foreignkeyscan		scan of the foreign key's
*								backing index
* @param templaterow			a template row for the indexes.
*								will be cloned when it is used.
*								must be a full index row.
* @param quitonfirstfailure	quit on first unreferenced key
* @param unreferencedcc	put unreferenced keys here
* @param firstrowtofail		the first row that fails the constraint
*								is copied to this, if non-null
*/
public ribulkchecker
groupfetchscancontroller    referencedkeyscan
groupfetchscancontroller	foreignkeyscan
execrow					    templaterow
boolean					    quitonfirstfailure
conglomeratecontroller	    unreferencedcc
execrow					    firstrowtofail
this referencedkeyscan   referencedkeyscan
this foreignkeyscan   foreignkeyscan
this quitonfirstfailure   quitonfirstfailure
this unreferencedcc   unreferencedcc
this firstrowtofail   firstrowtofail
foreignkeyrowarray		  new datavaluedescriptor
foreignkeyrowarray	  templaterow getrowarrayclone
referencedkeyrowarray	  new datavaluedescriptor
referencedkeyrowarray  templaterow getrowarrayclone
failedcounter   0
numcolumns   templaterow getrowarray   length   1
currfkrowindex    1
currrefrowindex    1
/**
* perform the check.
*
* @return the number of failed rows
*
* @exception standardexception on error
*/
public int docheck
throws standardexception
datavaluedescriptor foreignkey
datavaluedescriptor referencedkey
int compareresult
referencedkey   getnextref
/*
** 	for each foreign key
**
**		while (fk > pk)
**			next pk
**			if no next pk
**				failed
**
**		if fk != pk
**			failed
*/
while   foreignkey   getnextfk       null
/*
** if all of the foreign key is not null and there are no
** referenced keys, then everything fails
** ansi standard says the referential constraint is
** satisfied if either at least one of the values of the
** referencing columns(i.e., foreign key) is null or the
** value of each referencing column is equal to the
** corresponding referenced column in the referenced table
*/
if   anynull foreignkey     referencedkey    null
do
failure foreignkey
if  quitonfirstfailure
return 1
while   foreignkey   getnextfk       null
return failedcounter
while   compareresult   greaterthan foreignkey  referencedkey      greater_than
if   referencedkey   getnextref       null
do
failure foreignkey
if  quitonfirstfailure
return 1
while   foreignkey   getnextfk       null
return failedcounter
if  compareresult    equal
failure foreignkey
if  quitonfirstfailure
return 1
return failedcounter
/*
* use bulk fetch to get the next set of rows,
* or read the next out of our internal array.
*/
private datavaluedescriptor getnextfk
throws standardexception
if   currfkrowindex > lastfkrowindex
currfkrowindex     1
int rowcount
foreignkeyscan fetchnextgroup foreignkeyrowarray   rowlocation  null
if  rowcount    0
currfkrowindex    1
return null
lastfkrowindex   rowcount   1
currfkrowindex   0
return foreignkeyrowarray
/*
* use bulk fetch to get the next set of rows,
* or read the next out of our internal array.
*/
private datavaluedescriptor getnextref
throws standardexception
if   currrefrowindex > lastrefrowindex
currrefrowindex     1
int rowcount
referencedkeyscan fetchnextgroup referencedkeyrowarray   rowlocation  null
if  rowcount    0
currrefrowindex    1
return null
lastrefrowindex   rowcount   1
currrefrowindex   0
return referencedkeyrowarray
private void failure datavaluedescriptor foreignkeyrow
throws standardexception
if  failedcounter    0
if  firstrowtofail    null
firstrowtofail setrowarray foreignkeyrow
// clone it
firstrowtofail setrowarray firstrowtofail getrowarrayclone
failedcounter
if  unreferencedcc    null
unreferencedcc insert foreignkeyrow
/*
** returns true if any of the foreign keys are null
** otherwise, false.
*/
private boolean anynull datavaluedescriptor fkrowarray
throws standardexception
datavaluedescriptor	fkcol
/*
** check all columns excepting the row location.
*/
for  int i   0  i < numcolumns  i
fkcol    datavaluedescriptor fkrowarray
/*
** if any column in the fk is null,
** return true
*/
if  fkcol isnull
return true
return false
private int greaterthan datavaluedescriptor fkrowarray  datavaluedescriptor refrowarray
throws standardexception
datavaluedescriptor	fkcol
datavaluedescriptor	refcol
int 				result
/*
** if any column in the fk is null,
** it is assumed to be equal
*/
if  anynull fkrowarray
return equal
for  int i   0  i < numcolumns  i
fkcol    datavaluedescriptor fkrowarray
refcol    datavaluedescriptor refrowarray
result   fkcol compare refcol
if  result    1
return greater_than
else if  result     1
return less_than
/*
** if they are equal, go on to the next
** column.
*/
/*
** if we got here they must be equal
*/
return equal