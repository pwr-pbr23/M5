/*
derby - class org.apache.derby.client.am.encryptionmanager
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby client am
import java security provider
import java security security
import org apache derby shared common reference sqlstate
import org apache derby shared common sanity sanitymanager
// this class is get used when using encrypted password and/or userid mechanism.
// the <b>encryptionmanager</b> classs uses diffie_hellman algorithm to get the publick key and
// secret key, and then des encryption is done using certain token (based on security
// mechanism) and server side's public key. basically, this class is called when using
// security mechanism user id and encrypted password (usrencpwd) and encrypted user id and password
// (eusridpwd).
// this class uses jce provider to do diffie_hellman algorithm and des encryption,
// obtainpublickey(), calculateencryptiontoken(int, byte[]) and encryptdata(byte[], int, byte[], byte[])
// the agreed public value for the diffie-hellman prime is 256 bits
// and hence the encrytion will work only if the jce provider supports a 256 bits prime
//
// this class also have methods for the secmec_usrssbpwd security mechanism.
public class encryptionmanager
transient agent agent_     for obtaining an exception log writer only
// protocol's diffie-hellman agreed public value: prime.
private static final byte modulusbytes__
byte  0xc6   byte  0x21   byte  0x12   byte  0xd7
byte  0x3e   byte  0xe6   byte  0x13   byte  0xf0
byte  0x94   byte  0x7a   byte  0xb3   byte  0x1f
byte  0x0f   byte  0x68   byte  0x46   byte  0xa1
byte  0xbf   byte  0xf5   byte  0xb3   byte  0xa4
byte  0xca   byte  0x0d   byte  0x60   byte  0xbc
byte  0x1e   byte  0x4c   byte  0x7a   byte  0x0d
byte  0x8c   byte  0x16   byte  0xb3   byte  0xe3
//the prime value in biginteger form. it has to be in biginteger form because this
//is the form used in jce library.
private static final java math biginteger modulus__
new java math biginteger 1  modulusbytes__
//  protocol's diffie-hellman agreed public value: base.
private static final byte basebytes__
byte  0x46   byte  0x90   byte  0xfa   byte  0x1f
byte  0x7b   byte  0x9e   byte  0x1d   byte  0x44
byte  0x42   byte  0xc8   byte  0x6c   byte  0x91
byte  0x14   byte  0x60   byte  0x3f   byte  0xde
byte  0xcf   byte  0x07   byte  0x1e   byte  0xdc
byte  0xec   byte  0x5f   byte  0x62   byte  0x6e
byte  0x21   byte  0xe2   byte  0x56   byte  0xae
byte  0xd9   byte  0xea   byte  0x34   byte  0xe4
// the base value in biginteger form.
private static final java math biginteger base__
new java math biginteger 1  basebytes__
//protocol's diffie-hellman agreed exponential length
private static final int exponential_length__   255
private javax crypto spec dhparameterspec paramspec_
private java security keypairgenerator keypairgenerator_
private java security keypair keypair_
private javax crypto keyagreement keyagreement_
private byte token_     init vector
private byte seckey_     security key
private javax crypto secretkeyfactory secretkeyfactory_   null
private string providername     security provider name
private provider provider
// required for secmec_usrssbpwd drda security mechanism
// note: in a next incarnation, these constants are being moved
// to a dedicated/specialized secmec_usrssbpwd class implementing
// a securitymechanism interface.
private java security messagedigest messagedigest   null
private java security securerandom securerandom   null
private final static int secmec_usrssbpwd_seed_len   8      seed length
// pwseqs's 8-byte value constant - see drda vol 3
private static final byte secmec_usrssbpwd_pwdseqs
byte  0x00   byte  0x00   byte  0x00   byte  0x00
byte  0x00   byte  0x00   byte  0x00   byte  0x01
// random number generator (prng) algorithm
private final static string sha_1_prng_algorithm
public final static string sha_1_digest_algorithm
// encryptionmanager constructor. in this constructor,dhparameterspec,
// keypairgenerator, keypair, and keyagreement  are initialized.
public encryptionmanager agent agent  throws sqlexception
agent_   agent
try
// get a security provider that supports the diffie helman key agreement algorithm
provider list   security getproviders
if  list    null
throw new java security nosuchproviderexception
provider   list
providername   provider getname
paramspec_   new javax crypto spec dhparameterspec modulus__  base__  exponential_length__
keypairgenerator_   java security keypairgenerator getinstance    providername
keypairgenerator_ initialize paramspec_
keypair_   keypairgenerator_ generatekeypair
keyagreement_   javax crypto keyagreement getinstance    providername
keyagreement_ init keypair_ getprivate
catch  java security generalsecurityexception e
throw new sqlexception agent_ logwriter_
new clientmessageid sqlstate security_exception_encountered   e
// retrieve a particular instance of the encryption manager for a given
// (messsage digest) algorithm. this is currently required for the
// secmec_usrssbpwd (strong password substitute) security mechanism.
//
// note: this is temporary logic as the encryption manager is being
// rewritten into a drdasecuritymanager and have some of the
// client/engine common logic moved to the derby 'shared' package.
public encryptionmanager agent agent  string algorithm  throws sqlexception
agent_   agent
try
// instantiate the encryption manager for the passed-in security
// algorithm and this from the default provider
// note: we're only dealing with message digest algorithms for now.
messagedigest   java security messagedigest getinstance algorithm
// we're also verifying that we can instantiate a randon number
// generator (prng).
securerandom
java security securerandom getinstance sha_1_prng_algorithm
catch  java security nosuchalgorithmexception nsae
// the following exception should not be raised for sha-1 type of
// message digest as we've already verified during boot-up that this
// algorithm was available as part of the jre (since built-in
// authentication requires it); but we still raise the exception if
// a client were to request a different algorithm.
throw new sqlexception agent_ logwriter_
new clientmessageid sqlstate security_exception_encountered
nsae
// this method generates the public key and returns it. this
// shared public key is the application requester's connection key and will
// be exchanged with the application server's connection key. this connection
// key will be put in the sectkn in accsec command and send to the application
// server.
// @param   null
// @return  a byte array that is the application requester's public key
public byte obtainpublickey
//we need to get the plain form public key because protocol accepts plain form
//public key only.
java math biginteger apub     javax crypto interfaces dhpublickey  keypair_ getpublic    gety
byte apubkey   apub tobytearray
//the following lines of code is to adjust the length of the key. publickey
//in jce is in the form of biginteger and it's a signed value. when tranformed
//to a byte array form, normally this array is 32 bytes. however, if the
//value happens to take up all 32 x 8 bits and it is positive, an extra
//bit is needed and then a 33 byte array will be returned. since protocol can't
//recogize the 33 byte key, we check the length here, if the length is 33,
//we will just trim off the first byte (0) and get the rest of 32 bytes.
if  apubkey length    33    apubkey    0
//system.out.println ("adjust length");
byte newkey   new byte
for  int i   0  i < newkey length  i
newkey   apubkey
return newkey
//the following lines of code is to adjust the length of the key. occasionally,
//the length of the public key is less than 32, the reason of this is that the 0 byte
//in the beginning is somehow not returned. so we check the length here, if the length
//is less than 32, we will pad 0 in the beginning to make the public key 32 bytes
if  apubkey length < 32
byte newkey   new byte
int i
for  i   0  i < 32   apubkey length  i
newkey   0
for  int j   i  j < newkey length  j
newkey   apubkey
return newkey
return apubkey
// this method is used to calculate the encryption token. des encrypts the
// data using a token and the generated shared private key. the token used
// depends on the type of security mechanism being used:
// usrencpwd - the userid is used as the token. the usrid is zero-padded to
// 8 bytes if less than 8 bytes or truncated to 8 bytes if greater than 8 bytes.
// eusridpwd - the middle 8 bytes of the server's connection key is used as
// the token.
// @param  int     securitymechanism
// @param  byte[]  userid or server's connection key
// @return byte[]  the encryption token
private byte calculateencryptiontoken int securitymechanism  byte initvector
byte token   new byte
//usrencpwd, the userid is used as token
if  securitymechanism    7
if  initvector length < 8      shorter than 8 bytes  zero padded to 8 bytes
for  int i   0  i < initvector length  i
token   initvector
for  int i   initvector length  i < 8  i
token   0
else      longer than 8 bytes  truncated to 8 bytes
for  int i   0  i < 8  i
token   initvector
//eusridpwd - the middle 8 bytes of the server's connection key is used as
//the token.
else if  securitymechanism    9
for  int i   0  i < 8  i
token   initvector
return token
//jdk 1.4 has a parity check on the des encryption key. each byte needs to have an odd number
//of "1"s in it, and this is required by des. otherwise jdk 1.4 throws invalidkeyexception.
//older jdk doesn't check this. in order to make encryption work with jdk1.4, we are going to
//check each of the 8 byte of our key and flip the last bit if it has even number of 1s.
private void keyparitycheck byte key  throws sqlexception
byte temp
int changeparity
if  key length    8
throw new sqlexception agent_ logwriter_
new clientmessageid sqlstate des_key_has_wrong_length
new integer 8   new integer key length
for  int i   0  i < 8  i
temp   key
changeparity   1
for  int j   0  j < 8  j
if  temp < 0
changeparity   1   changeparity
temp    byte   temp << 1
if  changeparity    1
if   key   1     0
key    0xfe
else
key    1
// this method generates a secret key using the application server's
// public key
private byte generateprivatekey byte targetpublickey  throws sqlexception
try
//initiate a diffie_hellman keyfactory object.
java security keyfactory keyfac   java security keyfactory getinstance    provider
//use server's public key to initiate a dhpublickeyspec and then use
//this dhpublickeyspec to initiate a publickey object
java math biginteger publickey   new java math biginteger 1  targetpublickey
javax crypto spec dhpublickeyspec dhkeyspec
new javax crypto spec dhpublickeyspec publickey  modulus__  base__
java security publickey pubkey   keyfac generatepublic dhkeyspec
//execute the first phase of dh keyagreement protocal.
keyagreement_ dophase pubkey  true
//generate the shared secret key. the application requestor's shared secret
//key should be exactly the same as the application server's shared secret
//key
byte sharedsecret   keyagreement_ generatesecret
byte newkey   new byte
//we adjust the length here. if the length of secret key is 33 and the first byte is 0,
//we trim off the frist byte. if the length of secret key is less than 32, we will
//pad 0 to the beginning of the byte array tho make the secret key 32 bytes.
if  sharedsecret length    33    sharedsecret    0
for  int i   0  i < newkey length  i
newkey   sharedsecret
if  sharedsecret length < 32
int i
for  i   0  i <  32   sharedsecret length   i
newkey   0
for  int j   i  j < sharedsecret length  j
newkey   sharedsecret
//the data encryption standard (des) is going to be used to encrypt userid
//and password. des is a block cipher; it encrypts data in 64-bit blocks.
//protocol encryption uses des cbc mode as defined by the fips standard
//des cbc requires an encryption key and an 8 byte token to encrypt the data.
//the middle 8 bytes of diffie-hellman shared private key is used as the
//encryption key. the following code retrieves middle 8 bytes of the shared
//private key.
byte key   new byte
//if secret key is not 32, we will use the adjust length secret key
if  sharedsecret length    32
for  int i   0  i < 8  i
key   sharedsecret
else if  sharedsecret length    33    sharedsecret length < 32
for  int i   0  i < 8  i
key   newkey
else
throw new sqlexception agent_ logwriter_
new clientmessageid sqlstate shared_key_length_error
new integer sharedsecret length
//we do parity check here and flip the parity bit if the byte has even number of 1s
keyparitycheck key
return key
catch  java security generalsecurityexception e
throw new sqlexception agent_ logwriter_
new clientmessageid sqlstate security_exception_encountered   e
// this method encrypts the usreid/password with the middle 8 bytes of
// the generated secret key and an encryption token. then it returns the
// encrypted data in a byte array.
// plaintext   the byte array form userid/password to encrypt.
// initvector  the byte array which is used to calculate the
//                             encryption token.
// targetpublickey   derby' public key.
// returns the encrypted data in a byte array.
public byte encryptdata byte plaintext
int securitymechanism
byte initvector
byte targetpublickey  throws sqlexception
byte ciphertext   null
java security key key   null
if  token_    null
token_   calculateencryptiontoken securitymechanism  initvector
try
if  seckey_    null
//use this encryption key to initiate a secretkeyspec object
seckey_   generateprivatekey targetpublickey
javax crypto spec secretkeyspec deskey   new javax crypto spec secretkeyspec seckey_
key   deskey
else
//use this encryption key to initiate a secretkeyspec object
javax crypto spec deskeyspec deskey   new javax crypto spec deskeyspec seckey_
if  secretkeyfactory_    null
secretkeyfactory_   javax crypto secretkeyfactory getinstance    providername
key   secretkeyfactory_ generatesecret deskey
//we use des in cbc mode because this is the mode used in protocol. the
//encryption mode has to be consistent for encryption and decryption.
//cbc mode requires an initialization vector(iv) parameter. in cbc mode
//we need to initialize the cipher object with an iv, which can be supplied
// using the javax.crypto.spec.ivparameterspec class.
javax crypto cipher cipher   javax crypto cipher getinstance    providername
//generate a ivparameterspec object and use it to initiate the
//cipher object.
javax crypto spec ivparameterspec ivparam   new javax crypto spec ivparameterspec token_
//initiate the cipher using encryption mode, encryption key and the
//iv parameter.
cipher init javax crypto cipher encrypt_mode  key  ivparam
//execute the final phase of encryption
ciphertext   cipher dofinal plaintext
catch  javax crypto nosuchpaddingexception e
throw new sqlexception agent_ logwriter_
new clientmessageid sqlstate crypto_no_such_padding
catch  javax crypto badpaddingexception e
throw new sqlexception agent_ logwriter_
new clientmessageid sqlstate crypto_bad_padding
catch  javax crypto illegalblocksizeexception e
throw new sqlexception agent_ logwriter_
new clientmessageid sqlstate crypto_illegal_block_size
catch  java security generalsecurityexception e
throw new sqlexception agent_ logwriter_
new clientmessageid sqlstate security_exception_encountered   e
return ciphertext
// this method decrypts the usreid/password with the middle 8 bytes of
// the generated secret key and an encryption token. then it returns the
// decrypted data in a byte array.
// plaintext   the byte array form userid/password to encrypt.
// initvector  the byte array which is used to calculate the
//                             encryption token.
// targetpublickey   derby' public key.
// returns the decrypted data in a byte array.
public byte decryptdata byte ciphertext
int securitymechanism
byte initvector
byte targetpublickey  throws sqlexception
byte plaintext   null
java security key key   null
if  token_    null
token_   calculateencryptiontoken securitymechanism  initvector
try
if  seckey_    null
//use this encryption key to initiate a secretkeyspec object
seckey_   generateprivatekey targetpublickey
javax crypto spec secretkeyspec deskey   new javax crypto spec secretkeyspec seckey_
key   deskey
else
//use this encryption key to initiate a secretkeyspec object
javax crypto spec deskeyspec deskey   new javax crypto spec deskeyspec seckey_
if  secretkeyfactory_    null
secretkeyfactory_   javax crypto secretkeyfactory getinstance    providername
key   secretkeyfactory_ generatesecret deskey
//we use des in cbc mode because this is the mode used in protocol. the
//encryption mode has to be consistent for encryption and decryption.
//cbc mode requires an initialization vector(iv) parameter. in cbc mode
//we need to initialize the cipher object with an iv, which can be supplied
// using the javax.crypto.spec.ivparameterspec class.
javax crypto cipher cipher   javax crypto cipher getinstance    providername
//generate a ivparameterspec object and use it to initiate the
//cipher object.
javax crypto spec ivparameterspec ivparam   new javax crypto spec ivparameterspec token_
//initiate the cipher using encryption mode, encryption key and the
//iv parameter.
cipher init javax crypto cipher decrypt_mode  key  ivparam
//execute the final phase of encryption
plaintext   cipher dofinal ciphertext
catch  javax crypto nosuchpaddingexception e
throw new sqlexception agent_ logwriter_
new clientmessageid sqlstate crypto_no_such_padding
catch  javax crypto badpaddingexception e
throw new sqlexception agent_ logwriter_
new clientmessageid sqlstate crypto_bad_padding
catch  javax crypto illegalblocksizeexception e
throw new sqlexception agent_ logwriter_
new clientmessageid sqlstate crypto_illegal_block_size
catch  java security generalsecurityexception e
throw new sqlexception agent_ logwriter_
new clientmessageid sqlstate security_exception_encountered   e
return plaintext
public void setinitvector byte initvector
token_   initvector
public void setseckey byte seckey
seckey_   seckey
public void resetsecuritykeys
token_   null
seckey_   null
/****************************************************************
* below are methods for the secmec_usrssbpwd security mechanism.
****************************************************************/
/**
* this method generates an 8-byte random seed for the client (source).
*
* @return a random 8-byte seed.
*/
public byte generateseed
byte randomseedbytes   new byte
securerandom setseed securerandom generateseed
secmec_usrssbpwd_seed_len
securerandom nextbytes randomseedbytes
return randomseedbytes
/**
* strong password substitution (usrssbpwd).
*
* this method generate a password subtitute to send to the target
* server.
*
* substitution algorithm works as follow:
*
* pw_token = sha-1(pw, id)
* the password (pw) and user name (id) can be of any length greater
* than or equal to 1 byte.
* the client generates a 20-byte password substitute (pw_sub) as follows:
* pw_sub = sha-1(pw_token, rdr, rds, id, pwseqs)
*
* w/ (rds) as the random client seed and (rdr) as the server one.
*
* see pwdssb - strong password substitution security mechanism
* (drda vol.3 - p.650)
*
* @param username the user's name
* @param password the user's password
* @param sourceseed_ random client seed (rds)
* @param targetseed_ random server seed (rdr)
*
* @return a password substitute.
*/
public byte substitutepassword
string username
string password
byte sourceseed_
byte targetseed_  throws sqlexception
// pattern that is prefixed to the builtin encrypted password
string id_pattern_new_scheme
// generated password substitute
byte passwordsubstitute
// assert we have a sha-1 message digest already instantiated
if  sanitymanager debug
sanitymanager assert  messagedigest    null
sha_1_digest_algorithm equals
messagedigest getalgorithm
// important note: as the password is stored single-hashed in the
// database on the target side, it is impossible for the target to
// decrypt the password and recompute a substitute to compare with
// one generated on the source side - hence, for now we have to
// single-hash and encrypt the password the same way the target is
// doing it and we will still generate a substitute obviously - the
// password, even pre-hashed will never make it across the wire as
// a substitute is generated. in other words, if the target cannot
// figure what the original password is (because of not being able
// to decrypt it or not being able to retrieve it (i.e. ldap), then
// it may be problematic - so in a way, strong password substitution
// (usrssbpwd) cannot be supported for targets which can't access or
// decrypt some password on their side.
//
// so in short, secmec_usrssbpwd is only supported if the
// authentication provider on the target side is none or derby's
// builtin one and if using derby's client network driver (for now).
//
// encrypt the password as it is done by the derby engine - note that
// this code (logic) is not shared yet - will be in next revision.
messagedigest reset
messagedigest update this tohexbyte password  0  password length
byte encryptval   messagedigest digest
string hexstring   id_pattern_new_scheme
this tohexstring encryptval  0  encryptval length
// generate some 20-byte password token
byte userbytes   this tohexbyte username  0  username length
messagedigest update userbytes
messagedigest update this tohexbyte hexstring  0  hexstring length
byte passwordtoken   messagedigest digest
// now we generate the 20-byte password substitute
messagedigest update passwordtoken
messagedigest update targetseed_
messagedigest update sourceseed_
messagedigest update userbytes
messagedigest update secmec_usrssbpwd_pwdseqs
passwordsubstitute   messagedigest digest
return passwordsubstitute
/*********************************************************************
* resolve:                                                          *
* the methods and static vars below should go into some 'shared'    *
* package when the capability is put back in (stringutil.java).     *
*********************************************************************/
private static char hex_table
/**
convert a byte array to a string with a hexidecimal format.
the string may be converted back to a byte array using fromhexstring.
<br>
for each byte (b) two characaters are generated, the first character
represents the high nibble (4 bits) in hexidecimal (<code>b & 0xf0</code>),
the second character represents the low nibble (<code>b & 0x0f</code>).
<br>
the byte at <code>data[offset]</code> is represented by the first two
characters in the returned string.
@param	data	byte array
@param	offset	starting byte (zero based) to convert.
@param	length	number of bytes to convert.
@return the string (with hexidecimal format) form of the byte array
*/
private string tohexstring byte data  int offset  int length
stringbuffer s   new stringbuffer length 2
int end   offset length
for  int i   offset  i < end  i
int high_nibble    data   0xf0  >>> 4
int low_nibble    data   0x0f
s append hex_table
s append hex_table
return s tostring
/**
convert a string into a byte array in hex format.
<br>
for each character (b) two bytes are generated, the first byte
represents the high nibble (4 bits) in hexidecimal (<code>b & 0xf0</code>),
the second byte represents the low nibble (<code>b & 0x0f</code>).
<br>
the character at <code>str.charat(0)</code> is represented by the first two bytes
in the returned string.
@param	str string
@param	offset	starting character (zero based) to convert.
@param	length	number of characters to convert.
@return the byte[]  (with hexidecimal format) form of the string (str)
*/
private byte tohexbyte string str  int offset  int length
byte data   new byte
int end   offset length
for  int i   offset  i < end  i
char ch   str charat i
int high_nibble    ch   0xf0  >>> 4
int low_nibble    ch   0x0f
data    byte high_nibble
data    byte low_nibble
return data