/*
derby - class org.apache.derby.impl.store.access.btree.leafcontrolrow
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl store access btree
import org apache derby iapi reference sqlstate
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi services io formatidutil
import org apache derby iapi services io storedformatids
import org apache derby iapi services io typedformat
import org apache derby iapi error standardexception
import org apache derby iapi store access conglomerate logicalundo
import org apache derby iapi store access accessfactoryglobals
import org apache derby iapi store access conglomeratecontroller
import org apache derby iapi store access qualifier
import org apache derby iapi store access rowutil
import org apache derby iapi store access scancontroller
import org apache derby iapi store raw containerhandle
import org apache derby iapi store raw fetchdescriptor
import org apache derby iapi store raw page
import org apache derby iapi store raw recordhandle
import org apache derby iapi store raw transaction
import org apache derby iapi types datavaluedescriptor
import java io printstream
import org apache derby iapi services io formatablebitset
/**
* @format_id access_btree_leafcontrolrow_v1_id
*
* @purpose   btree pages all have a control row at the front of every page.  to
*            determine the type of row, read the first column which is a format
*            id and it tells what kind of control row it is.
*
* @upgrade   this format was made obsolete in the kimono release.
*
* @disk_layout
* column 1 - control row type         : storableformatid
* column 2 - left sibling page number : sqllongint
* column 3 - right sibling page number: sqllongint
* column 4 - parent page number       : sqllongint
* column 5 - level number (0 is leaf) : sqllongint
* column 6 - isroot                   : sqllongint
* column 7 - conglomerate object      : null unless it is root else
*                                       a conglomerate object, matching
*                                       that of current table.
*                                       currently this field
*                                       is only used by logical undo and
*                                       the type of object is inferred by
*                                       the logical undo code.
**/
public class leafcontrolrow extends controlrow
/*
** constructors of branchcontrolrow
*/
/**
* no arg constructor.
* <p>
* public no arg constructor is for the monitor to call for format
* id implemenation, it should not be called for any other reason.
**/
public leafcontrolrow
/**
* constructs a leaf-page control row, for a newly allocated leaf page.
*
* @param btree     the open btree to allocate this page from.
* @param page      the newly allocated page where the control row will
*                  be inserted.
* @param parent    the parent of the leaf page.  set to null for root.
*                  resolve (mikem) - set to null otherwise?
* @param isroot    is this page the root of the tree?
*
* @exception standardexception standard exception policy.
*/
leafcontrolrow
openbtree         btree
page		      page
controlrow	      parent
boolean           isroot
throws standardexception
// all leaf pages are at level 0.
super btree  page  0  parent  isroot
/* private/protected methods of this class: */
/**
* allocate a new leaf page to the conglomerate.
*
* @param btree     the open conglomerate from which to get the leaf from
* @param parent    the parent page of the newly allocated page, null if
*                  allocating root page.
*
* @exception standardexception standard exception policy.
*/
private static leafcontrolrow allocate
openbtree   btree
controlrow  parent
throws standardexception
page      page        btree container addpage
// create a control row for the new page.
leafcontrolrow control_row
new leafcontrolrow btree  page  parent  false
// insert the control row on the page, in the first slot on the page.
// this operation is only done as part of a new tree or split, which
// which both will be undone physically so no logical undo record is
// needed.
byte insertflag   page insert_initial
insertflag    page insert_default
recordhandle rh
page insertatslot page first_slot_number
control_row getrow
formatablebitset  null
logicalundo  null  insertflag
accessfactoryglobals btree_overflow_threshold
if  sanitymanager debug
recordhandle    rh2   null
rh2   page fetchfromslot
recordhandle  null  page first_slot_number
new datavaluedescriptor   fetchdescriptor  null  true
sanitymanager assert rh getid      rh2 getid
rh getpagenumber      rh2 getpagenumber
// page is returned latched.
return control_row
/**
* return the number of non-deleted rows from slot 1 through "startslot"
* <p>
* return the number of non-deleted rows that exist on the page starting
* at slot one through "startslot".
* <p>
* resolve (mikem) - is the expense of this routine worth it, it is only
* used for costing.  could an estimate from the nondeletedrecordcount()
* be used instead?
*
* @return the requested non_deleted_row_count.
*
* @param startslot  count non deleted row up to and including this slot.
*
* @exception  standardexception  standard exception policy.
**/
private float get_left_nondeleted_rowcnt
int startslot
throws standardexception
int non_deleted_row_count   0
for  int slot   1  slot <  startslot  slot
if   this page isdeletedatslot slot
non_deleted_row_count
return non_deleted_row_count
/* public methods of leafcontrolrow class: */
/**
* perform page specific initialization.
* <p>
**/
protected final void controlrowinit
/**
* initialize conglomerate with one page, to be a 1 page btree.
*
* given a conglomerate which already has one page allocated to it,
* initialize the page to be a leaf-root page with no entries.  allocate
* the control row and store it on the page.
*
* @param open_btree the open btree to initialize (container is open).
*
* @exception standardexception standard exception policy.
*/
public static void initemptybtree
openbtree   open_btree
throws standardexception
page page
open_btree container getpage containerhandle first_page_number
// create a leaf control row for root page of a single page index //
leafcontrolrow control_row
new leafcontrolrow open_btree  page  null  true
byte insertflag   page insert_initial
insertflag    page insert_default
recordhandle rh
page insertatslot
page first_slot_number
control_row getrow
formatablebitset  null
logicalundo  null  insertflag
accessfactoryglobals btree_overflow_threshold
if  sanitymanager debug
recordhandle    rh2   null
rh2   page fetchfromslot
recordhandle  null
page first_slot_number
new datavaluedescriptor   fetchdescriptor  null  true
sanitymanager assert rh getid      rh2 getid
rh getpagenumber      rh2 getpagenumber
if  sanitymanager debug
if  sanitymanager debug_on
control_row checkconsistency
open_btree   controlrow  null  true
page unlatch
return
/*
** non - debug/consistency check methods of controlrow:
*/
/**
* get the number of columns in the control row.
* <p>
* control rows all share the first columns as defined by this class and
* then add columns to the end of the control row.  for instance a branch
* control row add a child page pointer field.
* <p>
*
* @return the total number of columns in the control row.
**/
protected final int getnumberofcontrolrowcolumns
return this cr_ncolumns
/**
* is the current page the leftmost leaf of tree?
* <p>
*
* @return true if the current page is the leftmost leaf of the tree,
*              else return false.
*
* @exception  standardexception  standard exception policy.
**/
public boolean isleftmostleaf
throws standardexception
return getleftsiblingpagenumber
containerhandle invalid_page_number
/**
* is the current page the rightmost leaf of tree?
* <p>
*
* @return true if the current page is the rightmost leaf of the tree,
*              else return false.
*
* @exception  standardexception  standard exception policy.
**/
public boolean isrightmostleaf
throws standardexception
return getrightsiblingpagenumber
containerhandle invalid_page_number
/**
** perform a search of this leaf page, ultimately returning the latched
** leaf page and row slot after which the given key belongs.
** the slot is returned in the result structure.  if the key
** exists on the page, the result.exact will be true.  otherwise,
** result.exact will be false, and the row slot returned will be
** the one immediately preceding the position at which the key
** belongs.
*
* @exception standardexception standard exception policy.
**/
public controlrow search
searchparameters    sp
throws standardexception
searchforentry sp
if  sp searchforoptimizer
// update left_fraction to be used to estimate the number of
// rows left of the current search location.
// after the code below startslot will be the slot that is one
// before the first slot to be returned by the scan positioning
// for this key, including gt/ge positioning.  this is exactly
// what the leafcontrolrow.positionatstartforforwardscan() does,
// to position for the start of a scan.
int startslot   sp resultslot
if  sp resultexact
// we found exactly the row we are looking for.
if  sanitymanager debug
sanitymanager assert sp resultslot > 0
// resolve (mikem) - add in a search operator argument so that
//     below can be if (op == scancontroller.ge)
if  sp partial_key_match_op
searchparameters position_left_of_partial_key_match
// this means the scan was positioned for ge rather than gt
startslot
// non_deleted_left_row is the number of actual rows left of the
// first row to be returned by a scan positioned as requested.
// the 0th slot is a control row which is not counted.
float non_deleted_left_rows   get_left_nondeleted_rowcnt startslot
int   non_deleted_row_count   this page nondeletedrecordcount
// system.out.println(
//   "\n\t non_deleted_row_count = " + non_deleted_row_count +
// "\n\t non_deleted_left_rows = " + non_deleted_left_rows +
// "\n\t startslot = " + startslot);
if  this getisroot
sp current_fraction   1
sp left_fraction      0
// calculate the fraction of rows in the table which are left of
// the current slot in the search.  after the search is completed
// (sp.left_fraction * number of rows), is the estimated number
// of rows to the left of the current row.
if  non_deleted_row_count > 1
sp left_fraction
sp current_fraction
non_deleted_left_rows    non_deleted_row_count   1
// no-one really uses current fraction after leaf is through with
// it.  set it to help diagnose algorithm.
if  non_deleted_row_count > 1
sp current_fraction
sp current_fraction
float  1     non_deleted_row_count   1
return this
/**
* search and return the left most leaf page.
* <p>
* perform a recursive search, ultimately returning the
* leftmost leaf page which is the first leaf page in the
* leaf sibling chain.  (this method might better be called
* getfirstleafpage()).
*
* @return the leftmost leaf page.
*
* @param btree  the open btree to associate latches/locks with.
*
* @exception  standardexception  standard exception policy.
**/
protected controlrow searchleft openbtree btree
throws standardexception
return this
/**
* search and return the right most leaf page.
* <p>
* perform a recursive search, ultimately returning the
* rightmost leaf page which is the last leaf page in the
* leaf sibling chain.  (this method might better be called
* getlastleafpage()).
*
* @return the rightmost leaf page.
*
* @param btree  the open btree to associate latches/locks with.
*
* @exception  standardexception  standard exception policy.
**/
protected controlrow searchright openbtree btree
throws standardexception
return this
/**
**	perform a recursive shrink operation for the key.
** if this method returns true, the caller should
** remove the corresponding entry for the page.
** this routine is not guaranteed to successfully
** shrink anything.  the page lead to by the key might
** turn out not to be empty by the time shrink gets
** there, and shrinks will give up if there is a deadlock.
** <p>
** the receiver page must be latched on entry and is
** returned unlatched.
*
* @exception standardexception standard exception policy.
**/
protected boolean shrinkfor
openbtree               btree
datavaluedescriptor   key
throws standardexception
boolean shrink_me   false
try
// if this page is empty (ie. only has a control row), and it's not
// the root page, unlink it.  an empty btree consists of
// simply an empty leaf-root page.
// resolve (mikem) - may want this routine to try to purge
// committed delete rows here?
if   this page recordcount      1      getisroot
// see if we can unlink this page (might not be able to because
// unlinking can cause deadlocks).  a successful unlink
// unlatches the page.
shrink_me   unlink btree
finally
if   shrink_me
this release
return shrink_me
/**
* perform a top down split pass making room for the the key in "row".
* <p>
* perform a split such that a subsequent call to insert
* given the argument index row will likely find room for it.  since
* latches are released the client must code for the case where another
* user has grabbed the space made available by the split pass and be
* ready to do another split.
* <p>
* on entry, the parent is either null or latched, and the
* current page is latched.  on exit, all pages will have been
* unlatched.  if the parent is null, then this page is a root
* leaf page.
*
* @return page number of the newly allocated leaf page created by split.
*
* @param open_btree  the open btree to associate latches with.
* @param template    a scratch area to use while searching for split pass.
* @param parent_page the parent page of the current page in the split pass.
*                    starts at null for root.
* @param splitrow    the key to make room for during the split pass.
* @param flag        a flag used to direct where point of split should be
*                    chosen.
*
* @exception  standardexception  standard exception policy.
**/
protected long splitfor
openbtree               open_btree
datavaluedescriptor   template
branchcontrolrow        parent_page
datavaluedescriptor	splitrow
int                     flag
throws standardexception
long current_leaf_pageno   this page getpagenumber
if  sanitymanager debug
if  parent_page    null        this getisroot
sanitymanager.throwassert(
this
// see if this page has space.
if   this page recordcount     1 <
open_btree getconglomerate   maxrowsperpage
this page spaceforinsert splitrow   formatablebitset  null
accessfactoryglobals btree_overflow_threshold
// the splitfor() operation is complete, commit the work done
// before releasing the latches.
open_btree getxactmgr   commit
if  parent_page    null
parent_page release
this release
return current_leaf_pageno
// resolve (mikem) - for rows bigger than pages this assert may
// trigger until we have long rows.
if  sanitymanager debug
sanitymanager assert this page recordcount   > 1
// track.leafsplit++;
if  this getisroot
// track.leafsplitroot++;
growroot open_btree  template  this
// at this point, this page has been unlatched.  so code below this
// point must not access this object's fields.
controlrow new_root   controlrow get open_btree  btree rootpageid
return
new_root splitfor open_btree  template  null  splitrow  flag
// at this point we know that this page has to be split and
// that it isn't a root page.
int splitpoint    this page recordcount     1    2   1
if   flag   controlrow split_flag_first_on_page     0
// move all the row to the new page
splitpoint   1
else if   flag   controlrow split_flag_last_on_page     0
// this is not optimal as we would rather move no rows to the
// next page, but what should we use as a discriminator?
splitpoint   this page recordcount     1
if  sanitymanager debug
if  splitpoint <  0
sanitymanager throwassert this
// save away current split point leaf row, and build a branch row
// based on it.
datavaluedescriptor split_leaf_row
open_btree getconglomerate   createtemplate
this page fetchfromslot
recordhandle  null  splitpoint  split_leaf_row
fetchdescriptor  null  true
// create the branch row to insert onto the parent page.  for now
// use a fake page number because we don't know the real page
// number until the allocate is done, but want to delay the
// allocate until we know the insert will succeed.
branchrow branchrow   branchrow createbranchrowfromoldleafrow
split_leaf_row  branchrow dummy_page_number
// at this point we have guaranteed there is space in the parent
// page for splitrow, but it could be the case that the new
// "branchrow" does not fit on the parent page.
if   parent_page page spaceforinsert
branchrow getrow     formatablebitset  null
accessfactoryglobals btree_overflow_threshold
// there is no room on the parent page to complete a split at
// the current level, so restart the split at top with the
// branchrow that did not fit.  on return from this routine
// there is no way to know the state of the tree, so the
// current split pass recursion must end.
return
branchcontrolrow  parent_page  restartsplitfor
open_btree  template  parent_page  this
branchrow getrow    splitrow  flag
// before moving the rows on the page, while having the latch on the
// page, notify btree scans that the rows on this page may be moving
// onto another page.
//
// resolve (mikem) - need to pass conlgomid.
// resolve (mikem) - some optimization later, we only need to notify
// the scans which are positioned on moving rows.
if  sanitymanager debug
sanitymanager assert open_btree init_open_user_scans    null
open_btree init_open_user_scans savescanpositions
open_btree getconglomerate    this page
// get exclusive record_id_protection_handle lock to make sure that
// we wait for scans in other transactions to move off of this page
// before we split.
if   open_btree getlockingpolicy   lockscan
this  parent_page  true    for update
conglomeratecontroller lock_upd
// we had to give up latches on this and parent_page to get the
// split lock.  redo the whole split pass as we have lost our
// latches.  just returning is ok, as the caller can not assume
// that split has succeeded in making space.  note that at this
// point in the split no write work has been done in the current
// internal transaction, so giving up here is fairly cheap.
// resolve rll performance - we could keep a stack of visited
// pages so as to not have to redo the complete search.
return current_leaf_pageno
// create a new leaf page under the parent.
leafcontrolrow newleaf
leafcontrolrow allocate open_btree  parent_page
// now that we know the page number of the new child page update
// the branch row to be inserted with the correct value.
branchrow setpagenumber newleaf page getpagenumber
// test fail after allocation
if  sanitymanager debug
if  sanitymanager debug_on
throw standardexception newexception
sqlstate btree_abort_through_trace
// link it to the right of the current page.
newleaf linkright open_btree  this
// copy the index rows (from the splitpoint to the end of the page)
// from the old page to the new leaf, do not
// copy the control row.  this routine will purge all the copied rows
// and maintain the deleted status of the moved rows.
int num_rows_to_move   this page recordcount     splitpoint
if  sanitymanager debug
sanitymanager assert num_rows_to_move >  0
if  num_rows_to_move    0
this page copyandpurge
newleaf page  splitpoint  num_rows_to_move  1
// test fail after new page has been updated.
if  sanitymanager debug
if  sanitymanager debug_on
throw standardexception newexception
sqlstate btree_abort_through_trace
// test fail after new page has been updated.
if  sanitymanager debug
if  sanitymanager debug_on
throw standardexception newexception
sqlstate btree_abort_through_trace
// find spot to insert branch row, and insert it.
branchrow branch_template
branchrow createemptytemplate open_btree getconglomerate
searchparameters sp
new searchparameters
branchrow getrow
searchparameters position_left_of_partial_key_match
branch_template getrow
open_btree  false
parent_page searchforentry sp
// there must be space on the parent to insert the row!
if  sanitymanager debug
sanitymanager assert
parent_page page spaceforinsert
branchrow getrow     formatablebitset  null
accessfactoryglobals btree_overflow_threshold
byte insertflag   page insert_initial
insertflag    page insert_default
insertflag    page insert_undo_with_purge
if  parent_page page insertatslot
sp resultslot   1
branchrow getrow
formatablebitset  null
logicalundo null
insertflag
accessfactoryglobals btree_overflow_threshold     null
throw standardexception newexception
sqlstate btree_no_space_for_key
// branchrow is only valid while split_leaf_row remains unchanged.
branchrow   null
// resolve (mikem) - this case breaks the btree currently - as the
// abort of the insert leaves a logical delete in the tree.
//
// test fail after parent page has been updated.
if  sanitymanager debug
if  sanitymanager debug_on
throw standardexception newexception
sqlstate btree_abort_through_trace
if  sanitymanager debug
if  sanitymanager debug_on
this checkconsistency open_btree  parent_page  false
newleaf checkconsistency open_btree  parent_page  false
parent_page checkconsistency open_btree  null  false
// at this point a unit of work in the split down the tree has
// been performed in an internal transaction.  this work must
// be committed before any latches are released.
open_btree getxactmgr   commit
parent_page release
this release        xxx  nat  not good form to unlatch self
long new_leaf_pageno   newleaf page getpagenumber
newleaf release
// because we are at the leaf level and have completed the split
// there is no more work, no latches should be held, and control
// is returned up the recursive stack, to the insert causing the
// split.  because latches are released, the inserter must recheck
// that there is now space available as some other thread of control
// could get in before he latches the page again.
return new_leaf_pageno
/**
** grow a new root page from a leaf page.  slightly
** tricky because we want to retain page 0 as the root.
** <p>
** on entry, the current leaf root page is expected
** to be latched.  on exit, all latches will have been
** released.
** <p>
** the caller cannot not assume success.  if we have to release latches
** this routine just returns and assumes the caller will retry the
** grow root if necessary.
**/
private static void growroot
openbtree               open_btree
datavaluedescriptor   template
leafcontrolrow          leafroot
throws standardexception
branchcontrolrow branchroot    null
leafcontrolrow   newleaf       null
// before moving the rows on the page, while having the latch on the
// page, notify btree scans that the rows on this page may be moving
// onto another page.
//
open_btree init_open_user_scans savescanpositions
open_btree getconglomerate    leafroot page
// get exclusive record_id_protection_handle lock to make sure that
// we wait for scans in other transactions to move off of this page
// before we grow root.  if we don't wait, scanners in other
// transactions may be positioned on the leaf page which we are
// about to make into a branch page.
if   open_btree getlockingpolicy   lockscan
leafroot   controlrow  null
true    for update
conglomeratecontroller lock_upd
// we had to give up latches on leafroot to get the
// split lock.  redo the whole split pass as we have lost our
// latches - which may mean that the root has grown when we gave
// up the latch.  just returning is ok, as the caller can not assume
// that grow root has succeeded in making space.  note that at this
// point in the split no write work has been done in the current
// internal transaction, so giving up here is fairly cheap.
return
// allocate a new leaf page under the existing leaf root.
newleaf   leafcontrolrow allocate open_btree  leafroot
// test fail after allocation
if  sanitymanager debug
if  sanitymanager debug_on
throw standardexception newexception
sqlstate btree_abort_through_trace
// copy all the index rows from the root to the new leaf, do not
// copy the control row.  this routine will purge all the copied
// rows and maintain the deleted status of the moved rows.
if  sanitymanager debug
sanitymanager assert  leafroot page recordcount     1  > 0
leafroot page copyandpurge
newleaf page  1  leafroot page recordcount     1  1
// test fail after row copy
if  sanitymanager debug
if  sanitymanager debug_on
throw standardexception newexception
sqlstate btree_abort_through_trace
// test fail after purge
if  sanitymanager debug
if  sanitymanager debug_on
// make sure tree is very trashed and logical recovery will
// not work.
leafroot setlevel 42
leafroot setparent 42
throw standardexception newexception
sqlstate btree_abort_through_trace
// put a branch control row on the root page, making the new leaf
// the left child.  all leaf splits result in level-1 branch pages.
// this will be a branch-root page.
// construction of the branchcontrolrow will set it as the aux
// object for the page, this in turn invalidates the previous aux
// object which is leafroot. thus leafroot must not be used once
// the constructor returns.
branchroot   new branchcontrolrow
open_btree  leafroot page  1  null  true
newleaf page getpagenumber
leafroot   null
// replace the old leaf root control row with the new branch root
// control row.
branchroot page updateatslot
0  branchroot getrow     formatablebitset  null
// test fail after purge
if  sanitymanager debug
if  sanitymanager debug_on
throw standardexception newexception
sqlstate btree_abort_through_trace
if  sanitymanager debug
if  sanitymanager debug_on
newleaf checkconsistency open_btree  branchroot  false
branchroot checkconsistency open_btree  null  false
// at this point a unit of work in the split down the tree has
// been performed in an internal transaction.  this work must
// be committed before any latches are released.
open_btree getxactmgr   commit
// test fail after commit of split
if  sanitymanager debug
if  sanitymanager debug_on
throw standardexception newexception
sqlstate btree_abort_through_trace
// the variable 'branchroot' refers to a page that was latched by
// leafroot.  after a growroot() from a leaf there will be no pages
// latched.  it is up to the callers to reget the root page latched
// and continue their work.
//
if  branchroot    null
branchroot release
if  leafroot    null
leafroot release
if  newleaf    null
newleaf release
/**
* return the left child pointer for the page.
* <p>
* leaf pages don't have children, so they override this and return null.
*
* @return the page which is the leftmost child of this page.
*
* @param btree  the open btree to associate latches/locks with.
*
* @exception  standardexception  standard exception policy.
**/
protected controlrow getleftchild openbtree btree
throws standardexception
return null
/**
* return the right child pointer for the page.
* <p>
* leaf pages don't have children, so they override this and return null.
*
* @return the page which is the rightmost child of this page.
*
* @param btree  the open btree to associate latches/locks with.
*
* @exception  standardexception  standard exception policy.
**/
protected controlrow getrightchild openbtree btree
throws standardexception
return null
/*
** debug/consistency check methods of controlrow:
*/
/**
** perform consistency checks on a leaf page.
**
** check consistency of the page and its children,
** returning the number of pages seen, and throwing
** errors if inconsistencies are found.
** the checks specific to a leaf page are:
** <menu>
** <li> page is at level 0.
** <li> version is a valid leaf page version.
** <li> control row has right number of columns for leaf.
** </menu>
** this method also performs the consistency checks that
** are common to both leaf and branch pages.
** @see controlrow#checkgeneric
**
** @exception standardexception standard exception policy.
**/
public int checkconsistency
openbtree  btree
controlrow parent
boolean    check_other_pages
throws standardexception
// do the consistency checks that are common to all
// types of pages.
checkgeneric btree  parent  check_other_pages
// leaf specific, control row checks
if  sanitymanager debug
sanitymanager assert this getlevel      0
// resolve (mikem) - how to sanity check correct version?
/*
if (this.getversion() != current_leaf_version)
sanitymanager.throwassert(
"expected leaf version:(" +
current_leaf_version + ") but got (" +
this.getversion());
*/
sanitymanager assert
this page fetchnumfieldsatslot cr_slot
controlrow cr_ncolumns
// the remaining checks are specific to leaf pages.
// check that every row has at least as many columns
// as the number of key fields in the b-tree.
int numslots   this page recordcount
for  int slot   1  slot < numslots  slot
if  this page fetchnumfieldsatslot slot  <
btree getconglomerate   nkeyfields
sanitymanager.throwassert(
slot
this page fetchnumfieldsatslot slot
btree getconglomerate   nkeyfields
// resolve - the generic btree code should know nothing about
// the secondaryindex row location column, but put this here for
// now because i can't figure how to get a call out to the
// secondary index code at the page level consistency checking
// level.
// we checked one page (this one).
return 1
/**
** recursively print the tree starting at current node in tree.
** this is a leaf so return.
@exception standardexception standard exception policy.
**/
public void printtree
openbtree  btree
throws standardexception
if  sanitymanager debug
sanitymanager debug_print    this debugpage btree
return
/*
* methods of typedformat:
*/
/**
return my format identifier.
@see org.apache.derby.iapi.services.io.typedformat#gettypeformatid
*/
public int gettypeformatid
return storedformatids access_btree_leafcontrolrow_v1_id