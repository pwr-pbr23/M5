/*
derby - class org.apache.derby.impl.sql.compile.basetablenumbersvisitor
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package	org apache derby impl sql compile
import org apache derby iapi sql compile visitable
import org apache derby iapi sql compile visitor
import org apache derby iapi util jbitset
import org apache derby iapi error standardexception
import org apache derby iapi services sanity sanitymanager
/**
* walk through a subtree and build a list of the assigned numbers for
* all tables that exist in that subtree.  we do this by looking for any
* column references in the subtree and, for each column reference, we
* walk down the columnreference-resultcolumn chain until we find the
* the bottom-most table number, which should correspond to a base
* table.
*/
public class basetablenumbersvisitor implements visitor
// jbitset to hold the table numbers that we find.
private jbitset tablemap
/**
* constructor: takes a jbitset to use as the holder for any base table
* numbers found while walking the subtree.
*
* @param tablemap jbitset into which we put the table numbers we find.
*/
public basetablenumbersvisitor jbitset tablemap
this tablemap   tablemap
/**
* set a new jbitset to serve as the holder for base table numbers
* we find while walking.
*
* @param tablemap jbitset into which we put the table numbers we find.
*/
protected void settablemap jbitset tablemap
this tablemap   tablemap
////////////////////////////////////////////////
//
// visitor interface
//
////////////////////////////////////////////////
/**
* @see org.apache.derby.iapi.sql.compile.visitor#visit
*/
public visitable visit visitable node
throws standardexception
resultcolumn rc   null
if  node instanceof columnreference
// start by seeing if this column reference is the
// bottom-most one, meaning that there are no column
// references beneath this one.
rc     columnreference node  getsource
if  rc    null
// this can happen if column reference is pointing to a column
// that is not from a base table.  for example, if we have a
// values clause like
//
//    (values (1, 2), (3, 4)) v1 (i, j)
//
// and then a column reference to vi.i, the column reference
// won't have a source.
return node
else if  node instanceof resultcolumn
rc    resultcolumn rc
else if  node instanceof selectnode
// if the node is a selectnode we just need to look at its
// from list.
selectnode node  getfromlist   accept this
else if  node instanceof frombasetable
// just grab the fbt's table number.
tablemap set   frombasetable node  gettablenumber
if  rc    null
// this next call will walk through the resultcolumn tree
// until it finds another columnreference, and then will
// return the table number for that column reference.  we
// can't stop there, though, because the column reference
// that we found might in turn have column references beneath
// it, and we only want the table number of the bottom-most
// column reference.  so once we find the column reference,
// we have to recurse.
int basetablenumber   rc gettablenumber
if  basetablenumber >  0
// move down to the column reference that has the table
// number that we just found.  there may be one or more
// virtualcolumnnode-to-resultcolumnnode links between
// the current resultcolumn and the column reference we're
// looking for, so we have to walk past those until we find
// the desired column reference.
valuenode rcexpr   rc getexpression
while  rcexpr instanceof virtualcolumnnode
rc     virtualcolumnnode rcexpr  getsourcecolumn
rcexpr   rc getexpression
if  rcexpr instanceof columnreference
// we found our column reference; recurse using that.
rcexpr accept this
else
// else we must have found the table number someplace
// other than within a columnreference (ex. we may
// have pulled it from a virtualcolumnnode's source
// table); so just set the number.
tablemap set basetablenumber
else if  node instanceof columnreference
// we couldn't find any other table numbers beneath the
// columnreference, so just use the table number for
// that reference.
columnreference node  gettablesreferenced tablemap
return node
/**
* @see org.apache.derby.iapi.sql.compile.visitor#skipchildren
*/
public boolean skipchildren visitable node
/* a selectnode's children can include a where clause in the
* form of either a predicatelist or an andnode.  in either
* case we don't want to descend into the where clause because
* it's possible that it references a base table that is not
* in the subtree we're walking.  so we skip the children of
* a selectnode.  similarly, any other predicatelist may contain
* references to base tables that we don't want to include, so
* we skip a predicatelist's children as well.  note, though,
* that if this visitor is specifically targeted for a particular
* predicate or andnode (i.e. a call is directly made to
* predicate.accept() or andnode.accept()) then we _will_ descend
* into that predicate's operands and retrieve referenced base
* table numbers.
*
* and finally, if we visit a frombasetable we can just grab
* it's number and that's it--there's no need to go any further.
*/
return  node instanceof frombasetable
node instanceof selectnode
node instanceof predicatelist
/**
* @see org.apache.derby.iapi.sql.compile.visitor#stoptraversal
*/
public boolean stoptraversal
return false