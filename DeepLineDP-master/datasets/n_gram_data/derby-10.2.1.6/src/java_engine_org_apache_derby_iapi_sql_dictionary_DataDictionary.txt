/*
derby - class org.apache.derby.iapi.sql.dictionary.datadictionary
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby iapi sql dictionary
import org apache derby iapi services context contextmanager
import org apache derby iapi sql depend dependencymanager
import org apache derby iapi sql depend dependent
import org apache derby iapi sql depend provider
import org apache derby iapi sql preparedstatement
import org apache derby iapi types datatypedescriptor
import org apache derby iapi types numberdatavalue
import org apache derby iapi types datavaluefactory
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi sql compile costestimate
import org apache derby iapi sql conn languageconnectioncontext
import org apache derby iapi sql execute executionfactory
import org apache derby iapi error standardexception
import org apache derby iapi store access transactioncontroller
import org apache derby iapi types rowlocation
import org apache derby catalog uuid
import org apache derby iapi services uuid uuidfactory
import java util list
import java util hashtable
import java util properties
import java util vector
/**
* the datadictionary interface is used with the data dictionary to get
* descriptors for binding and compilation. some descriptors (such as table
* and column descriptors) are added to and deleted from the data dictionary
* by other modules (like the object store). other descriptors are added and
* deleted by the language module itself (e.g. the language module adds and
* deletes views, because views are too high-level for modules like the object
* store to know about).
*
* @version 0.1
* @author jeff lichtman
*/
public interface datadictionary
string module
/** special version indicating the database must be upgraded to or created at the current engine level
*
* databasemetadata will use this to determine if the data dictionary
* is at the latest system catalog version number. a data dictionary version
* will not be at latest system catalog version when the database is getting
* booted in soft upgrade mode. in soft upgrade mode, engine should goto
* metadata.properties to get the sql for the metadata calls rather
* than going to the system tables (and using stored versions of these queries).
* this is required because if the metadata sql has changed between the
* releases, we want to use the latest metadata sql rather than what is
* stored in the system catalogs. had to introduce this behavior for
* embeddeddatabasemetadata in 10.2 release where optimizer overrides
* syntax was changed. if 10.2 engine in soft upgrade mode for a pre-10.2
* database went to system tables for stored metadata queires, the metadata
* calls would fail because 10.2 release doesn't recognize the pre-10.2
* optimizer overrides syntax. to get around this, the 10.2 engine in
* soft upgrade mode should get the sql from metata.properties which has
* been changed to 10.2 syntax for optimizer overrides. to make this
* approach more generic for all soft upgrades, from 10.2 release onwards,
* databasemetadata calls will always look at metadata.properties so it
* will get the compatible syntax for that release.
*/
public static final int dd_version_current			   1
/** cloudscape 5.0 system catalog version */
public static final int dd_version_cs_5_0			  80
/** cloudscape 5.1 (arwen) system catalog version */
public static final int dd_version_cs_5_1			  90
/** cloudscape 5.2 (frodo) system catalog version */
public static final int dd_version_cs_5_2			  100
/** cloudscape 8.1 (pre-gandalf) system catalog version */
public static final int dd_version_cs_8_1			  110
/** cloudscape/derby 10.0 (gandalf) system catalog version */
public static final int dd_version_cs_10_0			  120
/** derby 10.1 system catalog version */
public static final int dd_version_derby_10_1		  130
/** derby 10.2 system catalog version */
public static final int dd_version_derby_10_2		  140
// general info
public	static	final	string	database_id
// version ids
/**
* datadictionaryversion property indicates the updgrade level of the system catalogs.
* stored as a database property. set to an instance of dd_version with
* the major number one of the datadictionary.dd_* values.
*/
public	static	final	string	core_data_dictionary_version
/**
* createdatadictionaryversion property indicates the level of the system catalogs,
* at the time of database creation.
* stored as a database property. set to an instance of dd_version.
*/
public	static	final	string	create_data_dictionary_version
/**
* derby.softdatadictionaryversion property indicates the soft upgrade level of the system catalogs.
* soft upgrade will sometime make minor changes to the system catalogs that can be safely consumed by
* earlier versions, such as correcting values.
* stored as a database property. set to an instance of dd_version.
*/
public  static  final   string  soft_data_dictionary_version
public  static  final   string  property_conglomerate_version
/*
** core tables
*/
/* note - sysconglomerates must be first, since that table must exist before
* any other conglomerates can be created/added to the system.
*/
public static final int sysconglomerates_catalog_num   0
public static final int systables_catalog_num   1
public static final int syscolumns_catalog_num   2
public static final int sysschemas_catalog_num   3
/**
* catalog numbers for non core system catalogs.
*/
public static final int sysconstraints_catalog_num   4
public static final int syskeys_catalog_num   5
public static final int sysdepends_catalog_num   6
public static final int sysaliases_catalog_num   7
public static final int sysviews_catalog_num   8
public static final int syschecks_catalog_num   9
public static final int sysforeignkeys_catalog_num   10
public static final int sysstatements_catalog_num   11
public static final int sysfiles_catalog_num   12
public static final int systriggers_catalog_num   13
public static final int sysstatistics_catalog_num   14
public static final int sysdummy1_catalog_num   15
public static final int systableperms_catalog_num   16
public static final int syscolperms_catalog_num   17
public static final int sysroutineperms_catalog_num   18
/* static finals for constraints
* (here because they are needed by parser, compilation and execution.)
*/
public static final int notnull_constraint   1
public static final int primarykey_constraint   2
public static final int unique_constraint   3
public static final int check_constraint   4
public static final int drop_constraint   5
public static final int foreignkey_constraint   6
/** modes returned from startreading() */
public static final int compile_only_mode   0
public static final int ddl_mode   1
/**
* push a data dictionary context onto the
* current context manager.
*
* @param cm context manager
*/
datadictionarycontext pushdatadictionarycontext contextmanager cm
/**
* clear all of the datadictionary caches.
*
* @exception standardexception standard cloudscape error policy
*/
public void clearcaches   throws standardexception
/**
* inform this datadictionary that we are about to start reading it.  this
* means using the various get methods in the datadictionary.
* generally, this is done during query compilation.
*
* @param lcc	the languageconnectioncontext to use.
*
* @return	the mode that the reader will use, to be passed to donereading()
*			either compile_only_mode or ddl_mode.
*
* @exception standardexception		thrown on error
*/
public int startreading languageconnectioncontext lcc  throws standardexception
/**
* inform this datadictionary that we have finished reading it.  this
* typically happens at the end of compilation.
*
* @param mode	the mode that was returned by startreading().
* @param lcc	the languageconnectioncontext to use.
*
* @exception standardexception		thrown on error
*/
public void donereading int mode
languageconnectioncontext lcc
throws standardexception;
/**
* inform this datadictionary that we are about to start writing to it.
* this means using the various add and drop methods in the datadictionary.
* generally, this is done during execution of ddl.
*
* @param lcc	the languageconnectioncontext to use.
*
* @exception standardexception		thrown on error
*/
public void startwriting languageconnectioncontext lcc
throws standardexception;
/**
* inform this datadictionary that the transaction in which writes have
* been done (or may have been done) has been committed or rolled back.
*
* @exception standardexception		thrown on error
*/
public void transactionfinished   throws standardexception
/**
* get the executionfactory associated with this database.
*
* @return	the executionfactory
*/
public executionfactory	getexecutionfactory
/**
* get the datavaluefactory associated with this database.
*
* @return	the executionfactory
*/
public datavaluefactory	getdatavaluefactory
/**
* get a datadescriptorgenerator, through which we can create
* objects to be stored in the datadictionary.
*
* @return	a datadescriptorgenerator
*
*/
public datadescriptorgenerator	getdatadescriptorgenerator
/**
* get authorizationid of database owner
*
* @return	authorizationid
*/
public string getauthorizationdatabaseowner
/**
* get authorization model in force, sqlstandard or legacy mode
*
* @return	whether sqlauthorization is being used
*/
public boolean usessqlauthorization
/**
* get the descriptor for the named schema.
schema descriptors include authorization ids and schema ids.
* sql92 allows a schema to specify a default character set - we will
* not support this.  will check default schema for a match
* before scanning a system table.
*
* @param schemaname	the name of the schema we're interested in. must not be null.
* @param tc			transactioncontroller
*
* @param raiseerror    whether an exception should be thrown if the schema does not exist.
*
* @return	the descriptor for the schema. can be null (not found) if raiseerror is false.
*
* @exception standardexception		thrown on error
*/
public schemadescriptor	getschemadescriptor string schemaname
transactioncontroller tc
boolean raiseerror
throws standardexception;
/**
* get the descriptor for the named schema. if the schemaid
* parameter is null, it gets the descriptor for the current (default)
* schema. schema descriptors include authorization ids and schema ids.
* sql92 allows a schema to specify a default character set - we will
* not support this.
*
* @param schemaid	the id of the schema we're interested in.
*			if the name is null, get the descriptor for the
*			current schema.
*
* @param tc		the transaction controller to us when scanning
*					sysschemas
*
* @return	the descriptor for the schema.
*
* @exception standardexception		thrown on failure
*/
public schemadescriptor	getschemadescriptor uuid schemaid  transactioncontroller tc
throws standardexception;
/**
* get the descriptor for the system schema. schema descriptors include
* authorization ids and schema ids.
*
* sql92 allows a schema to specify a default character set - we will
* not support this.
*
* @return	the descriptor for the schema.
*
* @exception standardexception		thrown on failure
*/
public schemadescriptor	getsystemschemadescriptor
throws standardexception;
/**
* get the descriptor for the sysibm schema. schema descriptors include
* authorization ids and schema ids.
*
* sql92 allows a schema to specify a default character set - we will
* not support this.
*
* @return	the descriptor for the schema.
*
* @exception standardexception		thrown on failure
*/
public schemadescriptor	getsysibmschemadescriptor
throws standardexception;
/**
* get the descriptor for the syscs_diag schema. schema descriptors
* include authorization ids and schema ids.
*
* sql92 allows a schema to specify a default character set - we will
* not support this.
*
* @return	the descriptor for the schema.
*
* @exception standardexception		thrown on failure
*/
public schemadescriptor	getsystemdiagschemadescriptor
throws standardexception;
/**
* get the descriptor for the declared global temporary table schema which is always named "session".
*
* sql92 allows a schema to specify a default character set - we will
* not support this.
*
* @return	the descriptor for the schema.
*
* @exception standardexception		thrown on failure
*/
public schemadescriptor	getdeclaredglobaltemporarytablesschemadescriptor
throws standardexception;
/**
* determine whether a string is the name of the system schema.
*
* @param name
* @return	true or false
*
* @exception standardexception		thrown on failure
*/
public boolean issystemschemaname  string name
throws standardexception;
/**
* drop the descriptor for a schema, given the schema's name
*
* @param schemaname	the name of the schema to drop
* @param tc			transaction controller
*
* @exception standardexception		thrown on failure
*/
public void	dropschemadescriptor string schemaname
transactioncontroller tc
throws standardexception;
/**
* indicate whether there is anything in the
* particular schema.  checks for tables in the
* the schema, on the assumption that there cannot
* be any other objects in a schema w/o a table.
*
* @param sd schema descriptor
*
* @return true/false
*
* @exception standardexception on error
*/
public boolean isschemaempty schemadescriptor sd
throws standardexception;
/**
* get the descriptor for the named table within the given schema.
* if the schema parameter is null, it looks for the table in the
* current (default) schema. table descriptors include object ids,
* object types (table, view, etc.)
*
* @param tablename	the name of the table to get the descriptor for
* @param schema	the descriptor for the schema the table lives in.
*			if null, use the current (default) schema.
*
* @return	the descriptor for the table, null if table does not
*		existe.
*
* @exception standardexception		thrown on failure
*/
public tabledescriptor		gettabledescriptor string tablename
schemadescriptor schema
throws standardexception;
/**
* get the descriptor for the table with the given uuid.
*
* note: i'm assuming that the object store will define an uuid for
* persistent objects. i'm also assuming that uuids are unique across
* schemas, and that the object store will be able to do efficient
* lookups across schemas (i.e. that no schema descriptor parameter
* is needed).
*
* @param tableid	the uuid of the table to get the descriptor for
*
* @return	the descriptor for the table, null if the table does
*		not exist.
*
* @exception standardexception		thrown on failure
*/
public tabledescriptor		gettabledescriptor uuid tableid
throws standardexception;
/**
* drop the table descriptor.
*
* @param td	the table descriptor to drop
* @param schema		a descriptor for the schema the table
*						is a part of.  if this parameter is
*						null, then the table is part of the
*						current (default) schema
* @param tc			transactioncontroller for the transaction
* @exception standardexception		thrown on error
*/
public void	droptabledescriptor tabledescriptor td  schemadescriptor schema
transactioncontroller tc
throws standardexception;
/**
* update the lockgranularity for the specified table.
*
* @param td				the tabledescriptor for the table
* @param schema			the schemadescriptor for the table
* @param lockgranularity	the new lockgranularity
* @param tc				the transactioncontroller to use.
*
* @exception standardexception		thrown on error
*/
public void updatelockgranularity tabledescriptor td  schemadescriptor schema
char lockgranularity  transactioncontroller tc
throws standardexception;
/**
* drop all table descriptors for a schema.
*
* @param schema	a descriptor for the schema to drop the tables
*			from.
*
* @exception standardexception		thrown on failure
*/
/*
public void dropalltabledescriptors(schemadescriptor schema)
throws standardexception;
*/
/**
* get a columndescriptor given its default id.
*
* @param uuid	the uuid of the default
*
* @return the columndescriptor for the column.
*
* @exception standardexception		thrown on failure
*/
public columndescriptor getcolumndescriptorbydefaultid uuid uuid
throws standardexception;
/**
* given a column name and a table id, drops the column descriptor
* from the table.
*
* @param tableid	the uuid of the table to drop the column from
* @param columnname	the name of the column to drop
* @param tc		transactioncontroller for the transaction
*
* @exception standardexception		thrown on failure
*/
public void	dropcolumndescriptor uuid tableid
string columnname  transactioncontroller tc
throws standardexception;
/**
* drops all column descriptors from the given table.  useful for
* drop table.
*
* @param tableid	the uuid of the table from which to drop
*			all the column descriptors
* @param tc		transactioncontroller for the transaction
*
* @exception standardexception		thrown on failure
*/
public void	dropallcolumndescriptors uuid tableid  transactioncontroller tc
throws standardexception;
/**
* drops all table and column permission descriptors for the given table.
*
* @param tableid	the uuid of the table for which to drop
*			all the table and column permission descriptors
* @param tc		transactioncontroller for the transaction
*
* @exception standardexception		thrown on failure
*/
public void	dropalltableandcolpermdescriptors uuid tableid  transactioncontroller tc
throws standardexception;
/**
* drops all routine permission descriptors for the given routine.
*
* @param routineid	the uuid of the routine for which to drop
*			all the permission descriptors
* @param tc		transactioncontroller for the transaction
*
* @exception standardexception		thrown on failure
*/
public void	dropallroutinepermdescriptors uuid routineid  transactioncontroller tc
throws standardexception;
/**
* gets the viewdescriptor for the view with the given uuid.
*
* @param uuid	the uuid for the view
*
* @return  a descriptor for the view
*
* @exception standardexception		thrown on error
*/
public viewdescriptor	getviewdescriptor uuid uuid
throws standardexception;
/**
* gets the viewdescriptor for the view given its tabledescriptor.
*
* @param td	the tabledescriptor for the view.
*
* @return	a descriptor for the view
*
* @exception standardexception		thrown on error
*/
public viewdescriptor	getviewdescriptor tabledescriptor td
throws standardexception;
/**
* drops the view descriptor from the data dictionary.
*
* @param viewdescriptor	a descriptor for the view to be dropped
* @param tc				transactioncontroller to use
*
* @exception standardexception		thrown on failure
*/
public void	dropviewdescriptor viewdescriptor viewdescriptor
transactioncontroller tc
throws standardexception;
/**
* get a constraintdescriptor given its uuid.
*
* @param uuid	the uuid
*
* @return the constraintdescriptor for the constraint.
*
* @exception standardexception		thrown on failure
*/
public constraintdescriptor getconstraintdescriptor uuid uuid
throws standardexception;
/**
* get a constraintdescriptor given its name and schema id.
*
* @param constraintname	constraint name.
* @param schemaid			the schema uuid
*
* @return the constraintdescriptor for the constraint.
*
* @exception standardexception		thrown on failure
*/
public constraintdescriptor getconstraintdescriptor
string	constraintname
uuid	schemaid
throws standardexception;
/**
* load up the constraint descriptor list for this table
* descriptor and return it.  if the descriptor list
* is already loaded up, it is retuned without further
* ado.
*
* @param td			the table descriptor.
*
* @return the constraintdescriptorlist for the table
*
* @exception standardexception		thrown on failure
*/
public constraintdescriptorlist getconstraintdescriptors tabledescriptor td
throws standardexception;
/**
* convert a constraint descriptor list into a list
* of active constraints, that is, constraints which
* must be enforced. for the core product, these
* are just the constraints on the original list.
* however, during refresh we may have deferred some
* constraints until statement end. this method returns
* the corresponding list of constraints which aren't
* deferred.
*
* @param cdl	the constraint descriptor list to wrap with
*				an active constraint descriptor list.
*
* @return the corresponding active constraintdescriptorlist
*
* @exception standardexception		thrown on failure
*/
public constraintdescriptorlist getactiveconstraintdescriptors constraintdescriptorlist cdl
throws standardexception;
/**
* reports whether an individual constraint must be
* enforced. for the core product, this routine always
* returns true.
*
* however, during refresh we may have deferred some
* constraints until statement end. this method returns
* false if the constraint deferred
*
* @param constraint	the constraint to check
*
*
* @return the corresponding active constraintdescriptorlist
*
* @exception standardexception		thrown on failure
*/
public boolean activeconstraint  constraintdescriptor constraint
throws standardexception;
/**
* get the constraint descriptor given a table and the uuid string
* of the backing index.
*
* @param td			the table descriptor.
* @param uuid			the uuid  for the backing index.
*
* @return the constraintdescriptor for the constraint.
*
* @exception standardexception		thrown on failure
*/
public constraintdescriptor getconstraintdescriptor tabledescriptor td
uuid uuid
throws standardexception;
/**
* get the constraint descriptor given a table and the uuid string
* of the constraint
*
* @param td			the table descriptor.
* @param uuid			the uuid for the constraint
*
* @return the constraintdescriptor for the constraint.
*
* @exception standardexception		thrown on failure
*/
public constraintdescriptor getconstraintdescriptorbyid
tabledescriptor	td
uuid			uuid
throws standardexception;
/**
* get the constraint descriptor given a tabledescriptor and the constraint name.
*
* @param td				the table descriptor.
* @param sd				the schema descriptor for the constraint
* @param constraintname	the constraint name.
* @param forupdate			whether or not access is for update
*
* @return the constraintdescriptor for the constraint.
*
* @exception standardexception		thrown on failure
*/
public constraintdescriptor getconstraintdescriptorbyname tabledescriptor td
schemadescriptor sd
string constraintname
boolean forupdate
throws standardexception;
/**
* return a table descriptor corresponding to the tableid
* field in sysconstraints where constraintid matches
* the constraintid passed in.
*
* @param constraintid	the id of the constraint
*
* @return	the corresponding table descriptor
*
* @exception standardexception		thrown on error
*/
public tabledescriptor getconstrainttabledescriptor uuid constraintid
throws standardexception;
/**
* return a list of foreign keys constraints referencing
* this constraint.  returns both enabled and disabled
* constraints.
*
* @param constraintid	the id of the referenced constraint
*
* @return	list of constraints
*
* @exception standardexception		thrown on error
*/
public constraintdescriptorlist getforeignkeys uuid constraintid
throws standardexception;
/**
* adds the given constraintdescriptor to the data dictionary,
* associated with the given table and constraint type.
*
* @param descriptor	the descriptor to add
* @param tc			the transaction controller
*
* @exception standardexception		thrown on error
*/
public void	addconstraintdescriptor
constraintdescriptor descriptor
transactioncontroller tc
throws standardexception;
/**
* drops the given constraintdescriptor that is associated
* with the given table and constraint type from the data dictionary.
*
* note: caller is responsible for dropping any backing index
*
* @param table	the table from which to drop the
*			constraint descriptor
* @param descriptor	the descriptor to drop
* @param tc	the transactioncontroller.
*
* @exception standardexception		thrown on failure
*/
public void	dropconstraintdescriptor tabledescriptor table
constraintdescriptor descriptor
transactioncontroller tc
throws standardexception;
/**
* drops all constraintdescriptors from the data dictionary
* that are associated with the given table.
*
* note: caller is responsible for dropping any backing index
*
* @param table	the table from which to drop all
*			constraint descriptors
* @param tc	the transactioncontroller.
*
* @exception standardexception		thrown on failure
*/
public void	dropallconstraintdescriptors tabledescriptor table
transactioncontroller tc
throws standardexception;
/**
* update the constraint descriptor in question.  updates
* every row in the base conglomerate.
*
* @param cd					the constraintescriptor
* @param formeruuid			the uuid for this column in sysconstraints,
*								may differ from what is in cd if this
*								is the column that is being set.
* @param colstoset 			array of ints of columns to be modified,
*								1 based.  may be null (all cols).
* @param tc					the transactioncontroller to use
*
*
* @exception standardexception		thrown on failure
*/
public void updateconstraintdescriptor constraintdescriptor cd
uuid		formeruuid
int		colstoset
transactioncontroller tc
throws standardexception;
/**
* get a subkeyconstraintdescriptor from syskeys or sysforeignkeys for
* the specified constraint id.  for primary foreign and and unique
* key constraints.
*
* @param constraintid	the uuid for the constraint.
* @param type	the type of the constraint
*		(e.g. datadictionary.foreignkey_constraint)
*
* @return subkeyconstraintdescriptor	the sub descriptor for the constraint.
*
* @exception standardexception		thrown on failure
*/
public subkeyconstraintdescriptor getsubkeyconstraint uuid constraintid  int type
throws standardexception;
/**
* get a spsdescriptor given its uuid.
*
* @param uuid	the uuid
*
*
* @return the spsdescriptor for the constraint.
*
* @exception standardexception		thrown on failure
*/
public spsdescriptor getspsdescriptor uuid uuid
throws standardexception;
/**
* get the stored prepared statement descriptor given
* a sps name.
*
* @param name	the sps name.
* @param sd	the schema descriptor.
*
* @return the spsdescriptor for the constraint.
*
* @exception standardexception		thrown on failure
*/
public spsdescriptor getspsdescriptor string name  schemadescriptor sd
throws standardexception;
/**
* get every statement in this database.
* return the spsdescriptors in an list.
*
* @return the list of descriptors
*
* @exception standardexception		thrown on failure
*/
public list getallspsdescriptors
throws standardexception;
/**
* get all the parameter descriptors for an sps.
* look up the params in syscolumns and turn them
* into parameter descriptors.
*
* @param spsd	sps descriptor
* @param defaults the parameter defaults.  if not null,
*					all the parameter defaults will be stuffed
*					in here.
*
* @return array of data type descriptors
*
* @exception standardexception		thrown on error
*/
public datatypedescriptor getspsparams spsdescriptor spsd  vector defaults
throws standardexception;
/**
* adds the given spsdescriptor to the data dictionary,
* associated with the given table and constraint type.
*
* @param descriptor	the descriptor to add
* @param tc			the transaction controller
* @param wait			to wait for lock or not
*
* @exception standardexception		thrown on error
*/
public void	addspsdescriptor
spsdescriptor 			descriptor
transactioncontroller	tc
boolean					wait
throws standardexception
/**
* updates sys.sysstatements with the info from the
* spsd.
*
* @param spsd	the descriptor to add
* @param tc			the transaction controller
* @param recompile		whether to recompile or invalidate
* @param updatesyscolumns indicate whether syscolumns needs to be updated
*							or not.
* @param wait		if true, then the caller wants to wait for locks. false will be
* @param firstcompilation  first time sps is getting compiled.
* when we using a nested user xaction - we want to timeout right away if
* the parent holds the lock.  (bug 4821)
*
* @exception standardexception		thrown on error
*/
public void	updatesps
spsdescriptor		spsd
transactioncontroller	tc
boolean                 recompile
boolean					updatesyscolumns
boolean					wait
boolean                 firstcompilation
throws standardexception;
/**
* drops the given spsdescriptor.
*
* @param descriptor	the descriptor to drop
* @param tc	the transactioncontroller.
*
* @exception standardexception		thrown on failure
*/
public void	dropspsdescriptor spsdescriptor descriptor
transactioncontroller tc
throws standardexception;
/**
* drops the given spsdescriptor.
*
* @param uuid	the statement uuid
* @param tc	the transactioncontroller.
*
* @exception standardexception		thrown on failure
*/
public void	dropspsdescriptor
uuid 					uuid
transactioncontroller	tc
throws standardexception
/**
* invalidate all the stored plans in sys.sysstatements.
* @exception standardexception		thrown on error
*/
public void invalidateallspsplans   throws standardexception
/**
* get a triggerdescriptor given its uuid.
*
* @param uuid	the uuid
*
*
* @return the triggerdescriptor for the constraint.
*
* @exception standardexception		thrown on failure
*/
public triggerdescriptor gettriggerdescriptor uuid uuid
throws standardexception;
/**
* get the stored prepared statement descriptor given
* a sps name.
*
* @param name	the sps name.
* @param sd	the schema descriptor.
*
* @return the triggerdescriptor for the constraint.
*
* @exception standardexception		thrown on failure
*/
public triggerdescriptor gettriggerdescriptor string name  schemadescriptor sd
throws standardexception;
/**
* load up the trigger descriptor list for this table
* descriptor and return it.  if the descriptor list
* is already loaded up, it is retuned without further
* ado.
*
* @param td			the table descriptor.
*
* @return the constraintdescriptorlist for the table
*
* @exception standardexception		thrown on failure
*/
public genericdescriptorlist gettriggerdescriptors tabledescriptor td
throws standardexception;
/**
* update the trigger descriptor in question.  updates
* every row in the base conglomerate.
*
* @param triggerd				the triggerescriptor
* @param formeruuid			the uuid for this column in systriggers,
*								may differ from what is in triggerd if this
*								is the column that is being set.
* @param colstoset 			array of ints of columns to be modified,
*								1 based.  may be null (all cols).
* @param tc					the transactioncontroller to use
*
* @exception standardexception		thrown on failure
*/
public void updatetriggerdescriptor
triggerdescriptor 	triggerd
uuid					formeruuid
int					colstoset
transactioncontroller	tc
throws standardexception
/**
* drops the given triggerdescriptor that is associated
* with the given table and constraint type from the data dictionary.
*
* @param descriptor	the descriptor to drop
* @param tc	the transactioncontroller.
*
* @exception standardexception		thrown on failure
*/
public void	droptriggerdescriptor
triggerdescriptor 		descriptor
transactioncontroller 	tc
throws standardexception
/**
* get all of the conglomeratedescriptors in the database and
* hash them by conglomerate number.
* this is useful as a performance optimization for the locking vtis.
* note:  this method will scan sys.sysconglomerates at read committed.
* it should really scan at read uncommitted, but there is no such
* thing yet.
*
* @param tc		transactioncontroller for the transaction
*
* @return	a hashtable with all of the conglomeratedescriptors
*		in the database hashed by conglomerate number.
*
* @exception standardexception		thrown on failure
*/
public hashtable hashallconglomeratedescriptorsbynumber transactioncontroller tc
throws standardexception;
/**
* get all of the tabledescriptors in the database and hash them by tableid
* this is useful as a performance optimization for the locking vtis.
* note:  this method will scan sys.systables at read committed.
* it should really scan at read uncommitted, but there is no such
* thing yet.
*
* @param tc		transactioncontroller for the transaction
*
* @return	a hashtable with all of the table descriptors in the database
*			hashed by tableid
*
*
* @exception standardexception		thrown on failure
*/
public hashtable hashalltabledescriptorsbytableid transactioncontroller tc
throws standardexception;
/**
* get a conglomeratedescriptor given its uuid.  if it is an index
* conglomerate shared by at least another duplicate index, this returns
* one of the conglomeratedescriptors for those indexes.
*
* @param uuid	the uuid
*
*
* @return a conglomeratedescriptor for the conglomerate.
*
* @exception standardexception		thrown on failure
*/
public conglomeratedescriptor getconglomeratedescriptor uuid uuid
throws standardexception;
/**
* get an array of conglomeratedescriptors given the uuid.  if it is a
* heap conglomerate or an index conglomerate not shared by a duplicate
* index, the size of the return array is 1.
*
* @param uuid	the uuid
*
*
* @return an array of conglomeratedescriptors for the conglomerate.
*
* @exception standardexception		thrown on failure
*/
public conglomeratedescriptor getconglomeratedescriptors uuid uuid
throws standardexception;
/**
* get a conglomeratedescriptor given its conglomerate number.  if it is an
* index conglomerate shared by at least another duplicate index, this
* returns one of the conglomeratedescriptors for those indexes.
*
* @param conglomeratenumber	the conglomerate number.
*
*
* @return a conglomeratedescriptor for the conglomerate.  returns null if
*				no such conglomerate.
*
* @exception standardexception		thrown on failure
*/
public conglomeratedescriptor	getconglomeratedescriptor
long conglomeratenumber
throws standardexception;
/**
* get an array of conglomerate descriptors for the given conglomerate
* number.  if it is a heap conglomerate or an index conglomerate not
* shared by a duplicate index, the size of the return array is 1.
*
* @param conglomeratenumber	the number for the conglomerate
*				we're interested in
*
* @return	an array of conglomeratedescriptors that share the requested
*		conglomerate. returns size 0 array if no such conglomerate.
*
* @exception standardexception		thrown on failure
*/
public conglomeratedescriptor	getconglomeratedescriptors
long conglomeratenumber
throws standardexception;
/**
* gets a conglomerate descriptor for the named index in the given schema,
* getting an exclusive row lock on the matching row in
* sys.sysconglomerates (for ddl concurrency) if requested.
*
* @param indexname	the name of the index we're looking for
* @param sd		the schema descriptor
* @param forupdate	whether or not to get an exclusive row
*					lock on the row in sys.sysconglomerates.
*
* @return	a conglomeratedescriptor describing the requested
*		conglomerate. returns null if no such conglomerate.
*
* @exception standardexception		thrown on failure
*/
public conglomeratedescriptor	getconglomeratedescriptor
string indexname
schemadescriptor sd
boolean forupdate
throws standardexception;
/**
* drops a conglomerate descriptor
*
* @param conglomerate	the conglomeratedescriptor for the conglomerate
* @param tc		transactioncontroller for the transaction
*
* @exception standardexception		thrown on failure
*/
public void dropconglomeratedescriptor
conglomeratedescriptor conglomerate
transactioncontroller tc
throws standardexception;
/**
* drops all conglomerates associated with a table.
*
* @param td		the tabledescriptor of the table
* @param tc		transactioncontroller for the transaction
*
* @exception standardexception		thrown on failure
*/
public void dropallconglomeratedescriptors
tabledescriptor td
transactioncontroller tc
throws standardexception;
/**
* update the conglomeratenumber for an array of conglomeratedescriptors.
* in case of more than one conglomeratedescriptor, they are for duplicate
* indexes sharing one conglomerate.
* this is useful, in 1.3, when doing a bulkinsert into an
* empty table where we insert into a new conglomerate.
* (this will go away in 1.4.)
*
* @param cds					the array of conglomeratedescriptors
* @param conglomeratenumber	the new conglomerate number
* @param tc					the transactioncontroller to use
*
* @exception standardexception		thrown on failure
*/
public void updateconglomeratedescriptor conglomeratedescriptor cds
long conglomeratenumber
transactioncontroller tc
throws standardexception;
/**
* update the conglomeratenumber for a conglomeratedescriptor.
* this is useful, in 1.3, when doing a bulkinsert into an
* empty table where we insert into a new conglomerate.
* (this will go away in 1.4.)
*
* @param cd					the conglomeratedescriptor
* @param conglomeratenumber	the new conglomerate number
* @param tc					the transactioncontroller to use
*
* @exception standardexception		thrown on failure
*/
public void updateconglomeratedescriptor conglomeratedescriptor cd
long conglomeratenumber
transactioncontroller tc
throws standardexception;
/**
* gets a list of the dependency descriptors for the given dependent's id.
*
* @param dependentid		the id of the dependent we're interested in
*
* @return	list			returns a list of dependencydescriptors.
*							returns an empty list if no stored dependencies for the
*							dependent's id.
*
* @exception standardexception		thrown on failure
*/
public list getdependentsdescriptorlist string dependentid
throws standardexception;
/**
* gets a list of the dependency descriptors for the given provider's id.
*
* @param providerid		the id of the provider we're interested in
*
* @return	list			returns a list of dependencydescriptors.
*							returns an empty list if no stored dependencies for the
*							provider's id.
*
* @exception standardexception		thrown on failure
*/
public list getprovidersdescriptorlist string providerid
throws standardexception;
/**
* build and return an list with dependencydescriptors for
* all of the stored dependencies.
* this is useful for consistency checking.
*
* @return list		list of all dependencydescriptors.
*
* @exception standardexception		thrown on failure
*/
public list getalldependencydescriptorslist
throws standardexception;
/**
* drop a dependency from the data dictionary.
*
* @param dd	the dependencydescriptor.
* @param tc	transactioncontroller for the transaction
*
* @exception standardexception		thrown on failure
*/
public void dropstoreddependency dependencydescriptor dd
transactioncontroller tc
throws standardexception;
/**
* remove all of the stored dependencies for a given dependent's id
* from the data dictionary.
*
* @param dependentsuuid	dependent's uuid
* @param tc				transactioncontroller for the transaction
*
* @exception standardexception		thrown on failure
*/
public void dropdependentsstoreddependencies uuid dependentsuuid
transactioncontroller tc
throws standardexception;
/**
* get the uuid factory.  (no need to make the uuidfactory a module.)
*
* @return uuidfactory	the uuid factory for this datadictionary.
*/
uuidfactory getuuidfactory
/**
* get an aliasdescriptor given its uuid.
*
* @param uuid	the uuid
*
*
* @return the aliasdescriptor for method alias.
*
* @exception standardexception		thrown on failure
*/
public aliasdescriptor getaliasdescriptor uuid uuid
throws standardexception;
/**
* get a aliasdescriptor by alias name and name space.
* note: caller responsible for handling no match.
*
@param schemaid		schema identifier
* @param aliasname		the alias name.
* @param namespace		the alias name space.
*
* @return aliasdescriptor	aliasdescriptor for the alias name and name space
*
* @exception standardexception		thrown on failure
*/
public aliasdescriptor getaliasdescriptor string schemaid  string aliasname  char namespace
throws standardexception;
/**
get the list of routines matching the schema and routine name.
*/
public java util list getroutinelist string schemaid  string routinename  char namespace
throws standardexception;
/**
* drop an aliasdescriptor from the datadictionary
*
* @param ad	the aliasdescriptor to drop
* @param tc	the transactioncontroller
*
* @exception standardexception		thrown on failure
*/
public void dropaliasdescriptor aliasdescriptor ad
transactioncontroller tc
throws standardexception;
public	int	getenginetype
/**
* get a fileinfodescriptor given its id.
*
* @param id the descriptor's id.
*
* @exception standardexception		thrown on failure
*/
public fileinfodescriptor getfileinfodescriptor uuid id
throws standardexception;
/**
* get a fileinfodescriptor given its sql name and
* schema name.
*
* @param sd        the schema that holds the fileinfodescriptor.
* @param name		sql name of file.
*
* @exception standardexception		thrown on failure
*/
public fileinfodescriptor getfileinfodescriptor schemadescriptor sd  string name
throws standardexception;
/**
* drop a filedescriptor from the datadictionary.
*
* @exception standardexception oops
*/
public void dropfileinfodescriptor fileinfodescriptor fid
throws standardexception;
/**
* returns an array of rowlocations corresponding to
* the autoincrement columns in the table. the rowlocation points to the
* row in syscolumns for this particular ai column.
* the array has as many elements as there are columns in the table. if a column
* is not an ai column, the entry is null.
*
* @param 	tc		transactioncontroler to use to compute the row location.
* @param   td		tabledescriptor
*
* @return  array of row locations, null if table has no autoinc columns.
*
* @exception standard exception on error.
*/
public rowlocation computeautoincrowlocations transactioncontroller tc
tabledescriptor td
throws standardexception;
/* returns a row location template for a table */
public rowlocation getrowlocationtemplate  languageconnectioncontext lcc  tabledescriptor td
throws standardexception;
/**
* getsetautoincrementvalue fetches the autoincrement value from
* syscolumns given a row location. if doupdate is true it updates
* the autoincrement column with the new value.
* the value returned by this routine is the new value and *not* the
* value in the system catalogs.
*
* @param rl		rowlocation of the entry in syscolumns.
* @param tc		transactioncontroller to use.
* @param doupdate  write the new value to disk if true.
* @param newvalue	a numberdatavalue to use to return incremented value. if
* null, then the caller simply wants the current value fromd disk.
* @param wait		if true, then the caller wants to wait for locks. when
* using a nested user xaction we want to timeout right away if the parent
* holds the lock.
*/
public numberdatavalue 	getsetautoincrementvalue rowlocation rl
transactioncontroller tc
boolean doupdate
numberdatavalue newvalue
boolean wait
throws standardexception;
/**
* sets a new value in syscolumns for a particular
* autoincrement column.
*
* @param tc		 transaction controller to use.
* @param tableuuid		 table descriptor
* @param columnname name of the column.
* @param aivalue	 value to write to syscolumns.
* @param incrementneeded whether we should increment the value passed in by
* the user (aivalue) before writing the value to syscolumns.
*/
public void setautoincrementvalue transactioncontroller tc
uuid tableuuid
string columnname
long aivalue
boolean incrementneeded
throws standardexception;
/**
* gets all statistics descriptors for a given table.
*/
public list getstatisticsdescriptors tabledescriptor td
throws standardexception;
/**
* drops all statistics descriptors for a given table/index column
* combination. if the index is not specified, then all statistics for the
* table are dropped.
*
* @param 	tableuuid 	  uuid of the table
* @param   referenceuuid uuid of the index. this can be null.
* @param   tc 			  transcation controller to use.
*/
public void dropstatisticsdescriptors uuid tableuuid  uuid referenceuuid
transactioncontroller tc
throws standardexception;
/**
* returns the dependency manager for this datadictionary. associated with
* each datadictionary object there is a dependencymanager object which
* keeps track of both persistent and stored dependencies.
*
* @see org.apache.derby.iapi.sql.depend.dependencymanager
*/
public dependencymanager getdependencymanager
/**
* returns the cache mode of the data dictionary.
*/
public int getcachemode
/**
*	returns a unique system generated name of the form sqlyymmddhhmmssxxn
*	  yy - year, mm - month, dd - day of month, hh - hour, mm - minute, ss - second,
*	  xx - the first 2 digits of millisec because we don't have enough space to keep the exact millisec value,
*	  n - number between 0-9
*
*	@return	system generated unique name
*/
public string getsystemsqlname
/**
* adds a descriptor to a system catalog identified by the catalognumber.
*
* @param tuple			   descriptor to insert.
* @param parent           parent descriptor; e.g for a column parent is the
* tabledescriptor to which the descriptor is beign inserted. for most other
* objects it is the schema descriptor.
* @param catalognumber	   a value which identifies the catalog into which
* the descriptor should be inserted. it is the users responsibility to
* ensure that the catalognumber is consistent with the tuple being
* inserted.
* @see datadictionary#sysconglomerates_catalog_num
* @param allowsduplicates whether an exception should be thrown if the
* insert results in a duplicate; if this parameter is false then one
* of the following exception will be thrown; lang_object_already_exists (if
* parent is null) or lang_object_already_exists_in_object (if parent is not
* null). the error message is created by getting the name and type of the
* tuple and parent.
* @see org.apache.derby.impl.sql.catalog.datadictionaryimpl#duplicatedescriptorexception
* @param 	tc	the transaction controller to use to do all of this.
*
* @see #adddescriptorarray
*/
public void adddescriptor tupledescriptor tuple  tupledescriptor parent
int catalognumber  boolean allowsduplicates
transactioncontroller tc
throws standardexception;
/** array version of adddescriptor.
* @see #adddescriptor
*/
public void adddescriptorarray tupledescriptor tuple  tupledescriptor parent
int catalognumber  boolean allowsduplicates
transactioncontroller tc
throws standardexception;
/**
check to see if a database has been upgraded to the required
level in order to use a langauge feature that is.
<p>
this is used to ensure new functionality that would lead on disk
information not understood by a previous release is not executed
while in soft upgrade mode. ideally this is called at compile time
and the parser has a utility method to enable easy use at parse time.
<p>
to use this method, a feature implemented in a certain release (datadictionary version)
would call it with the constant matching the release. e.g. for a new feature added
in 10.1, a call such as
<pre>
// check and throw an exception if the database is not at 10.1
dd.checkversion(datadictionary.dd_version_derby_10_1, "new feature name");
</pre>
this call would occur during the compile time, usually indirectly through
the parser utility method, but direct calls can be made during querynode initialization,
or even at bind time.
<br>
it is not expected that this method would be called at execution time.
@param majorversion data dictionary major version (datadictionary.dd_ constant)
@param feature non-null to throw an error, null to return the state of the version match.
@return true if the database has been upgraded to the required level, false otherwise.
*/
public boolean checkversion int majorversion  string feature  throws standardexception
/**
* add or remove a permission to the permission database.
*
* @param add if true then add the permission, if false remove it.
* @param perm
* @param grantee
* @param tc
*
* @return true means revoke has removed a privilege from system
* table and hence the caller of this method should send invalidation
* actions to permssiondescriptor's dependents.
*/
public boolean addremovepermissionsdescriptor  boolean add
permissionsdescriptor perm
string grantee
transactioncontroller tc
throws standardexception;
/**
* get one user's privileges on a table using tableuuid and authorizationid
*
* @param tableuuid
* @param authorizationid the user name
*
* @return a tablepermsdescriptor or null if the user has no permissions on the table.
*
* @exception standardexception
*/
public tablepermsdescriptor gettablepermissions  uuid tableuuid  string authorizationid
throws standardexception;
/**
* get one user's privileges on a table using tablepermsuuid
*
* @param tablepermsuuid
*
* @return a tablepermsdescriptor
*
* @exception standardexception
*/
public tablepermsdescriptor gettablepermissions  uuid tablepermsuuid
throws standardexception;
/**
* get one user's column privileges for a table.
*
* @param tableuuid
* @param privtype authorizer.select_priv, authorizer.update_priv, or authorizer.references_priv
* @param forgrant
* @param authorizationid the user name
*
* @return a colpermsdescriptor or null if the user has no separate column
*         permissions of the specified type on the table. note that the user may have been granted
*         permission on all the columns of the table (no column list), in which case this routine
*         will return null. you must also call gettablepermissions to see if the user has permission
*         on a set of columns.
*
* @exception standardexception
*/
public colpermsdescriptor getcolumnpermissions  uuid tableuuid
int privtype
boolean forgrant
string authorizationid
throws standardexception;
/**
* get one user's column privileges for a table. this routine gets called
* during revoke privilege processing
*
* @param tableuuid
* @param privtypestr (as string) authorizer.select_priv, authorizer.update_priv, or authorizer.references_priv
* @param forgrant
* @param authorizationid the user name
*
* @return a colpermsdescriptor or null if the user has no separate column
*         permissions of the specified type on the table. note that the user may have been granted
*         permission on all the columns of the table (no column list), in which case this routine
*         will return null. you must also call gettablepermissions to see if the user has permission
*         on a set of columns.
*
* @exception standardexception
*/
public colpermsdescriptor getcolumnpermissions  uuid tableuuid
string privtypestr
boolean forgrant
string authorizationid
throws standardexception;
/**
* get one user's column privileges on a table using colpermsuuid
*
* @param colpermsuuid
*
* @return a colpermsdescriptor
*
* @exception standardexception
*/
public colpermsdescriptor getcolumnpermissions  uuid colpermsuuid
throws standardexception;
/**
* get one user's permissions for a routine (function or procedure).
*
* @param routineuuid
* @param authorizationid the user's name
*
* @return the descriptor of the users permissions for the routine.
*
* @exception standardexception
*/
public routinepermsdescriptor getroutinepermissions  uuid routineuuid  string authorizationid
throws standardexception;
/**
* get one user's privileges for a routine using routinepermsuuid
*
* @param routinepermsuuid
*
* @return a routinepermsdescriptor
*
* @exception standardexception
*/
public routinepermsdescriptor getroutinepermissions  uuid routinepermsuuid
throws standardexception;
/**
* return the java class to use for the vti for
* the virtual table. assumes the descriptor is
* of type tabledescriptor.vti_type.
*/
public string getvticlass tabledescriptor td
throws standardexception;
/**
* adds a descriptor to a system catalog identified by the catalognumber.
*
* @param tuple			   descriptor to insert.
* @param parent           parent descriptor; e.g for a column parent is the
* tabledescriptor to which the descriptor is beign inserted. for most other
* objects it is the schema descriptor.
* @param catalognumber	   a value which identifies the catalog into which
* the descriptor should be inserted. it is the users responsibility to
* ensure that the catalognumber is consistent with the tuple being
* inserted.
* @see datadictionary#sysconglomerates_catalog_num
* @param allowsduplicates whether an exception should be thrown if the
* insert results in a duplicate; if this parameter is false then one
* of the following exception will be thrown; lang_object_already_exists (if
* parent is null) or lang_object_already_exists_in_object (if parent is not
* null). the error message is created by getting the name and type of the
* tuple and parent.
* @see org.apache.derby.impl.sql.catalog.datadictionaryimpl#duplicatedescriptorexception
* @param 	tc	the transaction controller to use to do all of this.
* @param wait  if true, then the caller wants to wait for locks. false will
*	            be when we using a nested user xaction - we want to timeout
*              right away if the parent holds the lock.
* @see #adddescriptorarray
*/
public void adddescriptor tupledescriptor tuple  tupledescriptor parent
int catalognumber  boolean allowsduplicates
transactioncontroller tc  boolean wait
throws standardexception;
/**
* remove all of the stored dependencies for a given dependent's id
* from the data dictionary.
*
* @param dependentsuuid	dependent's uuid
* @param tc				transactioncontroller for the transaction
* @param wait  if true, then the caller wants to wait for locks. false will
*	            be when we using a nested user xaction - we want to timeout
*              right away if the parent holds the lock.
*
* @exception standardexception		thrown on failure
*/
public void dropdependentsstoreddependencies uuid dependentsuuid
transactioncontroller tc
boolean wait
throws standardexception;