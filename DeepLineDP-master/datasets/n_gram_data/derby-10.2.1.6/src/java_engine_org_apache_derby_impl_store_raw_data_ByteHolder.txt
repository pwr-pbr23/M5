/*
derby - class org.apache.derby.impl.store.raw.data.byteholder
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl store raw data
import org apache derby iapi services sanity sanitymanager
import java io ioexception
import java io inputstream
import java io outputstream
import java util vector
/**
holder for a growing sequence of bytes. the byteholder supports a
writing phase in which a caller appends bytes to the byteholder.
later the caller may read the bytes out of the byteholder in
the order they were written.
*/
public interface byteholder
/**
write a byte to this byteholder.
<p>the byteholder must be in writing mode to call this.
*/
public void write int b
throws ioexception
/**
write len bytes of data starting at 'offset' to this byteholder.
<p>the byteholder must be in writing mode to call this.
*/
public void write byte data  int offset  int len
throws ioexception
/**
write up to count bytes from an input stream to this
byteholder. this may write fewer bytes if it encounters
an end of file on the input stream.
@return the number of bytes written.
@exception ioexception thrown when reading in causes an
error.
*/
public long write inputstream in  long count
throws ioexception
/**
clear the bytes from the byteholder and place it in writing
mode. this may not free the memory the byteholder uses to
store data.
*/
public void clear
throws ioexception
/**
place a byteholder in reading mode. after this call,
reads scan bytes sequentially in the order they were
written to the byteholder starting from the first byte.
when the byteholder is already in readmode this simply
arranges for reads to start at the beginning of the
sequence of saved bytes.
*/
public void startreading
throws ioexception
/**
read a byte from this byteholder.
<p>the byteholder must be in reading mode to call this.
@return the byte or -1 if there are no bytes available.
*/
public int read
throws ioexception
/**
read up to 'len' bytes from this byteholder and store them in
an array at offset 'off'.
<p>the byteholder must be in reading mode to call this.
@return the number of bytes read or -1 if the this byteholder
has no more bytes.
*/
public int read byte b
int off
int len
throws ioexception
/**
read from the byteholder.
<p>
read up to 'len' bytes from this byteholder and write them to
the outputstream
<p>the byteholder must be in reading mode to call this.
@return the number of bytes read or -1 if the this byteholder
has no more bytes.
*/
public int read outputstream out
int len
throws ioexception
/**
shift the remaining unread bytes to the beginning of the byte holder
*/
public int shifttofront
throws ioexception
/**
return the number of bytes that can be read from this byteholder
without blocking on an io.
*/
public int available
throws ioexception
/**
return the number of bytes that have been saved to this byte holder.
this result is different from available() as it is unaffected by the
current read position on the byteholder.
*/
public int numbytessaved
throws ioexception
/**
skip over the specified number of bytes in a byteholder.
*/
public long skip long count
throws ioexception
/**
return true if this is in writing mode.
*/
public boolean writingmode