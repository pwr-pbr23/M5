/*
derby - class org.apache.derby.iapi.services.memory.lowmemory
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby iapi services memory
/**
* methods to aid classes recover from outofmemoryerrors by denying
* or reducing service rather than a complete shutdown of the jvm.
* it's intended that classes use to functionality to allow then to
* deny service when memory is low to allow the jvm to recover,
* rather than start new operations that are probably doomed to
* failure due to the low memory.
* <p>
* expected usage is one instance of this class per major logical
* operation, e.g. creating a connection, preparing a statement,
* adding an entry to a specific cache etc.
* <br>
* the logical operation would call islowmemory() before starting
* the operation, and thrown a static exception if it returns true.
* <br>
* if during the operation an outofmemoryexception is thrown the
* operation would call setlowmemory() and throw its static exception
* representing low memory.
* <p>
* future enhancments could be a callback mechanism for modules
* where they register they can reduce memory usage on a low
* memory situation. these callbacks would be triggered by
* a call to setlowmemory. for example the page cache could
* reduce its current size by 10% in a low memory situation.
*
*/
public class lowmemory
/**
* free memory seen when caller indicated an out of
* memory situation. becomes a low memory watermark
* for five seconds that causes islowmemory to return
* true if free memory is lower than this value.
* this allows the jvm a chance to recover memory
* rather than start new operations that are probably
* doomed to failure due to the low memory.
*
*/
private long lowmemory
/**
* time in ms corresponding to system.currenttimemillis() when
* lowmemory was set.
*/
private long whenlowmemoryset
/**
* set a low memory watermark where the owner of this object just hit an
* outofmemoryerror. the caller is assumed it has just freed up any
* references it obtained during the operation, so that the freememory call
* as best as it can reflects the memory before the action that caused the
* outofmemoryerror, not part way through the action.
*
*/
public void setlowmemory
// can read lowmemory unsynchronized, worst
// case is that we force extra garbage collection.
if  lowmemory    0l
// the caller tried to dereference any objects it
// created during its instantation. try to garbage
// collect these so that we can a best-guess effort
// at the free memory before the overall operation we are
// failing on occurred. of course in active multi-threading
// systems we run the risk that some other thread just freed
// up some memory that throws off our calcuation. this is
// avoided by clearing lowmemory some time later on an
// islowmemory() call.
for  int i   0  i < 5  i
system gc
system runfinalization
try
thread sleep 50l
catch  interruptedexception e
synchronized  this
if  lowmemory    0l
lowmemory   runtime getruntime   freememory
whenlowmemoryset   system currenttimemillis
/**
* return true if a low memory water mark has been set and the current free
* memory is lower than it. otherwise return false.
*/
public boolean islowmemory
synchronized  this
long lm   lowmemory
if  lm    0
return false
if  runtime getruntime   freememory   > lm
return false
// only allow an low memory watermark to be valid
// for five seconds after it was set. this stops
// an incorrect limit being set for ever. this could
// occur if other threads were freeing memory when
// we called runtime.getruntime().freememory()
long now   system currenttimemillis
if   now   this whenlowmemoryset  > 5000l
lowmemory   0l
whenlowmemoryset   0l
return false
return true