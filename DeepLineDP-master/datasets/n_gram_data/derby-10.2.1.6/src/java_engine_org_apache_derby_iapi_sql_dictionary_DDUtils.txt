/*
derby - class org.apache.derby.iapi.sql.dictionary.ddutils
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby iapi sql dictionary
import org apache derby iapi error standardexception
import org apache derby iapi reference sqlstate
import org apache derby iapi sql statementtype
import java util hashtable
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi services i18n messageservice
import java util enumeration
/**
*	static data dictionary utilities.
*
* @version 0.1
* @author rick hillegas
*/
public	class	ddutils
/*
** for a foreign key, this is used to locate the referenced
** key using the constraintinfo.  if it doesn't find the
** correct constraint it will throw an error.
*/
public	static referencedkeyconstraintdescriptor locatereferencedconstraint
datadictionary	dd
tabledescriptor	td
string			myconstraintname 	   for error messages
string		mycolumnnames
consinfo		otherconstraintinfo
throws standardexception
tabledescriptor reftd   otherconstraintinfo getreferencedtabledescriptor dd
if  reftd    null
throw standardexception newexception sqlstate lang_invalid_fk_no_ref_tab
myconstraintname
otherconstraintinfo getreferencedtablename
referencedkeyconstraintdescriptor refcd   null
/*
** there were no column names specified, just find
** the primary key on the table in question
*/
string	refcolumnnames   otherconstraintinfo getreferencedcolumnnames
if  refcolumnnames    null
refcolumnnames length    0
refcd   reftd getprimarykey
if  refcd    null
throw standardexception newexception sqlstate lang_invalid_fk_no_pk
myconstraintname
reftd getqualifiedname
columndescriptorlist cdl   getcolumndescriptors dd  td  mycolumnnames
/*
** check the column list length to give a more informative
** error in case they aren't the same.
*/
if  cdl size      refcd getcolumndescriptors   size
throw standardexception newexception sqlstate lang_invalid_fk_different_col_count
myconstraintname  string valueof cdl size
string valueof refcd getcolumndescriptors   size
/*
** make sure all types are the same.
*/
if   refcd arecolumnscomparable cdl
throw standardexception newexception sqlstate lang_invalid_fk_col_types_do_not_match
myconstraintname
return refcd
/*
** check the referenced columns vs. each unique or primary key to
** see if they match the foreign key.
*/
else
constraintdescriptor cd
columndescriptorlist coldl   getcolumndescriptors dd  td  mycolumnnames
constraintdescriptorlist refcdl   dd getconstraintdescriptors reftd
int refcdlsize   refcdl size
for  int index   0  index < refcdlsize  index
cd   refcdl elementat index
/*
** matches if it is not a check or fk, and
** all the types line up.
*/
if   cd instanceof referencedkeyconstraintdescriptor
cd arecolumnscomparable coldl
columnnamesmatch refcolumnnames
cd getcolumndescriptors
return  referencedkeyconstraintdescriptor cd
/*
** if we got here, we didn't find anything
*/
throw standardexception newexception sqlstate lang_invalid_fk_no_ref_key  myconstraintname
reftd getqualifiedname
public	static columndescriptorlist getcolumndescriptors
datadictionary	dd
tabledescriptor td
string 		columnnames
throws standardexception
columndescriptorlist cdl   new columndescriptorlist
for  int colctr   0  colctr < columnnames length  colctr
columndescriptor cd   td getcolumndescriptor columnnames
cdl add td getuuid    cd
return cdl
public	static boolean columnnamesmatch string columnnames  columndescriptorlist cdl
throws standardexception
if  columnnames length    cdl size
return false
string name
for  int index   0  index < columnnames length  index
name     columndescriptor  cdl elementat index   getcolumnname
if   name equals columnnames
return false
return true
/*
**checks whether the foreign key relation ships referential action
**is violating the restrictions we have in the current system.
**/
public static void validatereferentialactions
datadictionary	dd
tabledescriptor	td
string			myconstraintname 	   for error messages
consinfo		otherconstraintinfo
string        columnnames
throws standardexception
int refaction   otherconstraintinfo getreferentialactiondeleterule
//do not allow on delete set null as a referential action
//if none of the foreign key columns are  nullable.
if refaction    statementtype ra_setnull
boolean foundnullablecolumn   false
//check if we have a nullable foreign key column
for  int colctr   0  colctr < columnnames length  colctr
columndescriptor cd   td getcolumndescriptor columnnames
if   cd gettype   isnullable
foundnullablecolumn   true
break
if  foundnullablecolumn
throw standardexception newexception sqlstate lang_invalid_fk_col_for_setnull
myconstraintname
//check whether the foreign key relation ships referential action
//is not violating the restrictions we have in the current system.
tabledescriptor reftd   otherconstraintinfo getreferencedtabledescriptor dd
hashtable deleteconnhashtable   new hashtable
//find whether the foreign key is self referencing.
boolean isselfreferencingfk    reftd getuuid   equals td getuuid
string reftablename   reftd getschemaname         reftd getname
//look for the other foreign key constraints on this table first
int currentselfrefvalue   getcurrentdeleteconnections dd  td   1  deleteconnhashtable  false  true
validatedeleteconnection dd  td  reftd
refaction
deleteconnhashtable   hashtable  deleteconnhashtable clone
true  myconstraintname  false
new stringbuffer 0   reftablename
isselfreferencingfk
currentselfrefvalue
//if it not a selfreferencing key check for violation of exiting connections.
if  isselfreferencingfk
checkforanyexistingdeleteconnectionviolations dd  td
refaction
deleteconnhashtable
myconstraintname
/*
** finds the existing delete connection for the table and the referential
** actions that will occur  and stores the information in the hash table.
** hashtable (key , value) = ( table name that this table is delete
** connected to, referential action that will occur if there is a delete on
** the table this table connected to[casacde, setnull , restrict ...etc).)
**/
private	static int  getcurrentdeleteconnections
datadictionary	dd
tabledescriptor	td
int refactiontype
hashtable dch
boolean prevnotcascade
boolean findselfref
throws standardexception
int selfrefvalue    1    store the self reference referential action
//make sure we get any foreign key constraints added earlier in the same statement.
td emptyconstraintdescriptorlist
constraintdescriptorlist cdl   dd getconstraintdescriptors td
int cdlsize   cdl size
boolean passedinprevnotcascade   prevnotcascade
for  int index   0  index < cdlsize  index
constraintdescriptor cd   cdl elementat index
//look for  foreign keys
if   cd instanceof foreignkeyconstraintdescriptor
foreignkeyconstraintdescriptor fkcd    foreignkeyconstraintdescriptor  cd
string constraintname   fkcd getconstraintname
int radeleterule   fkcd getradeleterule
int raupdaterule   fkcd getraupdaterule
if findselfref    fkcd isselfreferencingfk
//all self references will have same  referential actions type
selfrefvalue   radeleterule
findselfref   false
referencedkeyconstraintdescriptor refcd
fkcd getreferencedconstraint
tabledescriptor reftd   refcd gettabledescriptor
int childrefaction   refactiontype     1 ? radeleterule   refactiontype
string reftablename   reftd getschemaname         reftd getname
//check with  the existing references.
integer raction     integer dch get reftablename
if raction    null     we already looked at this table
prevnotcascade   passedinprevnotcascade
continue
//if we are not cascading, check whether the link before
//this was cascade or not. if we travel through  two non cascade action
//links then the  delete connection is broken(only a delete can have further
// referential effects)
if radeleterule    statementtype ra_cascade
if prevnotcascade
prevnotcascade   passedinprevnotcascade
continue
else
prevnotcascade   true
//store the delete connection info in the hash table,
//note that the referential action value is not what is
//not specified on the current link. it is actually the
//value of what happens to the table whose delete
// connections we are finding.
dch put reftablename   new integer childrefaction
//find the next delete conectiions on this path for non
//self referencig delete connections.
if  fkcd isselfreferencingfk
getcurrentdeleteconnections dd   reftd  childrefaction
dch  true  false
prevnotcascade   passedinprevnotcascade
return selfrefvalue
/*
** following function validates whether the new foreign key relation ship
** violates any restriction on the referential actions. current refaction
** implementation does not allow cases where we can possible land up
** having multiple action for the same row in a table, this happens becase
** user can possibly define differential action through multiple paths.
** following function throws error while creating foreign keys if the new
** releations ship leads to any such conditions.
** note : sql99 standard also does not cleary says what we are suppose to do
** in these non determenistic cases.
** our implementation just follows what is did in db2 and throws error
** messaged similar to db2 (sql0632n, sql0633n, sql0634n)
*/
private	static void validatedeleteconnection
datadictionary	dd
tabledescriptor actualtd      the table we are adding the foriegn key
tabledescriptor	reftd
int refactiontype
hashtable dch
hashtable ech     existing delete connections
boolean checkimmediatereftable
string myconstraintname
boolean prevnotcascade
stringbuffer cyclestring
string currentreftablename    the name of the table we are referring too
boolean isselfreferencingfk
int currentselfrefvalue
throws standardexception
integer raction
string reftablename   reftd getschemaname         reftd getname
/*
** validate the new referentail action value with respect to the
** already existing connections to this table we gathered  from
** the getcurrentdeleteconnections() call.
*/
if checkimmediatereftable
raction     integer dch get reftablename
// check possible invalide cases incase of self referencing foreign key
if isselfreferencingfk
//all the relation ship referring to a table should have the
//same refaction except incase of set null. in this case
//it is the same table , so we have to check with existing self
//referencing actions.
if currentselfrefvalue      1
if currentselfrefvalue    refactiontype
//if there is a set null relation ship we can not have any
// other relation ship with it.
if currentselfrefvalue    statementtype ra_setnull
throw
generateerror sqlstate lang_cant_be_dependent_eself
myconstraintname  currentreftablename
else
/*
** case where we can cleary say what the
** referential actions should be. like,
** if there is no action relationsip
**already, new relation ship also shold be no action.
*/
throw
generateerror sqlstate lang_delete_rule_mustbe_eself
myconstraintname  currentselfrefvalue
else
//more than one  on delet set null to the same table is not allowed
if currentselfrefvalue    statementtype ra_setnull
refactiontype    statementtype ra_setnull
throw
generateerror sqlstate lang_cant_be_dependent_eself
myconstraintname  currentreftablename
/*
** if the new releation ship is self referencing and if
** the current existing relation ship to other tables is
** cascade type them  new self reference should be of type
** cascade, otherwise we should throw error.
*/
if isselfreferencingfk    dch contains new integer statementtype ra_cascade
refactiontype    statementtype ra_cascade
throw
generateerror sqlstate lang_delete_rule_mustbe_ecascade
myconstraintname statementtype ra_cascade
//end of possible error case scenarios for self reference key additions
return
//cases where the new  reference is referring to  another table
//check whether it matched with existing self references.
// if a self-referencing constraint exists with a delete rule of
// set null,  no action or restrict. we can not add cascade
// relationship with another table.
if currentselfrefvalue      1
if refactiontype    statementtype ra_cascade
currentselfrefvalue    statementtype ra_cascade
throw generateerror sqlstate lang_delete_rule_cant_be_cascade_eself   myconstraintname
//check for the cases with existing relationships to the
//referenced table
if raction    null
checkformultiplepathinvalidcases raction intvalue
refactiontype
myconstraintname currentreftablename
//mark the current connect to the reference table to identify the cycle.
if refactiontype    statementtype ra_cascade
prevnotcascade   true
/*
** cycle string is used to keep track of the referential actions of
** the nodes we visited, this is required to make sure that in case
** of cycles , all the nodes in the cycle have same type of
** referential action.
**/
cyclestring   cyclestring append refactiontype
boolean passedinprevnotcascade   prevnotcascade
//delete connection is broken for if we see on delet set null link
// one level deeper than the table we are adding the foreing key
//where as to check for cycles we need to go for more level also;
// to check cases like cascade cascade set null cycle is not valid.
//following variable is used make the distinction.
boolean multipathcheck   true
// check for cases where the new connection we are forming to the
// reference table could create invalid any cycles or mutiple paths
// with the delete-connections the  referencing table might have already.
constraintdescriptorlist refcdl   dd getconstraintdescriptors reftd
int refcdlsize   refcdl size
for  int index   0  index < refcdlsize  index
constraintdescriptor cd   refcdl elementat index
if   cd instanceof foreignkeyconstraintdescriptor
foreignkeyconstraintdescriptor fkcd    foreignkeyconstraintdescriptor  cd
string constraintname   fkcd getconstraintname
int radeleterule   fkcd getradeleterule
int raupdaterule   fkcd getraupdaterule
referencedkeyconstraintdescriptor refcd
fkcd getreferencedconstraint
tabledescriptor nextreftd   refcd gettabledescriptor
//if we are not cascading, check  whether the link before
//this was cascade or not. if we travel through  two non cascade action
//links then the delete connection is broken(only a delete can have further
//referential effects)
if radeleterule    statementtype ra_cascade
if prevnotcascade
prevnotcascade   passedinprevnotcascade
continue
else
prevnotcascade   true
multipathcheck   false
//check whether the current link is a self referencing one
boolean isselfreflink   fkcd isselfreferencingfk
//check for this is non self referencing cycles case
//in cases of cycle, whole cycle should have the same refaction
// value. other wise we should throw an exception
cyclestring   cyclestring append radeleterule
boolean isformingcycle    nextreftd getuuid   equals actualtd getuuid
if isformingcycle
//make sure that all the nodes in the cycle have the same
//referential action  value, otherwise we should throw an error.
for int i   0   i < cyclestring length    i
int otherrefaction   character getnumericvalue cyclestring charat i
if otherrefaction    refactiontype
//cases where one of the existing relation ships in
//the cycle is not cascade , so we can not have
// cascade relation ship.
if otherrefaction    statementtype ra_cascade
throw generateerror sqlstate lang_delete_rule_cant_be_cascade_ecycle  myconstraintname
else
//possibly all the other nodes in the cycle has
//cascade relationsship , we can not add a non
//cascade relation ship.
throw
generateerror sqlstate lang_cant_be_dependent_ecycle
myconstraintname  currentreftablename
string nextreftablename    nextreftd getschemaname         nextreftd getname
raction     integer ech get nextreftablename
if raction    null
/*
** if the table name has entry in the hash table means, there
** is already  a path to this table exists from the table
** the new foreign key relation ship is being formed.
** note: refvalue in the hash table is how the table we are
** adding the new relationsship is going to affected not
** current path refvalue.
**/
if  isselfreflink    multipathcheck
checkformultiplepathinvalidcases raction intvalue
refactiontype
myconstraintname currentreftablename
else
raction     integer dch get nextreftablename
if raction    null
if multipathcheck
dch put nextreftablename   new integer refactiontype
if  isselfreflink
validatedeleteconnection dd  actualtd   nextreftd
refactiontype  dch  ech  false
myconstraintname prevnotcascade
cyclestring  currentreftablename
isselfreferencingfk  currentselfrefvalue
prevnotcascade   passedinprevnotcascade
//removes the char added for the current call
cyclestring setlength cyclestring length    1
/*
**check whether the mulitple path case is valid or not following
** cases are invalid:
** case 1: the relationship causes the table to be delete-connected to
** the indicated table through multiple relationships and the
** delete rule of the existing relationship is set null.
** case 2: the relationship would cause the table to be
** delete-connected to the same table through multiple
** relationships and such relationships must have the same
** delete rule (no action, restrict or cascade).
** case 3: the relationship would cause another table to be
** delete-connected to the same table through multiple paths
** with different delete rules or with delete rule equal to set null.
**/
private static void checkformultiplepathinvalidcases int currentrefaction
int refactiontype
string myconstraintname
string currentreftablename
throws standardexception
//all the relation ship referring to a table should have the
//same refaction except incase of set null
if currentrefaction    refactiontype
//if there is a set null relation ship we can not have any
// other relation ship with it.
if currentrefaction    statementtype ra_setnull
throw generateerror sqlstate lang_cant_be_dependent_mpath
myconstraintname  currentreftablename
else
//this error say what the delete rule must be for the
// foreign key be valid
throw generateerror sqlstate lang_delete_rule_mustbe_mpath
myconstraintname  currentrefaction
else
//more than one  on delet set null to the same table is not allowed
if currentrefaction    statementtype ra_setnull
refactiontype    statementtype ra_setnull
throw
generateerror sqlstate lang_cant_be_dependent_mpath
myconstraintname  currentreftablename
/*
** check whether the delete rule of foreign key  must not be cascade because
** the  new relationship would cause another table to be delete-connected to
** the same table through multiple paths with different delete rules or with
** delete rule equal to set null.
**
** for example :
**                      t1
**  		 cascade   /  \  cascade
**                    /    \
**                  t2      t3
**                   \      /
**          set null  \    /  cascade (can we add this one ? no)
**			          \   /
\t4/
**
**   existing links:
**   t2 references t1   on delete cascade  (fkey1)
**   t3 references t1   on delete cascade  (fkey2)
**   t2 reference  t4   on delete set null (fkey3)
**   now if if try to add a new link i.e
**   t4 references t3   on delete set null  (fkey4)
**   say if we add it,  then if we execute 'delete from t1'
**   because of referential actions , we will try to delete a row through
**   one path and tries to update  through another path.
**   nothing in standard that say whether we are suppose to delete the row
**   or update the row.  db2udb raises error when we try to create the
**   foreign key fkey4, cloudscape also does the same.
**
**   how we catch the error case ?
**   point to note here is the table(t4) we are  adding the foreign key does
**   not have a problem in this scenarion because we are adding a
**   a casacde link , some other table(t2) that is referring
**   can get multiple referential action paths. we can not
**   this error case for self referencing links.
**   algorithm:
**   -gather the foreign keys that are
**   referring(referencedkeyconstraintdescriptor) to the table we are adding
**   foreign key, in our example case we get (fkey3 - table t2 -t4 link)
**   for each referencedkeyconstraintdescriptor
**   {
**    1)find the delete connections of the referring table.
**    [getcurrentdeleteconnections() will return this hash table]
**	  2) we already have collected the delete connections
**       in validdeleteconnections() for the actual table we are adding the
**       foreign key.
**    3) now check whether the referring table  is also
**       referring  any table that the table we are adding
**       foreign key has delete connection.
**
**     for each table referring table delete connection hash table
**     {
**      if it is there in the actual table delete connection hash table
**      {
**         //in our example case we find t1 in both the hash tables.
**         make sure we are having valid referential action
**         from the existing path and the new path we got from
**         new foreign key relation ship.
**        //in our example case t2 has cascade relations with t1
**        //because of new foreign key added we also get
**        //set null relation ship with t1. this is not valid
**        //so we should throw error.
**      }
**     }
** }
**/
private static void checkforanyexistingdeleteconnectionviolations
datadictionary	dd
tabledescriptor td
int refactiontype
hashtable newdconnhashtable
string myconstraintname
throws standardexception
//we need to check for the condition in this function only when we are
//adding ref action of type cascade
if refactiontype    statementtype ra_cascade
return
//find the tables that are referring to the table we
//are adding the foreign key and check whether we violate their existing rules.
string addtablename   td getschemaname         td getname
constraintdescriptorlist refcdl   dd getconstraintdescriptors td
int refcdlsize   refcdl size
for  int index   0  index < refcdlsize  index
constraintdescriptor cd   refcdl elementat index
if   cd instanceof referencedkeyconstraintdescriptor
constraintdescriptorlist fkcdl   dd getactiveconstraintdescriptors
referencedkeyconstraintdescriptor cd  getforeignkeyconstraints constraintdescriptor all
int size   fkcdl size
if  size    0
continue
//note: more than one table can refer to the same
//referencedkeyconstraintdescriptor, so we need to find all the tables.
hashtable dconnhashtable   new hashtable
for  int inner   0  inner < size  inner
foreignkeyconstraintdescriptor fkcd    foreignkeyconstraintdescriptor  fkcdl elementat inner
tabledescriptor fktd   fkcd gettabledescriptor
//delete rule that we have to the table we are adding the
// foreign key relation shop
int radeleteruletoaddtable   fkcd getradeleterule
//this check should not be done on self referencing references.
if  fkcd isselfreferencingfk
//gather the delete connections of the table that is
//referring to the table we are adding foreign key relation ship
getcurrentdeleteconnections dd  fktd   1  dconnhashtable  false  true
/*
**find out if we introduced more than one delete connection
**paths to the table that are referring the table we adding
**the foreign key relatiosn ship.
**if we have multiple paths they should have the same type
**referential action and only one set null path.
**/
for  enumeration e   dconnhashtable keys     e hasmoreelements
string tname    string  e nextelement
//we should not check for the table name to which  we are
//adding the foreign key relation ship.
if  tname equals addtablename
if newdconnhashtable containskey tname
int currentdeleterule     integer 	dconnhashtable get tname   intvalue
if  currentdeleterule    statementtype ra_setnull
radeleteruletoaddtable    statementtype ra_setnull
currentdeleterule     radeleteruletoaddtable
throw
generateerror sqlstate lang_delete_rule_cant_be_cascade_mpath
myconstraintname
//same hash table can be used for the other referring tables
//so clear the hash table.
dconnhashtable clear
private static standardexception generateerror string messageid
string myconstraintname
string message   messageservice gettextmessage messageid
return standardexception newexception sqlstate lang_delete_rule_violation
myconstraintname  message
private static standardexception generateerror string messageid
string myconstraintname
int rarule
string rarulestringid
switch  rarule
case statementtype ra_cascade
rarulestringid   sqlstate lang_delete_rule_cascade
break
case statementtype ra_restrict
rarulestringid   sqlstate lang_delete_rule_restrict
break
case statementtype ra_noaction
rarulestringid   sqlstate lang_delete_rule_noaction
break
case statementtype ra_setnull
rarulestringid   sqlstate lang_delete_rule_setnull
break
case statementtype ra_setdefault
rarulestringid   sqlstate lang_delete_rule_setdefault
break
default
rarulestringid  sqlstate lang_delete_rule_noaction      no action  default value
string rarulemessagestring   messageservice gettextmessage rarulestringid
string message   messageservice gettextmessage messageid  rarulemessagestring
return standardexception newexception sqlstate lang_delete_rule_violation
myconstraintname  message
private static standardexception generateerror string messageid
string myconstraintname
string reftablename
string message   messageservice gettextmessage messageid  reftablename
return standardexception newexception sqlstate lang_delete_rule_violation
myconstraintname  message