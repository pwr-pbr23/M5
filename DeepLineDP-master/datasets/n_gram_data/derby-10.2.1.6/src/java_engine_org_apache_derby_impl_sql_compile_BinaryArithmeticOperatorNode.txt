/*
derby - class org.apache.derby.impl.sql.compile.binaryarithmeticoperatornode
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package	org apache derby impl sql compile
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi sql compile c_nodetypes
import org apache derby iapi types typeid
import org apache derby iapi types datatypedescriptor
import org apache derby iapi types numberdatavalue
import org apache derby iapi sql compile typecompiler
import org apache derby iapi error standardexception
import org apache derby impl sql compile activationclassbuilder
import org apache derby iapi reference classname
import java sql types
import java util vector
/**
* this node represents a binary arithmetic operator, like + or *.
*
* @author jeff lichtman
*/
public final class binaryarithmeticoperatornode extends binaryoperatornode
/**
* initializer for a binaryarithmeticoperatornode
*
* @param leftoperand	the left operand
* @param rightoperand	the right operand
*/
public void init
object leftoperand
object rightoperand
super init leftoperand  rightoperand
classname numberdatavalue  classname numberdatavalue
public void setnodetype int nodetype
string operator   null
string methodname   null
switch  nodetype
case c_nodetypes binary_divide_operator_node
operator   typecompiler divide_op
methodname
break
case c_nodetypes binary_minus_operator_node
operator   typecompiler minus_op
methodname
break
case c_nodetypes binary_plus_operator_node
operator   typecompiler plus_op
methodname
break
case c_nodetypes binary_times_operator_node
operator   typecompiler times_op
methodname
break
case c_nodetypes mod_operator_node
operator   typecompiler mod_op
methodname
break
default
if  sanitymanager debug
sanitymanager throwassert
nodetype
setoperator operator
setmethodname methodname
super setnodetype nodetype
/**
* bind this operator
*
* @param fromlist			the query's from list
* @param subquerylist		the subquery list being built as we find subquerynodes
* @param aggregatevector	the aggregate vector being built as we find aggregatenodes
*
* @return	the new top of the expression tree.
*
* @exception standardexception		thrown on error
*/
public valuenode bindexpression
fromlist	fromlist  subquerylist subquerylist
vector aggregatevector
throws standardexception
super bindexpression fromlist  subquerylist
aggregatevector
typeid	lefttype   leftoperand gettypeid
typeid	righttype   rightoperand gettypeid
datatypedescriptor	leftdts   leftoperand gettypeservices
datatypedescriptor	rightdts   rightoperand gettypeservices
/* do any implicit conversions from (long) (var)char. */
if  lefttype isstringtypeid      righttype isnumerictypeid
boolean nullableresult
nullableresult   leftdts isnullable
rightdts isnullable
/* if other side is decimal/numeric, then we need to diddle
* with the precision, scale and max width in order to handle
* computations like:  1.1 + '0.111'
*/
int precision   rightdts getprecision
int scale	    rightdts getscale
int maxwidth    rightdts getmaximumwidth
if  righttype isdecimaltypeid
int charmaxwidth   leftdts getmaximumwidth
precision     2   charmaxwidth
scale    charmaxwidth
maxwidth   precision   3
leftoperand    valuenode
getnodefactory   getnode
c_nodetypes cast_node
leftoperand
new datatypedescriptor righttype  precision
scale  nullableresult
maxwidth
getcontextmanager
castnode  leftoperand  bindcastnodeonly
else if  righttype isstringtypeid      lefttype isnumerictypeid
boolean nullableresult
nullableresult   leftdts isnullable
rightdts isnullable
/* if other side is decimal/numeric, then we need to diddle
* with the precision, scale and max width in order to handle
* computations like:  1.1 + '0.111'
*/
int precision   leftdts getprecision
int scale	    leftdts getscale
int maxwidth    leftdts getmaximumwidth
if  lefttype isdecimaltypeid
int charmaxwidth   rightdts getmaximumwidth
precision     2   charmaxwidth
scale    charmaxwidth
maxwidth   precision   3
rightoperand     valuenode
getnodefactory   getnode
c_nodetypes cast_node
rightoperand
new datatypedescriptor lefttype  precision
scale  nullableresult
maxwidth
getcontextmanager
castnode  rightoperand  bindcastnodeonly
/*
** set the result type of this operator based on the operands.
** by convention, the left operand gets to decide the result type
** of a binary operator.
*/
settype leftoperand gettypecompiler
resolvearithmeticoperation
leftoperand gettypeservices
rightoperand gettypeservices
operator
return this