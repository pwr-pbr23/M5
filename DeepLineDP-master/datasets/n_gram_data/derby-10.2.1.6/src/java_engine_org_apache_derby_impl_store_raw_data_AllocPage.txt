/*
derby - class org.apache.derby.impl.store.raw.data.allocpage
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl store raw data
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi reference sqlstate
import org apache derby iapi services io typedformat
import org apache derby iapi services io formatidutil
import org apache derby iapi services io storedformatids
import org apache derby iapi error standardexception
import org apache derby iapi store raw containerhandle
import org apache derby iapi store raw loggable
import org apache derby iapi store raw pagekey
import org apache derby iapi store raw pagetimestamp
import org apache derby iapi store raw rawstorefactory
import org apache derby iapi store raw log loginstant
import org apache derby iapi store raw xact rawtransaction
import org apache derby impl store raw data basecontainerhandle
import org apache derby impl store raw data basepage
import org apache derby impl store raw data pageversion
import java io ioexception
import java io objectoutput
import java io objectinput
import org apache derby iapi services io arrayinputstream
/**
an allocation page of the file container.
<p>
this class extends a normal stored page, with the exception that a hunk of
space may be 'borrowed' by the file container to store the file header.
<p>
the borrowed space is not visible to the alloc page even though it is
present in the page data array.  it is accessed directly by the
filecontainer.  any change made to the borrowed space is not managed or
seen by the allocation page.
<p
the reason for having this borrowed space is so that the container header
does not need to have a page of its own.
<p><b>page format</b><br>
an allocation page extends a stored page, the on disk format is different
from a stored page in that n bytes are 'borrowed' by the container and the
page header of an allocation page will be slightly bigger than a normal
stored page.  this n bytes are stored between the page header and the
record space.
<p>
the reason why this n bytes can't simply be a row is because it needs to be
statically accessible by the container object to avoid a chicken and egg
problem of the container object needing to instantiate an alloc page object
before it can be objectified, and an alloc page object needing to
instantiate a container object before it can be objectified.  so this n
bytes must be stored outside of the normal record interface yet it must be
settable because only the first alloc page has this borrowed space.  other
(non-first) alloc page have n == 0.
<pre>
<-- borrowed ->
+----------+-------------+---+---------+-------------------+-------------+--------+
| formatid | page header | n | n bytes | alloc extend rows | slot offset |checksum|
+----------+-------------+---+---------+-------------------+-------------+--------+
</pre>
n is a byte that indicates the size of the borrowed space.  once an alloc
page is initialized, the value of n cannot change.
<p>
the maximum space that can be borrowed by the container is 256 bytes.
<p>
the allocation page are of the same page size as any other pages in the
container. the first allocation page of the filecontainer starts at the
first physical byte of the container.  subsequent allocation pages are
chained via the nextallocpageoffset.  each allocation page is expected to
manage at least 1000 user pages (for 1k page size) so this chaining may not
be a severe performance hit.  the logical -> physical mapping of an
allocation page is stored in the previous allocation page.  the container
object will need to maintain this mapping.
<p>
the following fields are stored in the page header
<pre>
@format_id	raw_store_alloc_page
@purpose	manage page allocation
@upgrade
@disk_layout
formatid(int)
storedpageheader	see storedpage
nextallocpagenubmer(long)	the next allocation page's number
nextallocpageoffset(long)	the file offset of the next allocation page
reserved1(long)				reserved for future usage
reserved2(long)				reserved for future usage
reserved3(long)				reserved for future usage
reserved4(long)				reserved for future usage
n(byte)						the size of the borrowed container info
containerinfo(byte[n])		the content of the borrowed container info
allocextent					the one and only extent on this alloc page
@end_format
</pre>
<p>
the allocation page contains allocation extent rows.  in this first cut
implementation, there is only 1 allocation extent row per allocation page.
<p>
the allocation extent row is an externalizable object and is directly
written on to the page by the alloc page.  in other words, it will not be
converted in to a storeablerow.  this is to cut down overhead, enhance
performance and gives more control of the size and layout of the allocation
extent row to the alloc page.
<p>
<hr width="100%">
<br> detail implmentation notes <br>
<hr width="100%">
<p>
create container - an embryonic allocation page is formatted on disk by a
spcial static function to avoid instantiating a full allocpage object.
this embryonic allocation has enough information that it can find the
file header and not much else.  then the allocation page is perperly
initiated by creating the first extent.
<p>
open container - a static allocpage method will be used to read off the
container information directly from disk.  even if
the first alloc page (page 0) is already in the page cache, it will not be
used because cleaning the alloc page will introduce a deadlock if the
container is not in the container cache.  long term, the first alloc page
should probably live in the container cache rather than in the page cache.
<p>
get page - the first alloc page (page 0) will be read into the page cache.
continue to follow the alloc page chain until the alloc page that manages
the specified page is found.  from the alloc page, the physical offset of
the specified page is located.
<p>
cleaning alloc page - the alloc page is written out the same way any page
is written out.  the container object will provide a call back to the alloc
page to write the current version of the container object back into the
borrowed space before the alloc page itself is written out.
<p>
cleaning the container object - get the the first alloc page, dirty it and
clean it (which will cause it to call the container object to write itself
out into the borrowed space).  the versioning of the container is
independent of the versioning of the alloc page.  the container version is
stored inside the borrowed space and is opaque to the alloc page.
<p>
for the fields in an allocation extent row
@see allocextent
*/
public class allocpage extends storedpage
/*
* typed format
*/
public static final int format_number   storedformatids raw_store_alloc_page
// format id must fit in 4 bytes
/**
return my format identifier.
*/
public int gettypeformatid
return storedformatids raw_store_alloc_page
/*****************************************************************
* alloc page header
*****************************************************************/
private long nextallocpagenumber 	   if islast  nextallocpagenumber    invalid_page_number
private long nextallocpageoffset
private long reserved1
private long reserved2
private long reserved3
private long reserved4
private allocextent extent
private int borrowedspace
/*****************************************************************
* constants
*****************************************************************/
/*
* allocation page header
* 8 bytes	long	next alloc page number
* 8 bytes	long	next alloc page physical offset
* 8 bytes  long	reserved1
* 8 bytes  long	reserved2
* 8 bytes  long	reserved3
* 8 bytes  long	reserved4
*/
protected static final int alloc_page_header_offset
storedpage page_header_offset   storedpage page_header_size
protected static final int alloc_page_header_size   8 8  4 8
/* borrowed_space_offset is where the borrowed space len is kept */
protected static final int borrowed_space_offset
alloc_page_header_offset   alloc_page_header_size
/* size of the borrowed space length */
protected static final int borrowed_space_len   1     1 byte to store the containerinfo length
/*
* borrowed_space_offset + borrowed_space_len is the beginning offset of
* the borrowed space
*/
/*
* the entire borrowed space must live within max_borrowed_space of the
* alloc page
*/
protected static final int max_borrowed_space
rawstorefactory page_size_minimum   5     cannot take more then 1 5 of the page
public allocpage
super
/*
* overwriting storedpage methods
*/
protected int getmaxfreespace
// the maximum free space is reduced by the allocation page header the
// size of the borrowed space.  in all allocation page except the first
// one, there is no borrowed space and this is indeed the max free
// space.  in the first allocation page, need to further subtract
// the borrowed space
return super getmaxfreespace     alloc_page_header_size
borrowed_space_len   borrowedspace
/*
* methods of cachedpage - create, read and write up a page
* overwriting storedpage's cachedpage methods
*/
/**
* create a new alloc page.
*
* @exception  standardexception  standard exception policy.
**/
protected void createpage pagekey newidentity  int args
throws standardexception
super createpage newidentity  args
// args[0] is the format id
// args[1] is whether to sync the page to disk or not
// args[2] is the pagesize (used by storedpage)
// args[3] is the sparesize (used by storedpage)
// args[4] is the number of bytes to reserve for container header
// args[5] is the minimumrecordsize
// note: the arg list here must match the one in filecontainer
int pagesize   args
int minimumrecordsize   args
borrowedspace   args
if  sanitymanager debug
// max_borrowed_space can't be bigger than what can be represented in 1 byte space
sanitymanager assert max_borrowed_space <  255
if    borrowedspace   borrowed_space_len   borrowed_space_offset
< max_borrowed_space
sanitymanager throwassert
borrowedspace
sanitymanager assert pagedata    null
pagedata    byte borrowedspace
// remember that the borrowed space have been wiped out now, it
// needs to be put back when the page is written out.
// blot out borrowed space before checksum is verified
if  borrowedspace > 0
clearsection borrowed_space_offset   borrowed_space_len  borrowedspace
// init the rest of the header and the allocation extent
nextallocpagenumber   containerhandle invalid_page_number
nextallocpageoffset   0
reserved1   reserved2   reserved3   reserved4   0
// calculate how much space we have left for the extent map
int maxspace   getmaxfreespace
// the pages this extent is going to manage starts from pagenum+1
// starting physical offset is pagesize*(pagenum+1) since we have
// no logical to physical mapping yet...
extent   createextent newidentity getpagenumber   1  pagesize  0    pagesalloced     maxspace
private allocextent createextent long pagenum  int pagesize  int pagesalloced  int availspace
int maxpages   allocextent max_range availspace
if  sanitymanager debug
sanitymanager assert maxpages > 8
if  sanitymanager debug
if  sanitymanager debug_on test_multiple_alloc_page
maxpages   2 		   2 pages per alloc page
return new allocextent pagenum pagesize 	 		   starting offset
pagenum 					   extent start page number
pagesalloced 				   #pages already allocated
pagesize  					   page size
maxpages  					   max #pages to manage
/**
initialize in memory structure using the buffer in pagedata
@exception standardexception if the page cannot be read correctly, or is inconsistent.
*/
protected void initfromdata filecontainer mycontainer  pagekey newidentity
throws standardexception
if  pagedata length < borrowed_space_offset   borrowed_space_len
throw datafactory markcorrupt
standardexception newexception
sqlstate data_corrupt_page  newidentity
byte n   pagedata
borrowedspace    int n
if  pagedata length < borrowed_space_offset   borrowed_space_len   n
throw datafactory markcorrupt
standardexception newexception
sqlstate data_corrupt_page  newidentity
// blot out borrowed space before checksum is verified
if  borrowedspace > 0
clearsection borrowed_space_offset   borrowed_space_len  borrowedspace
super initfromdata mycontainer  newidentity
try
// now init alloc page header fields
readallocpageheader
// now init the allocation extent - read it from offset
int offset   borrowed_space_offset   borrowed_space_len   borrowedspace
extent   readextent offset
catch  ioexception ioe
throw datafactory markcorrupt
standardexception newexception
sqlstate data_corrupt_page  ioe  newidentity
catch  classnotfoundexception cnfe
throw datafactory markcorrupt
standardexception newexception
sqlstate data_corrupt_page  cnfe  newidentity
/**
write the page out
@exception standardexception if the page cannot be written
*/
protected void writepage pagekey identity  throws standardexception
try
updateallocpageheader       write out the next alloc page chain
// blot out borrowed space before checksum is calculated - even
// though the page is first read in with borrowed space blotted
// out, whenever this page got cleaned the container will overlay
// the container info in the borrowed space.
int n    int pagedata
if  sanitymanager debug
if  n    borrowedspace
sanitymanager throwassert
n       borrowedspace
if  n > 0
clearsection borrowed_space_offset   borrowed_space_len  n
int offset   borrowed_space_offset   borrowed_space_len   n
writeextent offset
catch  ioexception ioe
// i/o methods on the byte array have thrown an ioexception
throw datafactory markcorrupt
standardexception newexception
sqlstate data_corrupt_page  ioe  identity
// let store page write out the rest and do the checksum
super writepage identity
private void readallocpageheader   throws ioexception
arrayinputstream lrdi   rawdatain
lrdi setposition alloc_page_header_offset
nextallocpagenumber   lrdi readlong
nextallocpageoffset   lrdi readlong
reserved1   lrdi readlong
reserved2   lrdi readlong
reserved3   lrdi readlong
reserved4   lrdi readlong
private void updateallocpageheader   throws ioexception
// rawdataout and logicaldataout are defined by storedpage
rawdataout setposition alloc_page_header_offset
logicaldataout writelong nextallocpagenumber
logicaldataout writelong nextallocpageoffset
logicaldataout writelong 0      reserved1
logicaldataout writelong 0      reserved2
logicaldataout writelong 0      reserved3
logicaldataout writelong 0      reserved4
private allocextent readextent int offset
throws ioexception  classnotfoundexception
arrayinputstream lrdi   rawdatain
rawdatain setposition offset
allocextent newextent   new allocextent
newextent readexternal lrdi
// in 1.3 or later, make sure the upgrade from before 1.3 is legal.
if  sanitymanager debug
int max_range   newextent max_range getmaxfreespace
long extent_start   newextent getfirstpagenum
long extent_end   newextent getextentend
// extent_start + max_range - 1 is the absolute last page this
// extent can hope to manage.  see if it did the calculation
// correctly after upgrade.
if   extent_start max_range 1  < extent_end
sanitymanager throwassert
return newextent
private void writeextent int offset  throws ioexception
// rawdataout and logicaldataout are defined by storedpage
rawdataout setposition offset
extent writeexternal logicaldataout
/*
* borrowed space management
*/
/**
write the container information into the container information area.
@param containerinfo the container information
@param epage the allocation page data which may not be fully formed,
but is guarenteed to be big enough to cover the area inhibited by the
container info
@param create if create, write out the length of the container info
also. else check to make sure epage's original container info is of the
same length
@exception standardexception cloudscape standard error policy
*/
public static void writecontainerinfo byte containerinfo
byte epage
boolean create
throws standardexception
int n    containerinfo    null  ? 0   containerinfo length
if  sanitymanager debug
if  create
sanitymanager assert
containerinfo    null
sanitymanager assert epage    null
if     containerinfo    null
containerinfo length   borrowed_space_offset
borrowed_space_len  < epage length
sanitymanager throwassert
containerinfo length
if  borrowed_space_offset   borrowed_space_len   n >
max_borrowed_space
sanitymanager throwassert
n
if   n   borrowed_space_len   borrowed_space_offset  > epage length
if  sanitymanager debug
sanitymanager throwassert
n
if  create
epage    byte n
else
int oldn    int epage
if  oldn    n
throw standardexception newexception
sqlstate data_changing_container_info
new long oldn
new long n
if  n    0
system arraycopy containerinfo  0  epage
borrowed_space_offset   borrowed_space_len
n
/**
extract the container information from epage.
@param containerinfo where to put the extracted information
@param epage the allocation page which has the container information.
epage may not be fully formed, but is guarenteed to be big enough to
cover the area inhibited by the container info
*/
public static void readcontainerinfo byte containerinfo
byte epage
int n    int epage
if  sanitymanager debug
if  n    containerinfo length
sanitymanager throwassert      n
if  borrowed_space_offset   borrowed_space_len   n
>  max_borrowed_space
sanitymanager throwassert     n
if  n    0
system arraycopy epage  borrowed_space_offset borrowed_space_len
containerinfo  0  n
/*
* specific methods to allocpage
*/
/**
return the next free page number after given page number
*/
public long nextfreepagenumber long pnum
return extent getfreepagenumber pnum
/**
add a page which is managed by this alloc page.
return the page number of the newly added page.
<br> mt - thread aware (latched)
@param mycontainer (future) allows the alloc page to call back to the
container to grow the container by creating and syncing multiple
pages at once
@param ntt the nested top action that is the allocation transaction.
ntt will comit before the user transaction
@param userhandle the container handle that is opened by the user
transaction.  use the userhandle to latch the new page so that
it may remain latched after ntt is committed so the user
transaction can guarentee to have an empty page
@exception standardexception if the page cannot be added
*/
public void addpage filecontainer mycontainer  long newpagenumber
rawtransaction ntt  basecontainerhandle userhandle  throws standardexception
// resolved:
//
// to prevent allocating a free page before the freeing transaction has
// commit, need to grab the deallocate_protection_handle
// the lock probably should be gotten in filecontainer
// and not here
// page allocation is logged under the nested top action
owner getallocationactionset
actionallocatepage
ntt  this  newpagenumber
allocextent allocated_page  allocextent free_page
/*
deallocate page
*/
public void deallocatepage basecontainerhandle userhandle  long pagenumber
throws standardexception
if  sanitymanager debug
sanitymanager assert islatched
// resolved:
//
// to prevent this page from being freed before this transaction commits,
// need to grab the deallocate_protection_handle lock on the
// deallocated page
// the lock probably should be gotten in filecontainer
// and not here
owner getallocationactionset
actionallocatepage userhandle gettransaction
this  pagenumber  allocextent deallocated_page
allocextent allocated_page
/*
* update unfilled page information
* we will be using inputextent's unfilledpage bitmap as the new bitmap, so
* caller of this routine need to not touch the bitmap after this call (in
* other words, call this only in allocationcache invalidate and throw away
* the reference to the bitimpl)
*/
protected void updateunfilledpageinfo allocextent inputextent
if  sanitymanager debug
sanitymanager assert islatched
// update the unfilled page bit map unlogged - it is just a hint, not
// worth logging it - don't dirty the page either, since we didn't log
// it.  it will be dirtied soon enough by addpage or deallocpage,
// that is the only reasons why we are invalidataing the
// allocation cache and updating the unfilled page info.
// if we dirty the page, the bi will be copied to the side log
extent updateunfilledpageinfo inputextent
public boolean canaddfreepage long lastallocatedpage
if  sanitymanager debug
sanitymanager assert islatched
if  extent isretired
return false
// if we want to try allocating not from the beginning of the bit map
// and this alloc page is before that point and this is not the last
// alloc page, then skip over this alloc page
if  lastallocatedpage    containerhandle invalid_page_number
extent getlastpagenum   <  lastallocatedpage
islast
return false
// else we either want to start examining from this alloc page, or this
// is the last page, see if we can add a page.
return extent canaddfreepage lastallocatedpage
public long getnextallocpageoffset
if  sanitymanager debug
sanitymanager assert
islast
sanitymanager assert islatched
return nextallocpageoffset
public void chainnewallocpage basecontainerhandle allochandle
long newallocpagenum  long newallocpageoffset
throws standardexception
if  sanitymanager debug
sanitymanager assert islatched
if  sanitymanager debug_on filecontainer space_trace
sanitymanager debug filecontainer space_trace
newallocpagenum
getpagenumber
owner getallocationactionset
actionchainallocpage allochandle gettransaction
this  newallocpagenum  newallocpageoffset
public long getnextallocpagenumber
if  sanitymanager debug
sanitymanager assert islatched
sanitymanager assert
islast
return nextallocpagenumber
public boolean islast
if  sanitymanager debug
sanitymanager assert islatched
return nextallocpagenumber    containerhandle invalid_page_number
/*
* get the last pagenumber currently managed by this alloc page
*/
public long getlastpagenum
if  sanitymanager debug
sanitymanager assert islatched
return extent getlastpagenum
/*
* get the largest page number this alloc page can manage.
* this is the different from the last pagenumber currently managed by this
* alloc page unless the alloc page is full and all the pages have been
* allocated
*/
public long getmaxpagenum
return extent getextentend
/*
* get the last preallocated pagenumber managed by this alloc page
*/
protected long getlastpreallocpagenum
if  sanitymanager debug
sanitymanager assert islatched
return extent getlastpreallocpagenum
protected int getpagestatus long pagenumber
if  sanitymanager debug
sanitymanager assert islatched
return extent getpagestatus pagenumber
/**
do the actual page allocation/deallocation/ree underneath a log operation.
change the page status to new status
@exception standardexception if the page cannot be allocated
*/
protected void setpagestatus loginstant instant  long pagenumber  int newstatus  throws standardexception
if  sanitymanager debug
sanitymanager assert islatched
sanitymanager assert extent    null
logaction instant
switch newstatus
case allocextent allocated_page
extent allocpage pagenumber
break
case allocextent deallocated_page
extent deallocpage pagenumber
break
case allocextent free_page
extent deallocpage pagenumber
break
/**
chain the next page number and offset underneath a log record
@exception standardexception standard cloudscape error policy
*/
protected void chainnextallocpage loginstant instant
long newallocpagenum
long newallocpageoffset
throws standardexception
if  sanitymanager debug
sanitymanager assert islatched
logaction instant
nextallocpagenumber   newallocpagenum
nextallocpageoffset   newallocpageoffset
/**
* compress free pages.
* <p>
* compress the free pages at the end of the range maintained by
* this allocation page.  all pages being compressed should be free.
* only pages in the last allocation page can be compressed.
* <p>
*
* @param instant               log address for this operation.
* @param new_highest_page      the new highest page on this allocation
*                              page.  the number is the offset of the page
*                              in the array of pages maintained by this
*                              allocation page, for instance a value of 0
*                              indicates all page except the first one are
*                              to be truncated.  if all pages are
*                              truncated then the offset is set to -1.
* @param num_pages_truncated   the number of allocated pages in this
*                              allocation page prior to the truncate.
*                              note that all pages from newhighestpage+1
*                              through newhighestpage+num_pages_truncated
*                              should be free.
*
* @exception  standardexception  standard exception policy.
**/
protected void compressspace
loginstant  instant
int         new_highest_page
int         num_pages_truncated
throws standardexception
if  sanitymanager debug
sanitymanager assert islatched
sanitymanager assert islast
sanitymanager assert new_highest_page >  0
logaction instant
extent compresspages new_highest_page  num_pages_truncated
/**
* handle undo of compress space operation.
**/
protected void undocompressspace
loginstant  instant
int         new_highest_page
int         num_pages_truncated
throws standardexception
logaction instant
extent undocompresspages new_highest_page  num_pages_truncated
public string tostring
if  sanitymanager debug
string str
nextallocpagenumber
nextallocpageoffset
reserved1
reserved2
reserved3
reserved4
borrowedspace
extent todebugstring
super tostring
return str
else
return null
/**
return a copy of the allocextent to be cached by the container.
the container must take care to maintain its coherency by
invalidating the cache before any update.
*/
protected allocextent getallocextent
return extent
// return new allocextent(extent);
/**
preallocate user page if needed.
@param mycontainer the container object
@param preallocthreshold start preallocating after this threshold
@param preallocsize preallocate this number of pages
*/
protected void preallocatepage filecontainer mycontainer
int preallocthreshold
int preallocsize
if  sanitymanager debug
sanitymanager assert islatched
long lastpreallocatedpagenum   extent getlastpreallocpagenum
if  lastpreallocatedpagenum < preallocthreshold
return
// don't pre-allocate more than we the extent can handle - this is
// because if i preallocate the next alloc page as a stored page,
// that's going to be problem when we try to get it as an alloc page
// later.  we don't handle changing from a store page type to an alloc
// page type on disk very well.
if  extent getextentend   <  lastpreallocatedpagenum preallocsize
preallocsize    int  extent getextentend     lastpreallocatedpagenum
if  preallocsize <  0
return
// pre-allocate - only a container knows how to write pages
// preallocsize may exceed what this allocation page can really
// handle, but no harm done.  the next allocation page will benefit
// from the work we have done...
int n   mycontainer preallocate lastpreallocatedpagenum  preallocsize
if  n > 0  				   successfully preallocated some pages
// this is purely a performance issue during runtime.  during
// recovery, any page that is actually initialized will have its
// own initpage log record.  update extent's preallocpagenumber
// unlogged.
//
// we could have logged a redo-only log record, but we are counting
// on mycontainer.preallocate to do the right thing if we recovered
// and have out of date preallocate information.  a reason why
// logging this is undesirable is that the alloc page may think the
// preallocation happened, but the container may actually choose to
// lie about it - if it thinks there is no advantage in actually
// doing the i/o now.  so best to leave it alone.
extent setlastpreallocpagenum lastpreallocatedpagenum   n
// don't dirty the page - the new prealloc page number is only set
// in memory.  a page should only get 'dirtied' by a log operation,
// we are cheating here.  same with updating the extentstatus bit
// without logging.
/**
* compress out empty pages at end of container.
* <p>
* call the extent to update the data structure make the bit map look
* like contiguous free pages at the end of the extent no longer exist.
* similar to preallocate do the operation unlogged, need to force the
* change to the extent before actually removing the space from the
* file.
* <p>
* the sequence is:
*     1) update extent data structure
*     2) force extent changes to disk
*     3) truncate pages
*
* if the system crashes between 1 and 2 then no changes are on disk.
* if the system crashes between 2 and 3 then there are extra pages in
*     the file that extent does not know about, this is the same case
*     as preallocation which the code already handes.  it will handle
*     any set of pages from 0 to all of the intended pages being
*     truncated.  the next allocate looks at actual size of file as
*     does the right thing.
*
* <p)
* mt - expect container level x lock
*
* @exception  standardexception  standard exception policy.
**/
protected boolean compress
rawtransaction  ntt
filecontainer   mycontainer
throws standardexception
boolean all_pages_compressed   false
if  sanitymanager debug
sanitymanager assert islatched
int last_valid_page   extent compress owner  ntt  this
if  last_valid_page >  0
// a non-negative return means that pages can be returned to
// the operating system.
mycontainer truncatepages extent getpagenum last_valid_page
if  last_valid_page    this getpagenumber
// all pages of the extent have been returned to os.
all_pages_compressed   true
return all_pages_compressed
/*********************************************************************
* extent testing
*
* use these strings to simulate error conditions for
* testing purposes.
*
*********************************************************************/
public static final string test_multiple_alloc_page   sanitymanager debug ?     null