/*
derby - class org.apache.derby.impl.store.raw.data.storedrecordheader
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl store raw data
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi store raw pagekey
import org apache derby iapi store raw recordhandle
import java io ioexception
import java io eofexception
import java io inputstream
import java io outputstream
import org apache derby iapi services io compressednumber
/**
a class storedpage uses to cache record headers by passing instances
to basepage, and to write stored versions of record headers.
format
<pre>
1 byte          - status
compressed int  - record identifier
compressed long - overflow page } only if hasoverflow() is true
compressed int  - overflow id   }     "        "           "
compressed int  - first field   } only if hasfirstfield set - otherwise 0
compressed int  - number of fields in this portion - only if hasoverflow()
is false or hasfirstfield is true - otherwise 0
</pre>
*/
public final class storedrecordheader
/**************************************************************************
* constants of the class
**************************************************************************
*/
/**
* status bits for the record header:
*
* record_initial			- used when record header is first initialized
* record_deleted			- used to indicate the record has been deleted
* record_overflow			- used to indicate the record has been
*                            overflowed, it will point to the overflow
*                            page and id
* record_has_first_field	- used to indicate that firstfield is stored.
*                            when record_overflow and
*                            record_has_first_field both are set, part of
*                            record is on the page, the record header
*                            also stores the overflow point to the next
*                            part of the record.
* record_valid_mask        - a mask of valid bits that can be set
*                            currently, such that the following assert can
*                            be made:
*                              assert((status & ~record_valid_mask) == 0))
**/
public static final int record_initial  			0x00
public static final int record_deleted  			0x01
public static final int record_overflow  			0x02
public static final int record_has_first_field  	0x04
public static final int record_valid_mask           0x0f
/**************************************************************************
* fields of the class
**************************************************************************
*/
/**
* actual identifier of the record
*
* <br> mt - mutable
**/
protected int   id
/**
* status of the record.
*
* see above for description of fields:
*     record_initial
*     record_deleted
*     record_overflow
*     record_has_first_field
*     record_valid_mask
*
* <br> mt - mutable - single thread required.
**/
protected int status
/**
* number of fields in the row.
**/
protected int numberfields
/**
* a record handle that can represent the record, may be null.
**/
protected recordhandle	handle
/**
* if (hasoverflow()) then this is the id of the row on page overflowpage
* where the next portion of the row can be found.  in this case there
* are no "real" fields on this page.  this situation comes about if a
* row has been updated such that the real first field no longer fits on
* the head page.
**/
protected int	overflowid
/**
* if (hasoverflow()) then this is the page where where the next portion of
* the row can be found.  in this case there are no "real" fields on this
* page.
**/
protected long  overflowpage
/**
* if (hasfirstfield()) then this field is the number of the column in
* the orginal row which is now stored as the first field in this row.  this
* row is 2nd through n'th portion of a long row.
*
* for example if a row has its first 3 fields on page 0 and its next 3
* fields on page 1, then the record header of the row portion on page 1
* will have hasfirstfield() set to true, and the value would be 4,
* indicating that the 4th field of the row is stored as the 1st field of
* the partial row portion stored on page 1.
**/
protected int	firstfield
/**************************************************************************
* constructors for this class:
**************************************************************************
*/
public storedrecordheader
public storedrecordheader int id  int numberfields
setid id
setnumberfields numberfields
public storedrecordheader
byte    data
int     offset
read data  offset
public storedrecordheader storedrecordheader loadtargetfrom
this status           loadtargetfrom status
this id               loadtargetfrom id
this numberfields     loadtargetfrom numberfields
handle                null
overflowid            loadtargetfrom overflowid
overflowpage          loadtargetfrom overflowpage
firstfield            loadtargetfrom firstfield
/**************************************************************************
* public accessor "get" methods of this class:
**************************************************************************
*/
/**
* get a record handle for the record.
* <p>
*
* <br> mt - single thread required
**/
protected recordhandle gethandle
pagekey pageid
int current_slot
if  handle    null
handle   new recordid pageid  id  current_slot
return handle
/**
* get the record identifier
*
* <br> mt - thread safe
**/
public final int getid
return id
public int getnumberfields
return numberfields
public long getoverflowpage
return overflowpage
public int getoverflowid
return overflowid
public int getfirstfield
return firstfield
public final boolean hasoverflow
return   status   record_overflow     record_overflow
protected final boolean hasfirstfield
return   status   record_has_first_field     record_has_first_field
/**
* get the deleted state of the record.
* <p>
*
* <br> mt - single thread required
**/
public final boolean isdeleted
return   status   record_deleted     record_deleted
/**
* return the size of the record header.
* <p>
* calculates the size of the record header, mostly used to allow a
* reader to skip over the record header and position on the 1st field
* of the record.
* <p>
* this low level routine is performance critical to processing lots of
* rows, so calls to compressnumber have been hand inlined.
*
* @return the length of the record header.
*
* @exception  standardexception  standard exception policy.
**/
public int size
// account for length of fielddatalength field stored as a compressed
// int plus one byte for status.
//
//    int len = compressednumber.sizeint(id) + 1;
int len
id <  compressednumber max_compressed_int_one_byte  ?
2
id <  compressednumber max_compressed_int_two_bytes  ?
3   5
if   status    record_overflow   record_has_first_field      0
// usual case, not a record overflow and does not have first field
len
numberfields <  compressednumber max_compressed_int_one_byte  ?
1
numberfields <  compressednumber max_compressed_int_two_bytes  ?
2   4
else if   status   record_overflow     0
// not overflow, and has first field set.
// account for size of the numberfields field + size fo the
// firstfield field.
//
//     len += (compressednumber.sizeint(numberfields) +
//             compressednumber.sizeint(firstfield);
//
len
numberfields <  compressednumber max_compressed_int_one_byte  ?
1
numberfields <  compressednumber max_compressed_int_two_bytes  ?
2   4
firstfield <  compressednumber max_compressed_int_one_byte  ?
1
firstfield <  compressednumber max_compressed_int_two_bytes  ?
2   4
else
// is an overflow field
len    compressednumber sizelong overflowpage
len    compressednumber sizeint overflowid
if  hasfirstfield
len    compressednumber sizeint firstfield
len    compressednumber sizeint numberfields
return len
/**************************************************************************
* public accessor "set" methods of this class:
**************************************************************************
*/
/**
* set the deleted state of the record.
* <p>
* return	1, if delete status from not deleted to deleted
* return  -1, if delete status from deleted to not deleted
* return   0, if status unchanged.
*
* <br> mt - single thread required
**/
public int setdeleted boolean deletetrue
int retcode   0
if  deletetrue
if   isdeleted
// setting the bit from not deleted to deleted
retcode   1
status    record_deleted
else
if  isdeleted
// setting the bit from deleted to not deleted
retcode    1
status    ~record_deleted
return retcode
public void setfirstfield int firstfield
this firstfield   firstfield
status    record_has_first_field
public final void setid int id
this id   id
public void setoverflowdetails recordhandle overflowhandle
this overflowpage     overflowhandle getpagenumber
this overflowid       overflowhandle getid
public void setoverflowfields storedrecordheader loadfromtarget
this status            loadfromtarget status   record_overflow
this id               loadfromtarget id
this numberfields     loadfromtarget numberfields
this firstfield       loadfromtarget firstfield
handle                null
public final void setnumberfields int numberfields
this numberfields   numberfields
/**************************************************************************
* public methods implmenting read/write of storable interface:
**************************************************************************
*/
public int write outputstream out
throws ioexception
// check consistency of the status field - this has caught
// byte writing corruptions in storedpage in the past.
if  sanitymanager debug
if   status   ~record_valid_mask     0
sanitymanager throwassert
status
// write status
int len   1
out write status
// write id
len    compressednumber writeint out  id
// write overflow information for overflow record headers
if  hasoverflow
// if overflow bit is set, then write the overflow pointer info.
len    compressednumber writelong out  overflowpage
len    compressednumber writeint out  overflowid
// write first field info for long row parts
if  hasfirstfield
len    compressednumber writeint out  firstfield
// write number of fields, except in the case of a record header
// which is solely a pointer to another row portion.
//
// see read
if   hasoverflow      hasfirstfield
len    compressednumber writeint out  numberfields
return len
public void read java io objectinput in
throws ioexception
// read status
status   in read
if  status < 0
throw new eofexception
// check consistency of the status field - this has caught
// byte writing corruptions in storedpage in the past.
if  sanitymanager debug
if   status   ~record_valid_mask     0
sanitymanager throwassert
status
// read the record id
id   compressednumber readint in
// initialize the overflow pointer based on status.
if  hasoverflow
overflowpage   compressednumber readlong in
overflowid     compressednumber readint in
else
overflowpage   0
overflowid     0
// initialize the 1st field overflow pointer based on status.
if  hasfirstfield
firstfield   compressednumber readint in
else
firstfield   0
// in releases prior to 1.3 an overflow record was handled
// by an overflow header pointing to a complete record on
// another page. this header had the has overflow bit set but not
// the has first field bit. this header also did not have the
// number of fields written out, but it can be seen as
// a header with 0 fields and a first field of 0.
if   hasoverflow      hasfirstfield
numberfields   compressednumber readint in
else
numberfields   0
handle   null
private int readid
byte  data
int     offset
int value   data
if   value   ~0x3f     0
// value stored in this byte.
id   value
return 1
else if   value   0x80     0
// value is stored in 2 bytes.  only use low 6 bits from 1st byte.
id      value   0x3f  << 8     data   0xff
return 2
else
// value is stored in 4 bytes.  only use low 7 bits from 1st byte.
id
value            0x7f  << 24
data   0xff  << 16
data   0xff  <<  8
data     0xff
return 4
private int readoverflowpage
byte  data
int     offset
int int_value   data
if   int_value   ~0x3f     0
// test for small case first - assuming this is usual case.
// this is stored in 2 bytes.
overflowpage     int_value << 8     data   0xff
return 2
else if   int_value   0x80     0
// value is stored in 4 bytes.  only use low 6 bits from 1st byte.
overflowpage
int_value        0x3f  << 24
data   0xff  << 16
data   0xff  <<  8
data     0xff
return 4
else
// value is stored in 8 bytes.  only use low 6 bits from 1st byte.
overflowpage
long   int_value        0x7f   << 56
long   data   0xff   << 48
long   data   0xff   << 40
long   data   0xff   << 32
long   data   0xff   << 24
long   data   0xff   << 16
long   data   0xff   <<  8
long   data     0xff
return 8
private int readoverflowid
byte  data
int     offset
int value   data
if   value   ~0x3f     0
// length stored in this byte.
overflowid   value
return 1
else if   value   0x80     0
// length is stored in 2 bytes.  only use low 6 bits from 1st byte.
overflowid      value   0x3f  << 8     data   0xff
return 2
else
// length is stored in 4 bytes.  only use low 7 bits from 1st byte.
overflowid
value            0x7f  << 24
data   0xff  << 16
data   0xff  <<  8
data     0xff
return 4
private int readfirstfield
byte  data
int     offset
int value   data
if   value   ~0x3f     0
// length stored in this byte.
firstfield   value
return 1
else if   value   0x80     0
// length is stored in 2 bytes.  only use low 6 bits from 1st byte.
firstfield      value   0x3f  << 8     data   0xff
return 2
else
// length is stored in 4 bytes.  only use low 7 bits from 1st byte.
firstfield
value            0x7f  << 24
data   0xff  << 16
data   0xff  <<  8
data     0xff
return 4
private void readnumberfields
byte  data
int     offset
int value   data
if   value   ~0x3f     0
// length stored in this byte.
numberfields   value
else if   value   0x80     0
// length is stored in 2 bytes.  only use low 6 bits from 1st byte.
numberfields      value   0x3f  << 8     data   0xff
else
// length is stored in 4 bytes.  only use low 7 bits from 1st byte.
numberfields
value            0x7f  << 24
data   0xff  << 16
data   0xff  <<  8
data     0xff
private void read
byte  data
int     offset
status   data
int value   data
if   value   ~0x3f     0
// value stored in this byte.
id   value
else if   value   0x80     0
// value is stored in 2 bytes.  only use low 6 bits from 1st byte.
id      value   0x3f  << 8     data   0xff
else
// value is stored in 4 bytes.  only use low 7 bits from 1st byte.
id
value            0x7f  << 24
data   0xff  << 16
data   0xff  <<  8
data   0xff
if   status    record_overflow   record_has_first_field      0
// usual case, not a record overflow and does not have first field
overflowpage   0
overflowid     0
firstfield     0
readnumberfields data  offset
else if   status   record_overflow     0
// not overflow, and has first field set.
overflowpage   0
overflowid     0
offset    readfirstfield data  offset
readnumberfields data  offset
else
// is an overflow field
offset    readoverflowpage data  offset
offset    readoverflowid data  offset
if  hasfirstfield
offset    readfirstfield data  offset
readnumberfields data  offset
else
firstfield     0
numberfields   0
handle   null
return
public string tostring
if  sanitymanager debug
string str       getid
str        isdeleted
str        hasoverflow
str        hasfirstfield
str        getnumberfields
str        getfirstfield
str        getoverflowpage
str        getoverflowid
return str
else
return null