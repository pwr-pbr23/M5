/*
derby - class org.apache.derby.impl.sql.execute.distinctscalaraggregateresultset
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl sql execute
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi sql execute execrow
import org apache derby iapi sql execute execindexrow
import org apache derby iapi sql execute noputresultset
import org apache derby iapi sql activation
import org apache derby iapi store access columnordering
import org apache derby iapi store access sortobserver
import org apache derby iapi store access transactioncontroller
import org apache derby iapi store access sortcontroller
import org apache derby iapi store access scancontroller
import org apache derby iapi services loader generatedmethod
import org apache derby iapi error standardexception
import org apache derby iapi services io formatablearrayholder
import java util properties
/**
* this resultset evaluates scalar aggregates where
* 1 (or more, in the future) of the aggregates are distinct.
* it will scan the entire source result set and calculate
* the scalar aggregates when scanning the source during the
* first call to next().
*
* @author jerry (broken out from sortresultset)
*/
class distinctscalaraggregateresultset extends scalaraggregateresultset
private columnordering order
private int maxrowsize
private boolean dropdistinctaggsort
private	long sortid
// set in open and not modified thereafter
private scancontroller scancontroller
private execindexrow sortresultrow
// remember whether or not any sort was performed
private boolean sorted
/**
* constructor
*
* @param	s			input result set
* @param	isinsortedorder	true if the source results are in sorted order
* @param	aggregateitem	indicates the number of the
*		savedobject off of the preparedstatement that holds the
*		aggregatorinfolist used by this routine.
* @param	a				activation
* @param	ra				generated method to build an empty
*	 	output row
* @param	resultsetnumber	the resultsetnumber for this result set
*
* @exception standardexception thrown on error
*/
distinctscalaraggregateresultset noputresultset s
boolean isinsortedorder
int	aggregateitem
int	orderingitem
activation a
generatedmethod ra
int maxrowsize
int resultsetnumber
boolean singleinputrow
double optimizerestimatedrowcount
double optimizerestimatedcost  throws standardexception
super s  isinsortedorder  aggregateitem  a  ra
resultsetnumber
singleinputrow
optimizerestimatedrowcount
optimizerestimatedcost
order    columnordering
formatablearrayholder
a getpreparedstatement   getsavedobject orderingitem
getarray columnordering class
this maxrowsize   maxrowsize
constructortime    getelapsedmillis begintime
///////////////////////////////////////////////////////////////////////////////
//
// resultset interface (leftover from noputresultset)
//
///////////////////////////////////////////////////////////////////////////////
/**
* open the scan.  load the sorter and prepare to get
* rows from it.
*
* @exception standardexception thrown if cursor finished.
*/
public void	opencore   throws standardexception
begintime   getcurrenttimemillis
// revisit: through the direct db api, this needs to be an
// error, not an assert; users can open twice. only through jdbc
// is access to open controlled and ensured valid.
if  sanitymanager debug
sanitymanager assert    isopen
sortresultrow   getexecutionfactory   getindexablerow sorttemplaterow getclone
sourceexecindexrow   getexecutionfactory   getindexablerow sorttemplaterow getclone
source opencore
/*
** load up the sorter because we have something to sort.
*/
scancontroller   loadsorter
sorted   true
isopen   true
numopens
opentime    getelapsedmillis begintime
/* resolve - this next method is only included because of a jit error. there is no other
* reason to override it in distinctscalaraggregateresultset.  the bug was found in
* 1.1.6 with the jit.
*/
/**
* return the next row.  if it is a scalar aggregate scan
*
* @exception standardexception thrown on failure.
* @exception standardexception resultsetnotopen thrown if not yet open.
*
* @return the next row in the result
*/
public execrow	getnextrowcore   throws standardexception
execindexrow sortresult   null
execrow result   null
execindexrow execindexrow   null
execindexrow aggresult   null
boolean	clonearg   true
begintime   getcurrenttimemillis
if  isopen
/*
** we are dealing with a scalar aggregate.
** zip through each row and accumulate.
** accumulate into the first row.  only
** the first row is cloned.
*/
while   execindexrow   getrowfromresultset clonearg      null
/*
** use a clone of the first row as our result.
** we need to get a clone since we will be reusing
** the original as the wrapper of the source row.
** turn cloning off since we wont be keeping any
** other rows.
*/
if  aggresult    null
clonearg   false
aggresult    execindexrow  execindexrow getclone
else
/*
** accumulate all aggregates.  for the distinct
** aggregates, we'll be accumulating, for the nondistinct
** we'll be merging.
*/
accumulatescalaraggregation execindexrow  aggresult  true
/*
** if we have aggregates, we need to generate a
** value for them now.  only finish the aggregation
** if we haven't yet (i.e. if countofrows == 0).
** if there weren't any input rows, we'll allocate
** one here.
*/
if  countofrows    0
aggresult   finishaggregation aggresult
currentrow   aggresult
setcurrentrow aggresult
countofrows
nexttime    getelapsedmillis begintime
return aggresult
/**
* reopen a scan on the table. scan parameters are evaluated
* at each open, so there is probably some way of altering
* their values...
*
* @exception standardexception thrown if cursor finished.
*/
public void	reopencore   throws standardexception
begintime   getcurrenttimemillis
if  sanitymanager debug
sanitymanager assert isopen
if  scancontroller    null
scancontroller close
scancontroller   null
source reopencore
/*
** load up the sorter because we have something to sort.
*/
scancontroller   loadsorter
sorted   true
numopens
countofrows   0
opentime    getelapsedmillis begintime
/**
* if the result set has been opened,
* close the open scan.
*/
public void close   throws standardexception
super close
closesource
///////////////////////////////////////////////////////////////////////////////
//
// scan abstraction utilities
//
///////////////////////////////////////////////////////////////////////////////
/**
* get a row from the sorter.  side effects:
* sets currentrow.
*
* @exception standardexception thrown on error
*/
public execindexrow getrowfromresultset boolean doclone
throws standardexception
execindexrow			inputrow   null
if  scancontroller next
// remind: hackalert we are assuming that result will
// point to what sortresult is manipulating when
// we complete the fetch.
currentrow   doclone ?
sortresultrow getclone     sortresultrow
inputrow   getexecutionfactory   getindexablerow currentrow
scancontroller fetch inputrow getrowarray
return inputrow
/**
* close the source of whatever we have been scanning.
*
* @exception standardexception thrown on error
*/
protected void	closesource   throws standardexception
if  scancontroller    null
if  dropdistinctaggsort
try
gettransactioncontroller   dropsort sortid
catch  standardexception se
// eat all errors at close() time
dropdistinctaggsort   false
scancontroller close
scancontroller   null
source close
///////////////////////////////////////////////////////////////////////////////
//
// misc utilities
//
///////////////////////////////////////////////////////////////////////////////
/**
* load up the sorter.  feed it every row from the
* source scan.  if we have a vector aggregate, initialize
* the aggregator for each source row.  when done, close
* the source scan and open the sort.  return the sort
* scan controller.
*
* @exception standardexception thrown on failure.
*
* @return	the sort controller
*/
private scancontroller loadsorter
throws standardexception
sortcontroller 			sorter
execrow 				sourcerow
int						inputrowcountestimate    int  optimizerestimatedrowcount
transactioncontroller tc   gettransactioncontroller
/*
** we have a distinct aggregate so, we'll need
** to do a sort.  we use all of the sorting columns and
** drop the aggregation on the distinct column.  then
** we'll feed this into the sorter again w/o the distinct
** column in the ordering list.
*/
genericaggregator aggsnodistinct   getsortaggregators agginfolist  true
activation getlanguageconnectioncontext    source
sortobserver sortobserver   new aggregatesortobserver true  aggsnodistinct  aggregates
sorttemplaterow
sortid   tc createsort  properties null
sorttemplaterow getrowarray
order
sortobserver
false 			   not in order
inputrowcountestimate 				   est rows   1 means no idea
maxrowsize		   est rowsize
sorter   tc opensort sortid
dropdistinctaggsort   true
while   sourcerow   source getnextrowcore     null
sorter insert sourcerow getrowarray
rowsinput
/*
** end the sort and open up the result set
*/
sorter close
scancontroller
tc opensortscan sortid  activation getresultsetholdability
/*
** aggs are initialized and input rows
** are in order.
*/
inputrowcountestimate   rowsinput
return scancontroller