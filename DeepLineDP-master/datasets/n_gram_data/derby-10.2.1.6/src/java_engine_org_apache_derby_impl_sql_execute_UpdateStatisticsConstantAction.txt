/*
derby - class org.apache.derby.impl.sql.execute.updatestatisticsconstantaction
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl sql execute
import org apache derby iapi sql dictionary tabledescriptor
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi sql dictionary statisticsdescriptor
import org apache derby iapi sql activation
import org apache derby iapi error standardexception
import org apache derby iapi sql execute execindexrow
import org apache derby iapi store access transactioncontroller
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi store access groupfetchscancontroller
import org apache derby iapi store access conglomeratecontroller
import org apache derby catalog uuid
import org apache derby catalog types statisticsimpl
import org apache derby iapi sql depend dependencymanager
import org apache derby iapi sql conn languageconnectioncontext
/**
* this class describes actions that are performed for an
* update statistics statement at execution time.
*/
class updatestatisticsconstantaction extends ddlconstantaction
private uuid tableuuid
private uuid objectuuid
private string objectname
private boolean fortable
private long conglomeratenumber
private execindexrow indexrow
/* runtime state of the system is maintained in these objects.
* rowbufferone simply reuses the index row prepared by
* makeconstantaction. rowbuffertwo is a clone (an extra copy) of
* objects. rowbuffercurrent just switches between rowbufferone and
* rowbuffertwo.
*/
private datavaluedescriptor rowbufferarray
private datavaluedescriptor rowbuffer
private datavaluedescriptor lastuniquekey
private static final int group_fetch_size   16
public updatestatisticsconstantaction
public updatestatisticsconstantaction boolean fortable
string objectname
uuid tableuuid
uuid objectuuid
long conglomeratenumber
execindexrow indexrow
this fortable   fortable
this objectname   objectname
this tableuuid   tableuuid
this objectuuid   objectuuid
this conglomeratenumber   conglomeratenumber
this indexrow   indexrow
public string tostring
return      fortable ?
objectname
public void executeconstantaction activation activation
throws standardexception
groupfetchscancontroller gsc   null
transactioncontroller tc   activation gettransactioncontroller
languageconnectioncontext lcc   activation getlanguageconnectioncontext
datadictionary dd   lcc getdatadictionary
dependencymanager dm   dd getdependencymanager
dd startwriting lcc
tabledescriptor td   dd gettabledescriptor tableuuid
dm invalidatefor td  dependencymanager update_statistics  lcc
for  int indexnumber   0  indexnumber < conglomeratenumber length
indexnumber
if  conglomeratenumber     1
continue
int numcols   indexrow ncolumns     1
long cardinality   new long
long numrows   0
initializerowbuffers indexrow
try
/* read uncommited, with record locking. actually cs store may
not hold record locks */
gsc
tc opengroupfetchscan
conglomeratenumber
false      hold
0          openmode  for read
transactioncontroller mode_record     locking
transactioncontroller isolation_read_uncommitted    isolation level
null       scancolumnlist   want everything
null       startkeyvalue   start from the beginning
0
null       qualifiers  none
null       stopkeyvalue
0
boolean firstrow   true
int rowsfetched   0
while   rowsfetched   gsc fetchnextgroup rowbufferarray  null   > 0
for  int i   0  i < rowsfetched  i
int whichpositionchanged   comparewithprevkey i  firstrow
firstrow   false
if  whichpositionchanged >  0
for  int j   whichpositionchanged  j < cardinality length  j
cardinality
numrows
datavaluedescriptor tmp
tmp   rowbufferarray
rowbufferarray   lastuniquekey
lastuniquekey   tmp
while
try
finally
if  gsc    null
gsc close
gsc   null
if  numrows    0
/* if there is no data in the table: no need to write anything
* to sys.systatstics.
*/
break
statisticsdescriptor statdesc
dd dropstatisticsdescriptors tableuuid  objectuuid
tc
for  int i   0  i < indexrow ncolumns     1  i
statdesc   new statisticsdescriptor dd  dd getuuidfactory   createuuid
objectuuid
tableuuid
new statisticsimpl numrows
cardinality
i   1
dd adddescriptor statdesc  null
datadictionary sysstatistics_catalog_num
true  tc
for each leading column  c1   c1 c2
for each index
private void initializerowbuffers execindexrow ir
rowbufferarray   new datavaluedescriptor
lastuniquekey   ir getrowarrayclone
rowbufferarray   ir getrowarray       1 gets old objects
private int comparewithprevkey int index  boolean firstrow
throws standardexception
if  firstrow
return 0
datavaluedescriptor prev    index    0  ? lastuniquekey   rowbufferarray
datavaluedescriptor curr   rowbufferarray
// no point trying to do rowlocation; hence - 1
for  int i   0  i <  prev length   1   i
datavaluedescriptor dvd    datavaluedescriptor prev
if  dvd isnull
return i 		   nulls are counted as unique values
if  prev compare curr     0
return i
return  1