/*
derby - class org.apache.derby.iapi.store.raw.containerhandle
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby iapi store raw
import org apache derby iapi store access spaceinfo
import org apache derby iapi error standardexception
import java util properties
/**
a container contains a contigious address space of pages, the pages
start at page number container.first_page_number and are numbered sequentially.
the page size is set at addcontainer() time.
resolve: this style of coding is not currently enforced
if the caller calls getpage (or one of its variants) more than once on the
same page, the caller must call unlatch a corresponding number of times in
order to ensure that the page is latched.  for example:
<p>
<blockquote><pre>
container c;
page p1 = c.getpage(container.first_page_number);
page p2 = c.getpage(container.first_page_number);
p1.unlatch();  -- page is still latched.
p2.unlatch();  -- page is now unlatched.
</pre></blockquote>
<p>
there is no restriction on the order in which latching and unlatching is
done.  in the example, p1 could have been unlatched after p2 with no ill
effects.
<p>	<b>open container modes</b>
containerhandle.mode are used to open or create the container.
unlike tableproperties, modes are not permanantely associated with the
container, it is effective only for the lifetime of the containerhandle
itself.
<br>a container may use any of these mode flags when it is opened.
<ul>
<li>mode_readonly - open the container in read only mode.
<li>mode_forupdate - open the container in update mode, if the underlying
storage does not allow updates
then the container will be opned in read only mode.
<li>mode_unlogged - if unset, any changes to the container are logged.
if set, any user changes to the container are unlogged. it is guaranteed
at commit time that all changes made during the transaction will have been
flushed to disk. using this mode automatically opens the container in
container locking, isolation 3 level. the state of the container following
an abort or any type of rollback is unspecified.
<li>mode_create_unlogged - if set, not only are user changes to the
container are unlogged, page allocations are also unlogged.  this mode is
only useful for container is created in the same statement and no change on
the container (other than the create) is ever logged.  the difference
between mode_unlogged and mode_create_unlogged is that page allocation is
also unlogged and commit of nested transaction will not cause the container
to be forced from the cache.  unlike mode_unlogged, mode_create_unlogged
does not force the cache.  it is up to the client of raw store to force the
cache at the appropriate time - this allows a statement to create and open
the container serveral times for bulk loading without logging or doing any
synchronous i/o.
<li>mode_lock_nowait - if set, then don't wait for the container lock, else
wait for the container lock.  this flag only dictates whether the lock
should be waited for or not.  after the container is successfully opened,
whether this bit is set or not has no effect on the container handle.
</ul>
if neither or both of the {mode_readonly, mode_forupdate} modes are
specified then the behaviour of the container is unspecified.
<br>
mode_unlogged must be set for mode_create_unlogged to be set.
<p>
<b>temporary containers</b><br>
if when creating a container the segment used is
containerhandle.temporary_segment then the container is a temporary
container. temporary containers are not logged or locked and do not live
across re-boots of the system. in addition any abort or rollback including
rollbacks to savepoints truncate the container if it has been opened for
update since the last commit or abort.  temporary containers are private
to a transaction and must only be used a single thread within the
transaction at any time, these restrictions are not currently enforced.
<br>
when opening a temporary container for update access these additional mode
flags may be used
<ul>
<li> mode_truncate_on_commit - at commit/abort time container is truncated.
<li> mode_drop_on_commit - at commit/abort time the container is dropped.
<li> mode_temp_is_kept - at commit/abort time the container is kept around.
</ul>
if a temporary container is opened multiple times in the same transaction
with different modes then the most severe mode is used, ie. none &lt;
truncate on commit &lt; drop on commit.
the mode_unlogged, mode_creat_unlogged flags are ignored when opening a
temporary container, not logged is always assumed.  */
public interface containerhandle
/**
used in add container.
*/
public static final int default_pagesize    1
public static final int default_sparespace    1
public static final int default_assign_id   0
/**
see comments above for these modes.
*/
public static final int mode_default                 0x00000000
public static final int mode_unlogged                0x00000001
public static final int mode_create_unlogged         0x00000002
public static final int mode_forupdate               0x00000004
public static final int mode_readonly	             0x00000008
public static final int mode_truncate_on_commit      0x00000010
public static final int mode_drop_on_commit          0x00000020
public static final int mode_open_for_lock_only      0x00000040
public static final int mode_lock_nowait             0x00000080
public static final int mode_truncate_on_rollback    0x00000100     internal raw store
public static final int mode_flush_on_commit         0x00000200     internal raw store
public static final int mode_no_actions_on_commit    0x00000400     internal raw store
public static final int mode_temp_is_kept		     0x00000800     internal raw store
public static final int mode_use_update_locks	     0x00001000     external access
public static final int mode_secondary_locked        0x00002000     external access
public static final int mode_baserow_insert_locked   0x00004000     external access
public static final int temporary_segment    1
/**
the first valid page number
*/
public static final long first_page_number   1
/**
a page number that is guaranteed to be invalid.
*/
public static final long invalid_page_number    1
/**
return my identifier.
*/
public containerkey getid
/**
return my unique identifier, this identifier will be unique to each
instance of an open container handle.  this id is used by the locking
system to group locks to an open container handle.
*/
public object getuniqueid
/**
* is the container opened for read only or update?
*
* @return true if container is opened for read only, else false.
**/
boolean isreadonly
/**
add an empty page to the container and obtain exclusive access to it.
<p>
note that the added page may not be the last page in the container.
once the page is no longer required the page's unlatch() method must
be called.
@return a reference to the page that was added.
@see page#unlatch
@exception standardexception	standard cloudscape error policy
@exception standardexception if a page could not be allocated.
*/
public page addpage   throws standardexception
/**
release free space to the os.
<p>
as is possible release any free space to the operating system.  this
will usually mean releasing any free pages located at the end of the
file using the java truncate() interface.
@exception standardexception	standard cloudscape error policy
*/
public void compresscontainer   throws standardexception
/**
* get the reusable recordid sequence number.
* @return version sequence number
* @exception standardexception	standard derby error policy
*/
public long getreusablerecordidsequencenumber   throws standardexception
/**
add an empty page to the container and obtain exclusive access to it.
<p>
if flag == add_page_default, this call is identical to addpage().
<br>
if flag == add_page_bulk, then this call signifies to the container that
this addpage is part of a large number of additional pages and it is
desirable to do whatever possible to facilitate adding many subsequent pages.
the actual container implementation will decide whether or not to heed
this hint and what to do about it.
@return a reference to the page that was added.
@see page#unlatch
@exception standardexception	standard cloudscape error policy
@exception standardexception if a page could not be allocated.
*/
public page addpage int flag  throws standardexception
public static final int add_page_default   0x1
public static final int add_page_bulk   0x2
/**
try to preallocate numpage new pages if possible.
*/
public void preallocate int numpage
/**
remove this page from the container and unlatch the page.  <b>caller
should commit or abort this transaction asap because failure to do so
will slow down page allocation of this container. </b>
<br>the page to be removed must be latched and gotten (or added) by
this containerhandle.  the page should not be used again after this
call as if it has been unlatched.  if the call to removepage is
successful, this page is invalid should not be gotten again with
getpage.
<br>removepage will guarantee to unlatch the page even if a
standardexception is thrown.
<p>
<b>locking policy</b>
<br>
the page will not be freed until the transaction that removed the page
commits.  a special recordhandle.dealloc_protection_handle lock will be
gotten for the transaction and which is used to prevent the page from
being freed.  this lock will be held regardless of the default locking
policy of the transaction that called removedpage.
@see lockingpolicy
@see recordhandle
@exception standardexception standard cloudscape error policy
*/
public void removepage page page  throws standardexception
/**
obtain exclusive access to the page with the given page number.
once the page is no longer required the page's unlatch() method must
be called.
<p>
the page object is guaranteed to remain in-memory and exclusive to the
caller until its unlatch() method is called.
@return the required page or null if the page does not exist or is not
valid (i.e, it has been deallocated or freed or never initialized)
note that an overflow page will be returned since it is a valid page.
@exception standardexception	standard cloudscape error policy
*/
public page getpage long pagenumber
throws standardexception
/**
identical to getpage but returns null immediately if the desired page
is already latched by another container.
@return the required page or null if the page does not exist or the page
is already latched.
@exception standardexception	standard cloudscape error policy
*/
public page getpagenowait long pagenumber  throws standardexception
/**
obtain exclusive access to the page with the given page number.
will only return a valid, non-overflow user page - so can be used by
routines in post commit to get pages to attempt deleted row space
reclamation.  if for some reason a request is made for an overflow
page a null will be returned.
once the page is no longer required the page's unlatch() method must
be called.
<p>
the page object is guaranteed to remain in-memory and exclusive to the
caller until its unlatch() method is called.
@return the required page or null if the page does not exist or is not
valid (i.e, it has been deallocated, freed, never initialized, or is
an allocation page or overflow page)
@exception standardexception	standard cloudscape error policy
*/
public page getuserpagenowait long pagenumber  throws standardexception
/**
obtain exclusive access to the page with the given page number.
will only return a valid, non-overflow user page - so can be used by
routines in post commit to get pages to attempt deleted row space
reclamation.  if for some reason a request is made for an overflow
page a null will be returned.
once the page is no longer required the page's unlatch() method must
be called.
<p>
the page object is guaranteed to remain in-memory and exclusive to the
caller until its unlatch() method is called.
@return the required page or null if the page does not exist or is not
valid (i.e, it has been deallocated, freed, never initialized, or is
an allocation page or overflow page)
@exception standardexception	standard cloudscape error policy
*/
public page getuserpagewait long pagenumber  throws standardexception
/**
obtain exclusive access to the current first page of the container.
only a valid, non overflow page will be returned.
pages in the container are ordered in an internally defined ordering.
<p>
note that once this method returns this page may no longer be the
first page of the container.  i.e, other threads may allocate pages
prior to this page number while this page is latched.  it is up to
the caller of this routine to synchronize this call with addpage to
assure that this is the first page.
<br>
as long as the client provide the necessary lock to ensure
that no addpage is called, then this page is guaranteed to be the
first page of the container in some internally defined ordering of
the pages.
@return latched page or null if there is no page in the container
@exception standardexception	standard cloudscape error policy
@see containerhandle#getpage
*/
public page getfirstpage   throws standardexception
/**
obtain exclusive access to the next valid page of the given page number
in the container. only a valid, non overflow page will be returned.
pages in the container are ordered in an internally defined ordering.
<p>
note that once this method returns this page may no longer be the
next page of the container.  i.e, other threads may allocate pages
prior to this page number while this page is latched.  it is up to
the caller of this routine to synchronize this call with addpage to
assure that this is the first page.
<br>
as long as the client provide the necessary lock to ensure
that no addpage is called, then this page is guaranteed to be the
next page of the container in some internally defined ordering of
the pages.
<br>
if no pages are added or removed, then an iteration such as:
<pre>
for (page p = containerhandle.getfirstpage();
p != null;
p = containerhandle.getnextpage(p.getpagenumber()))
<pre>
will guarentee to iterate thru and latched all the valid pages
in the container
@param prevnum the pagenumber of the page previous to the page
that is to be gotten.  the page which correspond to prevnum
may or may not be latched by the caller, but it must be gotten
via a page which was (or currently still is) latched, and the page
number must be gotten while the container must not have been closed
or dropped or removed in the interim.
in other words, if the user manufactures a page number, or remembers
the page number from a previous session or a previous opencontainer,
then the behavior of this routine is undefined.
@return latched page or null if there is no next page in the container
@exception standardexception	standard cloudscape error policy
@see containerhandle#getpage
*/
public page getnextpage long prevnum  throws standardexception
/**
get a page for insert.  if rawstore thinks it knows where a potentially
suitable page is for insert, it will return it.  if rawstore doesn't
know where a suitable page for insert is, or if there are no allocated
page, then null is returned.  if a page is returned, it will be a
valid, non-overflow page.   a potentially suitable page is one which
has enough space for a minium sized record.
@return a valid, non-overflow page.  or null if rawstore doesn't know
where to find a good valid, non-overflow page.
@param flag a get_page_* flag.
@exception standardexception standard cloudscape error policy
*/
public page getpageforinsert int flag
throws standardexception
public page getpageforcompress
int     flag
long    pageno
throws standardexception
// try to get a page that is unfilled, 'unfill-ness' is defined by the
// page.  since unfill-ness is defined by the page, the only thing rawstore
// guarentees about the page is that it has space for a a minimum sized
// record.
//
// if this bit is not set, then getpageforinsert will get the page that was
// last gotten, provided it has space for a minimum sized record.
//
// if for whatever reasons rawstore is unable to come up with such a page,
// null will be returned.
public static final int get_page_unfilled   0x1
/**
* request the system properties associated with a container.
* <p>
* request the value of properties that are associated with a table.  the
* following properties can be requested:
*     derby.storage.pagesize
*     derby.storage.pagereservedspace
*     derby.storage.minimumrecordsize
* <p>
* to get the value of a particular property add it to the property list,
* and on return the value of the property will be set to it's current
* value.  for example:
*
* get_prop(conglomeratecontroller cc)
* {
*     properties prop = new properties();
*     prop.put("derby.storage.pagesize", "");
*     cc.gettableproperties(prop);
*
*     system.out.println(
*         "table's page size = " +
*         prop.getproperty("derby.storage.pagesize");
* }
*
* @param prop   property list to fill in.
*
* @exception  standardexception  standard exception policy.
**/
void getcontainerproperties properties prop
throws standardexception
/**
close me. after using this method the caller must throw away the
reference to the container object, e.g.
<pre>
ref.close();
ref = null;
</pre>
<br>
the container will be closed automatically at the commit or abort
of the transaction if this method is not called explictly.
<br>
any pages that were obtained using me and have not been released
using page's unlatch method are released, and references to them must be
thrown away.
@see page#unlatch
@see page#fetch
*/
public void close
/**
cost estimation
*/
/**
get the total estimated number of rows in the container, not including
overflow rows.  this number is a rough estimate and may be grossly off.
@param flag different flavors of row count (reserved for future use)
@exception standardexception	standard cloudscape error policy
*/
public long getestimatedrowcount int flag  throws standardexception
/**
set the total estimated number of rows in the container.  often, after
a scan, the client of rawstore has a much better estimate of the number
of rows in the container then what rawstore has.  use this better
number for future reference.
<br>
it is ok for a readonly containerhandle to set the estimated row count.
@param count the estimated number of rows in the container.
@param flag different flavors of row count (reserved for future use)
@exception standardexception	standard cloudscape error policy
*/
public void setestimatedrowcount long count  int flag  throws standardexception
/**
get the total estimated number of allocated (not freed, not
deallocated) user pages in the container, including overflow pages.
this number is a rough estimate and may be grossly off.
@param flag different flavors of page count (reserved for future use)
@exception standardexception	standard cloudscape error policy
*/
public long getestimatedpagecount int flag  throws standardexception
/**
flush all dirty pages of the container to disk.  used mainly for
unlogged or create_unlogged operation.
@exception standardexception	standard cloudscape error policy
*/
public void flushcontainer   throws standardexception
/**
return the locking policy for this open container.
*/
public lockingpolicy getlockingpolicy
/**
set the locking policy for this open container
*/
public void setlockingpolicy lockingpolicy newlockingpolicy
/**
return a record handle that is initialized to the given segment id,
container id, page number and record id.
@exception standardexception standard cloudscape exception policy.
@param pagenumber   the page number of the recordhandle.
@param recordid     the record id of the recordhandle.
@see recordhandle
*/
public recordhandle makerecordhandle long pagenumber  int recordid
throws	standardexception
/**
this record probably has shrunk considerably.  free its reserved space
or compact it.
@param record	the record handle, the record must have been locked execlusively already.
@exception standardexception standard cloudscape exception policy.
*/
public void compactrecord recordhandle record  throws standardexception
/**
return true if this containerhandle refers to a temporary container.
@exception standardexception standard cloudscape exception policy.
*/
public boolean istemporarycontainer   throws standardexception
/**
get information about space used by the container.
**/
public spaceinfo getspaceinfo   throws standardexception
/**
backup the container to the specified path.
@exception standardexception	standard cloudscape error policy
*/
public void backupcontainer string backupcontainerpath  throws standardexception