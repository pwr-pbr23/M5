/*
derby - class org.apache.derby.iapi.store.access.conglomerate.conglomerate
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby iapi store access conglomerate
import org apache derby iapi error standardexception
import org apache derby iapi store access conglomeratecontroller
import org apache derby iapi store access dynamiccompiledopenconglominfo
import org apache derby iapi store access qualifier
import org apache derby iapi store access rowlocationretrowsource
import org apache derby iapi store access storecostcontroller
import org apache derby iapi store access staticcompiledopenconglominfo
import org apache derby iapi store access transactioncontroller
import org apache derby iapi store raw containerkey
import org apache derby iapi store raw lockingpolicy
import org apache derby iapi store raw transaction
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi services io storable
import org apache derby iapi services io formatablebitset
/**
a conglomerate is an abstract storage structure (they
correspond to access methods).  the conglomerate interface
corresponds to a single instance of a conglomerate. in
other words, for each conglomerate in the system, there
will be one object implementing conglomerate.
<p>
the conglomerate interface is implemented by each access method.
the implementation must maintain enough information to properly
open the conglomerate and scans, and to drop the conglomerate.
this information typically will include the id of the container
or containers in which the conglomerate is stored, and my also
include property information.
<p>
conglomerates are created by a conglomerate factory.  the access
manager stores them in a directory (which is why they implement
storable).
**/
public interface conglomerate extends storable  datavaluedescriptor
/**
* add a column to the conglomerate.
* <p>
* this routine update's the in-memory object version of the
* conglomerate to have one more column of the type described by the
* input template column.
*
* note that not all conglomerates may support this feature.
*
* @param xact_manager     the transactioncontroller under which this
*                         operation takes place.
* @param column_id        the column number to add this column at.
* @param template_column  an instance of the column to be added to table.
*
* @exception  standardexception  standard exception policy.
**/
public void addcolumn
transactionmanager  xact_manager
int                 column_id
storable            template_column
throws standardexception
/**
* drop this conglomerate.
*
* @exception  standardexception  standard exception policy.
**/
void drop transactionmanager  xact_manager
throws standardexception
/**
* retrieve the maximum value row in an ordered conglomerate.
* <p>
* returns true and fetches the rightmost row of an ordered conglomerate
* into "fetchrow" if there is at least one row in the conglomerate.  if
* there are no rows in the conglomerate it returns false.
* <p>
* non-ordered conglomerates will not implement this interface, calls
* will generate a standardexception.
* <p>
* resolve - this interface is temporary, long term equivalent (and more)
* functionality will be provided by the openbackwardscan() interface.
*
* @param xact_manager    the transactioncontroller under which this
*                        operation takes place.
*
* @param rawtran         the raw store xact to associate all ops with.
*
* @param conglomid       the identifier of the conglomerate
*                        to open the scan for.
*
* @param open_mode       specifiy flags to control opening of table.
*                        openmode_forupdate - if set open the table for
*                        update otherwise open table shared.
* @param lock_level      one of (mode_table, mode_record, or mode_none).
*
* @param locking_policy  the lockingpolicy to use to open the conglomerate.
*
* @param isolation_level the isolation level to lock the conglomerate at.
*                        one of (isolation_read_committed,
*                        isolation_repeatable_read, or
*                        isolation_serializable).
*
* @param scancolumnlist  a description of which columns to return from
*                        every fetch in the scan. fetchrow
*                        and scancolumnlist work together
*                        to describe the row to be returned by the scan -
*                        see rowutil for description of how these three
*                        parameters work together to describe a "row".
*
* @param fetchrow        the row to retrieve the maximum value into.
*
* @return boolean indicating if a row was found and retrieved or not.
*
* @exception  standardexception  standard exception policy.
**/
boolean fetchmaxonbtree
transactionmanager      xact_manager
transaction             rawtran
long                    conglomid
int                     open_mode
int                     lock_level
lockingpolicy           locking_policy
int                     isolation_level
formatablebitset                 scancolumnlist
datavaluedescriptor   fetchrow
throws standardexception
/**
* get the containerid of conglomerate.
* <p>
* will have to change when a conglomerate could have more than one
* containerid.
*
* @return the containerid.
*
* @exception  standardexception  standard exception policy.
**/
long getcontainerid
/**
* get the id of the container of the conglomerate.
* <p>
* will have to change when a conglomerate could have more than one
* container.  the containerkey is a combination of the container id
* and segment id.
*
* @return the containerkey.
*
* @exception  standardexception  standard exception policy.
**/
containerkey getid
/**
* return static information about the conglomerate to be included in a
* a compiled plan.
* <p>
* the static info would be valid until any ddl was executed on the
* conglomid, and would be up to the caller to throw away when that
* happened.  this ties in with what language already does for other
* invalidation of static info.  the type of info in this would be
* containerid and array of format id's from which templates can be created.
* the info in this object is read only and can be shared among as many
* threads as necessary.
* <p>
*
* @return the static compiled information.
*
* @param tc        the transactioncontroller under which this operation
*                  takes place.
* @param conglomid the identifier of the conglomerate to open.
*
* @exception  standardexception  standard exception policy.
**/
public staticcompiledopenconglominfo getstaticcompiledconglominfo
transactioncontroller   tc
long                    conglomid
throws standardexception
/**
* return dynamic information about the conglomerate to be dynamically
* reused in repeated execution of a statement.
* <p>
* the dynamic info is a set of variables to be used in a given
* scancontroller or conglomeratecontroller.  it can only be used in one
* controller at a time.  it is up to the caller to insure the correct
* thread access to this info.  the type of info in this is a scratch
* template for btree traversal, other scratch variables for qualifier
* evaluation, ...
* <p>
*
* @return the dynamic information.
*
* @param conglomid the identifier of the conglomerate to open.
*
* @exception  standardexception  standard exception policy.
**/
public dynamiccompiledopenconglominfo getdynamiccompiledconglominfo
long        conglomid
throws standardexception
/**
* is this conglomerate temporary?
* <p>
*
* @return whether conglomerate is temporary or not.
**/
boolean istemporary
/**
* bulk load into the conglomerate.
* <p>
* individual rows that are loaded into the conglomerate are not
* logged. after this operation, the underlying database must be backed up
* with a database backup rather than an transaction log backup (when we
* have them). this warning is put here for the benefit of future
* generation.
* <p>
* @param xact_manager  the transactioncontroller under which this operation
*                      takes place.
*
* @param createconglom if true, the conglomerate is being created in the
*                      same operation as the openandloadconglomerate.
*                      the enables further optimization as recovery does
*                      not require page allocation to be logged.
*
* @param rowsource     where the rows come from.
*
* @return the number of rows loaded.
*
* @exception standardexception standard exception policy.  if
* conglomerage supports uniqueness checks and has been created to
* disallow duplicates, and one of the rows being loaded had key columns
* which were duplicate of a row already in the conglomerate, then
* raise sqlstate.store_conglomerate_duplicate_key_exception.
*
**/
public long load
transactionmanager      xact_manager
boolean                 createconglom
rowlocationretrowsource rowsource
throws standardexception
/**
* open a conglomerate controller.
* <p>
*
* @return the open conglomeratecontroller.
*
* @param xact_manager   the access xact to associate all ops on cc with.
* @param rawtran        the raw store xact to associate all ops on cc with.
* @param open_mode      a bit mask of transactioncontroller.mode_* bits,
*                       indicating info about the open.
* @param lock_level     either transactioncontroller.mode_table or
*                       transactioncontroller.mode_record, as passed into
*                       the openconglomerate() call.
* @param locking_policy the lockingpolicy to use to open the conglomerate.
*
* @exception  standardexception  standard exception policy.
*
* @see transactioncontroller
**/
conglomeratecontroller open
transactionmanager              xact_manager
transaction                     rawtran
boolean                         hold
int                             open_mode
int                             lock_level
lockingpolicy                   locking_policy
staticcompiledopenconglominfo   static_info
dynamiccompiledopenconglominfo  dynamic_info
throws standardexception
/**
* open a scan controller.
*
* @exception  standardexception  standard exception policy.
**/
scanmanager openscan
transactionmanager              xact_manager
transaction                     rawtran
boolean                         hold
int                             open_mode
int                             lock_level
lockingpolicy                   locking_policy
int                             isolation_level
formatablebitset				scancolumnlist
datavaluedescriptor	        startkeyvalue
int                             startsearchoperator
qualifier                       qualifier
datavaluedescriptor           stopkeyvalue
int                             stopsearchoperator
staticcompiledopenconglominfo   static_info
dynamiccompiledopenconglominfo  dynamic_info
throws standardexception
/**
* online compress table.
*
* returns a scanmanager which can be used to move rows
* around in a table, creating a block of free pages at the end of the
* table.  the process of executing the scan will move rows from the end
* of the table toward the beginning.  the groupfetchscancontroller will
* return the old row location, the new row location, and the actual data
* of any row moved.  note that this scan only returns moved rows, not an
* entire set of rows, the scan is designed specifically to be
* used by either explicit user call of the syscs_online_compress_table()
* procedure, or internal background calls to compress the table.
*
* the old and new row locations are returned so that the caller can
* update any indexes necessary.
*
* this scan always returns all collumns of the row.
*
* all inputs work exactly as in openscan().  the return is
* a groupfetchscancontroller, which only allows fetches of groups
* of rows from the conglomerate.
* <p>
* note that all conglomerates may not implement opencompressscan(),
* currently only the heap conglomerate implements this scan.
*
* @return the groupfetchscancontroller to be used to fetch the rows.
*
* @param hold                  see openscan()
* @param open_mode             see openscan()
* @param lock_level            see openscan()
* @param isolation_level       see openscan()
*
* @exception  standardexception  standard exception policy.
**/
scanmanager defragmentconglomerate
transactionmanager              xact_manager
transaction                     rawtran
boolean                         hold
int                             open_mode
int                             lock_level
lockingpolicy                   locking_policy
int                             isolation_level
throws standardexception
void purgeconglomerate
transactionmanager              xact_manager
transaction                     rawtran
throws standardexception
void compressconglomerate
transactionmanager              xact_manager
transaction                     rawtran
throws standardexception
/**
* return an open storecostcontroller for the conglomerate.
* <p>
* return an open storecostcontroller which can be used to ask about
* the estimated row counts and costs of scancontroller and
* conglomeratecontroller operations, on the given conglomerate.
* <p>
* @param xact_manager the transactioncontroller under which this
*                     operation takes place.
* @param rawtran  raw transaction context in which scan is managed.
*
* @return the open storecostcontroller.
*
* @exception  standardexception  standard exception policy.
*
* @see storecostcontroller
**/
storecostcontroller openstorecost
transactionmanager  xact_manager
transaction         rawtran
throws standardexception