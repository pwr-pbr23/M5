/*
derby - class org.apache.derby.impl.sql.execute.genericaggregator
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl sql execute
import org apache derby iapi types numberdatavalue
import org apache derby iapi types userdatavalue
import org apache derby iapi reference sqlstate
import org apache derby iapi sql execute execrow
import org apache derby iapi store access transactioncontroller
import org apache derby iapi services io storable
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi sql resultdescription
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi services loader classfactory
import org apache derby iapi sql execute execaggregator
import org apache derby iapi sql execute noputresultset
import org apache derby iapi sql conn languageconnectioncontext
import org apache derby iapi error standardexception
import org apache derby iapi jdbc connectioncontext
import java sql statement
/**
* adaptor that sits between execution layer and aggregates.
*
* @author jamie
*/
class genericaggregator
aggregatorinfo			agginfo
int						aggregatorcolumnid
private int						inputcolumnid
private int						resultcolumnid
private resultdescription		inputcolumnresultdescription
private	execrow			rowarray
private	temporaryrowholderresultset execresultset
private final classfactory		cf
/*
** we cache an aggregator to speed up
** the instantiation of lots of aggregators.
*/
private execaggregator		cachedaggregator
/**
* constructor:
*
* @param agginfo 	information about the user aggregate
* @param cf		the class factory.
*/
genericaggregator
aggregatorinfo	agginfo
classfactory	cf
this agginfo   agginfo
aggregatorcolumnid   agginfo getaggregatorcolnum
inputcolumnid   agginfo getinputcolnum
resultcolumnid   agginfo getoutputcolnum
int colarray   new int
inputcolumnresultdescription   agginfo getresultdescription
this cf   cf
/**
* initialize the aggregator
*
* @param	row 	the row with the aggregator to be initialized
*
* @exception standardexception  on error
*/
void initialize execrow row
throws standardexception
if  sanitymanager debug
sanitymanager assert row    null
userdatavalue aggregatorcolumn    userdatavalue  row getcolumn aggregatorcolumnid   1
execaggregator ua    execaggregator  aggregatorcolumn getobject
if  ua    null
ua   getaggregatorinstance
aggregatorcolumn setvalue ua
/**
* accumulate the aggregate results.  this is the
* guts of the aggregation.  we will call the user aggregate
* on itself to do the aggregation.
*
* @param	inputrow 	the row with the input colum
* @param	accumulaterow 	the row with the aggregator
*
* @exception standardexception  on error
*/
void accumulate execrow	inputrow
execrow	accumulaterow
throws standardexception
datavaluedescriptor	inputcolumn   null
if  sanitymanager debug
sanitymanager assert  inputrow    null      accumulaterow    null
datavaluedescriptor aggregatorcolumn   accumulaterow getcolumn aggregatorcolumnid   1
inputcolumn   inputrow getcolumn inputcolumnid   1
accumulate inputcolumn  aggregatorcolumn
/**
* accumulate the aggregate results.  this is the
* guts of the aggregation.  we will call the user aggregate
* on itself to do the aggregation.
*
* @param	inputrow 	the row with the input colum
* @param	accumulaterow 	the row with the aggregator
*
* @exception standardexception  on error
*/
void accumulate object	inputrow
object	accumulaterow
throws standardexception
datavaluedescriptor	inputcolumn   null
if  sanitymanager debug
sanitymanager assert  inputrow    null      accumulaterow    null
datavaluedescriptor aggregatorcolumn    datavaluedescriptor  accumulaterow
inputcolumn    datavaluedescriptor  inputrow
accumulate inputcolumn  aggregatorcolumn
/**
* accumulate the aggregate results.  this is the
* guts of the aggregation.  we will call the user aggregate
* on itself to do the aggregation.
*
* @param	inputcolumn
* @param	aggregatorcolumn
*
* @exception standardexception  on error
*/
void accumulate datavaluedescriptor	inputcolumn
datavaluedescriptor	aggregatorcolumn
throws standardexception
execaggregator		ua
if  sanitymanager debug
/*
** just to be on the safe side, confirm that we actually
** have a aggregator in this column.
*/
if    aggregatorcolumn instanceof userdatavalue
sanitymanager throwassert
aggregatorcolumn getclass   getname
ua    execaggregator  aggregatorcolumn getobject
/*
** if we don't have an aggregator, then we have to
** create one now.  this happens when the input result
** set is null.
*/
if  ua    null
ua   getaggregatorinstance
ua accumulate inputcolumn  this
/**
* merge the aggregate results.  this is the
* guts of the aggregation.  we will call the user aggregate
* on itself to do the aggregation.
*
* @param	inputrow 	the row with the input colum
* @param	mergerow 	the row with the aggregator
*
* @exception standardexception  on error
*/
void merge execrow	inputrow
execrow	mergerow
throws standardexception
datavaluedescriptor mergecolumn   mergerow getcolumn aggregatorcolumnid   1
datavaluedescriptor inputcolumn   inputrow getcolumn aggregatorcolumnid   1
merge inputcolumn  mergecolumn
/**
* merge the aggregate results.  this is the
* guts of the aggregation.  we will call the user aggregate
* on itself to do the aggregation.
*
* @param	inputrow 	the row with the input colum
* @param	mergerow 	the row with the aggregator
*
* @exception standardexception  on error
*/
void merge object	inputrow
object	mergerow
throws standardexception
datavaluedescriptor mergecolumn    datavaluedescriptor  mergerow
datavaluedescriptor inputcolumn    datavaluedescriptor  inputrow
merge inputcolumn  mergecolumn
/**
* get the results of the aggregation and put it
* in the result column.
*
* @param	row	the row with the result and the aggregator
*
* @exception standardexception on error
*/
boolean finish execrow row
throws standardexception
datavaluedescriptor outputcolumn   row getcolumn resultcolumnid   1
datavaluedescriptor aggregatorcolumn   row getcolumn aggregatorcolumnid   1
/*
** just to be on the safe side, confirm that we actually
** have a aggregator in aggregatorcolumn.
*/
if  sanitymanager debug
sanitymanager assert aggregatorcolumn    null
sanitymanager assert outputcolumn    null
sanitymanager assert aggregatorcolumn instanceof userdatavalue
execaggregator ua    execaggregator  aggregatorcolumn getobject
/*
** if we don't have an aggregator, then we have to
** create one now.  this happens when the input result
** set is null.
*/
if  ua    null
ua   getaggregatorinstance
/*
**
** we are going to copy
** then entire datavaluedescriptor into the result column.
** we could call setvalue(result.setobject()), but we
** might loose state (e.g. sqlbit.getobject() returns a
** byte[] which looses the precision of the bit.
**
*/
datavaluedescriptor result   ua getresult
if  result    null
outputcolumn settonull
else
outputcolumn setvalue result
return ua dideliminatenulls
/**
* get a new instance of the aggregator and initialize it.
*
* @return an exec aggregator
*
* @exception standardexception on error
*/
execaggregator getaggregatorinstance
throws standardexception
execaggregator aggregatorinstance
if  cachedaggregator    null
try
class aggregatorclass   cf loadapplicationclass agginfo getaggregatorclassname
object agg   aggregatorclass newinstance
aggregatorinstance    execaggregator agg
cachedaggregator   aggregatorinstance
aggregatorinstance setup agginfo getaggregatename
catch  exception e
throw standardexception unexpecteduserexception e
else
aggregatorinstance   cachedaggregator newaggregator
return aggregatorinstance
/////////////////////////////////////////////////////////////
//
/////////////////////////////////////////////////////////////
/**
* return the column id that is being aggregated
*/
int getcolumnid
// every sort has to have at least one column.
return aggregatorcolumnid
/**
* merge two partial aggregations.  this is how the
* sorter merges partial aggregates.
*
* @exception standardexception on error
*/
void merge storable aggregatorcolumnin
storable aggregatorcolumnout
throws standardexception
execaggregator	uain
execaggregator	uaout
if  sanitymanager debug
/*
** just to be on the safe side, confirm that we actually
** have a aggregator in this column.
*/
if    aggregatorcolumnin instanceof userdatavalue
sanitymanager throwassert
aggregatorcolumnin getclass   getname
if    aggregatorcolumnout instanceof userdatavalue
sanitymanager throwassert
aggregatorcolumnout getclass   getname
uain    execaggregator    userdatavalue  aggregatorcolumnin  getobject
uaout    execaggregator    userdatavalue  aggregatorcolumnout  getobject
uaout merge uain
//////////////////////////////////////////////////////
//
// misc
//
//////////////////////////////////////////////////////
aggregatorinfo getaggregatorinfo
return agginfo