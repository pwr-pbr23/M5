/*
derby - class org.apache.derby.impl.drda.dsstrace
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl drda
// generic process and error tracing encapsulation.
// this class also traces a drda communications buffer.
// the value of the hex bytes are traced along with
// the ascii and ebcdic translations.
public class dsstrace
// this class was implemented using character arrays to translate bytes
// into ascii and ebcdic.  the goal was to be able to quickly index into the
// arrays to find the characters.  char arrays instead of strings were used as
// much as possible in an attempt to help speed up performance.
private static final string list_separator
// trace representation for a java null.
private static final string null_value
// an array of characters used to translate bytes to ascii.
// the position in the array corresponds to the hex value of the
// character
private static final char asciichar
// 0   1   2   3   4   5   6   7   8   9   a   b   c   d   e   f
0
1
2
3
4
5
6
7
8
9
a
b
c
d
e
f
// this mapping table associates a codepoint to a string describing the codepoint.
// this is needed because the trace prints the
// first codepoint in send and receive buffers.
// this could be final but there is no need to create the mapping
// if tracing isn't used.  so... this array will only be created when
// the com buffer trace is started.  note this ref is not protected
// by final and care must be taken if it's value needs to change.
private static codepointnametable codepointnametable   null
// this column position header is used to mark offsets into the trace.
private static final string colposheader
// an array of characters used to translate bytes to ebcdic.
// the position in the array corresponds to the hex value of the
// character.
private static final char ebcdicchar
// 0   1   2   3   4   5   6   7   8   9   a   b   c   d   e   f
0
1
2
3
4
5
6
7
8
9
a
b
c
d
e
f
// an array of characters representing hex numbers.
private static final char hexdigit
// a printwriter is used in printing the trace.
private java io printwriter combufferwriter   null
// the receive header comes befor bytes which would be read from
// a stream.
private static final string receiveheader
// the send header comes before bytes which would be written to
// a stream.
private static final string sendheader
// the space character is defined for convience.
private static final char spacechar
// this boolean indicates if the trace is on.
// it has been declared private now but may be made public at
// a later time.
private boolean combuffertraceon   false
// the combuffersync is an object used for serialization.
// this separate object is used because this trace code may
// get eventually placed into another class which performs
// method entry and exit tracing.  since each trace may be writing
// to different logs, separate objects will be used to perform the
// synchronization.
private boolean combuffersync   new boolean  true
// the zero character is defined for convinience.
private static final char zerochar
// the recevie constant is used to indicate that the bytes were read to a stream.
// it indicates to this class that a receive header should be used.
protected static final int type_trace_receive   2
// the send constant is used to indicate that the bytes were written to
// a stream.  it indicates to this class that a send header should be used.
protected static final int type_trace_send   1
// query if trace is on.
// this is currently needed since the combuffertrcon flag is private.
protected boolean iscombuffertraceon
// the trace flag indicates if tracing is on.
return combuffertraceon
// start the communications buffer trace.
// the name of the file to place the trace is passed to this method.
// after calling this method, calls to iscombuffertraceon() will return true.
protected void startcombuffertrace  string filename
synchronized  combuffersync
try
// only start the trace if it is off.
if  combuffertraceon    false
// the writer will be buffered for effeciency.
combufferwriter   new java io printwriter  new java io bufferedwriter  new java io filewriter  filename   4096
// turn on the trace flag.
combuffertraceon   true
// initialize the codepoint name table if it is null.
// this is done here so that the codepointname objects
// aren't created if the trace isn't used (save some memory).
// this process should only be done once
// since after the table is created the ref will
// no longer be null.
if  dsstrace codepointnametable    null
codepointnametable   new codepointnametable
catch  java io ioexception e
// the ioexception is currently ignored.  handling should be added.
// stop the communications buffer trace.
// the trace file is flushed and closed.  after calling this method,
// calls to iscombuffertraceon () will return false.
protected void stopcombuffertrace
synchronized  combuffersync
// only stop the trace if it is actually on.
if  combuffertraceon    true
// turn of the trace flag.
combuffertraceon   false
// flush and close the writer used for tracing.
combufferwriter flush
combufferwriter close
// write the communication buffer data to the trace.
// the data is passed in via a byte array.  the start and length of the data is given.
// the type is needed to indicate if the data is part of the send or receive buffer.
// the class name, method name, and trcpt number are also written to the trace.
// not much checking is performed on the parameters.  this is done to help performance.
protected void writecombufferdata  byte buff
int offset
int len
int type
string classname
string methodname
int trcpt
// why don't we synchronize the method!!!
// grab the lock to make sure another thread doesn't try to
// write data or close the writer.
synchronized  combuffersync
// only take action if the trace is on.
if  combuffertraceon
// obtain an instance of the calendar so a timestamp can be written.
// this call seems to slow things down a bit.
java util calendar time   java util calendar getinstance
// print the timestamp, class name, method name, thread name, and tracepoint.
combufferwriter println
time get  java util calendar year
time get  java util calendar month    1
time get  java util calendar day_of_month
time get  java util calendar hour_of_day
time get  java util calendar minute
time get  java util calendar second
classname
methodname
thread currentthread   getname
trcpt
// a newline is added for formatting.
combufferwriter println
// the data will only be written if there is a non-zero positive length.
if  len    0
string codepointname   null
// if the length <= 10, lookup the first codepoint so it's name can be printed???
if  len >  10
// get the int value of the two byte unsigned codepoint.
int codepoint   getcodepoint  buff  offset 8
codepointname   codepointnametable lookup  codepoint
if  codepointname    null
// codepointname was still null so either < 10 bytes were given or
// the codepoint wasn't found in the table.  just print the plain send header.
combufferwriter println  getheader  type
else
// codepointname isn't null so the name of the codepoint will be printed.
printheaderwithcodepointname  codepointname  type
// print the col position header in the trace.
combufferwriter println  colposheader
// a char array will be used to translate the bytes to their character
// representations along with ascii and ebcdic representations.
char trcdump   new char
// bcounter, acounter, ecounter are offsets used to help position the characters
short bcounter   7
short acounter   43
short ecounter   61
// the lines will be counted starting at zero.  this is hard coded since we are
// at the beginning.
trcdump   dsstrace zerochar
trcdump   dsstrace zerochar
trcdump   dsstrace zerochar
trcdump   dsstrace zerochar
// the 0's are already in the trace so bump the line counter up a row.
int linecounter   0x10
// make sure the character array has all blanks in it.
// some of these blanks will be replaced later with values.
// the 0's were not wrote over.
for  int j   4  j < 77  j
trcdump   dsstrace spacechar
// i will maintain the position in the byte array to be traced.
int i   0
do
// get the unsigned value of the byte.
//                  int num = b[off++] & 0xff;
int num    buff < 0 ? buff   256   buff     jev
offset
i
// place the characters representing the bytes in the array.
trcdump   dsstrace hexdigit
trcdump   dsstrace hexdigit
// place the ascii and ebcdc representations in the array.
trcdump   dsstrace asciichar
trcdump   dsstrace ebcdicchar
if    i%8     0
if    i%16     0
// print the array each time 16 bytes are processed.
combufferwriter println  trcdump
if  i    len
// not yet at the end of the byte array.
if   len   i  < 16
// this is the last line so blank it all out.
// this keeps the last line looking pretty in case
// < 16 bytes remain.
for  int j   0  j < trcdump length  j
trcdump   dsstrace spacechar
// reset the counters.
bcounter   0
acounter   43
ecounter   61
// reset the linecounter if it starts to get too large.
if  linecounter    0xfff0
linecounter   0
// place the characters representing the line counter in the array.
trcdump   dsstrace hexdigit
trcdump   dsstrace hexdigit
trcdump   dsstrace hexdigit
trcdump   dsstrace hexdigit
bcounter    3
// bump up the line counter.
linecounter    0x10
else
// 8 bytes were processed so move the counter to adjust for
// spaces between the columns of bytes.
bcounter    2
// do this until we all the data has been traced.
while  i < len
// print the last line and add some blank lines to make it easier to read.
if  len % 16    0
combufferwriter println  trcdump
combufferwriter println
combufferwriter println
// flush the writer.
combufferwriter flush
// gets the int value of the two byte unsigned codepoint.
private static int getcodepoint  byte buff  int offset
return   buff   0xff  << 8
buff   0xff  << 0
private static string getheader  int type
switch  type
case dsstrace type_trace_send
return dsstrace sendheader
case dsstrace type_trace_receive
return dsstrace receiveheader
default
//  throw new !!!
return null
private static int getstartposition  int type
switch  type
case dsstrace type_trace_send
return 20     this is right after
case dsstrace type_trace_receive
return 23     this is right after
default
//  throw new !!!
return 0
private void printheaderwithcodepointname  string codepointname  int type
// create a char array so some of the characters
// can be replaced with the name of the codepoint.
char headerarray   dsstrace getheader type  tochararray
// at most, 16 character name will be used.  this is so
// the headers on top of the ascii and ebcdic rows aren't shifted.
int replacelen    codepointname length   < 17  ? codepointname length     16
int offset   getstartposition  type
for  int i   0  i < replacelen  i
headerarray   codepointname charat  i      make sure charat   starts at 0
combufferwriter println  headerarray