/*
derby - class org.apache.derby.iapi.store.access.rowutil
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby iapi store access
import org apache derby iapi services monitor monitor
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi error standardexception
import org apache derby iapi services io storable
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi services io formatablebitset
import org apache derby iapi services loader instancegetter
import org apache derby iapi store raw fetchdescriptor
import java lang reflect invocationtargetexception
import java util enumeration
import java util hashtable
import java util vector
/**
a set of static utility methods to work with rows.
<p>
a row or partial row is described by two or three parameters.
<ol>
<li>datavaluedescriptor[] row - an array of objects, one per column.
<li>formatablebitset validcolumns -
an indication of which objects in row map to which columns
</ol>
these objects can describe a complete row or a partial row. a partial row is
one where a sub-set (e.g. columns 0, 4 and 7) of the columns are supplied
for update, or requested to be fetched on a read.  here's an example
of code to set up a partial column list to fetch the 0th (type foo),
4th (type bar), and 7th (type mmm) columns from a row with 10 columns, note
that the format for a partial row changed from a "packed" representation
in the 3.0 release to a "sparse" representation in later releases:
<blockquote><pre>
// allocate/initialize the row
datavaluedescriptor row = new datavaluedescriptor[10]
row[0] = new foo();
row[4] = new bar();
row[7] = new mmm();
// allocate/initialize the bit set
formatablebitset formatablebitset = new formatablebitset(10);
formatablebitset.set(0);
formatablebitset.set(4);
formatablebitset.set(7);
</blockquote></pre>
<br><b>column mapping<b><br>
when validcolumns is null:
<ul>
<li> the number of columns is given by row.length
<li> column n maps to row[n], where column numbers start at zero.
</ul>
<br>
when validcolumns is not null, then
<ul>
<li> the number of requested columns is given by the number of bits set in
validcolumns.
<li> column n is not in the partial row if validcolumns.isset(n)
returns false.
<li> column n is in the partial row if validcolumns.isset(n) returns true.
<li> if column n is in the partial row then it maps to row[n].
if n >= row.length then the column is taken as non existent for an
insert or update, and not fetched on a fetch.
</ul>
if row.length is greater than the number of columns indicated by validcolumns
the extra entries are ignored.
**/
public class rowutil
private rowutil
/**
an object that can be used on a fetch to indicate no fields
need to be fetched.
*/
public static final datavaluedescriptor empty_row
new datavaluedescriptor
/**
an object that can be used on a fetch as a formatablebitset to indicate no fields
need to be fetched.
*/
public static final formatablebitset empty_row_bitset
new formatablebitset 0
/**
an object that can be used on a fetch as a formatablebitset to indicate no fields
need to be fetched.
*/
public static final fetchdescriptor empty_row_fetch_descriptor
new fetchdescriptor 0
public static final fetchdescriptor rowutil_fetch_descriptor_constants
empty_row_fetch_descriptor
new fetchdescriptor 1  1
new fetchdescriptor 2  2
new fetchdescriptor 3  3
new fetchdescriptor 4  4
new fetchdescriptor 5  5
new fetchdescriptor 6  6
new fetchdescriptor 7  7
/**
get the object for a column identifer (0 based) from a complete or
partial row.
@param row the row
@param columnlist valid columns in the row
@param columnid which column to return (0 based)
@return the obejct for the column, or null if the column is not represented.
*/
public static datavaluedescriptor getcolumn
datavaluedescriptor   row
formatablebitset                 columnlist
int                     columnid
if  columnlist    null
return columnid < row length ? row   null
if    columnlist getlength   > columnid    columnlist isset columnid
return null
return columnid < row length ? row   null
public static object getcolumn
object   row
formatablebitset                 columnlist
int                     columnid
if  columnlist    null
return columnid < row length ? row   null
if    columnlist getlength   > columnid    columnlist isset columnid
return null
return columnid < row length ? row   null
/**
get a formatablebitset representing all the columns represented in
a qualifier list.
@return a formatablebitset describing the valid columns.
*/
public static formatablebitset getqualifierbitset qualifier qualifiers
formatablebitset qualifiercolumnlist   new formatablebitset
if  qualifiers    null
for  int i   0  i < qualifiers length  i
for  int j   0  j < qualifiers length  j
int colid   qualifiers getcolumnid
// we are about to set bit colid, need length to be colid+1
qualifiercolumnlist grow colid 1
qualifiercolumnlist set colid
return qualifiercolumnlist
/**
* get the number of columns represented by a formatablebitset.
* <p>
* this is simply a count of the number of bits set in the formatablebitset.
* <p>
*
* @param maxcolumnnumber because the formatablebitset.size() can't be used as
*                        the number of columns, allow caller to tell
*                        the maximum column number if it knows.
*                        -1  means caller does not know.
*                        >=0 number is the largest column number.
*
* @param columnlist valid columns in the row
*
* @return the number of columns represented in the formatablebitset.
**/
public static int getnumberofcolumns
int     maxcolumnnumber
formatablebitset  columnlist
if  sanitymanager debug
sanitymanager assert columnlist    null
int max_col_number   columnlist getlength
if  maxcolumnnumber > 0    maxcolumnnumber < max_col_number
max_col_number   maxcolumnnumber
int ret_num_cols   0
for  int i   0  i < max_col_number  i
if  columnlist isset i
ret_num_cols
return ret_num_cols
/**
see if a row actually contains no columns.
returns true if row is null or row.length is zero.
@return true if row is empty.
*/
public static boolean isrowempty
datavaluedescriptor   row
if  row    null
return true
if  row length    0
return true
return false
/**
return the column number of the first column out of range, or a number
less than zero if all columns are in range.
*/
public static int columnoutofrange
datavaluedescriptor   row
formatablebitset                 columnlist
int                     maxcolumns
if  columnlist    null
if  row length > maxcolumns
return maxcolumns
return  1
int size   columnlist getlength
for  int i   maxcolumns  i < size  i
if  columnlist isset i
return i
return  1
/**
get the next valid column after or including start column.
returns -1 if no valid columns exist after startcolumn
*/
public static int nextcolumn
object   row
formatablebitset                 columnlist
int                     startcolumn
if  columnlist    null
int size   columnlist getlength
for    startcolumn < size  startcolumn
if  columnlist isset startcolumn
return startcolumn
return  1
if  row    null
return  1
return startcolumn < row length ? startcolumn    1
/**
* return a fetchdescriptor which describes a single column set.
* <p>
* this routine returns one of a set of constant fetchdescriptor's, and
* should not be altered by the caller.
**/
public static final fetchdescriptor getfetchdescriptorconstant
int     single_column_number
if  single_column_number < rowutil_fetch_descriptor_constants length
return rowutil_fetch_descriptor_constants
else
return
new fetchdescriptor
single_column_number  single_column_number
/**************************************************************************
* public methods dealing with cloning and row copying util functions
**************************************************************************
*/
/**
* generate a row of instancegetter objects to be used to generate  "empty" rows.
* <p>
* generate an array of instancegetter objects which will be used to make
* repeated calls to newrowfromclassinfotemplate(), to repeatedly and
* efficiently generate new rows.  this is important for certain
* applications like the sorter and fetchset which generate large numbers
* of "new" empty rows.
* <p>
*
* @return the new row.
*
* @param format_ids an array of format id's, one per column in row.
*
* @exception  standardexception  standard exception policy.
**/
public static instancegetter newclassinfotemplate
formatablebitset column_list
int    format_ids
throws standardexception
int         num_cols   format_ids length
instancegetter ret_row    new instancegetter
int column_listsize
column_list    null  ? 0   column_list getlength
for  int i   0  i < num_cols  i
// does caller want this column?
if   column_list    null
column_listsize > i
column_list isset i
// no - column should be skipped.
else
// yes - create the column
// get empty instance of object identified by the format id.
ret_row   monitor classfromidentifier format_ids
return ret_row
private static void newrowfromclassinfotemplateerror
if  sanitymanager debug
sanitymanager throwassert
/**
* generate an "empty" row from an array of classinfo objects.
* <p>
* generate an array of new'd objects by using the getnewinstance()
* method on each of the instancegetter objects.  it is more
* efficient to allocate new objects based on this "cache'd"
* instancegetter object than to call the monitor to generate a new class
* from a format id.
* <p>
*
* @return the new row.
*
* @param classinfo_template   an array of instancegetter objects each of
*                             which can be used to create a new instance
*                             of the appropriate type to build a new empty
*                             template row.
*
* @exception  standardexception  standard exception policy.
**/
public static datavaluedescriptor newrowfromclassinfotemplate
instancegetter    classinfo_template
throws standardexception
datavaluedescriptor columns
new datavaluedescriptor
try
for  int column_index   classinfo_template length
column_index   > 0
if  classinfo_template    null
// get empty instance of datavaluedescriptor identified by
// the format id.
columns    datavaluedescriptor
classinfo_template getnewinstance
catch  instantiationexception ie
newrowfromclassinfotemplateerror
catch  illegalaccessexception iae
newrowfromclassinfotemplateerror
catch  invocationtargetexception ite
newrowfromclassinfotemplateerror
return columns
/**
* return string version of row.
* <p>
* for debugging only.
*
* @return the string version of row.
*
* @param row the row.
*
**/
public static string tostring object row
if  sanitymanager debug
string str   new string
if  row    null
if  row length    0
str
else
for  int i   0  i < row length  i
str        i       row
else
str
return str
else
return null
/**
* return string version of a hashtable returned from a fetchset.
* <p>
*
* @return the string version of row.
*
*
**/
// for debugging only.
public static string tostring hashtable hash_table
if  sanitymanager debug
string str   new string
object  row_or_vector
for  enumeration e   hash_table elements    e hasmoreelements
row_or_vector   e nextelement
if  row_or_vector instanceof object
// it's a row
str    rowutil tostring  object  row_or_vector
str
else if  row_or_vector instanceof vector
// it's a vector
vector vec    vector  row_or_vector
for  int i   0  i < vec size    i
str
i
rowutil tostring  object  vec elementat i
str
else
str
return str
else
return null
/**
* process the qualifier list on the row, return true if it qualifies.
* <p>
* a two dimensional array is to be used to pass around a and's and or's in
* conjunctive normal form.  the top slot of the 2 dimensional array is
* optimized for the more frequent where no or's are present.  the first
* array slot is always a list of and's to be treated as described above
* for single dimensional and qualifier arrays.  the subsequent slots are
* to be treated as and'd arrays or or's.  thus the 2 dimensional array
* qual[][] argument is to be treated as the following, note if
* qual.length = 1 then only the first array is valid and it is and an
* array of and clauses:
*
* (qual[0][0] and qual[0][0] ... and qual[0][qual[0].length - 1])
* and
* (qual[1][0] or  qual[1][1] ... or  qual[1][qual[1].length - 1])
* and
* (qual[2][0] or  qual[2][1] ... or  qual[2][qual[2].length - 1])
* ...
* and
* (qual[qual.length - 1][0] or  qual[1][1] ... or  qual[1][2])
*
*
* @return true if the row qualifies.
*
* @param row               the row being qualified.
* @param qual_list         2 dimensional array representing conjunctive
*                          normal form of simple qualifiers.
*
* @exception  standardexception  standard exception policy.
**/
public static final boolean qualifyrow
object        row
qualifier   qual_list
throws standardexception
boolean     row_qualifies   true
if  sanitymanager debug
sanitymanager assert row    null
// first do the qual[0] which is an array of qualifer terms.
if  sanitymanager debug
// routine should not be called if there is no qualifier
sanitymanager assert qual_list    null
sanitymanager assert qual_list length > 0
for  int i   0  i < qual_list length  i
// process each and clause
row_qualifies   false
// process each or clause.
qualifier q   qual_list
// get the column from the possibly partial row, of the
// q.getcolumnid()'th column in the full row.
datavaluedescriptor columnvalue
datavaluedescriptor  row
row_qualifies
columnvalue compare
q getoperator
q getorderable
q getorderednulls
q getunknownrv
if  q negatecompareresult
row_qualifies    row_qualifies
// once an and fails the whole qualification fails - do a return!
if   row_qualifies
return false
// all the qual[0] and terms passed, now process the or clauses
for  int and_idx   1  and_idx < qual_list length  and_idx
// loop through each of the "and" clause.
row_qualifies   false
if  sanitymanager debug
// each or clause must be non-empty.
sanitymanager assert qual_list length > 0
for  int or_idx   0  or_idx < qual_list length  or_idx
// apply one qualifier to the row.
qualifier q        qual_list
int       col_id   q getcolumnid
if  sanitymanager debug
sanitymanager assert
col_id < row length
// get the column from the possibly partial row, of the
// q.getcolumnid()'th column in the full row.
datavaluedescriptor columnvalue
datavaluedescriptor  row
if  sanitymanager debug
if  columnvalue    null
sanitymanager throwassert
rowutil tostring row
row length
q getcolumnid
// do the compare between the column value and value in the
// qualifier.
row_qualifies
columnvalue compare
q getoperator
q getorderable
q getorderednulls
q getunknownrv
if  q negatecompareresult
row_qualifies    row_qualifies
// sanitymanager.debug_print("storedpage.qual", "processing qual[" + and_idx + "][" + or_idx + "] = " + qual_list[and_idx][or_idx] );
// sanitymanager.debug_print("storedpage.qual", "value = " + row_qualifies);
// processing "or" clauses, so as soon as one is true, break
// to go and process next and clause.
if  row_qualifies
break
// the qualifier list represented a set of "and'd"
// qualifications so as soon as one is false processing is done.
if   row_qualifies
break
return row_qualifies