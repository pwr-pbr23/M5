/*
derby - class org.apache.derby.iapi.store.access.conglomerate.logicalundo
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby iapi store access conglomerate
import org apache derby iapi error standardexception
import org apache derby iapi store raw logicalundoable
import org apache derby iapi store raw page
import org apache derby iapi store raw transaction
import org apache derby iapi services io limitobjectinput
import java io ioexception
/**
a logical undo is an undo operation that operates on a different page
from the page that has the original change.  the reason one would
need logical undo is when an uncommitted row move from one page to
another in a nested internal transaction which is committed.  for
example, an uncommitted insert on a btree may be moved by a later split
operation to another page, the split operation will have committed.  if
the insert needs to be rolled back, it can only be found at the new
page where the split puts it and not at the original page where it is
inserted.
<p>
the logging and recovery system does not know how to do logical undo.
client of the logging system must provide it with a call back function
so that during undo time (both runtime undo and recovery undo), the
appropriate page and row can be found so that the logging system can
apply the log's undo operation.
<p>
any log operation that needs logical undo must implement this
logicalundo interface, which serves the purpose of a callback function
pointer.  this callback function findundoinfo is called by log operation
generateundo and will be given all the information in the log operation.
<p>
findundo uses the information in the pageop to find the correct page
and record that needs to be rolled back, i.e., a latched page
(undopage) and the recordid (undorid).  it returns the latched
undopage, and modifies the pageop to contain the correct segmentid,
containerid, pagenumber and recordid etc.  it also need to supply a
releaseresource() method that the logging system can call to unlatch
the page and release the container, etc, after the undo has been
applied.
<p>
the logging system will use the information in the undopackage to put
together a compensation operation which has the undopage number
and undorid.  logical undo is only called during the generation of a
clr, never during recovery redo.
<p>
<b>note: logicalundo is a call back function pointer that will be
written out as part of the log operation, it should not contain any
non-transient member fields </b>
<p>
details.
<p>
logicalundo, and logicalundoable is the interface used by logical undo
between the logging system in rawstore and access.  a log operation
that needs logical undo should implment logicalundoable intead of
undoable.  a logicalundoable log operation contains a logicalundo
member field, which is a function pointer to an access function that
provides the logical undo logic of, say, traversing a btree.
<p>
when called to generateundo, that logicalundoable log operation will
call logicalundo.findundo instead of relying on the page number and
recordid that is stored in it during the runtime roll forward
operation.  <b>the logging system opens the container before it calls
findundo, therefore the container where the log operation is applied
cannot between rollforward and rollback.</b>
<p>
in logicalundo.findundo, it can use information stored in
the logicalundoable, such as pagenumber, containerid, to come up with a
template row.  it can then ask the logicalundoable log record
to restore a row from the log record that fits the template.  using
this restored row, logicalundo can, e.g., restore the key to the btree
and traverses the btree.  once it finds the correct recordhandle where
the rollback should go, findundo should call pageop.resetrecord and
return a latched page where the undo should go.
<p>
upon the return of findundo, the logicalundoable log operation should
have information about the new recordhandle and the page should be
return latched.  a compensation operation is then generated with the
new record location and undome is applied on the correct location.
<p>
the logging system will unlatch the undopage when it is done with
rollback and will close the container.
@see org.apache.derby.iapi.store.raw.logicalundoable
@see org.apache.derby.iapi.store.raw.undoable#generateundo
*/
public interface logicalundo
/**
find the page and record to undo.  if no logical undo is necessary,
i.e., row has not moved, then just return the latched page where undo
should go.  if the record has moved, it has a new recordid on the new
page, this routine needs to call pageop.resetrecord with the new
recordhandle so that the logging system can update the compensation
operation with the new location.
@param transaction the transaction doing the rollback
@param pageop the page operation that supports logical undo.  this
logicalundo function pointer is a field of that pageoperation
@param in data stored in the log stream that contains the record data
necessary to restore the row.
@exception standardexception standard cloudscape error policy
@exception ioexception method may read from inputstream
*/
public page findundo
transaction     transaction
logicalundoable pageop
limitobjectinput     in
throws standardexception  ioexception