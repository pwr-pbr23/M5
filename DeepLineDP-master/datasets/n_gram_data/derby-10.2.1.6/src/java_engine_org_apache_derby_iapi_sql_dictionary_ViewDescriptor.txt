/*
derby - class org.apache.derby.iapi.sql.dictionary.viewdescriptor
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby iapi sql dictionary
import org apache derby catalog uuid
import org apache derby iapi sql depend dependent
import org apache derby iapi sql depend provider
import org apache derby iapi sql dictionary genericdescriptorlist
import org apache derby iapi error standardexception
import org apache derby iapi sql conn languageconnectioncontext
import org apache derby iapi store access transactioncontroller
import org apache derby iapi sql depend dependencymanager
import org apache derby iapi services context contextservice
import org apache derby iapi reference sqlstate
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi sql statementtype
import org apache derby catalog dependablefinder
import org apache derby catalog dependable
import org apache derby iapi services io storedformatids
import org apache derby impl sql execute droptriggerconstantaction
/**
* this is the implementation of viewdescriptor. users of view descriptors
* should only use the following methods:
* <ol>
* <li> getuuid
* <li> setuuid
* <li> getviewtext
* <li> setviewname
* <li> getcheckoptiontype
* <li> getcompschemaid
* </ol>
*
* @version 0.1
* @author jeff lichtman
*/
public final class viewdescriptor extends tupledescriptor
implements uniquetupledescriptor  dependent  provider
private final int			checkoption
private string		viewname
private final string		viewtext
private uuid		uuid
private final uuid		compschemaid
public static final	int no_check_option   0
/**
* constructor for a viewdescriptor.
*
* @param datadictionary		the data dictionary that this descriptor lives in
* @param viewid	the uuid for the view
* @param viewname	the name of the view
* @param viewtext	the text of the query expression from the view definition.
* @param checkoption	int check option type
* @param compschemaid	the schemaid to compile in
*/
public viewdescriptor datadictionary datadictionary  uuid viewid  string viewname  string viewtext
int checkoption  uuid compschemaid
super  datadictionary
uuid   viewid
this viewtext   viewtext
this viewname   viewname
/* resolve - no check options for now */
if  sanitymanager debug
if  checkoption    viewdescriptor no_check_option
sanitymanager throwassert     checkoption
viewdescriptor no_check_option
this checkoption   checkoption
this compschemaid   compschemaid
//
// viewdescriptor interface
//
/**
* gets the uuid of the view.
*
* @return	the uuid of the view.
*/
public uuid	getuuid
return uuid
/**
* sets the uuid of the view.
*
* @param uuid	the uuid of the view.
*/
public void	setuuid uuid uuid
this uuid   uuid
/**
* gets the text of the view definition.
*
* @return	a string containing the text of the create view
*		statement that created the view
*/
public string	getviewtext
return viewtext
/**
* sets the name of the view.
*
* @param name	the name of the view.
*/
public void	setviewname string name
viewname   name
/**
* gets an identifier telling what type of check option
* is on this view.
*
* @return	an identifier telling what type of check option
*			is on the view.
*/
public int	getcheckoptiontype
return checkoption
/**
* get the compilation type schema id when this view
* was first bound.
*
* @return the schema uuid
*/
public uuid getcompschemaid
return compschemaid
//
// provider interface
//
/**
@return the stored form of this provider
@see dependable#getdependablefinder
*/
public dependablefinder getdependablefinder
return getdependablefinder storedformatids view_descriptor_finder_v01_id
/**
* return the name of this provider.  (useful for errors.)
*
* @return string	the name of this provider.
*/
public string getobjectname
return viewname
/**
* get the provider's uuid
*
* @return string	the provider's uuid
*/
public uuid getobjectid
return uuid
/**
* get the provider's type.
*
* @return string		the provider's type.
*/
public string getclasstype
return dependable view
//
// dependent inteface
//
/**
check that all of the dependent's dependencies are valid.
@return true if the dependent is currently valid
*/
public boolean isvalid
return true
/**
prepare to mark the dependent as invalid (due to at least one of
its dependencies being invalid).
@param action	the action causing the invalidation
@param p		the provider
@exception standardexception thrown if unable to make it invalid
*/
public void preparetoinvalidate provider p  int action
languageconnectioncontext lcc
throws standardexception
switch   action
/*
* we don't care about creating or dropping indexes or
* alter table on an underlying table.
*/
case dependencymanager create_index
case dependencymanager drop_index
case dependencymanager create_constraint
case dependencymanager alter_table
case dependencymanager create_trigger
case dependencymanager drop_trigger
case dependencymanager bulk_insert
case dependencymanager compress_table
case dependencymanager rename_index
case dependencymanager update_statistics
case dependencymanager drop_statistics
case dependencymanager truncate_table
/*
** set constriants is a bit odd in that it
** will send a set_constraints on the table
** when it enables a constraint, rather than
** on the constraint.  so since we depend on
** the table, we have to deal with this action.
*/
case dependencymanager set_constraints_enable
case dependencymanager set_triggers_enable
//when revoke_privilege gets sent (this happens for privilege
//types select, update, delete, insert, references, trigger), we
//don't do anything here. later in makeinvalid method, we make
//the viewdescriptor drop itself.
case dependencymanager revoke_privilege
break
//notice that revoke_privilege_restrict is not caught earlier.
//it gets handled in this default: action where an exception
//will be thrown. this is because, if such an invalidation
//action type is ever received by a dependent, the dependent
//show throw an exception.
//in derby, at this point, revoke_privilege_restrict gets sent
//when execute privilege on a routine is getting revoked.
default
dependencymanager dm
dm   getdatadictionary   getdependencymanager
throw standardexception newexception sqlstate lang_provider_has_dependent_view
dm getactionstring action
p getobjectname    viewname
end switch
/**
mark the dependent as invalid (due to at least one of
its dependencies being invalid).
@param	action	the action causing the invalidation
@exception standardexception thrown if unable to make it invalid
*/
public void makeinvalid int action  languageconnectioncontext lcc
throws standardexception
switch   action
/* we don't care about creating or dropping indexes or
* alter table on an underlying table.
*/
case dependencymanager create_index
case dependencymanager drop_index
case dependencymanager alter_table
case dependencymanager create_constraint
case dependencymanager bulk_insert
case dependencymanager compress_table
case dependencymanager set_constraints_enable
case dependencymanager set_triggers_enable
case dependencymanager create_trigger
case dependencymanager drop_trigger
case dependencymanager rename_index
case dependencymanager update_statistics
case dependencymanager drop_statistics
case dependencymanager truncate_table
break
//when revoke_privilege gets sent (this happens for privilege
//types select, update, delete, insert, references, trigger), we
//make the viewdescriptor drop itself.
case dependencymanager revoke_privilege
dropviewwork getdatadictionary
getdatadictionary   getdependencymanager    lcc
lcc gettransactionexecute
getdatadictionary   gettabledescriptor uuid  getschemadescriptor
getdatadictionary   gettabledescriptor uuid   false
return
default
/* we should never get here, since we can't have dangling references */
if  sanitymanager debug
sanitymanager throwassert
break
end switch
/**
attempt to revalidate the dependent. for prepared statements,
this could go through its dependencies and check that they
are up to date; if not, it would recompile the statement.
any failure during this attempt should throw
standardexception.unabletorevalidate().
@exception standardexception thrown if unable to make it valid
*/
public void makevalid languageconnectioncontext lcc
throws standardexception
//
// class interface
//
/**
* prints the contents of the viewdescriptor
*
* @return the contents as a string
*/
public string tostring
if  sanitymanager debug
return	    uuid       viewname
viewtext
checkoption
compschemaid
else
return
public void dropviewwork datadictionary dd  dependencymanager dm
languageconnectioncontext lcc  transactioncontroller tc
schemadescriptor sd  tabledescriptor td  boolean cascade
throws standardexception
/* drop the columns */
dd dropallcolumndescriptors td getuuid    tc
/* prepare all dependents to invalidate.  (this is there chance
* to say that they can't be invalidated.  for example, an open
* cursor referencing a table/view that the user is attempting to
* drop.) if no one objects, then invalidate any dependent objects.
*/
dm invalidatefor td  dependencymanager drop_view  lcc
/* clear the dependencies for the view */
dm cleardependencies lcc  this
/* drop the view */
dd dropviewdescriptor this  tc
/* drop all table and column permission descriptors */
dd dropalltableandcolpermdescriptors td getuuid    tc
/* drop the table */
dd droptabledescriptor td  sd  tc