/*
derby - class org.apache.derby.iapi.db.consistencychecker
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby iapi db
import org apache derby iapi error standardexception
import org apache derby iapi error publicapi
import org apache derby iapi sql dictionary datadictionarycontext
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi sql dictionary schemadescriptor
import org apache derby iapi sql dictionary tabledescriptor
import org apache derby iapi sql dictionary columndescriptor
import org apache derby iapi sql dictionary columndescriptorlist
import org apache derby iapi sql dictionary constraintdescriptor
import org apache derby iapi sql dictionary constraintdescriptorlist
import org apache derby iapi sql dictionary conglomeratedescriptor
import org apache derby iapi sql depend dependencymanager
import org apache derby iapi sql execute execrow
import org apache derby iapi sql execute executioncontext
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi types datavaluefactory
import org apache derby iapi sql conn languageconnectioncontext
import org apache derby iapi sql conn connectionutil
import org apache derby iapi store access transactioncontroller
import org apache derby iapi types rowlocation
import org apache derby iapi store access scancontroller
import org apache derby iapi store access conglomeratecontroller
import org apache derby iapi store access rowutil
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi reference sqlstate
import org apache derby iapi services io formatablebitset
import java sql sqlexception
/**
* the consistencychecker class provides static methods for verifying
* the consistency of the data stored within a database.
*
*
<p>this class can only be used within an sql-j statement, a java procedure or a server side java method.
<p>this class can be accessed using the class alias <code> consistencychecker </code> in sql-j statements.
*/
public class consistencychecker
/** no requirement for a constructor */
private consistencychecker
/**
* check the named table, ensuring that all of its indexes are consistent
* with the base table.
* use this
*  method only within an sql-j statement; do not call it directly.
* <p>when tables are consistent, the method returns true. otherwise, the method throws an exception.
* <p>to check the consistency of a single table:
* <p><code>
* values consistencychecker::checktable(<i>schemaname</i>, <i>tablename</i>)</code></p>
* <p>for example, to check the consistency of the table <i>app.flights</i>:
* <p><code>
* values consistencychecker::checktable('app', 'flights')</code></p>
* <p>to check the consistency of all of the tables in the 'app' schema,
* stopping at the first failure:
*
* <p><code>select tablename, consistencychecker::checktable(<br>
* 'app', tablename)<br>
* from sys.sysschemas s, sys.systables t
* where s.schemaname = 'app' and s.schemaid = t.schemaid</code>
*
* <p> to check the consistency of an entire database, stopping at the first failure:
*
* <p><code>select schemaname, tablename,<br>
* consistencychecker::checktable(schemaname, tablename)<br>
* from sys.sysschemas s, sys.systables t<br>
* where s.schemaid = t.schemaid</code>
*
*
*
* @param schemaname	the schema name of the table.
* @param tablename		the name of the table
*
* @return	true, if the table is consistent, exception thrown if inconsistent
*
* @exception	sqlexception	thrown if some inconsistency
*									is found, or if some unexpected
*									exception is thrown..
*/
public static boolean checktable string schemaname  string tablename
throws sqlexception
datadictionary			dd
tabledescriptor			td
long					baserowcount    1
transactioncontroller	tc
conglomeratedescriptor	heapcd
conglomeratedescriptor	indexcd
execrow					baserow
execrow					indexrow
rowlocation				rl   null
rowlocation				scanrl   null
scancontroller			scan   null
int					basecolumnpositions
int						basecolumns   0
datavaluefactory		dvf
long					indexrows
conglomeratecontroller	basecc   null
conglomeratecontroller	indexcc   null
executioncontext		ec
schemadescriptor		sd
constraintdescriptor	constraintdesc
languageconnectioncontext lcc   connectionutil getcurrentlcc
tc   lcc gettransactionexecute
try
dd   lcc getdatadictionary
dvf   lcc getdatavaluefactory
ec   lcc getexecutioncontext
sd   dd getschemadescriptor schemaname  tc  true
td   dd gettabledescriptor tablename  sd
if  td    null
throw standardexception newexception
sqlstate lang_table_not_found
schemaname       tablename
/* skip views */
if  td gettabletype      tabledescriptor view_type
return true
/* open the heap for reading */
basecc   tc openconglomerate
td getheapconglomerateid    false  0
transactioncontroller mode_table
transactioncontroller isolation_serializable
/* check the consistency of the heap */
basecc checkconsistency
heapcd   td getconglomeratedescriptor td getheapconglomerateid
/* get a row template for the base table */
baserow   ec getexecutionfactory   getvaluerow td getnumberofcolumns
/* fill the row with nulls of the correct type */
columndescriptorlist cdl   td getcolumndescriptorlist
int					 cdlsize   cdl size
for  int index   0  index < cdlsize  index
columndescriptor cd    columndescriptor  cdl elementat index
baserow setcolumn cd getposition
cd gettype   getnull
/* look at all the indexes on the table */
conglomeratedescriptor cds   td getconglomeratedescriptors
for  int index   0  index < cds length  index
indexcd   cds
/* skip the heap */
if     indexcd isindex
continue
/* check the internal consistency of the index */
indexcc
tc openconglomerate
indexcd getconglomeratenumber
false
0
transactioncontroller mode_table
transactioncontroller isolation_serializable
indexcc checkconsistency
indexcc close
indexcc   null
/* if index is for a constraint check that the constraint exists */
if  indexcd isconstraint
constraintdesc   dd getconstraintdescriptor td  indexcd getuuid
if  constraintdesc    null
throw standardexception newexception
sqlstate lang_object_not_found
indexcd getconglomeratename
/*
** set the base row count when we get to the first index.
** we do this here, rather than outside the index loop, so
** we won't do the work of counting the rows in the base table
** if there are no indexes to check.
*/
if  baserowcount < 0
scan   tc openscan heapcd getconglomeratenumber
false 	   hold
0 		   not forupdate
transactioncontroller mode_table
transactioncontroller isolation_serializable
rowutil empty_row_bitset
null 	   startkeyvalue
0 		   not used with null start posn
null 	   qualifier
null 	   stopkeyvalue
0  		   not used with null stop posn
/* also, get the row location template for index rows */
rl   scan newrowlocationtemplate
scanrl   scan newrowlocationtemplate
for  baserowcount   0  scan next    baserowcount
empty statement
scan close
scan   null
basecolumnpositions
indexcd getindexdescriptor   basecolumnpositions
basecolumns   basecolumnpositions length
formatablebitset indexcolsbitset   new formatablebitset
for  int i   0  i < basecolumns  i
indexcolsbitset grow basecolumnpositions
indexcolsbitset set basecolumnpositions   1
/* get one row template for the index scan, and one for the fetch */
indexrow   ec getexecutionfactory   getvaluerow basecolumns   1
/* fill the row with nulls of the correct type */
for  int column   0  column < basecolumns  column
/* column positions in the data dictionary are one-based */
columndescriptor cd   td getcolumndescriptor basecolumnpositions
indexrow setcolumn column   1
cd gettype   getnull
/* set the row location in the last column of the index row */
indexrow setcolumn basecolumns   1  rl
/* do a full scan of the index */
scan   tc openscan indexcd getconglomeratenumber
false 	   hold
0 		   not forupdate
transactioncontroller mode_table
transactioncontroller isolation_serializable
formatablebitset  null
null 	   startkeyvalue
0 		   not used with null start posn
null 	   qualifier
null 	   stopkeyvalue
0  		   not used with null stop posn
datavaluedescriptor baserowindexorder
new datavaluedescriptor
datavaluedescriptor baseobjectarray   baserow getrowarray
for  int i   0  i < basecolumns  i
baserowindexorder   baseobjectarray   1]
/* get the index rows and count them */
for  indexrows   0  scan fetchnext indexrow getrowarray     indexrows
/*
** get the base row using the rowlocation in the index row,
** which is in the last column.
*/
rowlocation baserl    rowlocation  indexrow getcolumn basecolumns   1
boolean base_row_exists
basecc fetch
baserl  baseobjectarray  indexcolsbitset
/* throw exception if fetch() returns false */
if    base_row_exists
string indexname   indexcd getconglomeratename
throw standardexception newexception sqlstate lang_inconsistent_row_location
schemaname       tablename
indexname
baserl tostring
indexrow tostring
/* compare all the column values */
for  int column   0  column < basecolumns  column
datavaluedescriptor indexcolumn
indexrow getcolumn column   1
datavaluedescriptor basecolumn
baserowindexorder
/*
** with this form of compare(), null is considered equal
** to null.
*/
if  indexcolumn compare basecolumn     0
columndescriptor cd
td getcolumndescriptor
basecolumnpositions
/*
system.out.println(
"sqlstate.lang_index_column_not_equal:" +
"indexcd.getconglomeratename()" + indexcd.getconglomeratename() +
";td.getschemaname() = " + td.getschemaname() +
";td.getname() = " + td.getname() +
";baserl.tostring() = " + baserl.tostring() +
";cd.getcolumnname() = " + cd.getcolumnname() +
";indexcolumn.tostring() = " + indexcolumn.tostring() +
";basecolumn.tostring() = " + basecolumn.tostring() +
";indexrow.tostring() = " + indexrow.tostring());
*/
throw standardexception newexception
sqlstate lang_index_column_not_equal
indexcd getconglomeratename
td getschemaname
td getname
baserl tostring
cd getcolumnname
indexcolumn tostring
basecolumn tostring
indexrow tostring
/* clean up after the index scan */
scan close
scan   null
/*
** the index is supposed to have the same number of rows as the
** base conglomerate.
*/
if  indexrows    baserowcount
throw standardexception newexception sqlstate lang_index_row_count_mismatch
indexcd getconglomeratename
td getschemaname
td getname
long tostring indexrows
long tostring baserowcount
/* check that all constraints have backing index */
constraintdescriptorlist constraintdesclist
dd getconstraintdescriptors td
for  int index   0  index < constraintdesclist size    index
constraintdesc   constraintdesclist elementat index
if  constraintdesc hasbackingindex
conglomeratedescriptor conglomdesc
conglomdesc   td getconglomeratedescriptor
constraintdesc getconglomerateid
if  conglomdesc    null
throw standardexception newexception
sqlstate lang_object_not_found
constraintdesc getconstraintname
catch  standardexception se
throw publicapi wrapstandardexception se
finally
try
/* clean up before we leave */
if  basecc    null
basecc close
basecc   null
if  indexcc    null
indexcc close
indexcc   null
if  scan    null
scan close
scan   null
catch  standardexception se
throw publicapi wrapstandardexception se
return true