/*
derby - class org.apache.derby.impl.services.locks.singlepool
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl services locks
import org apache derby iapi services monitor monitor
import org apache derby iapi services locks lockfactory
import org apache derby iapi services locks c_lockfactory
import org apache derby iapi services locks lockable
import org apache derby iapi services locks latch
import org apache derby iapi services locks limit
import org apache derby iapi error standardexception
import org apache derby iapi services property propertyutil
import org apache derby iapi services daemon serviceable
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi util matchable
import org apache derby iapi reference property
import java util hashtable
import java util properties
import java io serializable
import java util dictionary
import java util enumeration
// debugging
import org apache derby iapi services stream headerprintwriter
/**
an implementation of lockfactory that uses a single pool
for the locks, i.e. all lock requests go through a single
point of synchronisation.
<p>
the default concrete class "singlepool.java", prints nothing and thus
incurs no overhead associated with the code to dump lock information.  an
alternate concrete class "lockdebug/tracingsinglepool.java", attempts to
output only lock information that "makes sense" to a user - for instance it
doesn't print latch locks.
<br>
mt - mutable - container object : thread aware
*/
public class singlepool extends hashtable
implements  lockfactory
/**
the complete set of locks in the system
<br>
mt - immutable - content dynamic : lockset is threadsafe
*/
protected final lockset			locktable
/**
this is now in this object, it now extends hashtable.
a hash table of all compatability spaces. key is the object
representing the compatability space, value is a lockspace object.
addition and removal from the hashtable is performed under the
hashtable's monitor. this requires holding this monitor while making
calls to the thread safe methods of lockspace. this is to ensure
that it is guaranteed that a lockspace is only removed when it is
empty and no-one is in the process of adding to it. no deadlocks are
possible because the spaces reference is not visible outside this
class and the lockspace class does not call back into this class.
<br>
mt - immutable - content dynamic : java synchronized(spaces)
this class creates a lockset and lockspaces, both classes are thread
safe.
*/
/**
true if all deadlocks errors should be logged.
*/
int deadlockmonitor
public singlepool
locktable   new lockset this
/*
** methods of lockfactory
*/
/**
latch a specific object with a timeout.
<br>
mt - thread safe
@exception standardexception standard cloudscape error policy
@see lockfactory#latchobject
*/
public boolean latchobject object compatabilityspace  lockable ref  object qualifier  int timeout
throws standardexception
lock latch   locktable lockobject compatabilityspace  ref  qualifier  timeout   latch  null
if  sanitymanager debug
if  latch    null
sanitymanager assert timeout    c_lockfactory no_wait
return latch    null
/**
unlatch an  object.
<br>
mt - thread safe
@see lockfactory#unlatch
*/
public void unlatch latch heldlatch
locktable unlock heldlatch  1
/**
lock a specific object with a timeout.
<br>
mt - thread safe
@exception standardexception standard cloudscape error policy
@see lockfactory#lockobject
*/
protected lock lockanobject object compatabilityspace  object group  lockable ref  object qualifier  int timeout  latch heldlatch
throws standardexception
if  sanitymanager debug
if  sanitymanager debug_on constants lock_trace
d_lockcontrol debuglock
compatabilityspace  group  ref  qualifier  timeout
if  sanitymanager debug_on constants lock_stack_trace
// the following will print the stack trace of the lock
// request to the log.
throwable t   new throwable
java io printwriter istream   sanitymanager get_debug_stream
istream println
t printstacktrace istream
lock lock
locktable lockobject compatabilityspace  ref  qualifier  timeout  heldlatch
// see if no_wait was passed in and the lock could not be granted.
if  lock    null
if  sanitymanager debug
sanitymanager assert timeout    c_lockfactory no_wait
return null
if  sanitymanager debug
if  sanitymanager debug_on constants lock_trace
d_lockcontrol debuglock
compatabilityspace  group  ref  qualifier  timeout
// find the space and atomically add lock to required group
synchronized  this
lockspace ls    lockspace  get compatabilityspace
if  ls    null
ls   new lockspace this  compatabilityspace
put compatabilityspace  ls
// we hold the spaces monitor while adding the lock to close
// the window between finding the lockspace and adding a lock
// to it, thus ensuring the lockspace is not removed from the
// spaces hashtable underneath us.
ls addlock group  lock
return lock
/**
lock a specific object
<br>
mt - thread safe
@exception standardexception standard cloudscape error policy
@see lockfactory#lockobject
*/
public boolean lockobject object compatabilityspace  object group  lockable ref  object qualifier  int timeout
throws standardexception
return lockanobject compatabilityspace  group  ref  qualifier  timeout   latch  null     null
/**
lock a specific object while holding a latch
<br>
mt - thread safe
@exception standardexception standard cloudscape error policy
@see lockfactory#lockobject
*/
public boolean lockobject object group  lockable ref  object qualifier  int timeout  latch latch
throws standardexception
if  sanitymanager debug
if  timeout    c_lockfactory no_wait
sanitymanager throwassert
lock lock   lockanobject latch getcompatabilityspace    group  ref  qualifier  timeout  latch
return lock instanceof activelock
/**
unlock a specific object
<br>
mt - thread safe
@see lockfactory#unlock
*/
public int unlock object compatabilityspace  object group  lockable ref  object qualifier
if  sanitymanager debug
if  sanitymanager debug_on constants lock_trace
d_lockcontrol debuglock
compatabilityspace  group  ref  qualifier   1
lockspace ls    lockspace  get compatabilityspace
if  ls    null
return 0
int count   ls unlockreference locktable  ref  qualifier  group
if  sanitymanager debug
sanitymanager assert
count    0      count    1       count
return count
/**
unlock a group of objects.
<br>
mt - thread safe
@param group handle of group that objects were locked with.
if group is	null then this call is equivilent to unlockall().
@see lockfactory#unlockgroup
*/
public void unlockgroup object compatabilityspace  object group
if  sanitymanager debug
if  sanitymanager debug_on constants lock_trace
d_lockcontrol debuglock    compatabilityspace  group
lockspace ls    lockspace  get compatabilityspace
if  ls    null
return
ls unlockgroup locktable  group
public void unlockgroup object compatabilityspace  object group  matchable key
if  sanitymanager debug
if  sanitymanager debug_on constants lock_trace
d_lockcontrol debuglock    compatabilityspace  group
lockspace ls    lockspace  get compatabilityspace
if  ls    null
return
ls unlockgroup locktable  group  key
/**
transfer a set of locks from one group to another.
<br>
mt - thread safe
@see lockfactory#transfer
*/
public void transfer object compatabilityspace  object oldgroup  object newgroup
if  sanitymanager debug
if  sanitymanager debug_on constants lock_trace
stringbuffer sb   new stringbuffer
d_lockcontrol debugappendobject
sb     compatabilityspace
d_lockcontrol debugappendobject sb     oldgroup
d_lockcontrol debugappendobject sb     newgroup
d_lockcontrol debugaddthreadinfo sb
sanitymanager debug constants lock_trace  sb tostring
lockspace ls    lockspace  get compatabilityspace
if  ls    null
return
// there is a window where someone could remove the lockspace from the
// spaces hashtable, since we do not hold the spaces' monitor. this is
// ok as the lockspace will have no locks and this method
// will correctly do nothing.
ls transfer oldgroup  newgroup
/**
returns true if locks by anyone are blocking anyone else
*/
public boolean anyoneblocked
return locktable anyoneblocked
/**
return true if locks are held in this group and this space.
<br>
mt - thread safe
@param group handle of group that objects were locked with.
@see lockfactory#arelocksheld
*/
public boolean arelocksheld object compatabilityspace  object group
lockspace ls    lockspace  get compatabilityspace
if  ls    null
return false
// there is a window where someone could remove the lockspace from the
// spaces hashtable, since we do not hold the spaces' monitor. this is
// ok as the lockspace will have no locks and this method will
// correctly return false.
return ls arelocksheld group
/**
return true if locks are held in this space
<br>
mt - thread safe
@see lockfactory#arelocksheld
*/
public boolean arelocksheld object compatabilityspace
lockspace ls    lockspace  get compatabilityspace
if  ls    null
return false
return  ls isempty
public boolean zerodurationlockobject object compatabilityspace  lockable ref  object qualifier  int timeout
throws standardexception
if  sanitymanager debug
if  sanitymanager debug_on constants lock_trace
d_lockcontrol debuglock
compatabilityspace   object  null  ref  qualifier  timeout
if  sanitymanager debug_on constants lock_stack_trace
// the following will print the stack trace of the lock
// request to the log.
throwable t   new throwable
java io printwriter istream   sanitymanager get_debug_stream
istream println
t printstacktrace istream
// very fast zerodurationlockobject() for unlocked objects.
// if no entry exists in the lock manager for this reference
// then it must be unlocked.
// if the object is locked then we perform a grantable
// check, skipping over any waiters.
// if the caller wants to wait and the lock cannot
// be granted then we do the slow join the queue and
// release the lock method.
synchronized  locktable
control control    control  locktable get ref
if  control    null
return true
// if we are grantable, ignoring waiting locks then
// we can also grant this request now, as skipping
// over the waiters won't block them as we release
// the lock rightway.
if  control isgrantable true  compatabilityspace  qualifier
return true
// can't be granted and are not willing to wait.
if  timeout    c_lockfactory no_wait
return false
lock lock
locktable lockobject compatabilityspace  ref  qualifier  timeout   latch  null
if  sanitymanager debug
if  sanitymanager debug_on constants lock_trace
d_lockcontrol debuglock
compatabilityspace   object  null  ref  qualifier  timeout
// and simply unlock it once
locktable unlock lock  1
return true
public boolean islockheld object compatabilityspace  object group  lockable ref  object qualifier
lockspace ls    lockspace  get compatabilityspace
if  ls    null
return false
return ls islockheld group  ref  qualifier
public synchronized void setlimit object compatabilityspace  object group  int limit  limit callback
lockspace ls    lockspace  get compatabilityspace
if  ls    null
ls   new lockspace this  compatabilityspace
put compatabilityspace  ls
ls setlimit group  limit  callback
/**
clear a limit set by setlimit.
*/
public void clearlimit object compatabilityspace  object group
lockspace ls    lockspace  get compatabilityspace
if  ls    null
return
ls clearlimit group
//exclude-start-lockdiag-
/**
routines to support lock diagnostics vtis for the benefit of virtuallocktable
*/
/* package */
public enumeration makevirtuallocktable
// make a shallow copy of the locktable.
locktablevti myclone   new locktablevti locktable shallowclone
return myclone
//exclude-end-lockdiag-
/*
** non-public methods
*/
//exclude-start-debug-
public string todebugstring
return locktable todebugstring
//exclude-end-debug-
/*
** methods of propertysetcallback
*/
public void init boolean dbonly  dictionary p
getandapply dbonly  p  property deadlock_timeout
getandapply dbonly  p  property lockwait_timeout
getandapply dbonly  p  property deadlock_monitor
//exclude-start-lockdiag-
getandapply dbonly  p  property deadlock_trace
//exclude-end-lockdiag-
private void getandapply boolean dbonly  dictionary p  string key
try
serializable value    string  propertyutil getpropertyfromset dbonly  p  key
if  value    null
validate key  value  p
apply key  value  p
catch  standardexception se
// just ignore value at bootup.
public boolean validate string key  serializable value  dictionary p
throws standardexception
if   key startswith property locks_intro
return false
if  value    null
if  key equals property deadlock_timeout
getwaitvalue  string  value   property deadlock_timeout_default
else if  key equals property lockwait_timeout
getwaitvalue  string  value   property wait_timeout_default
else if  key equals property deadlock_monitor
propertyutil booleanproperty property deadlock_monitor  value  false
else if  key equals property deadlock_trace
propertyutil booleanproperty property deadlock_trace  value  false
return true
public serviceable apply string key  serializable value  dictionary p
throws standardexception
if  value    null
// a delete, fill in the new value
value   propertyutil getpropertyfromset p  key
string svalue    string  value
if  key equals property deadlock_timeout
locktable deadlocktimeout   getwaitvalue svalue   property deadlock_timeout_default
else if  key equals property lockwait_timeout
locktable waittimeout   getwaitvalue svalue   property wait_timeout_default
else if  key equals property deadlock_monitor
deadlockmonitor   propertyutil booleanproperty property deadlock_monitor  svalue  false  ?
standardexception report_always   standardexception report_default
//exclude-start-lockdiag-
else if  key equals property deadlock_trace
locktable setdeadlocktrace propertyutil booleanproperty property deadlock_trace  svalue  false
//exclude-end-lockdiag-
return null
public serializable map string key  serializable value  dictionary p
return null
/*
** property related methods
*/
private static int getwaitvalue string value  int defaultvalue
// properties are defined in seconds
int wait   propertyutil handleint value  integer min_value  integer max_value   1000  defaultvalue
if  wait < 0
wait   c_lockfactory wait_forever
else
// convert to milliseconds
wait    1000
return wait