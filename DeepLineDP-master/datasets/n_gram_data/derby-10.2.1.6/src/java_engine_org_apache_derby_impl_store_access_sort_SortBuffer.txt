/*
derby - class org.apache.derby.impl.store.access.sort.sortbuffer
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl store access sort
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi error standardexception
import org apache derby iapi store access sortobserver
import org apache derby iapi types datavaluedescriptor
/**
this class implements an in-memory ordered set
based on the balanced binary tree algorithm from
knuth vol. 3, sec. 6.2.3, pp. 451-471.
nodes are always maintained in order,
so that inserts and deletes can be intermixed.
<p>
this algorithm will insert/delete n elements
in o(n log(n)) time using o(n) space.
**/
class sortbuffer
/**
returned from insert when the row was inserted
without incident.
**/
public static final int insert_ok   0
/**
returned from insert when the row which was
inserted was a duplicate.  the set will have
aggregated it in.
**/
public static final int insert_duplicate   1
/**
returned from insert when the row was not able to be
inserted because the set was full.
**/
public static final int insert_full   2
/**
the sort this set is associated with.
**/
private mergesort sort
/**
where to allocate nodes from.
**/
private nodeallocator allocator   null
/**
special head node for the tree.  head.rightlink is the
root of the tree.
**/
private node head   null
/**
the current height of the tree.
**/
private int height   0
/**
set, as a side effect of deleteleftmost (only), to the
key from the node that was deleted from the tree.  this
field is only valid after a call to deleteleftmost.
**/
private datavaluedescriptor deletedkey
/**
set, as a side effect of deleteleftmost and rotateright,
if the subtree they're working on decreased in height.
this field is only valid after a call to deleteleftmost
or rotateright.
**/
private boolean subtreeshrunk
/**
set by the setnextaux() method.  this value is stuffed
into the aux field of the next node that's allocated.
**/
private int nextaux
/**
read by the getlastaux() method.  this value is read out
of the last node that was deallocated from the tree.
**/
private int lastaux
/**
arrange that the next node allocated in the tree have
it's aux field set to the argument.
**/
public void setnextaux int aux
nextaux   aux
/**
retrieve the aux value from the last node deallocated
from the tree.
**/
public int getlastaux
return lastaux
/**
construct doesn't do anything, callers must call init
and check its return code.
**/
public sortbuffer mergesort sort
this sort   sort
/**
initialize.  returns false if the allocator
couldn't be initialized.
**/
public boolean init
allocator   new nodeallocator
boolean initok   false
if  sort sortbuffermin > 0
initok   allocator init sort sortbuffermin  sort sortbuffermax
else
initok   allocator init sort sortbuffermax
if  initok    false
allocator   null
return false
reset
return true
public void reset
allocator reset
head   allocator newnode
height   0
public void close
if  allocator    null
allocator close
allocator   null
height   0
head   null
/**
grow by a certain percent if we can
*/
public void grow int percent
if  percent > 0
allocator grow percent
/**
return the number of elements this sorter can sort.
it's the capacity of the node allocator minus one
because the sorter uses one node for the head.
**/
public int capacity
if  allocator    null
return 0
return allocator capacity     1
/**
insert a key k into the tree. returns true if the
key was inserted, false if the tree is full.  silently
ignores duplicate keys.
<p>
see knuth vol. 3, sec. 6.2.3, pp. 455-457 for the algorithm.
**/
public int insert datavaluedescriptor k
throws standardexception
int c
node p  q  r  s  t
if  head rightlink    null
if   sort sortobserver    null
k   sort sortobserver insertnonduplicatekey k      null
return insert_duplicate
q   allocator newnode
q key   k
q aux   nextaux
head rightlink   q
height   1
return insert_ok
// [a1. initialize]
t   head
p   s   head rightlink
// search
while  true
// [a2. compare]
c   sort compare k  p key
if  c    0
// the new key compares equal to the
// current node's key.
// see if we can use the aggregators
// to get rid of the new key.
if   sort sortobserver    null
k   sort sortobserver insertduplicatekey k  p key      null
return insert_duplicate
// keep the duplicate key...
// allocate a new node for the key.
q   allocator newnode
if  q    null
return insert_full
q aux   nextaux
// link the new node onto the current
// node's duplicate chain.  the assumption
// is made that a newly allocated node
// has null left and right links.
q key   k
q dupchain   p dupchain
p dupchain   q
// from the caller's perspective this was
// not a duplicate insertion.
return insert_ok
if  c < 0
// [a3. move left]
q   p leftlink
if  q    null
q   allocator newnode
if  q    null
return insert_full
q aux   nextaux
p leftlink   q
break
else    c > 0
// [a4. move right]
q   p rightlink
if  q    null
q   allocator newnode
if  q    null
return insert_full
q aux   nextaux
p rightlink   q
break
if  q balance    0
t   p
s   q
p   q
/*
* [a5. insert]
* node has been allocated and placed for k.
* initialize it.
*/
if   sort sortobserver    null
k   sort sortobserver insertnonduplicatekey k      null
return insert_duplicate
q key   k
/*
* [a6. adjust balance factors for nodes between
* s and q]
*/
c   sort compare k  s key
if  c < 0
r   p   s leftlink
else
r   p   s rightlink
while  p    q
if  sort compare k  p key  < 0
p balance    1
p   p leftlink
else    sort compare k  p key  > 0
p balance   1
p   p rightlink
// [a7. balancing act]
int a    c > 0 ? 1     c    0  ? 0    1
if  s balance    0
//debug("a7 (i). the tree has gotten higher");
s balance   a
height
return insert_ok
if  s balance     a
//debug("a7 (ii). the tree has gotten more balanced");
s balance   0
return insert_ok
//debug("a7 (iii). the tree has gotten more out of balance");
// s.balance == a
if  r balance    a
//debug("a8. single rotation");
p   r
s setlink a  r link  a
r setlink  a  s
s balance   0
r balance   0
else    r balance     a
//debug("a8. double rotation");
p   r link  a
r setlink  a  p link a
p setlink a  r
s setlink a  p link  a
p setlink  a  s
if  p balance    a
s balance    a
r balance   0
else if  p balance    0
s balance   0
r balance   0
else    p balance     a
s balance   0
r balance   a
p balance   0
// [a10. finishing touch]
if  s    t rightlink
t rightlink   p
else
t leftlink   p
return insert_ok
/**
return the lowest key and delete it from
the tree, preserving the balance of the tree.
**/
public datavaluedescriptor removefirst
if  head rightlink    null
return null
head rightlink   deleteleftmost head rightlink
if  this subtreeshrunk
height
return this deletedkey
/**
delete the node with the lowest key from the subtree defined
by 'thisnode', maintaining balance in the subtree.  returns
the node that should be the new root of the subtree.  this
method sets this.subtreeshrunk if the subtree of thisnode
decreased in height. saves the key that was in the deleted
node in 'deletedkey'.
**/
private node deleteleftmost node thisnode
// if this node has no left child, we've found the
// leftmost one, so delete it.
if  thisnode leftlink    null
// see if the current node has duplicates.  if so, we'll
// just return one of them and not change the tree.
if  thisnode dupchain    null
node dupnode   thisnode dupchain
//system.out.println("deleteleftmost(" + thisnode + "): found dup: " + dupnode);
// return the key from the duplicate.  note that even
// though the keys compare equal they may not be equal,
// depending on how the column ordering was specified.
this deletedkey   dupnode key
lastaux   dupnode aux
// unlink the dup node and free it.
thisnode dupchain   dupnode dupchain
allocator freenode dupnode
dupnode   null
// tree is not changing height since we're just removing
// a node from the duplicate chain.
this subtreeshrunk   false
// preserve the current node as the root of this subtree..
return thisnode
else    thisnode dupchain    null
//system.out.println("deleteleftmost(" + thisnode + "): found key");
// key to return is this node's key.
this deletedkey   thisnode key
lastaux   thisnode aux
// we're removing this node, so it's subtree is shrinking
// from height 1 to height 0.
this subtreeshrunk   true
// save this node's right link which might be cleared
// out by the allocator.
node newroot   thisnode rightlink
// free the node we're deleting.
allocator freenode thisnode
// rearrange the tree to put this node's right subtree where
// this node was.
return newroot
// since this wasn't the leftmost node, delete the leftmost
// node from this node's left subtree.  this operation may
// rearrange the subtree, including the possiblility that the
// root note changed, so set the root of the left subtree to
// what the delete operation wants it to be.
thisnode leftlink   deleteleftmost thisnode leftlink
// if the left subtree didn't change size, then this subtree
// could not have changed size either.
if  this subtreeshrunk    false
return thisnode
// if the delete operation shrunk the subtree, we may have
// some rebalancing to do.
if  thisnode balance    1
// tree got more unbalanced.  need to do some
// kind of rotation to fix it.  the rotateright()
// method will set subtreeshrunk appropriately
// and return the node that should be the new
// root of this subtree.
return rotateright thisnode
if  thisnode balance     1
// tree became more balanced
thisnode balance   0
// since the left subtree was higher, and it
// shrunk, then this subtree shrunk, too.
this subtreeshrunk   true
else    thisnode balance    0
// tree became acceptably unbalanced
thisnode balance   1
// we had a balanced tree, and just the left
// subtree shrunk, so this subtree as a whole
// has not changed in height.
this subtreeshrunk   false
// we have not rearranged this subtree.
return thisnode
/**
perform either a single or double rotation, as appropriate,
to get the subtree 'thisnode' back in balance, assuming
that the right subtree of 'thisnode' is higher than the
left subtree.  returns the node that should be the new
root of the subtree.
<p>
these are the cases depicted in diagrams (1) and (2) of
knuth (p. 454), and the node names reflect these diagrams.
however, in deletion, the single rotation may encounter
a case where the "beta" and "gamma" subtrees are the same
height (b.balance == 0), so the resulting does not always
shrink.
<p>
note: this code will not do the "mirror image" cases.
it only works when the right subtree is the higher one
(this is the only case encountered when deleting leftmost
nodes from the tree).
**/
private node rotateright node thisnode
node a   thisnode
node b   thisnode rightlink
if  b balance >  0
// single rotation
a rightlink   b leftlink
b leftlink   a
if  b balance    0
a balance   1
b balance    1
this subtreeshrunk   false
else    b balance    1
a balance   0
b balance   0
this subtreeshrunk   true
return b
else    b balance     1
// double rotation
node x   b leftlink
a rightlink   x leftlink
x leftlink   a
b leftlink   x rightlink
x rightlink   b
if  x balance    1
a balance    1
b balance   0
else if  x balance     1
a balance   0
b balance   1
else    x balance    0
a balance   0
b balance   0
x balance   0
this subtreeshrunk   true
return x
public void check
if  sanitymanager debug
string error   null
if  head rightlink    null
if  height    0
error       height
else
if  depth head rightlink     height
error       height       depth head rightlink
else
error   checknode head rightlink
if  error    null
system out println     error
print
system exit 1
private string checknode node n
if  sanitymanager debug
if  n    null
return null
int ld   depth n leftlink
int rd   depth n rightlink
if  n balance     rd   ld
return     n       ld       rd
string e
e   checknode n rightlink
if  e    null
e   checknode n leftlink
return e
else
return null
private int depth node n
int ld   0
int rd   0
if  n    null
return 0
if  n leftlink    null
ld   depth n leftlink
if  n rightlink    null
rd   depth n rightlink
if  rd > ld
return rd   1
else
return ld   1
public void print
node root   head rightlink
system out println     height
root    null  ?  1   root id
if  root    null
printrecursive root  0
private void printrecursive node n  int depth
if  n rightlink    null
printrecursive n rightlink  depth   1
for  int i   0  i < depth  i
system out print
system out println n
if  n leftlink    null
printrecursive n leftlink  depth   1
private void debug string s
if  sanitymanager debug
system out println     s