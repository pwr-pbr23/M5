/*
derby - class org.apache.derby.impl.sql.execute.dmlwriteresultset
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl sql execute
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi sql execute noputresultset
import org apache derby iapi services io streamstorable
import org apache derby iapi sql execute execrow
import org apache derby iapi sql execute constantaction
import org apache derby iapi error standardexception
import org apache derby iapi sql activation
import org apache derby iapi sql conn languageconnectioncontext
import org apache derby iapi store access dynamiccompiledopenconglominfo
import org apache derby iapi store access staticcompiledopenconglominfo
import org apache derby iapi store access transactioncontroller
import org apache derby catalog uuid
import org apache derby iapi services io formatablebitset
/**
* for insert/update/delete impls.  used to tag them.
*/
abstract class dmlwriteresultset extends norowsresultsetimpl
protected writecursorconstantaction constantaction
protected int baserowreadmap
protected int streamstorableheapcolids
protected execrow	deferredsparserow
protected dynamiccompiledopenconglominfo heapdcoci
protected dynamiccompiledopenconglominfo indexdcocis
private boolean needtoobjectifystream
public int rowcount
/**
* constructor
*
* @param activation		an activation
*
* @exception standardexception on error
*/
dmlwriteresultset activation activation
throws standardexception
this activation  activation getconstantaction
dmlwriteresultset activation activation  constantaction constantaction
throws standardexception
super activation
this constantaction    writecursorconstantaction  constantaction
baserowreadmap   this constantaction getbaserowreadmap
streamstorableheapcolids   this constantaction getstreamstorableheapcolids
transactioncontroller tc   activation gettransactioncontroller
// special handling for updatable vtis
if     constantaction instanceof updatablevticonstantaction
heapdcoci   tc getdynamiccompiledconglominfo this constantaction conglomid
if  this constantaction indexcids length    0
indexdcocis   new dynamiccompiledopenconglominfo
for  int index   0  index < this constantaction indexcids length  index
indexdcocis   tc getdynamiccompiledconglominfo
this constantaction indexcids
/* we only need to objectify the streams here if they are exposed to the users through the
* trigger context.  for "before" trigger, we could just return the stream wrapped in
* rememberbytesinputstream to the user and reset it after usage, but this wouldn't work
* because the user may get the stream in trigger action and do something with it in parallel
* with the store doing insert.  we could also delay the materializing until the stream is
* fetched in before trigger but that would complicate the code.  for "after" trigger, we have
* to materialize it here because store only keeps a page's amount for each round.  for other
* reasons of "deferred" operations we don't need to objectify here.  simply going through a
* temp table (either in memory part or spilled to disk) is fine for the stream, unless a
* same stream appears in two rows in the temp table, which could happen for an "update", in
* which case we do the objectifying in updateresultset.  beetle 4896.  related bug entries:
* 2432, 3383.
*/
needtoobjectifystream    this constantaction gettriggerinfo
activation getlanguageconnectioncontext   getexecutioncontext       null
public final int	modifiedrowcount     return rowcount
/**
* get next row from the source result set.
*
* @param source		sourceresultset
* also look at track#2432/change 12433
*/
protected execrow getnextrowcore noputresultset source
throws standardexception
execrow row   source getnextrowcore
if  needtoobjectifystream
/*
see comments in the constructor. we also need to load the column
if it is part of an index on an insert but that is done in
insertresultset#normalinsertcore or irs#changedrow
*/
objectifystreams row
return row
private void objectifystreams execrow row  throws standardexception
// if the column is a streamstorable, we need to materialize the object
// therefore, the object can be used to multiple rows.
if   row    null      streamstorableheapcolids    null
for  int ix 0  ix < streamstorableheapcolids length  ix
int heapix   streamstorableheapcolids
int readix    baserowreadmap    null  ?
heapix
baserowreadmap
datavaluedescriptor col   row getcolumn readix 1
streamstorable col  loadstream
/**
* for deferred update, get a deferred sparse row based on the
* deferred non-sparse row. share the underlying columns. if there
* is no column bit map, make them the same row.
*
* @exception standardexception		thrown on error
*/
protected execrow makedeferredsparserow
execrow deferredbaserow
formatablebitset baserowreadlist
languageconnectioncontext lcc
throws standardexception
execrow deferredsparserow
if  baserowreadlist    null
/* no sparse row */
deferredsparserow   deferredbaserow
else
/*
** we need to do a fetch doing a partial row
** read.  we need to shift our 1-based bit
** set to a zero based bit set like the store
** expects.
*/
deferredsparserow
rowutil getemptyvaluerow
baserowreadlist getlength     1
lcc
/*
** getcolumn(), setcolumn(), and baserowreadlist are
** one-based.
*/
int fromposition   1
for  int i   1  i <  deferredsparserow ncolumns    i
if  baserowreadlist isset i
deferredsparserow setcolumn
i
deferredbaserow getcolumn fromposition
return deferredsparserow
/**
* get the index name given the conglomerate id of the index.
*
* @param indexcid		conglomerate id of the index.
*
* @return index name of given index.
*/
string getindexnamefromcid long indexcid
return this constantaction getindexnamefromcid indexcid