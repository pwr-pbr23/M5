/*
derby - class org.apache.derby.iapi.store.raw.xact.rawtransaction
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby iapi store raw xact
import org apache derby iapi store raw containerkey
import org apache derby iapi services locks lockfactory
import org apache derby iapi store raw data datafactory
import org apache derby iapi store raw compensation
import org apache derby iapi store raw lockingpolicy
import org apache derby iapi store raw loggable
import org apache derby iapi store raw transaction
import org apache derby iapi store raw globaltransactionid
import org apache derby iapi store raw log loginstant
import org apache derby iapi store raw data rawcontainerhandle
import org apache derby iapi error standardexception
import org apache derby iapi util bytearray
import org apache derby iapi services io dynamicbytearrayoutputstream
import org apache derby catalog uuid
import java util observable
import org apache derby iapi services io limitobjectinput
/**
rawtransaction is the form of transaction used within the raw store. this
allows the break down of rawstore functionality into (at least) three modules
(transactions, data, log) without exposing internal information on the
external interface.
<p>
the transaction will notify any observer's just before the transaction
is committed, aborted or a rollback to savepoint occurs. the argument passed
to the update() method of the observer's will be one of
<ul>
<li> rawtransaction.commit - transaction is committing
<li> rawtransaction.abort - transaction is aborting
<li> rawtransaction.savepointrollback - transaction is being rolled back to a savepoint
</ul>
the observer's must perform a value equality check (equals()) on the
update arg to see why it is being notified.
@see java.util.observer
*/
public abstract class rawtransaction extends observable implements transaction
public static final integer		commit               new integer 0
public static final integer		abort                new integer 1
public static final integer     savepoint_rollback   new integer 2
public static final integer		lock_escalate        new integer 3
protected standardexception		observerexception
/**
get the lock factory to be used during this transaction.
*/
public abstract lockfactory getlockfactory
/**
get the data factory to be used during this transaction.
*/
public abstract datafactory getdatafactory
/**
get cache statistics for the specified cache
*/
public abstract long getcachestats string cachename
/**
reset the cache statistics for the specified cache
*/
public abstract void resetcachestats string cachename
/**
get the log buffer to be used during this transaction.
*/
public abstract dynamicbytearrayoutputstream getlogbuffer
/**
log a compensation operation and then action it in the context of this
transaction.
the compensationoperation is logged in the transaction log file and
then its dome method is called to perform the required change.  this
compensation operation will rollback the change that was done by the
loggable operation at undoinstant.
@param compensation	the compensation operation
@param undoinstant	the loginstant of the loggable operation this
compensation operation is going to roll back
@param in			optional data for the rollback operation
@see compensation
@exception standardexception  standard cloudscape exception policy
*/
public abstract void logandundo compensation compensation  loginstant undoinstant
limitobjectinput in
throws standardexception
/** methods to help logging and recovery */
/**
set the transaction ids (global and internal) of this transaction
*/
public abstract void settransactionid globaltransactionid id  transactionid shortid
/**
set the transactionid (global and internal) of this transaction using a
log record that contains the global id
*/
abstract public void settransactionid loggable beginxact  transactionid shortid
/**
get the shortid of this transaction.  may return null if transactio
has no id.
*/
abstract public transactionid getid
/**
get the shortid of this transaction.  may return null if transactio
has no id.
*/
abstract public globaltransactionid getglobalid
/**
add this raw transaction on to the list of update transaction
*/
public abstract void addupdatetransaction int transactionstatus
/**
remove this raw transaction from the list of update transaction
*/
public abstract void removeupdatetransaction
/**
change the state of transaction in table to prepare.
*/
public abstract void preparetransaction
/**
set the log instant for the first log record written by this
transaction.
*/
abstract public void setfirstloginstant loginstant instant
/**
get the log instant for the first log record written by this
transaction.
*/
abstract public loginstant getfirstloginstant
/**
set the log instant for the last log record written by this transaction.
*/
abstract public void setlastloginstant loginstant instant
/**
get the log instant for the last log record written by this transaction.
if the transaction is unclear what its last log instant is,
than it may return null.
*/
abstract public loginstant getlastloginstant
/**
check to see if a logical operation is allowed by this transaction,
throws a transactionexceotion if it isn't. this implementation allows
logical operations. transactions that need to disallow logical
operations should hide this method.
@exception standardexception standard cloudscape error policy,
*/
public void checklogicaloperationok   throws standardexception
/**
return true if this transaction should be rolled back first
in recovery. this implementation returns false. transactions that
need to rollback first during recovery should hide this method.
*/
public boolean recoveryrollbackfirst
return false
/**
* during recovery re-prepare a transaction.
* <p>
* after redo() and undo(), this routine is called on all outstanding
* in-doubt (prepared) transactions.  this routine re-acquires all
* logical write locks for operations in the xact, and then modifies
* the transaction table entry to make the transaction look as if it
* had just been prepared following startup after recovery.
* <p>
*
* @exception  standardexception  standard exception policy.
**/
abstract public void reprepare
throws standardexception
/**
allow an observer to indicate an exception to the transaction that
is raised in its update() method.
*/
public void setobserverexception standardexception se
if  observerexception    null
observerexception   se
/**
start a nested top transaction. a nested top transaction behaves exactly
like a user transaction. nested top transaction allow system type work
to proceed in a separate transaction to the current user transaction
and be committed independently of the user transaction (usually before
the user transaction).
only one nested top transaction can be active in a context at any one
time.
after a commit the transaction may be re-used.
a nested top transaction conflicts on the logical locks of its "parent"
transaction.
@exception standardexception standard cloudscape error policy
*/
public abstract rawtransaction startnestedtoptransaction   throws standardexception
/**
open a container that may be dropped - use only by logging and recovery.
during recovery redo, a log record may refer to a container that has
long been dropped.  this interface is provided so a dropped container
may be opened.
if the container has been dropped and is known to be committed, then
even if we open the dropped container with forupdate true, the
container will be silently opened as read only.  logging and recovery
code always check for committed drop status.  anybody else wanting to
use this interface must keep this in mind.
@exception standardexception  standard cloudscape exception policy
*/
public abstract rawcontainerhandle opendroppedcontainer
containerkey containerid  lockingpolicy locking
throws standardexception
/**
recreate a container during redo recovery.
used during redo recovery when processing log records trying to
create a container, but no container is found in the db.
@exception standardexception  standard cloudscape exception policy
*/
public abstract void recreatecontainerforredorecovery
long segmentid  long containerid  bytearray containerinfo
throws standardexception
/**
status that needs to go into the begin transaction log record, if there
is one, to help with recovery
*/
protected abstract int statusforbeginxactlog
/**
status that needs to go into the end transaction log record, if there
is one, to help with recovery
*/
protected abstract int statusforendxactlog
/**
is the transaction in the middle of an abort.
*/
public abstract boolean inabort
/**
can this transaction handles post termination work
*/
public abstract boolean handlespostterminationwork
/**
make this transaction aware that it is being used by recovery
*/
public abstract void recoverytransaction
/**
allow my users to notigy my observers.
*/
public void notifyobservers object arg
if  countobservers      0
setchanged
super notifyobservers arg
/**
*retunrs true if the transaction is part of rollforward recovery
*/
public abstract boolean inrollforwardrecovery
/**
* redo a checkpoint during rollforward recovery
*/
public abstract void checkpointinrollforwardrecovery loginstant cinstant
long redolwm
throws standardexception
/*
* make the transaction block the online backup.
*
* @param wait if <tt>true</tt>, waits until the transaction
*             can block the backup.
* @return     <tt>true</tt> if the transaction  blocked the
*             backup.  <tt>false</tt> otherwise.
* @exception standardexception if interrupted while waiting
*            for the backup in progress to complete.
*/
public abstract boolean blockbackup boolean wait
throws standardexception
/**
* check if the transaction is blocking the backup ?
* @return <tt> true </tt> if this transaction is
*         blocking the backup, otherwise <tt> false </tt>
*/
public abstract boolean isblockingbackup