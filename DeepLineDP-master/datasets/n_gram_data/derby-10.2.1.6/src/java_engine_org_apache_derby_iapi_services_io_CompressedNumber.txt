/*
derby - class org.apache.derby.iapi.services.io.compressednumber
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby iapi services io
import org apache derby iapi services sanity sanitymanager
import java io
/**
static methods to write and read compressed forms of numbers
to dataout and datain interfaces. format written is platform
independent like the data* interfaces and must remain fixed
once a product is shipped. if a different format is required
then write a new set of methods, e.g. writeint2. the formats
defined by stored format identifiers are implicitly dependent
on these formats not changing.
*/
public abstract class compressednumber
// the maximum number of bytes written out for an int
public static final int max_int_stored_size   4
// the maximum number of bytes written out for a long
public static final int max_long_stored_size   8
// largest int stored compressed in 1 byte
public static final int max_compressed_int_one_byte    0x3f
// largest int stored compressed in 2 bytes
public static final int max_compressed_int_two_bytes   0x3fff
/**
write a compressed integer only supporting signed values.
formats are (with x representing value bits):
<pre>
1 byte - 00xxxxxx                              represents the value <= 63 (0x3f)
2 byte - 01xxxxxx xxxxxxxx                     represents the value > 63 && <= 16383 (0x3fff)
4 byte - 1xxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx   represents the value > 16383 && <= max_int
</pre>
@exception ioexception value is negative or an exception was thrown by a method on out.
*/
public static final int writeint dataoutput out  int value  throws ioexception
if  value < 0
throw new ioexception
if  value <  0x3f
out writebyte value
return 1
}
if  value <  0x3fff
out writebyte 0x40    value >>> 8
out writebyte value   0xff
return 2
}
out writebyte   value >>> 24    0x80    0xff
out writebyte  value >>> 16    0xff
out writebyte  value >>> 8    0xff
out writebyte  value    0xff
return 4
}
/**
write a compressed integer directly to an outputstream.
@exception ioexception an exception was thrown by a method on in.
*/
public static final int writeint outputstream out  int value  throws ioexception
if  value < 0
throw new ioexception
if  value <  0x3f
out write value
return 1
}
if  value <  0x3fff
out write 0x40    value >>> 8
out write value   0xff
return 2
}
out write   value >>> 24    0x80    0xff
out write  value >>> 16    0xff
out write  value >>> 8    0xff
out write  value    0xff
return 4
}
/**
read an integer previously written by writeint().
@exception ioexception an exception was thrown by a method on in.
*/
public static final int readint datainput in  throws ioexception
int value   in readunsignedbyte
if   value   ~0x3f     0
{
// length is stored in this byte, we also know that the 0x80 bit
// was not set, so no need to mask off the sign extension from
// the byte to int conversion.
// account for 1 byte stored length of field + 1 for all returns
return value
}
else if   value   0x80     0
{
// length is stored in 2 bytes.  only use low 6 bits from 1st byte.
if  sanitymanager debug
{
sanitymanager assert  value   0x40     0x40
}
// top 8 bits of 2 byte length is stored in this byte, we also
// know that the 0x80 bit was not set, so no need to mask off the
// sign extension from the 1st byte to int conversion.  need to
// mask the byte in data[offset + 1] to account for possible sign
// extension.
return   value   0x3f  << 8    in readunsignedbyte
}
else
{
// length is stored in 4 bytes.  only use low 7 bits from 1st byte.
if  sanitymanager debug
{
sanitymanager assert  value   0x80     0x80
}
// top 8 bits of 4 byte length is stored in this byte, we also
// know that the 0x80 bit was set, so need to mask off the
// sign extension from the 1st byte to int conversion.  need to
// mask the bytes from the next 3 bytes data[offset + 1,2,3] to
// account for possible sign extension.
//
return
value   0x7f         << 24
in readunsignedbyte   << 16
in readunsignedbyte   <<  8
in readunsignedbyte
}
}
/**
read an integer previously written by writeint().
@exception ioexception an exception was thrown by a method on in.
*/
public static final int readint inputstream in  throws ioexception
int value   inputstreamutil readunsignedbyte in
if   value   ~0x3f     0
{
return value
}
else if   value   0x80     0
{
return
value   0x3f  << 8    inputstreamutil readunsignedbyte in
}
else
{
return
value            0x7f               << 24
inputstreamutil readunsignedbyte in  << 16
inputstreamutil readunsignedbyte in  <<  8
inputstreamutil readunsignedbyte in
}
}
public static final int readint
byte    data
int       offset
{
int value   data
if   value   ~0x3f     0
{
// length is stored in this byte, we also know that the 0x80 bit
// was not set, so no need to mask off the sign extension from
// the byte to int conversion.
return value
}
else if   value   0x80     0
{
// length is stored in 2 bytes.  only use low 6 bits from 1st byte.
if  sanitymanager debug
{
sanitymanager assert  value   0x40     0x40
}
// top 8 bits of 2 byte length is stored in this byte, we also
// know that the 0x80 bit was not set, so no need to mask off the
// sign extension from the 1st byte to int conversion.  need to
// mask the byte in data[offset + 1] to account for possible sign
// extension.
return   value   0x3f  << 8     data   0xff
}
else
{
// length is stored in 4 bytes.  only use low 7 bits from 1st byte.
if  sanitymanager debug
{
sanitymanager assert  value   0x80     0x80
}
// top 8 bits of 4 byte length is stored in this byte, we also
// know that the 0x80 bit was set, so need to mask off the
// sign extension from the 1st byte to int conversion.  need to
// mask the bytes from the next 3 bytes data[offset + 1,2,3] to
// account for possible sign extension.
//
return
value            0x7f  << 24
data   0xff  << 16
data   0xff  <<  8
data     0xff
}
}
/**
* return the compressed int value + stored size of the length + 1
* <p>
* given offset in array to beginning of compressed int, return the
* value of the compressed int + the number of bytes used to store the
* length.
* <p>
* so 1 byte lengths will return: length + 1 + 1
* so 2 byte lengths will return: length + 2 + 1
* so 4 byte lengths will return: length + 4 + 1
* <p>
* note that this routine will not work for lengths max_int - (max_int - 5).
* <p>
* this routine is currently used by the storepage code to skip fields
* as efficiently as possible.  since the page size is less than
* (max_int - 5) it is all right to use this routine.
*
* @return compressed int value + length used to store the length.
*
* @param data   byte array containing the field.
* @param offset offset to beginning of field, ie. data[offset] contains
*               1st byte of the compressed int.
**/
public static final int readintandreturnintplusoverhead
byte  data
int     offset
{
int value   data
if   value   ~0x3f     0
{
// length is stored in this byte, we also know that the 0x80 bit
// was not set, so no need to mask off the sign extension from
// the byte to int conversion.
// account for 1 byte stored length of field + 1 for all returns
return value   2
}
else if   value   0x80     0
{
// length is stored in 2 bytes.  only use low 6 bits from 1st byte.
if  sanitymanager debug
{
sanitymanager assert  value   0x40     0x40
}
// top 8 bits of 2 byte length is stored in this byte, we also
// know that the 0x80 bit was not set, so no need to mask off the
// sign extension from the 1st byte to int conversion.  need to
// mask the byte in data[offset + 1] to account for possible sign
// extension.
// add 3 to account for 2 byte length + 1 added to all returns
return    value   0x3f  << 8     data   0xff     3
}
else
{
// length is stored in 4 bytes.  only use low 7 bits from 1st byte.
if  sanitymanager debug
{
sanitymanager assert  value   0x80     0x80
}
// top 8 bits of 4 byte length is stored in this byte, we also
// know that the 0x80 bit was set, so need to mask off the
// sign extension from the 1st byte to int conversion.  need to
// mask the bytes from the next 3 bytes data[offset + 1,2,3] to
// account for possible sign extension.
// add 5 to account for 4 byte length + 1 added to all returns
return
value              0x7f  << 24
data   0xff  << 16
data   0xff  <<  8
data   0xff     5
}
}
/**
skip an integer previously written by writeint().
@exception ioexception an exception was thrown by a method on in.
*/
public static final int skipint datainput in  throws ioexception
int value   in readunsignedbyte
if   value   0x80     0x80
in skipbytes 3
return 4
}
if   value   0x40     0x40
in skipbytes 1
return 2
}
return 1
}
/**
skip an integer previously written by writeint().
@exception ioexception an exception was thrown by a method on in.
*/
public static final int skipint inputstream in  throws ioexception
int value   inputstreamutil readunsignedbyte in
int skipbytes   0
if   value   0x80     0x80
skipbytes   3
}
else if   value   0x40     0x40
skipbytes   1
}
if  skipbytes    0
if  in skip skipbytes     skipbytes
throw new eofexception
}
return skipbytes   1
}
/**
return the number of bytes that would be written by a writeint call
*/
public static final int sizeint int value
if  value <  0x3f
return 1
}
if  value <  0x3fff
return 2
}
return 4
}
/**
write a compressed long only supporting signed values.
formats are (with x representing value bits):
<pre>
2 byte - 00xxxxxx xxxxxxxx                     represents the value <= 16383 (0x3fff)
4 byte - 01xxxxxx xxxxxxxx xxxxxxxx xxxxxxxx   represents the value > 16383  && <= 0x3fffffff
8 byte - 1xxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx   represents the value > 0x3fffffff && <= max_long
</pre>
@exception ioexception value is negative or an exception was thrown by a method on out.
*/
public static final int writelong dataoutput out  long value  throws ioexception
if  value < 0
throw new ioexception
if  value <  0x3fff
out writebyte  int    value >>> 8    0xff
out writebyte  int    value          0xff
return 2
}
if  value <  0x3fffffff
out writebyte  int     value >>> 24    0x40    0xff
out writebyte  int     value >>> 16    0xff
out writebyte  int     value >>>  8    0xff
out writebyte  int     value           0xff
return 4
}
out writebyte  int     value >>> 56    0x80    0xff
out writebyte  int     value >>> 48    0xff
out writebyte  int     value >>> 40    0xff
out writebyte  int     value >>> 32    0xff
out writebyte  int     value >>> 24    0xff
out writebyte  int     value >>> 16    0xff
out writebyte  int     value >>>  8    0xff
out writebyte  int     value           0xff
return 8
}
/**
write a compressed integer only supporting signed values.
@exception ioexception value is negative or an exception was thrown by a method on out.
*/
public static final int writelong outputstream out  long value  throws ioexception
if  value < 0
throw new ioexception
if  value <  0x3fff
out write  int    value >>> 8    0xff
out write  int    value          0xff
return 2
}
if  value <  0x3fffffff
out write  int     value >>> 24    0x40    0xff
out write  int     value >>> 16    0xff
out write  int     value >>>  8    0xff
out write  int     value           0xff
return 4
}
out write  int     value >>> 56    0x80    0xff
out write  int     value >>> 48    0xff
out write  int     value >>> 40    0xff
out write  int     value >>> 32    0xff
out write  int     value >>> 24    0xff
out write  int     value >>> 16    0xff
out write  int     value >>>  8    0xff
out write  int     value           0xff
return 8
}
/**
read a long previously written by writelong().
@exception ioexception an exception was thrown by a method on in.
*/
public static final long readlong datainput in  throws ioexception
int int_value   in readunsignedbyte
if   int_value   ~0x3f     0
{
// test for small case first - assuming this is usual case.
// this is stored in 2 bytes.
return  int_value << 8    in readunsignedbyte
}
else if   int_value   0x80     0
{
// value is stored in 4 bytes.  only use low 6 bits from 1st byte.
return
int_value   0x3f       << 24
in readunsignedbyte     << 16
in readunsignedbyte     <<  8
in readunsignedbyte
}
else
{
// value is stored in 8 bytes.  only use low 7 bits from 1st byte.
return
long   int_value   0x7f      << 56
long  in readunsignedbyte    << 48
long  in readunsignedbyte    << 40
long  in readunsignedbyte    << 32
long  in readunsignedbyte    << 24
long  in readunsignedbyte    << 16
long  in readunsignedbyte    <<  8
long  in readunsignedbyte
}
}
/**
read a long previously written by writelong().
@exception ioexception an exception was thrown by a method on in.
*/
public static final long readlong inputstream in  throws ioexception
int int_value   inputstreamutil readunsignedbyte in
if   int_value   ~0x3f     0
{
// test for small case first - assuming this is usual case.
// this is stored in 2 bytes.
return  int_value << 8    inputstreamutil readunsignedbyte in
}
else if   int_value   0x80     0
{
// value is stored in 4 bytes.  only use low 6 bits from 1st byte.
return
int_value        0x3f               << 24
inputstreamutil readunsignedbyte in  << 16
inputstreamutil readunsignedbyte in  <<  8
inputstreamutil readunsignedbyte in
}
else
{
// value is stored in 8 bytes.  only use low 7 bits from 1st byte.
long value   int_value
return
long   value   0x7f                         << 56
long  inputstreamutil readunsignedbyte in   << 48
long  inputstreamutil readunsignedbyte in   << 40
long  inputstreamutil readunsignedbyte in   << 32
long  inputstreamutil readunsignedbyte in   << 24
long  inputstreamutil readunsignedbyte in   << 16
long  inputstreamutil readunsignedbyte in   <<  8
long  inputstreamutil readunsignedbyte in
}
}
public static final long readlong
byte  data
int     offset
{
int int_value   data
if   int_value   ~0x3f     0
{
// test for small case first - assuming this is usual case.
// this is stored in 2 bytes.
return  int_value << 8     data   0xff
}
else if   int_value   0x80     0
{
// value is stored in 4 bytes.  only use low 6 bits from 1st byte.
return
int_value        0x3f  << 24
data   0xff  << 16
data   0xff  <<  8
data     0xff
}
else
{
// value is stored in 8 bytes.  only use low 6 bits from 1st byte.
return
long   int_value        0x7f   << 56
long   data   0xff   << 48
long   data   0xff   << 40
long   data   0xff   << 32
long   data   0xff   << 24
long   data   0xff   << 16
long   data   0xff   <<  8
long   data     0xff
}
}
/**
skip a long previously written by writelong().
@exception ioexception an exception was thrown by a method on in.
*/
public static final int skiplong datainput in  throws ioexception
long value   in readunsignedbyte
if   value   0x80     0x80
{
in skipbytes 7
return 8
}
if   value   0x40     0x40
{
in skipbytes 3
return 4
}
in skipbytes 1
return 2
}
/**
skip a long previously written by writelong().
@exception ioexception an exception was thrown by a method on in.
*/
public static final int skiplong inputstream in  throws ioexception
int value   inputstreamutil readunsignedbyte in
int skipbytes
if   value   0x80     0x80
skipbytes   7
}
else if   value   0x40     0x40
skipbytes   3
}
else
skipbytes   1
if  in skip skipbytes     skipbytes
throw new eofexception
return skipbytes   1
}
public static final int sizelong long value
if  value <  0x3fff
return 2
}
if  value <  0x3fffffff
return 4
}
return 8
}
// /* for testing
// *****************************************************
private static byte[] holder = new byte[8];
private static  arrayoutputstream aos = new arrayoutputstream(holder);
private static  dataoutput out = new dataoutputstream(aos);
private static  arrayinputstream ais = new arrayinputstream(holder);
private static  datainput in = new datainputstream(ais);
private static  inputstream in_stream = ais;
private static short checkint(int i, short oldlength) throws ioexception {
aos.setposition(0);
int length = compressednumber.writeint(out, i);
if (length != oldlength) {
system.out.println("changing length to " + length + " at value " + i + " 0x" + integer.tohexstring(i));
oldlength = (short) length;
}
int writtenbytes = aos.getposition();
if (writtenbytes != length) {
system.out.println("mismatch written bytes  expected " + length + " got " + writtenbytes);
system.exit(1);
}
if (length != compressednumber.sizeint(i)) {
system.out.println("mismatch sizeint() bytes  expected " + length + " got " + compressednumber.sizeint(i));
system.exit(1);
}
ais.setposition(0);
int value = compressednumber.readint(in);
if (value != i) {
system.out.println("mismatch value readint(datainput) expected " + i + " got " + value);
system.exit(1);
}
ais.setposition(0);
value = ais.readcompressedint();
if (value != i) {
system.out.println("mismatch value readint(datainput) expected " + i + " got " + value);
system.exit(1);
}
ais.setposition(0);
value = compressednumber.readint(in_stream);
if (value != i) {
system.out.println("mismatch value in readint(inputstream) expected " + i + " got " + value);
system.exit(1);
}
value = compressednumber.readint(holder, 0);
if (value != i) {
system.out.println(
"mismatch frome readint(byte[], offset) value expected " +
i + " got " + value);
system.exit(1);
}
ais.setposition(0);
int skiplength = compressednumber.skipint(in);
if (skiplength != length) {
system.out.println("mismatch skip length expected " + length + " got " + skiplength);
system.exit(1);
}
int value_plus_int_length = readintandreturnintplusoverhead(holder, 0);
if (value_plus_int_length != (length + i + 1)) {
system.out.println("mismatch readintandreturnintplusoverhead() return expected " + (length + i) + " got " + value_plus_int_length);
system.exit(1);
}
int skipposition = ais.getposition();
if (skipposition != length) {
system.out.println("mismatch skip position expected " + length + " got " + skipposition);
system.exit(1);
}
return oldlength;
}
private static short checklong(long i, short oldlength) throws ioexception {
aos.setposition(0);
int length = compressednumber.writelong(out, i);
if (length != oldlength) {
system.out.println("changing length to " + length + " at value " + i + " 0x" + long.tohexstring(i));
oldlength = (short) length;
}
int writtenbytes = aos.getposition();
if (writtenbytes != length) {
system.out.println("mismatch written bytes  expected " + length + " got " + writtenbytes);
system.exit(1);
}
if (length != compressednumber.sizelong(i)) {
system.out.println("mismatch sizelong() bytes  expected " + length + " got " + compressednumber.sizelong(i));
system.exit(1);
}
long value = compressednumber.readlong(holder, 0);
if (value != i) {
for (int j = 0; j < 8; j++) {
system.out.println(integer.tohexstring((int) holder[j]));
}
system.out.println(
"mismatch in readlong(byte[], offset) value expected " +
long.tohexstring(i) + " got " + value);
system.exit(1);
}
ais.setposition(0);
value = compressednumber.readlong(in_stream);
if (value != i) {
for (int j = 0; j < 8; j++) {
system.out.println(integer.tohexstring((int) holder[j]));
}
system.out.println("mismatch value in readlong(inputstream) expected " + long.tohexstring(i) + " got " + value);
system.exit(1);
}
ais.setposition(0);
value = ais.readcompressedlong();
if (value != i) {
for (int j = 0; j < 8; j++) {
system.out.println(integer.tohexstring((int) holder[j]));
}
system.out.println("mismatch value in readlong(inputstream) expected " + long.tohexstring(i) + " got " + value);
system.exit(1);
}
ais.setposition(0);
value = compressednumber.readlong(in);
if (value != i) {
for (int j = 0; j < 8; j++) {
system.out.println(integer.tohexstring((int) holder[j]));
}
system.out.println("mismatch value in readlong(datainput) expected " + long.tohexstring(i) + " got " + value);
system.exit(1);
}
ais.setposition(0);
int skiplength = compressednumber.skiplong(in);
if (skiplength != length) {
system.out.println("mismatch skip length expected " + length + " got " + skiplength);
system.exit(1);
}
int skipposition = ais.getposition();
if (skipposition != length) {
system.out.println("mismatch skip position expected " + length + " got " + skipposition);
system.exit(1);
}
return oldlength;
}
public static void main(string[] args) throws ioexception {
short oldlength = -1;
system.out.println("** testing int");
oldlength = checkint(0, oldlength);
oldlength = checkint(1, oldlength);
oldlength = checkint(2, oldlength);
oldlength = checkint(0x3f - 4, oldlength);
oldlength = checkint(0x3f - 3, oldlength);
oldlength = checkint(0x3f - 2, oldlength);
oldlength = checkint(0x3f - 1, oldlength);
oldlength = checkint(0x3f    , oldlength);
oldlength = checkint(0x3f + 1, oldlength);
oldlength = checkint(0x3f + 2, oldlength);
oldlength = checkint(0x3f + 3, oldlength);
oldlength = checkint(0x3f + 4, oldlength);
oldlength = checkint(0x3f80 - 4, oldlength);
oldlength = checkint(0x3f80 - 3, oldlength);
oldlength = checkint(0x3f80 - 2, oldlength);
oldlength = checkint(0x3f80 - 1, oldlength);
oldlength = checkint(0x3f80    , oldlength);
oldlength = checkint(0x3f80 + 1, oldlength);
oldlength = checkint(0x3f80 + 2, oldlength);
oldlength = checkint(0x3f80 + 3, oldlength);
oldlength = checkint(0x3f80 + 4, oldlength);
oldlength = checkint(0x3fff - 4, oldlength);
oldlength = checkint(0x3fff - 3, oldlength);
oldlength = checkint(0x3fff - 2, oldlength);
oldlength = checkint(0x3fff - 1, oldlength);
oldlength = checkint(0x3fff    , oldlength);
oldlength = checkint(0x3fff + 1, oldlength);
oldlength = checkint(0x3fff + 2, oldlength);
oldlength = checkint(0x3fff + 3, oldlength);
oldlength = checkint(0x3fff + 4, oldlength);
oldlength = checkint(integer.max_value - 4, oldlength);
oldlength = checkint(integer.max_value - 3, oldlength);
oldlength = checkint(integer.max_value - 2, oldlength);
oldlength = checkint(integer.max_value - 1, oldlength);
oldlength = checkint(integer.max_value    , oldlength);
oldlength = -1;
for (int i = 0; i < 0xf0000; i++)
{
oldlength = checkint(i, oldlength);
}
// takes 30 minutes to run.
//
// for (int i = 0; i < integer.max_value; i++)
// {
// if (i % 0x00800000 == 0)
// system.out.println("checking: " + i);
//
// oldlength = checkint(i, oldlength);
// }
system.out.println("** testing long");
oldlength = -1;
for (int i = 0; i < 0xf0000; i++)
{
oldlength = checklong(i, oldlength);
}
oldlength = -1;
oldlength = checklong(0, oldlength);
oldlength = checklong(1, oldlength);
oldlength = checklong(2, oldlength);
oldlength = checklong(0x3fff - 2, oldlength);
oldlength = checklong(0x3fff - 1, oldlength);
oldlength = checklong(0x3fff    , oldlength);
oldlength = checklong(0x3fff + 1, oldlength);
oldlength = checklong(0x3fff + 2, oldlength);
oldlength = checklong(0x3fffffff - 4, oldlength);
oldlength = checklong(0x3fffffff - 3, oldlength);
oldlength = checklong(0x3fffffff - 2, oldlength);
oldlength = checklong(0x3fffffff - 1, oldlength);
oldlength = checklong(0x3fffffff    , oldlength);
oldlength = checklong(0x3fffffff + 1, oldlength);
oldlength = checklong(0x3fffffff + 2, oldlength);
oldlength = checklong(0x3fffffff + 3, oldlength);
oldlength = checklong(0x3fffffff + 4, oldlength);
oldlength = checklong(0x70000000 - 2, oldlength);
oldlength = checklong(0x70000000 - 1, oldlength);
oldlength = checklong(0x70000000    , oldlength);
oldlength = checklong(0x70000000 + 1, oldlength);
oldlength = checklong(0x70000000 + 2, oldlength);
oldlength = checklong(long.max_value - 2, oldlength);
oldlength = checklong(long.max_value - 1, oldlength);
oldlength = checklong(long.max_value    , oldlength);
}
// ********************************************************/
}