/*
derby - class org.apache.derby.impl.store.access.btree.index.b2i
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl store access btree index
import java io objectoutput
import java io objectinput
import java io ioexception
import java util properties
import org apache derby iapi reference sqlstate
import org apache derby iapi services io arrayinputstream
import org apache derby iapi services io formatablebitset
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi error standardexception
import org apache derby iapi store access conglomerate conglomerate
import org apache derby iapi store access conglomerate logicalundo
import org apache derby iapi store access conglomerate scanmanager
import org apache derby iapi store access conglomerate transactionmanager
import org apache derby iapi store access conglomeratecontroller
import org apache derby iapi store access dynamiccompiledopenconglominfo
import org apache derby iapi store access qualifier
import org apache derby iapi types rowlocation
import org apache derby iapi store access rowlocationretrowsource
import org apache derby iapi store access scancontroller
import org apache derby iapi store access staticcompiledopenconglominfo
import org apache derby iapi store access storecostcontroller
import org apache derby iapi store access transactioncontroller
import org apache derby iapi store access columnordering
import org apache derby iapi services io formatidutil
import org apache derby iapi services io storedformatids
import org apache derby iapi store raw containerhandle
import org apache derby iapi store raw lockingpolicy
import org apache derby iapi store raw page
import org apache derby iapi store raw recordhandle
import org apache derby iapi store raw transaction
import org apache derby iapi types datavaluedescriptor
import org apache derby impl store access btree btree
import org apache derby impl store access btree btreelockingpolicy
import org apache derby impl store access btree leafcontrolrow
import org apache derby impl store access btree controlrow
import org apache derby impl store access btree openbtree
import org apache derby impl store access btree waiterror
import org apache derby impl store access conglomerate conglomerateutil
import org apache derby iapi services io formatablebitset
import org apache derby iapi services cache classsize
/*
* @format_id access_b2i_v1_id
*
* @purpose   the tag that describes the on disk representation of the b2i
*            conglomerate object.  the b2i conglomerate object is stored in
*            a field of a row in the conglomerate directory.
*
* @upgrade   this format was made obsolete in the kimono release.
*
* @disk_layout
*     containerid(long)
*     segmentid(int)
*     number_of_key_fields(int)
*     number_of_unique_columns(int)
*     allow_duplicates(boolean)
*     maintain_parent_links(boolean)
*     format_of_this_conlgomerate(byte[])
*     array_of_format_ids(byte[][])
*     baseconglomerateid(long)
*     rowlocationcolumn(int)
*/
/*
* @format_id access_b2i_v2_id
*
* @purpose   the tag that describes the on disk representation of the b2i
*            conglomerate object.  the b2i conglomerate object is stored in
*            a field of a row in the conglomerate directory.
*
* @upgrade   the format id of this object is currently always read from disk
*            as a separate column in the conglomerate directory.  to read
*            a conglomerate object from disk and upgrade it to the current
*            version do the following:
*
*                format_id = get format id from a separate column
*                upgradable conglom_obj = instantiate empty obj(format_id)
*                read in conglom_obj from disk
*                conglom = conglom_obj.upgradetocurrent();
*
* @disk_layout
*     format_of_this_conlgomerate(byte[])
*     containerid(long)
*     segmentid(int)
*     number_of_key_fields(int)
*     number_of_unique_columns(int)
*     allow_duplicates(boolean)
*     maintain_parent_links(boolean)
*     array_of_format_ids(byte[][])
*     baseconglomerateid(long)
*     rowlocationcolumn(int)
*/
/**
* implements an instance of a b-tree secondary index conglomerate.
* a b2i object has two roles.
* <ol>
* <li>
* the b2i object is stored on disk, and holds the store specific
* information needed to access/describe the conglomerate. this
* includes information such as the format ids of the columns,
* the conglomerate id of the base table, the location of
* row location column.
* </li>
* <li>
* access to all the interfaces start by making a call off the
* conglomerate interface. so for instance to get a scan on the
* conglomerate method {@link #openscan openscan} should be called.
* </li>
* </ol>
*/
public class b2i extends btree
public    static final string property_baseconglomid
public    static final string property_rowloccolumn
public static final int format_number   storedformatids access_b2i_v3_id
/*
** fields of b2i.
*/
/**
the id of the conglomerate which contains the base table.
row locations inserted into this secondary index are assumed
to refer to that conglomerate.  used to obtain table/row locks on the
base table rows which the index rows point at.
**/
protected long baseconglomerateid
/**
the column id (zero-based integer index) of the column which holds the row
location to the base conglomerate.
the default value of rowlocationcolumn is the last key column.
used to obtain table/row locks on the base table rows with the index rows
point at.
currently, rowlocationcolumn must be the last key column.
**/
protected int rowlocationcolumn
private static final int base_memory_usage   classsize estimatebasefromcatalog  b2i class
public int estimatememoryusage
return base_memory_usage
/**************************************************************************
* constructors for this class:
**************************************************************************
*/
/**************************************************************************
* protected locking implmentations of abtract btree routines:
*     getbtreelockingpolicy
*     locktable
**************************************************************************
*/
/**
* create a new btree locking policy from scratch.
*
* @exception  standardexception  standard exception policy.
**/
protected btreelockingpolicy getbtreelockingpolicy
transaction             rawtran
int                     lock_level
int                     mode
int                     isolation_level
conglomeratecontroller  base_cc
openbtree               open_btree
throws standardexception
btreelockingpolicy ret_locking_policy   null
if  sanitymanager debug
sanitymanager assert
isolation_level
transactioncontroller isolation_serializable
isolation_level
transactioncontroller isolation_repeatable_read
isolation_level
transactioncontroller isolation_read_committed_noholdlock
isolation_level
transactioncontroller isolation_read_committed
isolation_level
transactioncontroller isolation_read_uncommitted
isolation_level
if  lock_level    transactioncontroller mode_table
ret_locking_policy
new b2itablelocking3
rawtran
lock_level
rawtran newlockingpolicy
lockingpolicy mode_container
isolation_level
true
base_cc
open_btree
else if  lock_level    transactioncontroller mode_record
if  isolation_level    transactioncontroller isolation_serializable
ret_locking_policy
new b2irowlocking3
rawtran
lock_level
rawtran newlockingpolicy
lockingpolicy mode_record
isolation_level
true
base_cc
open_btree
else if   isolation_level
transactioncontroller isolation_repeatable_read
ret_locking_policy
new b2irowlockingrr
rawtran
lock_level
rawtran newlockingpolicy
lockingpolicy mode_record
isolation_level
true
base_cc
open_btree
else if   isolation_level
transactioncontroller isolation_read_committed
isolation_level
transactioncontroller isolation_read_committed_noholdlock
ret_locking_policy
new b2irowlocking2
rawtran
lock_level
rawtran newlockingpolicy
lockingpolicy mode_record
isolation_level
true
base_cc
open_btree
else if  isolation_level
transactioncontroller isolation_read_uncommitted
ret_locking_policy
new b2irowlocking1
rawtran
lock_level
rawtran newlockingpolicy
lockingpolicy mode_record
isolation_level
true
base_cc
open_btree
if  sanitymanager debug
sanitymanager assert
ret_locking_policy    null
return ret_locking_policy
/**
* lock the base table.
* <p>
* assumes that segment of the base container is the same as the segment
* of the btree segment.
* <p>
* resolve - we really want to get the lock without opening the container.
* raw store will be providing this.
*
* @param xact_manager transaction to associate the lock with.
*
* @exception  standardexception  standard exception policy.
**/
public final conglomeratecontroller locktable
transactionmanager  xact_manager
int                 open_mode
int                 lock_level
int                 isolation_level
throws standardexception
open_mode    transactioncontroller openmode_for_lock_only
// open the base conglomerate - just to get the table lock.
conglomeratecontroller cc
xact_manager openconglomerate
this baseconglomerateid  false  open_mode  lock_level
isolation_level
return cc
/**************************************************************************
*  private methods of b2i, arranged alphabetically.
**************************************************************************
*/
private void traverseright
// resolve - do i have to do this???????????????
if  sanitymanager debug
sanitymanager throwassert
/*
** methods of b2i.
*/
/**
create an empty secondary index b-tree, using the generic b-tree to do the
generic part of the creation process.
this routine opens the newly created container, adds a single page, and
makes this page the root by inserting a leafcontrolrow onto this page
at slot 0 and marking in that control row that the page is a root page.
the following properties are specific to the b-tree secondary index:
<ul>
<li> "baseconglomerateid" (integer).  the conglomerate id of the base
conglomerate is never actually accessed by the b-tree secondary
index implementation, it only serves as a namespace for row locks.
this property is required.
<li> "rowlocationcolumn" (integer).  the zero-based index into the row which
the b-tree secondary index will assume holds a @see rowlocation of
the base row in the base conglomerate.  this value will be used
for acquiring locks.  in this implementation rowlocationcolumn must be
the last key column.
this property is required.
</ul>
a secondary index i (a, b) on table t (a, b, c) would have rows
which looked like (a, b, row_location).  baseconglomerateid is set to the
conglomerate id of t.  rowlocationcolumns is set to 2.  allowsduplicates
would be set to false, @see btree#create.  to create a unique
secondary index set uniquenesscolumns to 2, this means that the btree
code will compare the key values but not the row id when determing
uniqueness.  to create a nonunique secondary index set uniquenesscolumns
to 3, this would mean that the uniqueness test would include the row
location and since all row locations will be unique  all rows inserted
into the index will be differentiated (at least) by row location.
@see btree#create
@exception standardexception standard exception policy.
**/
public void create
transactionmanager      xact_manager
int                     segmentid
long                    input_conglomid
datavaluedescriptor	template
columnordering	    columnorder
properties              properties
int                     temporaryflag
throws standardexception
string      property_value   null
transaction rawtran          xact_manager getrawstorexact
if  properties    null
throw standardexception newexception
sqlstate btree_property_not_found  property_baseconglomid
// get baseconglomerateid //
property_value   properties getproperty property_baseconglomid
if  property_value    null
throw standardexception newexception
sqlstate btree_property_not_found  property_baseconglomid
if  sanitymanager debug
if  property_value    null
sanitymanager throwassert
property_baseconglomid
baseconglomerateid   long parselong property_value
// get rowlocationcolumn //
property_value   properties getproperty property_rowloccolumn
if  sanitymanager debug
if  property_value    null
sanitymanager throwassert
property_rowloccolumn
if  property_value    null
throw standardexception newexception
sqlstate btree_property_not_found  property_baseconglomid
rowlocationcolumn   integer parseint property_value
// currently the row location column must be the last column (makes)
// comparing the columns in the index easier.
if  sanitymanager debug
sanitymanager assert rowlocationcolumn    template length   1
sanitymanager assert
template instanceof
rowlocation
// there must be at least one key column
if  rowlocationcolumn < 1
sanitymanager throwassert
rowlocationcolumn
/* covert the sorting order information into a boolean array map.
* if the sorting order for the columns is not provided, we
* assign the default as ascending order.
* array length is equla to template length , because column order
* length changes wther it is unique is non unique. store assumes
* template length arrays. so , we make  template length array and make
* the last column as ascending instead of having lot of execeptions code.
*/
ascdescinfo   new boolean
for  int i 0   i < ascdescinfo length  i
if  columnorder    null    i < columnorder length
ascdescinfo   columnorder getisascending
else
ascdescinfo   true      default values   ascending order
// do the generic part of creating the b-tree.
super create rawtran  segmentid  input_conglomid  template  properties  gettypeformatid    temporaryflag
// open the base conglomerate - to get the lock
conglomeratecontroller base_cc
xact_manager openconglomerate
baseconglomerateid
false
transactioncontroller openmode_for_lock_only
transactioncontroller mode_table
transactioncontroller isolation_serializable
openbtree open_btree   new openbtree
btreelockingpolicy b2i_locking_policy
new b2itablelocking3
rawtran
transactioncontroller mode_table
rawtran newlockingpolicy
lockingpolicy mode_container
transactioncontroller isolation_serializable  true   base_cc  open_btree
// the following call will "open" the new btree.  create is
// an interesting case.  what we really want is read only table lock
// on the base conglomerate and update locks on the index.  for now
// just get the update lock on the base table, this is done by the
// locktable() call made by base class.
open_btree init
transactionmanager  xact_manager      current user xact
transactionmanager  xact_manager      current xact
containerhandle  null         have init open the container
rawtran
false
containerhandle mode_forupdate
transactioncontroller mode_table
b2i_locking_policy             get table level lock
this
logicalundo  null             no logical undo necessary  as
// initemptybtree()
// work will be done single user and
// rows will not move.
dynamiccompiledopenconglominfo  null
// open the newly created container, and insert the first control row.
leafcontrolrow initemptybtree open_btree
open_btree close
base_cc close
/*
** methods of conglomerate
*/
/**
* retrieve the maximum value row in an ordered conglomerate.
* <p>
* returns true and fetches the rightmost row of an ordered conglomerate
* into "fetchrow" if there is at least one row in the conglomerate.  if
* there are no rows in the conglomerate it returns false.
* <p>
* non-ordered conglomerates will not implement this interface, calls
* will generate a standardexception.
* <p>
* resolve - this interface is temporary, long term equivalent (and more)
* functionality will be provided by the openbackwardscan() interface.
*
* @param xact_manager    the transactioncontroller under which this
*                        operation takes place.
*
* @param conglomid       the identifier of the conglomerate
*                        to open the scan for.
*
* @param open_mode       specifiy flags to control opening of table.
*                        openmode_forupdate - if set open the table for
*                        update otherwise open table shared.
* @param lock_level      one of (mode_table, mode_record, or mode_none).
*
* @param isolation_level the isolation level to lock the conglomerate at.
*                        one of (isolation_read_committed or isolation_serializable).
*
* @param scancolumnlist  a description of which columns to return from
*                        every fetch in the scan.  template,
*                        and scancolumnlist work together
*                        to describe the row to be returned by the scan -
*                        see rowutil for description of how these three
*                        parameters work together to describe a "row".
*
* @param fetchrow        the row to retrieve the maximum value into.
*
* @return boolean indicating if a row was found and retrieved or not.
*
* @exception  standardexception  standard exception policy.
**/
public boolean fetchmaxonbtree
transactionmanager      xact_manager
transaction             rawtran
long                    conglomid
int                     open_mode
int                     lock_level
lockingpolicy           locking_policy
int                     isolation_level
formatablebitset                 scancolumnlist
datavaluedescriptor   fetchrow
throws standardexception
boolean row_exists
// row level locking implementation.
// resolve (revisit implementation after all the xena rowlocking
// changes have been made).  can probably come up with single
// path implementation.
// create a new b-tree secondary index scan.
b2imaxscan b2is   new b2imaxscan
// initialize it.
b2is init
xact_manager
rawtran
open_mode
lock_level
locking_policy
isolation_level
true    get locks on base table as part of open
scancolumnlist
this
new b2iundo
row_exists   b2is fetchmax fetchrow
b2is close
return row_exists
/**
bulk load a b-tree secondary index.
@see conglomerate#load
@exception standardexception standard cloudscape error policy.
raise sqlstate.store_conglomerate_duplicate_key_exception if a duplicate
key is detected in the load.
**/
public long load
transactionmanager      xact_manager
boolean                 createconglom
rowlocationretrowsource rowsource
throws standardexception
long num_rows_loaded   0
b2icontroller b2ic   new b2icontroller
try
int open_mode   transactioncontroller openmode_forupdate
if  createconglom
open_mode
containerhandle mode_unlogged
containerhandle mode_create_unlogged
// do the actual open of the container in the super class.
b2ic init
xact_manager                        current transaction
xact_manager getrawstorexact        current raw store xact
false                               not holdable
open_mode
transactioncontroller mode_table
xact_manager getrawstorexact   newlockingpolicy
lockingpolicy mode_container
transactioncontroller isolation_serializable  true
true
this
new b2iundo
b2istaticcompiledinfo  null
dynamiccompiledopenconglominfo  null
num_rows_loaded   b2ic load xact_manager  createconglom  rowsource
finally
b2ic close
return num_rows_loaded
/**
open a b-tree controller.
@see conglomerate#open
@exception standardexception standard exception policy.
**/
public conglomeratecontroller open
transactionmanager              xact_manager
transaction                     rawtran
boolean                         hold
int                             open_mode
int                             lock_level
lockingpolicy                   locking_policy
staticcompiledopenconglominfo   static_info
dynamiccompiledopenconglominfo  dynamic_info
throws standardexception
// create a new b-tree secondary index controller.
b2icontroller b2ic   new b2icontroller
// do the actual open of the container in the super class.
b2ic init
xact_manager                   current transaction
rawtran                        current raw store transaction
hold                           holdability
open_mode
lock_level
locking_policy
true
this
new b2iundo
b2istaticcompiledinfo  static_info
dynamic_info
// return it to the caller.
return b2ic
/**
open a b-tree secondary index scan controller.
@see conglomerate#openscan
@see btree#openscan
@exception standardexception standard exception policy.
**/
public scanmanager openscan
transactionmanager              xact_manager
transaction                     rawtran
boolean                         hold
int                             open_mode
int                             lock_level
lockingpolicy                   locking_policy
int                             isolation_level
formatablebitset                         scancolumnlist
datavaluedescriptor			startkeyvalue
int                             startsearchoperator
qualifier                       qualifier
datavaluedescriptor			stopkeyvalue
int                             stopsearchoperator
staticcompiledopenconglominfo   static_info
dynamiccompiledopenconglominfo  dynamic_info
throws standardexception
// create a new b-tree secondary index scan.
b2iforwardscan b2is   new b2iforwardscan
// initialize it.
b2is init xact_manager  rawtran
hold
open_mode
lock_level
locking_policy
isolation_level
true    get locks on base table as part of open
scancolumnlist
startkeyvalue  startsearchoperator
qualifier
stopkeyvalue  stopsearchoperator  this  new b2iundo
b2istaticcompiledinfo  static_info
dynamic_info
// return it to the caller.
return b2is
/**
* open a b-tree compress scan.
* <p>
* b2i does not support a compress scan.
* <p>
* @see conglomerate#defragmentconglomerate
*
* @exception  standardexception  standard exception policy.
**/
public scanmanager defragmentconglomerate
transactionmanager              xact_manager
transaction                     rawtran
boolean                         hold
int                             open_mode
int                             lock_level
lockingpolicy                   locking_policy
int                             isolation_level
throws standardexception
throw standardexception newexception
sqlstate btree_unimplemented_feature
public void purgeconglomerate
transactionmanager              xact_manager
transaction                     rawtran
throws standardexception
// currently on work to do in btree's for purge rows, purging
// happens best when split is about to happen.
return
public void compressconglomerate
transactionmanager              xact_manager
transaction                     rawtran
throws standardexception
b2icontroller b2ic   new b2icontroller
try
int open_mode   transactioncontroller openmode_forupdate
// do the actual open of the container in the super class.
b2ic init
xact_manager                        current transaction
xact_manager getrawstorexact        current raw store xact
false                               not holdable
open_mode
transactioncontroller mode_table
xact_manager getrawstorexact   newlockingpolicy
lockingpolicy mode_container
transactioncontroller isolation_serializable  true
true
this
new b2iundo
b2istaticcompiledinfo  null
dynamiccompiledopenconglominfo  null
b2ic getcontainer   compresscontainer
finally
b2ic close
return
/**
* return an open storecostcontroller for the conglomerate.
* <p>
* return an open storecostcontroller which can be used to ask about
* the estimated row counts and costs of scancontroller and
* conglomeratecontroller operations, on the given conglomerate.
* <p>
* @param xact_manager the transactioncontroller under which this
*                     operation takes place.
* @param rawtran  raw transaction context in which scan is managed.
*
* @return the open storecostcontroller.
*
* @exception  standardexception  standard exception policy.
*
* @see storecostcontroller
**/
public storecostcontroller openstorecost
transactionmanager  xact_manager
transaction         rawtran
throws standardexception
b2icostcontroller b2icost   new b2icostcontroller
b2icost init xact_manager  this  rawtran
return b2icost
/**
drop this b-tree secondary index.
@see conglomerate#drop
@see btree#drop
@exception standardexception standard exception policy.
**/
public void drop transactionmanager xact_manager
throws standardexception
// hack to get around problem where index is dropped after the base
// table.
conglomeratecontroller base_cc   null
/* get x table lock to make sure no thread is accessing index */
base_cc
locktable
xact_manager
transactioncontroller openmode_forupdate
transactioncontroller mode_table
transactioncontroller isolation_repeatable_read
xact_manager getrawstorexact   dropcontainer id
if  base_cc    null
base_cc close
/**
* return static information about the conglomerate to be included in a
* a compiled plan.
* <p>
* the static info would be valid until any ddl was executed on the
* conglomid, and would be up to the caller to throw away when that
* happened.  this ties in with what language already does for other
* invalidation of static info.  the type of info in this would be
* containerid and array of format id's from which templates can be created.
* the info in this object is read only and can be shared among as many
* threads as necessary.
* <p>
*
* @return the static compiled information.
*
* @param conglomid the identifier of the conglomerate to open.
*
* @exception  standardexception  standard exception policy.
**/
public staticcompiledopenconglominfo getstaticcompiledconglominfo
transactioncontroller   xact_manager
long                    conglomid
throws standardexception
return new b2istaticcompiledinfo xact_manager  this
/*
** methods of storable (via conglomerate via btree).
** this class is responsible for re/storing its
** own state and calling its superclass to store its'.
*/
/*
* storable interface, implies externalizable, typedformat
*/
/**
return my format identifier.
@see org.apache.derby.iapi.services.io.typedformat#gettypeformatid
*/
public int gettypeformatid
return storedformatids access_b2i_v3_id
/**
store the stored representation of the column value in the stream.
it might be easier to simply store the properties - which would certainly
make upgrading easier.*/
public void writeexternal_v36 objectoutput out  throws ioexception
super writeexternal out
out writelong baseconglomerateid
out writeint rowlocationcolumn
/**
restore the in-memory representation from the stream.
@exception classnotfoundexception thrown if the stored representation is
serialized and a class named in the stream could not be found.
@see java.io.externalizable#readexternal
*/
public void readexternal_v36 objectinput in
throws ioexception  classnotfoundexception
super readexternal in
// xxx (nat) need to improve error handling
baseconglomerateid   in readlong
rowlocationcolumn   in readint
//set the default (ascending) sort order
ascdescinfo   new boolean
for  int i 0   i < ascdescinfo length  i
ascdescinfo   true
/**
store the stored representation of the column value in the stream.
it might be easier to simply store the properties - which would certainly
make upgrading easier.
*/
public void writeexternal objectoutput out  throws ioexception
super writeexternal out
out writelong baseconglomerateid
out writeint rowlocationcolumn
// if the conglomerate type is not not the version2
// sorting information is stored from version v3(release 3.7)
if  conglom_format_id    storedformatids access_b2i_v2_id
//write the coulmsn sort information as bits
formatablebitset ascdescbits   new formatablebitset ascdescinfo length
for  int i   0  i < ascdescinfo length  i
if  ascdescinfo
ascdescbits set i
ascdescbits writeexternal out
/**
restore the in-memory representation from the stream.
@exception classnotfoundexception thrown if the stored representation is
serialized and a class named in the stream could not be found.
@see java.io.externalizable#readexternal
*/
private final void localreadexternal objectinput in
throws ioexception  classnotfoundexception
super readexternal in
// xxx (nat) need to improve error handling
baseconglomerateid   in readlong
rowlocationcolumn   in readint
// if the conglomerate type is  not the version2
// sorting info is avaialable  from version v3(release 3.7)
if  conglom_format_id    storedformatids access_b2i_v2_id
// read the column sort order info
formatablebitset ascdescbits   new formatablebitset
ascdescbits readexternal in
ascdescinfo   new boolean
for int i  0   i < ascdescbits getlength    i
ascdescinfo   ascdescbits isset i
else
//set the default (ascending) sort order
ascdescinfo   new boolean
for  int i 0   i < ascdescinfo length  i
ascdescinfo   true
public void readexternal objectinput in
throws ioexception  classnotfoundexception
localreadexternal in
public void readexternalfromarray arrayinputstream in
throws ioexception  classnotfoundexception
localreadexternal in