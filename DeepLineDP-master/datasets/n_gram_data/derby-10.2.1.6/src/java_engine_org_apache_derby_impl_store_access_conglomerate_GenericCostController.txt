/*
derby - class org.apache.derby.impl.store.access.conglomerate.genericcostcontroller
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl store access conglomerate
import org apache derby iapi error standardexception
import org apache derby iapi reference sqlstate
import org apache derby iapi store access storecostcontroller
import org apache derby iapi store access storecostresult
import org apache derby iapi types datavaluedescriptor
import org apache derby impl sql execute rowutil
import org apache derby iapi services io formatablebitset
/**
a generic class which implements the basic functionality needed for a cost
controller.
**/
public abstract class genericcostcontroller
extends genericcontroller implements storecostcontroller
/**************************************************************************
* fields of the class
**************************************************************************
*/
/**************************************************************************
* constructors for this class:
**************************************************************************
*/
/**************************************************************************
* private/protected methods of this class:
**************************************************************************
*/
/**************************************************************************
* public methods of this class:
**************************************************************************
*/
/**************************************************************************
* public methods implementing storecostcontroller class:
**************************************************************************
*/
/**************************************************************************
* public methods implementing storecostcontroller class, default impl
*      just throws exception:
**************************************************************************
*/
/**
* return the cost of exact key lookup.
* <p>
* return the estimated cost of calling scancontroller.fetch()
* on the current conglomerate, with start and stop positions set such
* that an exact match is expected.
* <p>
* this call returns the cost of a fetchnext() performed on a scan which
* has been positioned with a start position which specifies exact match
* on all keys in the row.
* <p>
* example:
* <p>
* in the case of a btree this call can be used to determine the cost of
* doing an exact probe into btree, giving all key columns.  this cost
* can be used if the client knows it will be doing an exact key probe
* but does not have the key's at optimize time to use to make a call to
* getscancost()
* <p>
*
* @param validcolumns    a description of which columns to return from
*                        row on the page into "templaterow."  templaterow,
*                        and validcolumns work together to
*                        describe the row to be returned by the fetch -
*                        see rowutil for description of how these three
*                        parameters work together to describe a fetched
*                        "row".
*
* @param access_type     describe the type of access the query will be
*                        performing to the scancontroller.
*
*                        storecost_clustered - the location of one scan
*                            is likely clustered "close" to the previous
*                            scan.  for instance if the query plan were
*                            to used repeated "reopenscan()'s" to probe
*                            for the next key in an index, then this flag
*                            should be be specified.  if this flag is not
*                            set then each scan will be costed independant
*                            of any other predicted scan access.
*
* @return the cost of the fetch.
*
* @exception  standardexception  standard exception policy.
*
* @see rowutil
**/
public double getfetchfromfullkeycost
formatablebitset validcolumns
int     access_type
throws standardexception
// not implemented in default conglomerate, needs to be overridden.
throw standardexception newexception
sqlstate heap_unimplemented_feature