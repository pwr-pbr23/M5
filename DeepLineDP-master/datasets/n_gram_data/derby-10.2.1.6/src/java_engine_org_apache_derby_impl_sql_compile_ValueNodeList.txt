/*
derby - class org.apache.derby.impl.sql.compile.valuenodelist
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package	org apache derby impl sql compile
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi error standardexception
import org apache derby iapi sql conn languageconnectioncontext
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi types datatypedescriptor
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi types typeid
import org apache derby iapi sql compile typecompiler
import org apache derby iapi reference sqlstate
import org apache derby iapi store access qualifier
import org apache derby iapi util jbitset
import java util vector
/**
* a valuenodelist represents a list of valuenodes within a specific predicate
* (eg, in list, not in list or between) in a dml statement.
* it extends querytreenodevector.
*
* @author jerry brenner
*/
public class valuenodelist extends querytreenodevector
/**
* prints the sub-nodes of this object.  see querytreenode.java for
* how tree printing is supposed to work.
*
* @param depth		the depth of this node in the tree
*/
public void printsubnodes int depth
if  sanitymanager debug
super printsubnodes depth
for  int index   0  index < size    index
valuenode		valuenode
valuenode    valuenode  elementat index
valuenode treeprint depth   1
/**
* set the clause that this node appears in.
*
* @param clause	the clause that this node appears in.
*/
public void setclause int clause
int size   size
for  int index   0  index < size  index
valuenode		valuenode
valuenode    valuenode  elementat index
valuenode setclause clause
/**
* add a valuenode to the list.
*
* @param valuenode	a valuenode to add to the list
*
* @exception standardexception		thrown on error
*/
public void addvaluenode valuenode valuenode  throws standardexception
addelement valuenode
/**
* bind this expression.  this means binding the sub-expressions,
* as well as figuring out what the return type is for this expression.
*
* @param fromlist		the from list for the query this
*				expression is in, for binding columns.
* @param subquerylist		the subquery list being built as we find subquerynodes
* @param aggregatevector	the aggregate vector being built as we find aggregatenodes
*
* @exception standardexception		thrown on error
*/
public void	bindexpression fromlist fromlist
subquerylist subquerylist
vector aggregatevector
throws standardexception
int size   size
for  int index   0  index < size  index
valuenode vn    valuenode  elementat index
vn   vn bindexpression fromlist  subquerylist
aggregatevector
setelementat vn  index
/**
* generate a sql->java->sql conversion tree any node in the list
* which is not a system built-in type.
* this is useful when doing comparisons, built-in functions, etc. on
* java types which have a direct mapping to system built-in types.
*
* @exception standardexception	thrown on error
*/
public void gensqljavasqltrees
throws standardexception
int size   size
for  int index   0  index < size  index
valuenode valuenode    valuenode  elementat index
if  valuenode gettypeid   usertype
setelementat valuenode gensqljavasqltree    index
/**
* get the dominant datatypeservices from the elements in the list.
*
* @return datatypeservices		the dominant datatypeservices.
*
* @exception standardexception		thrown on error
*/
public datatypedescriptor getdominanttypeservices   throws standardexception
datatypedescriptor	dominantdts   null
for  int index   0  index < size    index
valuenode			valuenode
valuenode    valuenode  elementat index
if  valuenode requirestypefromcontext
continue
datatypedescriptor valuenodedts   valuenode gettypeservices
if  dominantdts    null
dominantdts   valuenodedts
else
dominantdts   dominantdts getdominanttype valuenodedts  getclassfactory
return dominantdts
/**
* get the first non-null datatypeservices from the elements in the list.
*
* @return datatypeservices		the first non-null datatypeservices.
*
* @exception standardexception		thrown on error
*/
public datatypedescriptor gettypeservices   throws standardexception
datatypedescriptor	firstdts   null
int size   size
for  int index   0  index < size  index
valuenode			valuenode
valuenode    valuenode  elementat index
datatypedescriptor valuenodedts   valuenode gettypeservices
if   firstdts    null      valuenodedts    null
firstdts   valuenodedts
break
return firstdts
/**
* return whether or not all of the entries in the list have the same
* type precendence as the specified value.
*
* @param precedence	the specified precedence.
*
* @return	whether or not all of the entries in the list have the same
*			type precendence as the specified value.
*/
boolean allsameprecendence int precedence
throws standardexception
boolean allsame   true
int size   size
for  int index   0  index < size  index
valuenode			valuenode
valuenode    valuenode  elementat index
datatypedescriptor valuenodedts   valuenode gettypeservices
if  valuenodedts    null
return false
if  precedence    valuenodedts gettypeid   typeprecedence
return false
return allsame
/**
* make sure that passed valuenode's type is compatible with the non-parameter elements in the valuenodelist.
*
* @param leftoperand	check for compatibility against this parameter's type
*
*/
public void compatible valuenode leftoperand  throws standardexception
int			 size   size
typeid	lefttype
valuenode		valuenode
typecompiler lefttc
lefttype   leftoperand gettypeid
lefttc   leftoperand gettypecompiler
for  int index   0  index < size  index
valuenode    valuenode  elementat index
if  valuenode requirestypefromcontext
continue
/*
** are the types compatible to each other?  if not, throw an exception.
*/
if    lefttc compatible valuenode gettypeid
throw standardexception newexception sqlstate lang_db2_coalesce_datatype_mismatch
lefttype getsqltypename
valuenode gettypeid   getsqltypename
/**
* determine whether or not the leftoperand is comparable() with all of
* the elements in the list. throw an exception if any of them are not
* comparable.
*
* @param leftoperand	the left side of the expression
*
* @exception standardexception		thrown on error
*/
public void comparable valuenode leftoperand  throws standardexception
int			 size   size
typeid	lefttype
valuenode		valuenode
typecompiler lefttc
lefttype   leftoperand gettypeid
lefttc   leftoperand gettypecompiler
for  int index   0  index < size  index
valuenode    valuenode  elementat index
/*
** can the types be compared to each other?  if not, throw an
** exception.
*/
if    lefttc comparable valuenode gettypeid
false
getclassfactory
throw standardexception newexception sqlstate lang_not_comparable
lefttype getsqltypename
valuenode gettypeid   getsqltypename
/**
* determine whether or not any of the elements in the list are nullable.
*
* @return boolean	whether or not any of the elements in the list
*					are nullable.
*/
public boolean isnullable
throws standardexception
int size   size
for  int index   0  index < size  index
if    valuenode  elementat index   gettypeservices   isnullable
return true
return false
/**
* does this list contain a parameternode?
*
* @return boolean	whether or not the list contains a parameternode
*/
public boolean containsparameternode
int size   size
for  int index   0  index < size  index
if    valuenode  elementat index   requirestypefromcontext
return true
return false
/**
* does this list contain all parameternodes?
*
* @return boolean	whether or not the list contains all parameternodes
*/
public boolean containsallparameternodes
int size   size
for  int index   0  index < size  index
if       valuenode  elementat index   requirestypefromcontext
return false
return true
/**
* does this list contain all constantnodes?
*
* @return boolean	whether or not the list contains all constantnodes
*/
public boolean containsallconstantnodes
int size   size
for  int index   0  index < size  index
if      valuenode  elementat index  instanceof constantnode
return false
return true
/**
* sort the entries in the list in ascending order.
* (all values are assumed to be constants.)
*
* @param judgeodv  in case of type not exactly matching, the judging type.
*
* @exception standardexception		thrown on error
*/
void sortinascendingorder datavaluedescriptor judgeodv
throws standardexception
int size   size
if  sanitymanager debug
sanitymanager assert size > 0
/* we use bubble sort to sort the list since we expect
* the list to be in sorted order > 90% of the time.
*/
boolean continuesort   true
while  continuesort
continuesort   false
for  int index   1  index < size  index
constantnode currcn    constantnode  elementat index
datavaluedescriptor currodv
currcn getvalue
constantnode prevcn    constantnode  elementat index   1
datavaluedescriptor prevodv
prevcn getvalue
/* swap curr and prev if prev > curr */
if   judgeodv    null     prevodv compare currodv   > 0
judgeodv    null    judgeodv greaterthan prevodv  currodv  equals true
setelementat currcn  index   1
setelementat prevcn  index
continuesort   true
/**
* set the descriptor for every parameternode in the list.
*
* @param descriptor	the datatypeservices to set for the parameters
*
* @exception standardexception		thrown on error
*/
public void setparameterdescriptor datatypedescriptor descriptor
throws standardexception
int size   size
valuenode	valuenode
for  int index   0  index < size  index
valuenode    valuenode  elementat index
if  valuenode requirestypefromcontext
valuenode settype descriptor
/**
* preprocess a valuenodelist.  for now, we just preprocess each valuenode
* in the list.
*
* @param	numtables			number of tables in the dml statement
* @param	outerfromlist		fromlist from outer query block
* @param	outersubquerylist	subquerylist from outer query block
* @param	outerpredicatelist	predicatelist from outer query block
*
* @exception standardexception		thrown on error
*/
public void preprocess int numtables
fromlist outerfromlist
subquerylist outersubquerylist
predicatelist outerpredicatelist
throws standardexception
int size   size
valuenode	valuenode
for  int index   0  index < size  index
valuenode    valuenode  elementat index
valuenode preprocess numtables
outerfromlist  outersubquerylist
outerpredicatelist
/**
* remap all columnreferences in this tree to be clones of the
* underlying expression.
*
* @return valuenodelist			the remapped expression tree.
*
* @exception standardexception			thrown on error
*/
public valuenodelist remapcolumnreferencestoexpressions
throws standardexception
int size   size
for  int index   0  index < size  index
setelementat
valuenode  elementat index   remapcolumnreferencestoexpressions
index
return this
/**
* return whether or not this expression tree represents a constant expression.
*
* @return	whether or not this expression tree represents a constant expression.
*/
public boolean isconstantexpression
int size   size
for  int index   0  index < size  index
boolean retcode
retcode     valuenode  elementat index   isconstantexpression
if    retcode
return retcode
return true
/** @see valuenode#constantexpression */
public boolean constantexpression predicatelist whereclause
int size   size
for  int index   0  index < size  index
boolean retcode
retcode
valuenode  elementat index   constantexpression whereclause
if    retcode
return retcode
return true
/**
* categorize this predicate.  initially, this means
* building a bit map of the referenced tables for each predicate.
* if the source of this columnreference (at the next underlying level)
* is not a columnreference or a virtualcolumnnode then this predicate
* will not be pushed down.
*
* for example, in:
*		select * from (select 1 from s) a (x) where x = 1
* we will not push down x = 1.
* note: it would be easy to handle the case of a constant, but if the
* inner select returns an arbitrary expression, then we would have to copy
* that tree into the pushed predicate, and that tree could contain
* subqueries and method calls.
* resolve - revisit this issue once we have views.
*
* @param referencedtabs	jbitset with bit map of referenced fromtables
* @param simplepredsonly	whether or not to consider method
*							calls, field references and conditional nodes
*							when building bit map
*
* @return boolean		whether or not source.expression is a columnreference
*						or a virtualcolumnnode.
* @exception standardexception		thrown on error
*/
public boolean categorize jbitset referencedtabs  boolean simplepredsonly
throws standardexception
/* we stop here when only considering simple predicates
*  as we don't consider in lists when looking
* for null invariant predicates.
*/
boolean pushable   true
int size   size
for  int index   0  index < size  index
pushable     valuenode  elementat index   categorize referencedtabs  simplepredsonly
pushable
return pushable
/**
* return the variant type for the underlying expression.
* the variant type can be:
*		variant				- variant within a scan
*							  (method calls and non-static field access)
*		scan_invariant		- invariant within a scan
*							  (column references from outer tables)
*		query_invariant		- invariant within the life of a query
*		constant			- constant
*
* @return	the variant type for the underlying expression.
* @exception standardexception	thrown on error
*/
protected int getorderablevarianttype   throws standardexception
int listtype   qualifier constant
int size   size
/* if any element in the list is variant then the
* entire expression is variant
* else it is scan_invariant if any element is scan_invariant
* else it is query_invariant.
*/
for  int index   0  index < size  index
int curtype     valuenode  elementat index   getorderablevarianttype
listtype   math min listtype  curtype
return listtype