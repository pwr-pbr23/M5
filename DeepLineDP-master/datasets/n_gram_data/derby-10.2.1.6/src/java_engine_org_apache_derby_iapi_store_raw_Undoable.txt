/*
derby - class org.apache.derby.iapi.store.raw.undoable
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby iapi store raw
import org apache derby iapi error standardexception
import org apache derby iapi services io limitobjectinput
import java io ioexception
/**
an undoable operation is an operation that changed the state of the rawstore
in the context of a transaction and this change can be rolled back.
@see transaction#loganddo
@see compensation
*/
public interface undoable extends loggable
/**
generate a loggable which will undo this change, using the optional
input if necessary.
<p><b>note</b><br>any logical undo logic must be hidden behind generateundo.
during recovery redo, it should not depend on any logical undo logic.
<p>
there are 3 ways to implement a redo-only log record:
<nl>
<li>make the log record a loggable instead of an undoable, this is the
cleanest method.
<li>if you want to extend a log operation class that is an undoable,
you can then either have generateundo return null - this is preferred -
(the log operation's undome should never be called, so you can put a
null body there if the super class you are extending does not implement
a undome).
<li>or, have undome do nothing - this is least preferred.
</nl>
<p>any resource (e.g., latched page) that is needed for the
undoable.undome() must be acquired in undoable.generateundo().
moreover, that resource must be identified in the compensation
operation, and reacquired in the compensation.needsredo() method during
recovery redo.
<br><b>if you do write your own generateundo or needsredo, any
resource you latch or acquire, you must release them in
compensation.dome() or in compensation.releaseresource().</b>
<p> to write a generateundo operation, find the object that needs to be
rolled back.  assuming that it is a page, latch it, put together a
compensation operation with the undoop set to this operation, and save
the page number in the compensation operation, then
return the compensation operation to the logging system.
<p>
the sequence of events in a rollback of a undoable operation is
<nl>
<li> the logging system calls undoable.generateundo.  if this returns
null, then there is nothing to undo.
<li> if generateundo returns a compensation operation, then the logging
system will log the compensation log record and call
compenstation.dome().  (hopefully, this just calls the undoable's
undome)
<li> after the compensation operation has been applied, the logging
system will call compensation.releaseresource(). if you do overwrite a
super class's releaseresource(), it would be prudent to call
super.releaseresource() first.
</nl>
<p> the available() method of in indicates how much data can be read, i.e.
how much was originally written.
@param xact	the transaction doing the rollback
@return the compensation operation that will rollback this change, or
null if nothing to undo.
@exception ioexception can be thrown by any of the methods of objectinput.
@exception standardexception standard cloudscape policy.
@see loggable#releaseresource
@see loggable#needsredo
*/
public compensation generateundo transaction xact  limitobjectinput in
throws standardexception  ioexception