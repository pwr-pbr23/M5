/*
derby - class org.apache.derby.client.net.netstatementrequest
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby client net
import org apache derby iapi reference drdaconstants
import org apache derby client am blob
import org apache derby client am clob
import org apache derby client am columnmetadata
import org apache derby client am resultset
import org apache derby client am section
import org apache derby client am sqlexception
import org apache derby client am types
import org apache derby client am clientmessageid
import org apache derby shared common reference sqlstate
// for performance, should we worry about the ordering of our ddm command parameters
public class netstatementrequest extends netpackagerequest implements statementrequestinterface
java util arraylist extdtapositions_   null     integers  build extdta for column i
int overridelid_   fdocaconstants first_override_lid
// promototed parameters hold parameters that are promotoed to a different
// data type because they are too large to represent in protocol otherwise.
// this currently only applies for promotion of (var)char -> clob and (var)binary -> blob
// the key for this structure is the parameter index.  note that having this
// collection does not eliminate the need for extdtapositions_ because that
// is still needed for non-promototed lobs
java util hashmap promototedparameters_   new java util hashmap
netstatementrequest netagent netagent  ccsidmanager ccsidmanager  int buffersize
super netagent  ccsidmanager  buffersize
}
//----------------------------- entry points ---------------------------------
// write the message to perform an execute immediate.
// the sql statement sent as command data cannot contain references
// to either input variables or output variables.
//
// preconditions:
public void writeexecuteimmediate netstatement materialstatement
string sql
section section  throws sqlexception
buildexcsqlimm section
false    sendqryinsid
0                            qryinsid
buildsqlsttcommanddata sql      statement follows in sqlstt command data object
}
// write the message to preform a prepare into.
// once the sql statement has been prepared, it is executed until the unit of work, in
// which the prpsqlstt command was issued, ends.  an exception to this is if
// keep dynamic is being used.
//
// preconditions:
public void writepreparedescribeoutput netstatement materialstatement
string sql
section section  throws sqlexception
buildprpsqlstt section
sql
true    sendrtnsqlda
true    sendtypsqlda
codepoint typsqlda_x_output      typsqlda
if    netstatement  materialstatement  statement_ cursorattributestosendonprepare_    null
buildsqlattrcommanddata   netstatement  materialstatement  statement_ cursorattributestosendonprepare_
}
buildsqlsttcommanddata sql       statement follows in sqlstt command data object
}
// write the message to perform a reprepare.
//
// preconditions:
public void writeprepare netstatement materialstatement
string sql
section section  throws sqlexception
buildprpsqlstt section
sql
false    sendrtnsqlda
false    sendtypsqlda
0          typsqlda
if    netstatement  materialstatement  statement_ cursorattributestosendonprepare_    null
buildsqlattrcommanddata   netstatement  materialstatement  statement_ cursorattributestosendonprepare_
}
buildsqlsttcommanddata sql      statement follows in sqlstt command data object
}
// write the message to execute  prepared sql statement.
//
// preconditions:
public void writeexecute netpreparedstatement materialpreparedstatement
section section
columnmetadata parametermetadata
object inputs
int numinputcolumns
boolean outputexpected
boolean chained  throws sqlexception     chained flag for blobs only    dupqry
{
buildexcsqlstt section
true     sendoutexp
outputexpected     outexp
false     sendprcnam
null     prcnam
false     sendqryblksz
false     sendmaxrslcnt
0     maxrslcnt
false     sendmaxblkext
0     maxblkext
false     sendrslsetflg
0     resultsetflag
false     sendqryrowset
0                    qryrowset
if  numinputcolumns > 0
if   extdtapositions_    null       extdtapositions_ isempty
extdtapositions_ clear        reset extdta column position markers
}
boolean overrideexists   buildsqldtacommanddata numinputcolumns
parametermetadata
inputs
// can we eleminate the chain argument needed for lobs
buildextdta parametermetadata  inputs  chained
}
}
// write the message to open a bound or prepared query with input parameters.
// check this -> for open query with input parameters
//
// preconditions:
public void writeopenquery netpreparedstatement materialpreparedstatement
section section
int fetchsize
int resultsettype
int numinputcolumns
org apache derby client am columnmetadata parametermetadata
object inputs  throws sqlexception
boolean sendqryrowset   checksendqryrowset fetchsize  resultsettype
fetchsize   checkfetchsize fetchsize  resultsettype
// think about if there is a way we can call build ddm just passing ddm parameters and not passing the material ps object
// maybe not, if sometimes we need to set the caches hanging off the ps object during the ddm build
// maybe we can extricate conditionals in the build ddm logic outside
buildopnqry section
sendqryrowset
fetchsize
// may be able to merge this with firstcontinuequery_ and push above conditional to common
netstatement  materialpreparedstatement  qryrowsetsentonopnqry_   sendqryrowset
if  numinputcolumns > 0
if   extdtapositions_    null       extdtapositions_ isempty
extdtapositions_ clear        reset extdta column position markers
}
// is this the best place for this
// excsqstt needs this too
// think about having this method return a boolean to
// indicate the extdta should be built
boolean overrideexists   buildsqldtacommanddata numinputcolumns
parametermetadata
inputs
// can we eleminate the chain argument needed for lobs
// do we chain after extdta's on open, verify this
buildextdta parametermetadata
inputs
false      chained  do we chain after extdta's on open
}
}
// write the message to open a bound or prepared query without input parameters.
// check this-> for open query without input parameters
public void writeopenquery netstatement materialstatement
section section
int fetchsize
int resultsettype  throws sqlexception
boolean sendqryrowset   checksendqryrowset fetchsize  resultsettype
fetchsize   checkfetchsize fetchsize  resultsettype
// think about if there is a way we can call build ddm just passing ddm parameters and not passing the material ps object
// maybe not, if sometimes we need to set the caches hanging off the ps object during the ddm build
// maybe we can extricate conditionals in the build ddm logic outside
buildopnqry section
sendqryrowset
fetchsize
// may be able to merge this with firstcontinuequery_ and push above conditional to common
netstatement  materialstatement  qryrowsetsentonopnqry_   sendqryrowset     net specific event
}
// write the message to peform a describe input.
//
public void writedescribeinput netpreparedstatement materialpreparedstatement
section section  throws sqlexception
int typsqlda   codepoint typsqlda_x_input
builddscsqlstt section
true    sendtypsqlda
typsqlda
}
// write the message to peform a describe output.
//
// preconditions:
public void writedescribeoutput netpreparedstatement materialpreparedstatement
section section  throws sqlexception
// pick standard, light, extended sqlda. possibly push this up even more
// right now use sqlam level as determining factor and go for the most data.
// if standard is the only suported option, don't send the typsqlda
// and let server default to standard.  this prevents accidentally sending
// a typsqlda to a downlevel server.  typsqlda is only supported at sqlam 6.
//kathey check
builddscsqlstt section
true    sendtypsqlda
codepoint typsqlda_x_output      typsqlda
}
// write the message to execute a stored procedure.
//
// preconditions:
public void writeexecutecall netstatement materialstatement
boolean outputexpected
string procedurename
section section
int fetchsize
boolean suppressresultsets     for batch updates    true
int resultsettype
columnmetadata parametermetadata
object inputs  throws sqlexception    chain is for blobs
{
// always send qryrowset on excsqlstt
boolean sendqryrowset   true
fetchsize    fetchsize    0  ? org apache derby client am configuration defaultfetchsize   fetchsize
boolean sendprcnam    procedurename    null  ? true   false
int numparameters    parametermetadata    null  ? parametermetadata columns_   0
outputexpected   numparameters > 0
// is it right here to send maxblkext (-1)
buildexcsqlstt section
true     sendoutexp
outputexpected     outexp
sendprcnam     sendprcnam
procedurename     prcnam
true     sendqryblksz
suppressresultsets     sendmaxrslcnt
codepoint maxrslcnt_nolimit     maxrslcnt
true     sendmaxblkext
1     maxblkext   1 for ar capable of receiving entire result set
true     sendrslsetflg
calculateresultsetflags       resultsetflag
sendqryrowset     sendqryrowset
fetchsize           qryrowset
if  numparameters > 0
if   extdtapositions_    null       extdtapositions_ isempty
extdtapositions_ clear        reset extdta column position markers
}
// is this the best place for this (opnqry needs this too)
// think about having this method return a boolean to
// indicate the extdta should be built
boolean overrideexists   buildsqldtacommanddata numparameters
parametermetadata
inputs
buildextdta parametermetadata  inputs  false      no chained autocommit for calls
}
netstatement  materialstatement  qryrowsetsentonopnqry_   sendqryrowset
}
// write the message to execute an sql set statement.
/*
public void writesetgenericsqlsetinfo (org.apache.derby.client.am.setgenericsqlsetpiggybackcommand setgenericsqlsetpiggybackcommand,
org.apache.derby.client.am.jdbcsection section) throws sqlexception
{
buildexcsqlset (section);
java.util.list sqlsttlist = setgenericsqlsetpiggybackcommand.getlist();
for (int i = 0; i < sqlsttlist.size(); i++) {
string sql = (string)sqlsttlist.get(i);
// build sqlstt only for the set statement that coming from the server after rlsconv
buildsqlsttcommanddata (sql);
}
}
*/
//----------------------helper methods----------------------------------------
// these methods are "private protected", which is not a recognized java privilege,
// but means that these methods are private to this class and to subclasses,
// and should not be used as package-wide friendly methods.
// build the open query command to open a query to a relational database.
// at sqlam >= 7 we can request the return of a da, are there
// scenarios where this should currently be done (it is not supported now)
//
// preconditions:
//   the sqlam and/or prdid must support command and parameters passed to this method,
//   method will not validate against the connection's level of support
//
void buildopnqry section section
boolean sendqueryrowset
int fetchsize  throws sqlexception
createcommand
marklengthbytes codepoint opnqry
buildpkgnamcsn section
buildqryblksz        specify a hard coded query block size
if  sendqueryrowset
buildmaxblkext  1
buildqryrowset fetchsize
}
// tell the server to close forward-only result sets
// implicitly when they are exhausted. the server will ignore
// this parameter if the result set is scrollable.
if  netagent_ netconnection_ serversupportsqryclsimp
buildqryclsimp
}
updatelengthbytes        opnqry is complete
}
// build the execute immediate sql statement command to
// execute a non-cursor sql statement sent as command data.
//
// precondtions:
void buildexcsqlimm section section
boolean sendqryinsid
long qryinsid  throws sqlexception
createcommand
marklengthbytes codepoint excsqlimm
buildpkgnamcsn section
buildrdbcmtok
if  sendqryinsid
buildqryinsid qryinsid
}
updatelengthbytes
}
// build the prepare sql statement command to dynamically binds an
// sql statement to a section in an existing relational database (rdb) package.
//
// preconditions:
//   the sqlam and/or prdid must support command and parameters passed to this method,
//   method will not validate against the connection's level of support
void buildprpsqlstt section section
string sql
boolean sendrtnsqlda
boolean sendtypsqlda
int typsqlda  throws sqlexception
createcommand
marklengthbytes codepoint prpsqlstt
buildpkgnamcsn section
if  sendrtnsqlda
buildrtnsqlda
}
if  sendtypsqlda
buildtypsqlda typsqlda
}
updatelengthbytes
}
// build the command to execute an sql set statement.
// called by netsetclientpiggybackcommand.write()
//
// preconditions:
//   the sqlam and/or prdid must support command and parameters passed to this method,
//   method will not validate against the connection's level of support
void buildexcsqlset section section
throws sqlexception
createcommand
marklengthbytes codepoint excsqlset
buildpkgnamcsn section       is this pkgnamcsn or pkgnamct
updatelengthbytes
}
// build the execute sql statement (excsqlstt) command
// to execute a non-cursor sql statement previously bound into a named package
// of a relational database (rdb).  the sql statement can optionally include
// references to input variables, output variables, or both.
//
// at sqlam >= 7 we can get a da back on this, are there times that we want to request it
// if so, we probably want to pass a parameter indicating the sqldalevel requested.
//
// preconditions:
//   the sqlam and/or prdid must support command and parameters passed to this method,
//   method will not validate against the connection's level of support
// here is the preferred codepoint ordering:
// pkgnamcsn
// rdbcmtok
// outexp
// qryblksz
// maxblkext
// maxrslcnt
// rslsetflg
// qryrowset
// rtnsqlda
// typsqlda
// nbrrow
// atmind
// prcnam
// outovropt
// rdbnam
void buildexcsqlstt section section
boolean sendoutexp
boolean outexp
boolean sendprcnam
string prcnam
boolean sendqryblksz
boolean sendmaxrslcnt
int maxrslcnt
boolean sendmaxblkext
int maxblkext
boolean sendrslsetflg
int resultsetflag
boolean sendqryrowset
int qryrowset  throws sqlexception
createcommand
marklengthbytes codepoint excsqlstt
buildpkgnamcsn section
buildrdbcmtok
if  sendoutexp
buildoutexp outexp
}
if  sendqryblksz
buildqryblksz
}
if  sendqryrowset    sendmaxblkext
buildmaxblkext maxblkext
}
if  sendmaxrslcnt
buildmaxrslcnt maxrslcnt
}
if  sendrslsetflg
buildrslsetflg resultsetflag
}
if  sendqryrowset
buildqryrowset qryrowset
}
if  sendprcnam
buildprcnam prcnam
}
updatelengthbytes        command is complete  update the length bytes
}
// build the describe sql statement command.
//
// preconditions:
//   the sqlam and/or prdid must support command and parameters passed to this method,
//   method will not validate against the connection's level of support
void builddscsqlstt section section
boolean sendtypsqlda
int typsqlda  throws sqlexception
createcommand
marklengthbytes codepoint dscsqlstt
buildpkgnamcsn section
if  sendtypsqlda
buildtypsqlda typsqlda
}
updatelengthbytes
}
// build the sql program variable data command data object.
// this object contains the input data to an sql statement
// that an rdb is executing.
//
// preconditions:
boolean buildsqldtacommanddata int numinputcolumns
columnmetadata parametermetadata
object inputrow  throws sqlexception
createencryptedcommanddata
int loc   offset_
marklengthbytes codepoint sqldta
int protocoltypesandlengths   allocatelidandlengthsarray parametermetadata
java util hashtable protocoltypetooverridelidmapping   null
java util arraylist mddoverridearray   null
protocoltypetooverridelidmapping
computeprotocoltypesandlengths inputrow  parametermetadata  protocoltypesandlengths
protocoltypetooverridelidmapping
boolean overrideexists   false
buildfdodsc numinputcolumns
protocoltypesandlengths
overrideexists
protocoltypetooverridelidmapping
mddoverridearray
buildfdodta numinputcolumns
protocoltypesandlengths
inputrow
updatelengthbytes       for sqldta
if  netagent_ netconnection_ getsecuritymechanism
netconfiguration secmec_eusriddta
netagent_ netconnection_ getsecuritymechanism
netconfiguration secmec_eusrpwddta
encryptdatastream loc
}
return overrideexists
}
// build the fdoca data descriptor scalar whose value is a fdoca
// descriptor or a segment of an fdoca descriptor.
//
// preconditions:
private void buildfdodsc int numcolumns
int protocoltypesandlengths
boolean overrideexists
java util hashtable overridemap
java util arraylist overridearray  throws sqlexception
marklengthbytes codepoint fdodsc
buildsqldta numcolumns  protocoltypesandlengths  overrideexists  overridemap  overridearray
updatelengthbytes
}
// build the fdoca sqldta late row descriptor.
//
// preconditions:
protected void buildsqldta int numcolumns
int lidandlengthoverrides
boolean overrideexists
java util hashtable overridemap
java util arraylist overridearray  throws sqlexception
// mdd overrides need to be built first if any before the descriptors are built.
if  overrideexists
buildmddoverrides overridearray
writebytes fdocaconstants mdd_sqldtagrp_tosend
}
buildsqldtagrp numcolumns  lidandlengthoverrides  overrideexists  overridemap
if  overrideexists
writebytes fdocaconstants mdd_sqldta_tosend
}
writebytes fdocaconstants sqldta_rlo_tosend
}
// build the fdoca sqldtagrp late group descriptor.
// preconditions:
protected void buildsqldtagrp int numvars
int lidandlengthoverrides
boolean mddrequired
java util hashtable overridemap  throws sqlexception
int n   0
int offset   0
n   calculatecolumnsinsqldtagrptriplet numvars
buildtripletheader   3   n    3
fdocaconstants ngda_triplet_type
fdocaconstants sqldtagrp_lid
do
writelidandlengths lidandlengthoverrides  n  offset  mddrequired  overridemap
numvars    n
if  numvars    0
break
}
offset    n
n   calculatecolumnsinsqldtagrptriplet numvars
buildtripletheader   3   n    3
fdocaconstants cpt_triplet_type
0x00
while  true
}
/////////// perf end
protected void buildoutovr resultset resultset
columnmetadata resultsetmetadata  throws sqlexception
createcommanddata
marklengthbytes codepoint outovr
int outputoverrides
calculateoutovrlidandlengthoverrides resultset  resultsetmetadata
buildsqldtard resultsetmetadata columns_  outputoverrides
updatelengthbytes
}
private int calculateoutovrlidandlengthoverrides resultset resultset
columnmetadata resultsetmetadata
int numvars   resultsetmetadata columns_
int lidandlengths   new int    everything initialized to
return lidandlengths
}
protected void buildsqldtard int numcolumns  int lidandlengthoverrides  throws sqlexception
buildsqlcadta numcolumns  lidandlengthoverrides
writebytes fdocaconstants sqldtard_rlo_tosend
}
protected void buildsqlcadta int numcolumns  int lidandlengthoverrides  throws sqlexception
buildsqldtagrp numcolumns  lidandlengthoverrides  false  null       false means no mdd override
writebytes fdocaconstants sqlcadta_rlo_tosend
}
private void buildfdodta int numvars
int protocoltypesandlengths
object inputs  throws sqlexception
try
{
long datalength   0
object o   null
marklengthbytes codepoint fdodta
write1byte fdocaconstants null_lid      write the 1 byte row indicator
// write data for each input column
for  int i   0  i < numvars  i
if  inputs    null
if   protocoltypesandlengths % 2     1
write1byte fdocaconstants null_data
else
//bug check
}
else
if   protocoltypesandlengths % 2     1
write1byte fdocaconstants indicator_nullable
}
switch  protocoltypesandlengths   0x01        mask out null indicator
case drdaconstants drda_type_nvarmix
case drdaconstants drda_type_nlongmix
// what to do for server that don't understand 1208 (utf-8)
// check for a promototed type, and use that instead if it exists
o   retrievepromotedparameterifexists i
if  o    null
writesingleormixedccsidldstring  string  inputs  netagent_ typdef_ getccsidmbcencoding
else      use the promototed object instead
clob c    clob  o
datalength   c length
setfdodtaloblength protocoltypesandlengths  i  datalength
}
break
case drdaconstants drda_type_nvarchar
case drdaconstants drda_type_nlong
o   retrievepromotedparameterifexists i
if  o    null
else      use the promototed object instead
datalength     clob  o  length
setfdodtaloblength protocoltypesandlengths  i  datalength
}
break
case drdaconstants drda_type_ninteger
writeintfdocadata   integer  inputs  intvalue
break
case drdaconstants drda_type_nsmall
writeshortfdocadata   short  inputs  shortvalue
break
case drdaconstants drda_type_nfloat4
writefloat   float  inputs  floatvalue
break
case drdaconstants drda_type_nfloat8
writedouble   double  inputs  doublevalue
break
case drdaconstants drda_type_ndecimal
writebigdecimal  java math bigdecimal  inputs
protocoltypesandlengths >> 8    0xff     described precision not actual
protocoltypesandlengths   0xff      described scale  not actual
break
case drdaconstants drda_type_ndate
writedate  java sql date  inputs
break
case drdaconstants drda_type_ntime
writetime  java sql time  inputs
break
case drdaconstants drda_type_ntimestamp
writetimestamp  java sql timestamp  inputs
break
case drdaconstants drda_type_ninteger8
writelongfdocadata   long  inputs  longvalue
break
case drdaconstants drda_type_nvarbyte
case drdaconstants drda_type_nlongvarbyte
o   retrievepromotedparameterifexists i
if  o    null
writeldbytes  byte  inputs
else      use the promototed object instead
blob b    blob  o
datalength   b length
setfdodtaloblength protocoltypesandlengths  i  datalength
}
break
case drdaconstants drda_type_nlobcsbcs
case drdaconstants drda_type_nlobcdbcs
// check for a promoted clob
o   retrievepromotedparameterifexists i
if  o    null
try
datalength     java sql clob  inputs  length
catch  java sql sqlexception e
throw new sqlexception netagent_ logwriter_
new clientmessageid sqlstate net_error_getting_blob_length
e
}
else
datalength     clob  o  length
}
setfdodtaloblength protocoltypesandlengths  i  datalength
break
case drdaconstants drda_type_nlobbytes
// check for a promoted clob
o   retrievepromotedparameterifexists i
if  o    null
try
datalength     java sql blob  inputs  length
catch  java sql sqlexception e
throw new sqlexception netagent_ logwriter_
new clientmessageid sqlstate net_error_getting_blob_length
e
}
else      use promoted blob
datalength     blob  o  length
}
setfdodtaloblength protocoltypesandlengths  i  datalength
break
case drdaconstants drda_type_nlobcmixed
// check for a promoted clob
o   retrievepromotedparameterifexists i
if  o    null
if    clob  inputs  isstring
datalength     clob  inputs  getutf8length
else    must be a unicode stream
{
datalength     clob  inputs  length
}
else      use promoted clob
datalength     clob  o  length
}
setfdodtaloblength protocoltypesandlengths  i  datalength
break
default
throw new sqlexception netagent_ logwriter_
new clientmessageid sqlstate net_unrecognized_jdbc_type
new integer protocoltypesandlengths
new integer numvars   new integer i
}
}
}
updatelengthbytes       for fdodta
}
catch   java sql sqlexception se
{
throw new sqlexception se
}
}
// preconditions:
private void buildextdta columnmetadata parametermetadata
object inputrow
boolean chained  throws sqlexception
try
{
// build the extdta data, if necessary
if  extdtapositions_    null
boolean chainflag  chainedwithsamecorrelator
for  int i   0  i < extdtapositions_ size    i
int index     integer  extdtapositions_ get i   intvalue
// is this the last extdta to be built?
if  i    extdtapositions_ size     1       no
chainflag   true
chainedwithsamecorrelator   true
else      yes
chainflag   chained
chainedwithsamecorrelator   false
}
// do we have to write a null byte?
boolean writenullbyte   false
if  parametermetadata nullable_
writenullbyte   true
}
// use the type of the input parameter rather than the input
// column if possible.
int parametertype   parametermetadata clientparamtertype_
if  parametertype    0
parametertype   parametermetadata types_
}
// the follow types are possible due to promotion to blob
if  parametertype    types blob
parametertype    types binary
parametertype    types varbinary
parametertype    types longvarbinary
blob o    blob  retrievepromotedparameterifexists index
java sql blob b    o    null  ?  java sql blob  inputrow   o
boolean isexternalblob     b instanceof org apache derby client am blob
if  isexternalblob
try
writescalarstream chainflag
chainedwithsamecorrelator
codepoint extdta
int  b length
b getbinarystream
writenullbyte
index   1
catch  java sql sqlexception e
throw new sqlexception netagent_ logwriter_
new clientmessageid sqlstate net_error_getting_blob_length
e
}
else if    blob  b  isbinarystream
writescalarstream chainflag
chainedwithsamecorrelator
codepoint extdta
int    blob  b  length
blob  b  getbinarystream
writenullbyte
index   1
else      must be a binary string
// note: a possible optimization is to use writescalarlobbytes
//       when the input is small
//   use this: if (b.length () < dssconstants.max_dss_len - 6 - 4)
//               writescalarlobbytes (...)
// yes, this would avoid having to new up a java.io.bytearrayinputstream
writescalarstream chainflag
chainedwithsamecorrelator
codepoint extdta
int    blob  b  length
blob  b  getbinarystream
writenullbyte
index   1
}
}
// the follow types are possible due to promotion to clob
else if
parametertype    types clob
parametertype    types char
parametertype    types varchar
parametertype    types longvarchar
clob o    clob  retrievepromotedparameterifexists index
java sql clob c    o    null  ?  java sql clob  inputrow   o
boolean isexternalclob     c instanceof org apache derby client am clob
if  isexternalclob
try
writescalarstream chainflag
chainedwithsamecorrelator
codepoint extdta
int  c length
c getcharacterstream
writenullbyte
index   1
catch  java sql sqlexception e
throw new sqlexception netagent_ logwriter_
new clientmessageid sqlstate net_error_getting_blob_length
e
}
else if    clob  c  ischaracterstream
writescalarstream chainflag
chainedwithsamecorrelator
codepoint extdta
int    clob  c  length
clob  c  getcharacterstream
writenullbyte
index   1
else if    clob  c  isasciistream
writescalarstream chainflag
chainedwithsamecorrelator
codepoint extdta
int    clob  c  length
clob  c  getasciistream
writenullbyte
index   1
else if    clob  c  isunicodestream
writescalarstream chainflag
chainedwithsamecorrelator
codepoint extdta
int    clob  c  length
clob  c  getunicodestream
writenullbyte
index   1
else      must be a string
// note: a possible optimization is to use writescalarlobbytes
//       when the input is small.
//   use this: if (c.length () < dssconstants.max_dss_len - 6 - 4)
//               writescalarlobbytes (...)
writescalarstream chainflag
chainedwithsamecorrelator
codepoint extdta
int    clob  c  getutf8length
new java io bytearrayinputstream   clob  c  getutf8string
writenullbyte
index   1
}
}
}
}
}
catch   java sql sqlexception se
{
throw new sqlexception se
}
}
//-------------------------helper methods-------------------------------------
// returns the a promototedparameter object for index or null if it does not exist
private object retrievepromotedparameterifexists int index
// consider using a nonsynchronized container or array
if  promototedparameters_ isempty
return null
}
return promototedparameters_ get new integer index
}
private int calculatecolumnsinsqldtagrptriplet int numvars
if  numvars > fdocaconstants max_vars_in_ngda    rename to max_vars_in_sqldtagrp_triplet
{
return fdocaconstants max_vars_in_ngda
}
return numvars
}
// consider refacctor so that this does not even have to look
// at the actual object data, and only uses tags from the meta data
// only have to call this once, rather than calling this for every input row
// backburner: after refactoring this, later on, think about replacing case statements with table lookups
private java util hashtable computeprotocoltypesandlengths object inputrow
columnmetadata parametermetadata
int lidandlengths
java util hashtable overridemap  throws sqlexception
try
{
int numvars   parametermetadata columns_
string s   null
if   promototedparameters_ isempty
promototedparameters_ clear
}
for  int i   0  i < numvars  i
int jdbctype
// send the input type unless it is not available.
// (e.g an output parameter)
jdbctype   parametermetadata clientparamtertype_
if  jdbctype    0
jdbctype   parametermetadata types_
}
// jdbc semantics - this should happen outside of the build methods
// if describe input is not supported, we require the user to at least
// call setnull() and provide the type information.  otherwise, we won't
// be able to guess the right protocol type to send to the server, and an
// exception is thrown.
if  jdbctype    0
throw new sqlexception netagent_ logwriter_
new clientmessageid sqlstate net_invalid_jdbc_type_for_param
new integer i
}
switch  jdbctype
case java sql types char
case java sql types varchar
// lid: protocol_type_nvarmix, length override: 32767 (max)
// dataformat: string
// this won't work if 1208 is not supported
s    string  inputrow
// assumes utf-8 characters at most 3 bytes long
// flow the string as a varchar
if  s    null    s length   <  32767   3
lidandlengths   drdaconstants drda_type_nvarmix
lidandlengths   32767
else
// flow the data as clob data if the data too large to for longvarchar
java io bytearrayinputstream bais   null
byte ba   null
try
ba   s getbytes
bais   new java io bytearrayinputstream ba
clob c   new clob netagent_  bais     ba length
// inputrow[i] = c;
// place the new lob in the promototedparameter_ collection for
// netstatementrequest use
promototedparameters_ put new integer i   c
lidandlengths   drdaconstants drda_type_nlobcmixed
lidandlengths   buildplaceholderlength c length
catch  java io unsupportedencodingexception e
throw new sqlexception netagent_ logwriter_
new clientmessageid sqlstate unsupported_encoding
e
}
}
break
case java sql types integer
// lid: protocol_type_ninteger, length override: 4
// dataformat: integer
lidandlengths   drdaconstants drda_type_ninteger
lidandlengths   4
break
case java sql types boolean
case java sql types smallint
case java sql types tinyint
case java sql types bit
// lid: protocol_type_nsmall,  length override: 2
// dataformat: short
lidandlengths   drdaconstants drda_type_nsmall
lidandlengths   2
break
case java sql types real
// lid: protocol_type_nfloat4, length override: 4
// dataformat: float
lidandlengths   drdaconstants drda_type_nfloat4
lidandlengths   4
break
case java sql types double
case java sql types float
// lid: protocol_type_nfloat8, length override: 8
// dataformat: double
lidandlengths   drdaconstants drda_type_nfloat8
lidandlengths   8
break
case java sql types numeric
case java sql types decimal
// lid: protocol_type_ndecimal
// dataformat: java.math.bigdecimal
// input only:
//   if null and describe input - use describe input precision and scale
//   if not null and describe input - calculate precision and actual scale from data
//   if null and no describe input - guess with precision 1 scale 0
//   if not null and no describe input - calculate precision and actual scale from data
// output only:
//   use largest precision/scale based on registered scale from registeroutparameter
// inout:
//   if null - use largest precision/scale based on scale from registeroutparameter
//   if not null - write bigdecimal () pass registered scale so it can pad, you don't even
//      have to look at the actual scale at this level.
/*
if (parametermetadata.isguessed) {
java.math.bigdecimal bigdecimal = (java.math.bigdecimal) inputrow[i];
int precision = utils.computebigdecimalprecision (bigdecimal);
lidandlengths[i][1] = (precision << 8) + // use precision above
(bigdecimal.scale() << 0);
}
*/
// split this entire method into two parts, the first method is called only once and the inputrow is not passed,!!
// the second method is called for every inputrow and overrides inputda lengths/scales based upon the acutal data!
// for decimal and blob columns only
int precision   parametermetadata sqlprecision_
int scale   parametermetadata sqlscale_
lidandlengths   drdaconstants drda_type_ndecimal
lidandlengths    precision << 8     scale << 0
break
case java sql types date
// for input, output, and inout parameters
// lid: protocol_type_ndate, length override: 8
// dataformat: java.sql.date
lidandlengths   drdaconstants drda_type_ndate
lidandlengths   10
break
case java sql types time
// for input, output, and inout parameters
// lid: protocol_type_ntime, length override: 8
// dataformat: java.sql.time
lidandlengths   drdaconstants drda_type_ntime
lidandlengths   8
break
case java sql types timestamp
// for input, output, and inout parameters
// lid: protocol_type_ntime, length overrid: 26
// dataformat: java.sql.timestamp
lidandlengths   drdaconstants drda_type_ntimestamp
lidandlengths   26
break
case java sql types bigint
// if sqlam < 6 this should be mapped to decimal (19,0) in common layer
// if sqlam >=6, lid: protocol_type_ninteger8, length override: 8
// dataformat: long
lidandlengths   drdaconstants drda_type_ninteger8
lidandlengths   8
break
case java sql types longvarchar
// is this the right thing to do  // should this be 32700
s    string  inputrow
if  s    null    s length   <  32767   3
lidandlengths   drdaconstants drda_type_nlongmix
lidandlengths   32767
else
// flow the data as clob data if the data too large to for longvarchar
java io bytearrayinputstream bais   null
byte ba   null
try
ba   s getbytes
bais   new java io bytearrayinputstream ba
clob c   new clob netagent_  bais     ba length
// inputrow[i] = c;
// place the new lob in the promototedparameter_ collection for
// netstatementrequest use
promototedparameters_ put new integer i   c
lidandlengths   drdaconstants drda_type_nlobcmixed
lidandlengths   buildplaceholderlength c length
catch  java io unsupportedencodingexception e
throw new sqlexception netagent_ logwriter_
new clientmessageid sqlstate unsupported_encoding
}
}
break
case java sql types binary
case java sql types varbinary
byte ba    byte  inputrow
if  ba    null
lidandlengths   drdaconstants drda_type_nvarbyte
lidandlengths   32767
else if  ba length <  32767
lidandlengths   drdaconstants drda_type_nvarbyte
lidandlengths   32767
else
// promote to a blob. only reach this path in the absence of describe information.
blob b   new blob ba  netagent_  0
// inputrow[i] = b;
// place the new lob in the promototedparameter_ collection for
// netstatementrequest use
promototedparameters_ put new integer i   b
lidandlengths   drdaconstants drda_type_nlobbytes
lidandlengths   buildplaceholderlength ba length
}
break
case java sql types longvarbinary
ba    byte  inputrow
if  ba    null
lidandlengths   drdaconstants drda_type_nlongvarbyte
lidandlengths   32767
else if  ba length <  32767
lidandlengths   drdaconstants drda_type_nlongvarbyte
lidandlengths   32767
else
// promote to a blob. only reach this path in the absensce of describe information.
blob b   new blob ba  netagent_  0
// inputrow[i] = b;
// place the new lob in the promototedparameter_ collection for
// netstatementrequest use
promototedparameters_ put new integer i   b
lidandlengths   drdaconstants drda_type_nlobbytes
lidandlengths   buildplaceholderlength ba length
}
break
case java sql types blob
java sql blob b    java sql blob  inputrow
if  b    null
lidandlengths   drdaconstants drda_type_nlobbytes
lidandlengths
buildplaceholderlength parametermetadata sqllength_
else
lidandlengths   drdaconstants drda_type_nlobbytes
try
lidandlengths   buildplaceholderlength b length
catch  java sql sqlexception e
throw new sqlexception netagent_ logwriter_
new clientmessageid sqlstate net_error_getting_blob_length   e
}
}
break
case java sql types clob
{
// use columnmeta.singlemixedbyteordouble_ to decide protocoltype
java sql clob c    java sql clob  inputrow
boolean isexternalclob     c instanceof org apache derby client am clob
long loblength   0
if  c    null
loblength   parametermetadata sqllength_
else if  isexternalclob
try
loblength   c length
catch  java sql sqlexception e
throw new sqlexception netagent_ logwriter_
new clientmessageid sqlstate net_error_getting_blob_length
e
}
else
loblength     clob  c  length
}
if  c    null
lidandlengths   drdaconstants drda_type_nlobcmixed
lidandlengths   buildplaceholderlength loblength
else if  isexternalclob
lidandlengths   drdaconstants drda_type_nlobcdbcs
lidandlengths   buildplaceholderlength loblength
else if    clob  c  ischaracterstream
lidandlengths   drdaconstants drda_type_nlobcdbcs
lidandlengths   buildplaceholderlength loblength
else if    clob  c  isunicodestream
lidandlengths   drdaconstants drda_type_nlobcmixed
lidandlengths   buildplaceholderlength loblength
else if    clob  c  isasciistream
lidandlengths   drdaconstants drda_type_nlobcsbcs
lidandlengths   buildplaceholderlength loblength
else if    clob  c  isstring
lidandlengths   drdaconstants drda_type_nlobcmixed
lidandlengths   buildplaceholderlength   clob  c  getutf8length
}
}
break
default
throw new sqlexception netagent_ logwriter_
new clientmessageid sqlstate unrecognized_java_sql_type
new integer jdbctype
}
if   parametermetadata nullable_
lidandlengths
}
}
return overridemap
}
catch   java sql sqlexception se
{
throw new sqlexception se
}
}
private int buildplaceholderlength long totallength
if  totallength < 0x7fff
return 0x8002     need 2 bytes
else if  totallength < 0x7fffffff
return 0x8004     need 4 bytes
else if  totallength < 0x7fffffffffffl
return 0x8006
else
return 0x8008     need 8 bytes
}
}
// output expected indicates wheterh the requester expects the target
// sqlam to return output with an sqldtard reply data object
// as a result of the execution of the referenced sql statement.
// this is a single byte.
// there are two possible enumerated values:
// 0x'f1' (codepoint.true) - for true indicating the requester expects output
// 0x'f0' (codepoint.false) - for false indicating the requeser does not expect output
// 0x'f0' is the default.
//
// preconditions:
//   sqlam must support this parameter on the command, method will not check.
private void buildoutexp boolean outputexpected  throws sqlexception
if  outputexpected
writescalar1byte codepoint outexp  codepoint true
}
}
// maximum number of extra blocks specifies a limit on the number of extra
// blocks of answer set data per result set that the requester is capable of
// receiveing.
// this value must be able to be contained in a two byte signed number.
// there is a minimum value of 0.
// a zero indicates that the requester is not capable of receiving extra
// query blocks of answer set data.
// there is a spcval of -1.
// a value of -1 indicates that the requester is capable of receiving
// the entire result set.
//
// preconditions:
//   sqlam must support this parameter on the command, method will not check.
void buildmaxblkext int maxnumofextrablocks  throws sqlexception
if  maxnumofextrablocks    0
writescalar2bytes codepoint maxblkext  maxnumofextrablocks
}
}
// preconditions:
void buildqryrowset int fetchsize  throws sqlexception
writescalar4bytes codepoint qryrowset  fetchsize
}
// the procedure name.
// the default value of prcnam is the procedure name value contained
// within the section identified by the pkgnamcsn parameter.  if that
// value is null, then the prcnam parameter must be specified.
// it has a max length of 255.
// the prcnam is required on commands if the procedure name is
// specified by a host variable.
// the default value is the procedure name contained in the section
// specified by the pkgnamcsn parameter on the excsqlstt command.
//
// preconditions:
//   sqlam must support this parameter for the command, method will not check.
//   prcnam can not be null, sqlexception will be thrown
//   prcnam can not be 0 length or > 255 length, sqlexception will be thrown.
private void buildprcnam string prcnam  throws sqlexception
if  prcnam    null
throw new sqlexception netagent_ logwriter_
new clientmessageid sqlstate net_null_procedure_name
}
int prcnamlength   prcnam length
if   prcnamlength    0      prcnamlength > 255
throw new sqlexception netagent_ logwriter_
new clientmessageid sqlstate net_procedure_name_length_out_of_range
new integer prcnamlength   new integer 255
}
writescalarstring codepoint prcnam  prcnam
}
// query block size specifies the query block size for the reply
// data objects and the reply messages being returned from this command.
// this is a 4 byte unsigned binary number.
// the sqlam 6 min value is 512 and max value is 32767.
// this value was increased in later sqlam levels.
// until the code is ready to support larger query block sizes,
// it will always use dssconstants.max_dss_len which is 32767.
//
// preconditions:
//   sqlam must support this parameter for the command, method will not check.
void buildqryblksz   throws sqlexception
writescalar4bytes codepoint qryblksz  dssconstants max_dss_len
}
// maximum result set count specifies a limit on the number of result sets
// the requester is capable of receiving as reply data in response to an ecsqlstt
// command that invokes a stored procedure.  if the stored procedure generates
// more than maxrslcnt result sets, then the target system returns at most, the first
// maxrslcnt of these result sets.  the stored procedure defines the order
// in which the target system returns result sets.
// this is s two byte signed binary number.
// it has a min value of 0 which indicates the requester is not capable
// of receiving result sets as reply data in response to the command.
// a special value, -1 (codepoint.maxrslcnt_nolimit = 0xffff), indicates the
// requester is capable of receiving all result sets in response the excsqlstt.
//
// preconditions:
//   sqlam must support this parameter for the command, method will not check.
//   the value must be in correct range (-1 to 32767), method will not check.
private void buildmaxrslcnt int maxresultsetcount  throws sqlexception
if  maxresultsetcount    0
return
}
writescalar2bytes codepoint maxrslcnt  maxresultsetcount
}
// rdb commit allowed specifies whether an rdb should allow the processing of any
// commit or rollback operations that occure during execution of a statement.
// true allow the processing of commits and rollbacks
private void buildrdbcmtok   throws sqlexception
writescalar1byte codepoint rdbcmtok  codepoint true
}
// result set flags is a single byte where each bit it a boolean flag.
// it specifies wheter the requester desires the server to return name,
// label and comment information for the columns of result sets generated by the command.
// the default is b'00000000'.
// columnnamesrequired
//    false means the requester does not desire column names returned.
//    true means the requester desires column names returned.
// columnlabelsrequired
//    false means the requester does not desire column labels returned.
//    true means the requester desires column labels returned.
// columncommentsrequired
//    false means the requester does not desire column comments returned.
//    true means the requester desired column comments returned.
// cantprocessanswersetdata
//    false means that for each result set, the requester expects the command
//    to return an fdoca description of the answer set data and to possibly
//    return answer set data.  the block containing the end of the description
//    may be completed if room exists with answer set data.  additional blocks
//    of answer set data may also be chained to the block containing the end of the
//    fdoca description.  up to the maximum number of extra blocks of answer set data
//    per result set specified in the maxblkext parameter.
//    true means that for each result set, the requester expects the command to return
//    an fdoca description of the answer set data but does not expect the command to
//    return any answer set data.
// at sqlam 7, new flags are supported which can be used to return
// standard, extended, and light sqlda
//
// preconditions:
//    sqlam must support this parameter, method will not check.
private void buildrslsetflg int resultsetflag  throws sqlexception
writescalar1byte codepoint rslsetflg  resultsetflag
}
void buildqryinsid long qryinsid  throws sqlexception
marklengthbytes codepoint qryinsid
writelong qryinsid
updatelengthbytes
}
// return sql descriptor area controls whether to return
// an sql descriptor area that applies to the sql statement this command
// identifies.  the target sqlam obtains the sql descriptor area by performing
// an sql describe function on the statement after the statement has been
// prepared.
// the value true, x'f1' (codepoint.true), indicates an sqlda is returned
// the value false, x'f0' (codepoint.false), default, indicates an sqlda is not returned.
//
// preconditions:
//   sqlam must support this parameter for the command, method will not check.
private void buildrtnsqlda   throws sqlexception
writescalar1byte codepoint rtnsqlda  codepoint true
}
// type of sql descriptor area.
// this is a single byte signed number that specifies the type of sqlda to
// return for the command.
// below sqlam 7 there were two possible enumerated values for this parameter.
// 0 (codepoint.typsqlda_std_output)- the default, indicates return the output sqlda.
// 1 (codepoint.typsqlda_std_input) - indicates return the input sqlda.
// the typsqlda was enhanced at sqlam 7 to support extened describe.
// at sqlam 7 the following enumerated values are supported.
// 0 (codepoint.typsqlda_std_output) - the default, standard output sqlda.
// 1 (codepoint.typsqlda_std_input) - standard input sqlda.
// 2 (codepoint.typsqlda_light_output) - light output sqlda.
// 3 (codepoint.typsqlda_light_input) - light input sqlda.
// 4 (codepoint.typsqlda_x_output) - extended output sqlda.
// 5 (codepoint.typsqlda_x_input) - extended input sqlda.
//
// preconditions:
//   sqlam or prdid must support this, method will not check.
//   valid enumerated type must be passed to method, method will not check.
private void buildtypsqlda int typesqlda  throws sqlexception
// possibly inspect typesqlda value and verify against sqlam level
if  typesqlda    codepoint typsqlda_std_output
writescalar1byte codepoint typsqlda  typesqlda
}
}
/**
* build qryclsimp (query close implicit). query close implicit
* controls whether the target server implicitly closes a
* non-scrollable query upon end of data (sqlstate 02000).
*/
private void buildqryclsimp
writescalar1byte codepoint qryclsimp  codepoint qryclsimp_yes
}
// helper method to buildfdodta to build the actual data length
private void setfdodtaloblength int protocoltypesandlengths  int i  long datalength  throws sqlexception
if  protocoltypesandlengths    0x8002
writeshort  short  datalength
else if  protocoltypesandlengths    0x8004
writeint  int  datalength       4 bytes to encode the length
else if  protocoltypesandlengths    0x8006    6 bytes to encode the length
{
writelong datalength
}
//throw new sqlexception (netagent_.logwriter_, "0x8006 lob place holders not yet supported");
else if  protocoltypesandlengths    0x8008    8 bytes to encode the length
{
writelong datalength
}
if  datalength    0
if  extdtapositions_    null
extdtapositions_   new java util arraylist
}
extdtapositions_ add new integer i
}
}
private boolean checksendqryrowset int fetchsize
int resultsettype
// if the cursor is forward_only, ignore the fetchsize and let the server return
// as many rows as fit in the query block.
// if the cursor is scrollable, send qryrowset if it is supported by the server
boolean sendqryrowset   false
if  resultsettype    java sql resultset type_forward_only
sendqryrowset   true
}
return sendqryrowset
}
private int checkfetchsize int fetchsize  int resultsettype
// if fetchsize is not set for scrollable cursors, set it to the default fetchsize
if  resultsettype    java sql resultset type_forward_only    fetchsize    0
fetchsize   org apache derby client am configuration defaultfetchsize
}
return fetchsize
}
private int calculateresultsetflags
return codepoint rslsetflg_extended_sqlda
}
public void writesetspecialregister java util arraylist sqlsttlist  throws sqlexception
section section
netagent_ sectionmanager_ getdynamicsection java sql resultset hold_cursors_over_commit
buildexcsqlset section
// sqlstt:
for (int i = 0; i < sqlsttlist.size(); i++) {
buildsqlsttcommanddata  string  sqlsttlist get i
}
}
private int allocatelidandlengthsarray columnmetadata parametermetadata
int numvars   parametermetadata columns_
int lidandlengths   parametermetadata protocoltypescache_
if   lidandlengths     null     lidandlengths length    numvars
lidandlengths   new int
parametermetadata protocoltypescache_   lidandlengths
}
return lidandlengths
}
private void buildmddoverrides java util arraylist sdaoverrides  throws sqlexception
byte mddbytes
for  int i   0  i < sdaoverrides size    i
mddbytes    byte   sdaoverrides get i
writebytes mddbytes
}
}
private int getnextoverridelid
return overridelid_
}
}