/*
derby - class org.apache.derby.impl.sql.compile.costestimateimpl
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl sql compile
import org apache derby iapi sql compile costestimate
import org apache derby iapi store access storecostresult
import org apache derby iapi services sanity sanitymanager
public class costestimateimpl implements costestimate
public double	cost
public double	rowcount
public double	singlescanrowcount
public costestimateimpl
public costestimateimpl double thecost
double therowcount
double thesinglescanrowcount
if  sanitymanager debug
if  thecost < 0 0
therowcount < 0 0
thesinglescanrowcount < 0 0
sanitymanager throwassert
thecost
therowcount
thesinglescanrowcount
this cost   thecost
this rowcount   therowcount
this singlescanrowcount   thesinglescanrowcount
/** @see costestimate#setcost */
public void setcost double cost  double rowcount
double singlescanrowcount
if  sanitymanager debug
if  cost < 0 0
rowcount < 0 0
singlescanrowcount < 0 0
sanitymanager throwassert
cost
rowcount
singlescanrowcount
this cost   cost
this rowcount   rowcount
this singlescanrowcount   singlescanrowcount
/** @see costestimate#setcost */
public void setcost costestimate other
cost   other getestimatedcost
rowcount   other rowcount
singlescanrowcount   other singlescanrowcount
/** @see costestimate#setsinglescanrowcount */
public void setsinglescanrowcount double singlescanrowcount
if  sanitymanager debug
if  singlescanrowcount < 0 0
sanitymanager throwassert
singlescanrowcount
this singlescanrowcount   singlescanrowcount
/** @see costestimate#compare */
public double compare costestimate other
if  sanitymanager debug
if  other    null
sanitymanager throwassert
if      other instanceof costestimateimpl
sanitymanager throwassert other getclass   getname
/* note: if both costestimates are infinity, an attempt to
* substract them will result in nan, which tells us nothing
* and thus makes it impossible to do a comparison.  so in
* that case we fallback and check the row counts as a secondary
* point of comparison, and the singlescanrowcounts as a
* third comparison.  if all three values are infinity
* for both costestimates then we just consider the two
* costs to equal (equally as bad?) and so return 0.0d (instead
* nan).  resolve: ideally the optimizer could be updated
* to give more reasonable estimates than infinity, but
* until that happens we're forced to deal with such
* comparisons.  note that we're most likely to end up with
* infinite cost estimates in situations where we have deeply
* nested subqueries and/or from lists with a large number of
* fromtables (such as 10 or more). the reason is that each
* fromtable's cost estimate is (potentially) multiplied by
* the row counts of all preceding fromtables, so if the
* row counts for the preceding fromtables are large, we
* can eventually end up going beyond double.max_value,
* which then gives us infinity.
*/
// if at least one of costs is _not_ infinity, then just do
// a normal compare (the other side is less).
if   this cost    double positive_infinity
other getestimatedcost      double positive_infinity
return this cost     costestimateimpl  other  cost
// if both costs are infinity, then compare row counts.
if   this rowcount    double positive_infinity
other rowcount      double positive_infinity
return this rowcount   other rowcount
// if both row counts are infinity, try singlescan counts.
if   this singlescanrowcount    double positive_infinity
other singlescanrowcount      double positive_infinity
return this singlescanrowcount   other singlescanrowcount
// if we get here, all three parts of both cost estimates are
// infinity; for lack of better choice, just say they're "equal".
return 0 0d
/** @see costestimate#add */
public costestimate add costestimate other  costestimate retval
if  sanitymanager debug
sanitymanager assert other instanceof costestimateimpl
sanitymanager assert retval    null
retval instanceof costestimateimpl
costestimateimpl	addend    costestimateimpl  other
double sumcost   this cost   addend cost
double sumrowcount   this rowcount   addend rowcount
if  sanitymanager debug
if  sumcost < 0 0
sumrowcount < 0 0
sanitymanager throwassert
this cost
addend cost
sumcost
this rowcount
addend rowcount
sumrowcount
/* presume that ordering is not maintained */
return setstate sumcost
sumrowcount
costestimateimpl  retval
/** @see costestimate#multiply */
public costestimate multiply double multiplicand  costestimate retval
if  sanitymanager debug
sanitymanager assert retval    null
retval instanceof costestimateimpl
double multcost   this cost   multiplicand
double multrowcount   this rowcount   multiplicand
if  sanitymanager debug
if  multcost < 0 0
multrowcount < 0 0
sanitymanager throwassert
this cost
multiplicand
multcost
this rowcount
multrowcount
/* presume that ordering is not maintained */
return setstate multcost
multrowcount
costestimateimpl  retval
/** @see costestimate#divide */
public costestimate divide double divisor  costestimate retval
if  sanitymanager debug
sanitymanager assert retval    null
retval instanceof costestimateimpl
double divcost   this cost   divisor
double divrowcount   this rowcount   divisor
if  sanitymanager debug
if  divcost < 0 0
divrowcount < 0 0
sanitymanager throwassert
this cost
divisor
divcost
this rowcount
divrowcount
/* presume that ordering is not maintained */
return setstate divcost
divrowcount
costestimateimpl  retval
/** @see costestimate#rowcount */
public double rowcount
return rowcount
/** @see costestimate#singlescanrowcount */
public double singlescanrowcount
return singlescanrowcount
/** @see costestimate#cloneme */
public costestimate cloneme
return new costestimateimpl cost
rowcount
singlescanrowcount
/** @see costestimate#isuninitialized */
public boolean isuninitialized
return  cost    double max_value
rowcount    double max_value
singlescanrowcount    double max_value
/** @see storecostresult#getestimatedcost */
public double getestimatedcost
return cost
/** @see storecostresult#setestimatedcost */
public void setestimatedcost double cost
this cost   cost
/** @see storecostresult#getestimatedrowcount */
public long getestimatedrowcount
return  long  rowcount
/** @see storecostresult#setestimatedrowcount */
public void setestimatedrowcount long count
/* this method is called by the store to
* give us the estimate for the # of rows
* returned in a scan.  so, we set both
* rowcount and singlescanrowcount here.
*/
rowcount    double  count
singlescanrowcount    double  count
public costestimateimpl setstate double thecost
double therowcount
costestimateimpl retval
if  retval    null
retval   new costestimateimpl
retval cost   thecost
retval rowcount   therowcount
return retval