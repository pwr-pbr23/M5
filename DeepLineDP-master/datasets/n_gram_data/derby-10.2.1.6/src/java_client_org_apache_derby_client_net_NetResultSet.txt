/*
derby - class org.apache.derby.client.net.netresultset
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby client net
import org apache derby client am cursor
import org apache derby client am disconnectexception
import org apache derby client am section
import org apache derby client am sqlexception
public class netresultset extends org apache derby client am resultset
// alias for (netconnection) super.statement.connection
private final netconnection netconnection_
// alias for (netstatement) super.statement
private final netstatement netstatement_
// alias for (netcursor) super.cursor
final netcursor netcursor_
// alias for (netagent) super.agent
final private netagent netagent_
// indicates whether the fixed row protocol is being used. if so,
// the fetch size will always be 1.
private boolean isfixedrowprotocol   false
//-----------------------------state------------------------------------------
// this is used to avoid sending multiple outovr over subsequent next()'s
public boolean firstoutovrbuilt_   false
//---------------------constructors/finalizer---------------------------------
// parseopnqrym() is called right after this constructor is called.
netresultset netagent netagent
netstatement netstatement
cursor cursor
int qryprctyp     protocoltype  codepoint fixrowprc
//              codepoint.lmtblkprc
int sqlcsrhld     holdoption  0xf0 for false  default    0xf1 for true
int qryattscr     scrolloption  0xf0 for false  default    0xf1 for true
int qryattsns     sensitivity  codepoint qryunk
//              codepoint.qryins |
//              codepoint.qrysnsstc
int qryattset     rowsetcursor  0xf0 for false  default    0xf1 for true
long qryinsid     instanceidentifier  0  if not returned  check default  or number
int actualresultsettype
int actualresultsetconcurrency
int actualresultsetholdability    throws disconnectexception
super netagent
netstatement statement_
//new netcursor (netagent, qryprctyp),
cursor
// call the constructor with the real resultsettype and resultsetconcurrency
// returned from the server
actualresultsettype
actualresultsetconcurrency
actualresultsetholdability
netagent_   netagent
// set up cheat-links
netcursor_    netcursor  cursor_
netstatement_   netstatement
netconnection_   netstatement netconnection_
netcursor_ netresultset_   this
cursorhold_    sqlcsrhld    0xf0
if  qryattscr    0xf1
scrollable_   true
// the number of rows returned by the server will always be 1 when the
// fixed row protocol is being used.
if  qryprctyp    codepoint fixrowprc
isfixedrowprotocol   true
fetchsize_   1
else
fetchsize_   suggestedfetchsize_
switch  qryattsns
case codepoint qryunk
sensitivity_   sensitivity_unknown__
break
case codepoint qryins
sensitivity_   sensitivity_insensitive__
break
case codepoint qrysnsstc
sensitivity_   sensitivity_sensitive_static__
break
default       shouldn't happen
break
if  qryattset    0xf1
isrowsetcursor_   true
queryinstanceidentifier_   qryinsid
nestinglevel_    int    queryinstanceidentifier_ >>> 48    0xffff
//-------------------------------flow methods---------------------------------
// go through the qrydta's received, and calculate the column offsets for each row.
protected void parserowset_   throws sqlexception
int row   0
// parse all the rows received in the rowset
// the index we are passing will keep track of which row in the rowset we are parsing
// so we can reuse the columndataposition/length/isnull arrays.
while  netcursor_ calculatecolumnoffsetsforrow_ row  true
rowsreceivedincurrentrowset_
row
// if rowset is not complete and an endqryrm was received, will skip the while loop
// and go to the checkandthrow method.  otherwise flow an cntqry to try to complete
// the rowset.
// -- there is no need to complete the rowset for rowset cursors.  fetching stops when
//    the end of data is returned or when an error occurs.  all successfully fetched rows
//    are returned to the user.  the specific error is not returned until the next fetch.
while  rowsreceivedincurrentrowset_    fetchsize_
netcursor_ allrowsreceivedfromserver       isrowsetcursor_
sensitivity_    sensitivity_sensitive_dynamic__
sensitivity_    sensitivity_sensitive_static__
flowfetchtocompleterowset
while  netcursor_ calculatecolumnoffsetsforrow_ row  true
rowsreceivedincurrentrowset_
row
checkandthrowreceivedqueryterminatingexception
public void setfetchsize_ int rows
// do not change the fetchsize for fixed row protocol
suggestedfetchsize_    rows    0  ? 64   rows
if   isfixedrowprotocol
fetchsize_   suggestedfetchsize_
//-----------------------------helper methods---------------------------------
void flowfetchtocompleterowset   throws disconnectexception
try
agent_ beginwritechain statement_
writescrollablefetch_  generatedsection_    null  ? statement_ section_   generatedsection_
fetchsize_   rowsreceivedincurrentrowset_
scrollorientation_relative__
1
false       false means do not disard pending
// partial row and pending query blocks
agent_ flow statement_
readscrollablefetch_
agent_ endreadchain
catch  sqlexception e
throw new disconnectexception agent_  e
void querydatawasreturnedonopen   throws disconnectexception
// ------------------------------- abstract box car methods --------------------------------------
public void writefetch_ section section  throws sqlexception
if  resultsettype_    java sql resultset type_forward_only    fetchsize_    0
rowsyettobereceivedforrowset_ > 0
netagent_ resultsetrequest_ writefetch this
section
rowsyettobereceivedforrowset_
else
netagent_ resultsetrequest_ writefetch this
section
fetchsize_
public void readfetch_   throws sqlexception
netagent_ resultsetreply_ readfetch this
public void writescrollablefetch_ section section
int fetchsize
int orientation
long rowtofetch
boolean resetqueryblocks  throws sqlexception
netagent_ resultsetrequest_ writescrollablefetch this
section
fetchsize
orientation
rowtofetch
resetqueryblocks
// think about splitting out the position cursor stuff from the fetch stuff
// use commented out abstract position cursor methods above
public void readscrollablefetch_   throws sqlexception
netagent_ resultsetreply_ readscrollablefetch this
public void writepositioningfetch_ section section
int orientation
long rowtofetch  throws sqlexception
netagent_ resultsetrequest_ writepositioningfetch this
section
orientation
rowtofetch
public void readpositioningfetch_   throws sqlexception
netagent_ resultsetreply_ readpositioningfetch this
public void writecursorclose_ section section  throws sqlexception
netagent_ resultsetrequest_ writecursorclose this  section
public void readcursorclose_   throws sqlexception
netagent_ resultsetreply_ readcursorclose this
/**
* method that is invoked by <code>closex()</code> before the
* result set is actually being closed. if qryclsimp is enabled on
* the cursor, scan data buffer for end of data (sql state
* 02000). if end of data is received, the result set is closed on
* the server.
*
* @exception sqlexception
*/
protected void preclose_   throws sqlexception
if  netcursor_ getqryclsimpenabled
netcursor_ scandatabufferforendofdata