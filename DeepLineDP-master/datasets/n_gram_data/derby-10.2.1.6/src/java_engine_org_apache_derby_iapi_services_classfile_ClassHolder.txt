/*
derby - class org.apache.derby.iapi.services.classfile.classholder
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby iapi services classfile
import org apache derby iapi services sanity sanitymanager
import java io inputstream
import java io outputstream
import java util enumeration
import java io ioexception
import java util vector
import org apache derby iapi util bytearray
import org apache derby iapi services classfile vmdescriptor
import org apache derby iapi services classfile vmdescriptor
import java util hashtable
import java util vector
import java util enumeration
/** based upon "the class file format" chapter of "the java virtual machine specification"
corresponding to version 1.0.2 of the java virtual machine and 1.0.2 of the
java language specification.
isbn  0-201-63452-x, september 1996.
*/
public class classholder
/*
** constants.
*/
/*
** fields
*/
protected int access_flags
protected int this_class
protected int super_class
// protected interfacesarray interfaces; // can be null
protected int interfaces    can be null
protected membertable field_info     can be null
protected membertable method_info 	   can be null
protected attributes attribute_info     can be null
/*
** fields for constant pool table
*/
protected hashtable cpthashtable
protected vector cptentries
private int cptestimatedsize
/**
used to search for index entries to avoid object allocation
in the case a referecne already exists.
*/
private final constant_index_info	searchindex   new constant_index_info 0  0  0
/*
**	constructors.
*/
protected classholder int estimatedconstantpoolcount
// constant pool information
// 100 is the estimate of the number of entries that will be generated
cptentries   new vector estimatedconstantpoolcount
cpthashtable   new hashtable estimatedconstantpoolcount   float 0 75
// reserve the 0'th constant pool entry
cptentries setsize 1
}
/**
this will not define a constructor -- it is up
to the caller to add at least one.
*/
public classholder string fullyqualifiedname  string superclassname
int modifiers
this 100
access_flags   modifiers      modifier super    0x0020
this_class   addclassreference fullyqualifiedname
super_class   addclassreference superclassname
method_info   new membertable 0
}
private void put classformatoutput out  throws ioexception
/* write out the header */
out putu4 vmdescriptor java_class_format_magic
out putu2 vmdescriptor java_class_format_minor_version
out putu2 vmdescriptor java_class_format_major_version
// special case checking that the number of constant
// pool entries does not exceed the limit of 65535
// (as it is stored as a u2).
// special case to allow somewhat easier debugging
// of the resulting failure.
out putu2    cptentries size
cptput out
out putu2 access_flags
out putu2 this_class
out putu2 super_class
if  interfaces    null
int ilen   interfaces length
out putu2 ilen
for  int i   0  i < ilen  i
out putu2 interfaces
}
else
out putu2 0
}
if  field_info    null
out putu2 field_info size
field_info put out
else
out putu2 0
}
if  method_info    null
out putu2 method_info size
method_info put out
else
out putu2 0
}
if  attribute_info    null
out putu2 attribute_info size
attribute_info put out
else
out putu2 0
}
}
/*
**	public methods from classholder.
*/
/**
* convert the object representation of the class into
* its class file format.
* @exception ioexception error writing the class
*/
public bytearray getfileformat   throws ioexception
int classfilesize   4    10   2
classfilesize    cptestimatedsize
if  interfaces    null
classfilesize     interfaces length   2
if  field_info    null
classfilesize    field_info classfilesize
if  method_info    null
classfilesize    method_info classfilesize
if  attribute_info    null
classfilesize    attribute_info classfilesize
classformatoutput cfo   new classformatoutput classfilesize   200
put cfo
return new bytearray cfo getdata    0  cfo size
}
/*
** public methods from classmember
*/
/** @see classmember
*/
public int getmodifier     return access_flags
/** @see classmember
*/
public string getname
return classname this_class  replace
}
/*
**	public methods from classholder
*/
/** @see classholder#addmember */
public classmember addmember string simplename  string descriptor  int modifier
if  sanitymanager debug
if  descriptor startswith
if  method_info    null
if  method_info find simplename  descriptor     null
sanitymanager throwassert     simplename       descriptor
}
}
else
if  field_info    null
if  field_info find simplename  descriptor     null
sanitymanager throwassert     simplename       descriptor
}
}
}
}
constant_utf8_info utf   addutf8entry simplename
int nameindex   utf getindex
int descriptorindex   addutf8entry descriptor  getindex
classmember item   new classmember this  modifier  nameindex  descriptorindex
membertable mt
if  descriptor startswith
mt   method_info
if  mt    null
mt   method_info   new membertable 0
}
else
mt   field_info
if  mt    null
mt   field_info   new membertable 0
}
mt addentry item
return item
}
/** @see classholder#addfieldreference */
public int addfieldreference string classname  string simplename  string descriptor
return addreference vmdescriptor constant_fieldref  classname  simplename  descriptor
}
public int addfieldreference classmember field
return addreference vmdescriptor constant_fieldref   classmember  field
}
/** @see classholder#addmethodreference */
public int addmethodreference string classname  string simplename  string descriptor  boolean isinterface
int tag   isinterface ?	vmdescriptor constant_interfacemethodref
vmdescriptor constant_methodref
return addreference tag  classname  simplename  descriptor
}
private int addreference int tag  string classname  string simplename  string descriptor
int classindex   addclassreference classname
int nametypeindex   addnameandtype simplename  descriptor
return addindexreference tag  classindex  nametypeindex
}
private int addreference int tag  classmember member
int nametypeindex   addindexreference vmdescriptor constant_nameandtype
member name_index  member descriptor_index
return addindexreference tag  this_class  nametypeindex
}
/** @see classholder#addconstant */
public int addconstant string value
return addstring value
}
/** @see classholder#addutf8 */
public int addutf8 string value
return addutf8entry value  getindex
}
/** @see classholder#addconstant */
public int addconstant int value
return adddirectentry new constant_integer_info value
}
/** @see classholder#addconstant */
public int addconstant float value
return adddirectentry new constant_float_info value
}
/** @see classholder#addconstant */
public int addconstant long value
return adddirectentry new constant_long_info value
}
/** @see classholder#addconstant */
public int addconstant double value
return adddirectentry new constant_double_info value
}
/** @see classmember
*/
public int getconstantpoolindex     return this_class
public void addattribute string attributename  classformatoutput info
if  attribute_info    null
attribute_info   new attributes 1
constant_utf8_info autf   addutf8entry attributename
int index   autf getindex
attribute_info addentry new attributeentry index  info
}
public string getsuperclassname
if  super_class    0
return null;
else
return classname super_class  replace
}
/*
public classmember getmemberreference(string fullyqualifiedclassname, string simplename, string descriptor) {
int classindex;
if (fullyqualifiedclassname == null)
classindex = this_class;
else
classindex = constantpool.findclass(fullyqualifiedclassname);
if (classindex < 0)
return null;
int nameandtypeindex = constantpool.findnameandtype(simplename, descriptor);
if (nameandtypeindex < 0)
return null;
return constantpool.findreference(classindex, nameandtypeindex);
}
*/
/*
** public methods from classread
*/
/*
** implementation specific methods.
*/
/*
** methods related to constant pool table
*/
/**
generic add entry to constant pool. includes the logic
for an entry to occupy more than one slot (e.g. long).
@return the number of slots occupied by the entry.
.
*/
protected int addentry object key  constantpoolentry item
item setindex cptentries size
if  key    null
cpthashtable put key  item
cptentries addelement item
cptestimatedsize    item classfilesize
if  item doubleslot
cptentries addelement null
return 2
else
return 1
}
}
/**
add an entry, but only if it doesn't exist.
@return the constant pool index of the added
or existing item.
*/
private int adddirectentry constantpoolentry item
constantpoolentry existingitem   findmatchingentry item
if  existingitem    null
item   existingitem
//foundcount++;
}
else
addentry item getkey    item
}
return item getindex
}
/**
add an index reference.
*/
private int addindexreference int tag  int i1  int i2
// search for the item using the pre-allocated object
searchindex set tag  i1  i2
constantpoolentry item   findmatchingentry searchindex
if (item == null) {
item   new constant_index_info tag  i1  i2
addentry item getkey    item
}
return item getindex
}
/**
add a class entry to the pool.
*/
public int addclassreference string fullyqualifiedname
if  classholder isexternalclassname fullyqualifiedname
fullyqualifiedname   classholder converttointernalclassname fullyqualifiedname
// system.out.println("addclassreference " + fullyqualifiedname);
}
int name_index   addutf8entry fullyqualifiedname  getindex
return addindexreference vmdescriptor constant_class  name_index  0
}
/**
add a name and type entry
*/
private int addnameandtype string name  string descriptor
int nameindex   addutf8entry name  getindex
int descriptorindex   addutf8entry descriptor  getindex
return addindexreference vmdescriptor constant_nameandtype  nameindex  descriptorindex
}
/**
add a utf8 into the pool and return the index to it.
*/
private constant_utf8_info addutf8entry string value
constant_utf8_info item    constant_utf8_info  findmatchingentry value
if (item == null) {
item   new constant_utf8_info value
addentry value  item
}
return item
}
/**
add an extra utf8 into the pool
*/
private constant_utf8_info addextrautf8 string value
constant_utf8_info item   new constant_utf8_info value
addentry null  item
return item
}
/**
add a string entry
*/
private int addstring string value
constant_utf8_info sutf   addutf8entry value
int valueindex   sutf setasstring
if  valueindex    0
// string is already being used as code
valueindex   addextrautf8 value  getindex
sutf setalternative valueindex
}
return addindexreference vmdescriptor constant_string  valueindex  0
}
/**
add a string entry
*/
private int addcodeutf8 string value
constant_utf8_info sutf   addutf8entry value
int index   sutf setascode
if  index    0
// code string is already being used as string
constant_utf8_info eutf   addextrautf8 value
eutf setascode       ensure the replace will happen
index   eutf getindex
sutf setalternative index
}
return index
}
protected void cptput classformatoutput out  throws ioexception
for  enumeration e   cptentries elements    e hasmoreelements
constantpoolentry item    constantpoolentry  e nextelement
if (item == null) {
continue
}
item put out
}
}
/*
** methods to convert indexes to constant pool entries and vice-versa.
*/
public constantpoolentry getentry int index
return  constantpoolentry  cptentries elementat index
}
/**
return the class name for an index to a constant_class_info.
*/
protected string classname int classindex
constant_index_info ci    constant_index_info  getentry classindex
return nameindextostring ci geti1    replace
}
/*
** methods to find specific types of constant pool entries.
in these methods we try to avoid using the constantpoolentry.matchvalue()
as that requires creating a new object for the search. the matchvalue()
call is really intended for when objects are being added to the constant pool.
*/
/**
return the index of a utf entry or -1 if it doesn't exist.
*/
int findutf8 string value
constantpoolentry item   findmatchingentry value
if (item == null)
return  1
return item getindex
}
/**
find a class descriptor (section 4.4.1) and return its
index, returns -1 if not found.
*/
public int findclass string fullyqualifiedname
string internalname   classholder converttointernalclassname fullyqualifiedname
int utf_index   findutf8 internalname
if  utf_index < 0
return  1
return findindexindex vmdescriptor constant_class
utf_index  0
}
/**
find a name and type descriptor (section 4.4.6) and
return it's index.
<p>
returns -1 if not found.
*/
public int findnameandtype string name  string descriptor
int name_index   findutf8 name
if  name_index < 0
return  1
int descriptor_index   findutf8 descriptor
if  descriptor_index < 0
return  1
return findindexindex vmdescriptor constant_nameandtype
name_index  descriptor_index
}
/*
public classmember findreference(int classindex, int nameandtypeindex) {
constant_index_info item = findindexentry(vmdescriptor.constant_methodref,
classindex, nameandtypeindex);
if (item == null) {
item = findindexentry(vmdescriptor.constant_interfacemethodref,
classindex, nameandtypeindex);
if (item == null) {
item = findindexentry(vmdescriptor.constant_fieldref,
classindex, nameandtypeindex);
if (item == null)
return null;
}
}
return new referencemember(this, item);
}
*/
protected constant_index_info findindexentry int tag  int i1  int i2
// search for the item using the pre-allocated object
searchindex set tag  i1  i2
return  constant_index_info  findmatchingentry searchindex
}
protected int findindexindex int tag  int i1  int i2
constant_index_info item   findindexentry tag  i1  i2
if (item == null)
return  1
return item getindex
}
protected constantpoolentry findmatchingentry object key
return  constantpoolentry  cpthashtable get key
}
/** get a string (utf) given a name_index into the constant pool
*/
string nameindextostring int index
return getentry index  tostring
}
/** get the class name of a class given the index of its constant_class_info
entry in the constant pool.
*/
protected string getclassname int index
if  index    0
return       must be the super class of java lang object  ie  nothing
return 	nameindextostring getentry index  geti1
}
/*
* determine whether the class descriptor string is
* in external format or not.  assumes that to be in external
* format means it must have a '.' or end in an ']'.
*
* @param classname	the name of the class to check
*
* @return true/false
*/
public static boolean isexternalclassname string classname
int len
if  classname indexof        1
return true
}
else if   len   classname length       0
return false
}
return  classname charat len   1
}
/*
* convert a class name to the internal vm class name format.
see sections 4.3.2, 4.4.1 of the vm spec.
* the normal leading 'l' and trailing ';' are left
* off of objects.  this is intended primarily for
* the class manager.
* <p>
* an example of a conversion would be java.lang.double[]
* to "[ljava/lang/double;".
<br>
java.lang.double would be converted to "java/lang/double"
<br>
note that for array types the result of converttointernalclassname()
and converttointernaldescriptor() are identical.
*
* @param the external name (cannot be null)
*
* @return the internal string
*/
public static string converttointernalclassname string externalname
return converttointernal externalname  false
}
/*
* convert a class name to internal jvm descriptor format.
see sections 4.3.2 of the vm spec.
* <p>
* an example of a conversion would be "java.lang.double[]"
* to "[ljava/lang/double;".
*
<br>
java.lang.double would be converted to "ljava/lang/double;"
<br>
note that for array types the result of converttointernalclassname()
and converttointernaldescriptor() are identical.
* @param the external name (cannot be null)
*
* @return the internal string
*/
public static string converttointernaldescriptor string externalname
return converttointernal externalname  true
}
/*
** workhorse method.  convert to internal format.
@param descriptor true if converting to descriptor format, false if
converting to class name format.
**
** lifted from bcclass.java.
**
** returns the result string.
*/
private static string converttointernal string externalname  boolean descriptor
if  sanitymanager debug
sanitymanager assert externalname    null
}
int len   externalname length
string internalname
string retval   null
int origlen   len
int arity   0
// first walk through all array-ness
if  externalname charat len 1
while  len > 0
externalname charat len 1
externalname charat len 2
len    2
arity
}
}
if  sanitymanager debug
sanitymanager assert len > 0
}
internalname    origlen    len ?
externalname
externalname substring 0 len
// then check for primitive types ...
// in length by expected frequency order
switch  len
case 7
if    equals internalname
retval   makedesc vmdescriptor c_boolean  arity
}
break
case 4
if    equals internalname
retval   makedesc vmdescriptor c_void  arity
}
else if    equals internalname
retval   makedesc vmdescriptor c_long  arity
}
else if    equals internalname
retval   makedesc vmdescriptor c_byte  arity
}
else if    equals internalname
retval   makedesc vmdescriptor c_char  arity
}
break
case 3
if    equals internalname
retval   makedesc vmdescriptor c_int  arity
}
break
case 6
if    equals internalname
retval   makedesc vmdescriptor c_double  arity
}
break
case 5
if    equals internalname
retval   makedesc vmdescriptor c_short  arity
}
else if    equals internalname
retval   makedesc vmdescriptor c_float  arity
}
break
}
// then it must be a java class
if  retval    null
retval   makedesc internalname  arity  descriptor
return retval
}
/**
a helper to build a type description based on a built-in type
and an array arity.
*/
static private string makedesc  char builtin  int arity
if  arity    0
switch  builtin
case vmdescriptor c_byte   return vmdescriptor byte
case vmdescriptor c_char   return vmdescriptor char
case vmdescriptor c_double   return vmdescriptor double
case vmdescriptor c_float   return vmdescriptor float
case vmdescriptor c_int   return vmdescriptor int
case vmdescriptor c_long   return vmdescriptor long
case vmdescriptor c_short   return vmdescriptor short
case vmdescriptor c_boolean   return vmdescriptor boolean
case vmdescriptor c_void   return vmdescriptor void
default
if  sanitymanager debug
sanitymanager throwassert
return null;
}
else
stringbuffer desc   new stringbuffer arity 3
for  int i 0 i<arity i
desc append vmdescriptor c_array
desc append classholder makedesc builtin  0
return desc tostring
}
}
/**
a helper to build a type description based on a java class
and an array arity.
if descriptor is true create a descriptor according to
section 4.3.2 of the vm spec. if false create a class name
according to sections 4.3.2 and 4.4.1 of the vm spec.
*/
static private string makedesc  string classname  int arity  boolean descriptor
if   descriptor     arity    0
return classname replace
}
stringbuffer desc   new stringbuffer arity 2 classname length
for  int i 0 i<arity i
desc append vmdescriptor c_array
desc append vmdescriptor c_class
desc append classname replace
desc append vmdescriptor c_endclass
return desc tostring
}
}