/*
derby - class org.apache.derby.impl.services.locks.lockcontrol
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl services locks
import org apache derby iapi services locks lockable
import org apache derby iapi services locks latch
import org apache derby iapi services sanity sanitymanager
import java util dictionary
import java util stack
import java util list
import java util listiterator
/**
a lockcontrol contains a reference to the item being locked
and doubly linked lists for the granted locks and the waiting
locks.
<p>
mt - mutable - container object : single thread required
*/
public class lockcontrol implements control
private final lockable		ref
/**
this lock control uses an optimistic locking scheme.
when the first lock on an object is granted it
simply sets firstgrant to be that object, removing the
need to allocate a list if no other locks are granted
before the first lock is release. if a second lock
is granted then a list is allocated and the
firstgrant lock is moved into the list. once a list
has been created it is always used.
*/
private lock				firstgrant
private list				granted
private list				waiting
private lock				lastpossibleskip
protected lockcontrol lock firstlock  lockable ref
super
this ref   ref
// system.out.println("new lockcontrol");
firstgrant   firstlock
// make a copy by cloning the granted and waiting lists
private lockcontrol lockcontrol copyfrom
super
this ref   copyfrom ref
this firstgrant   copyfrom firstgrant
if  copyfrom granted    null
this granted   new java util linkedlist copyfrom granted
if  copyfrom waiting    null
this waiting   new java util linkedlist copyfrom waiting
this lastpossibleskip   copyfrom lastpossibleskip
public lockcontrol getlockcontrol
return this
/**
*/
public boolean isempty
// if we are locked then we are not empty
if   isunlocked
return false
return  waiting    null     waiting isempty
/**
grant this lock.
*/
void grant lock lockitem
lockitem grant
list lgranted   granted
if  lgranted    null
if  firstgrant    null
// first ever lock on this item
firstgrant   lockitem
else
// second ever lock on this item
lgranted   granted   new java util linkedlist
lgranted add firstgrant
lgranted add lockitem
firstgrant   null
else
// this grants the lock
lgranted add lockitem
/**
*/
public boolean unlock latch lockingroup  int unlockcount
// note that lockingroup is not the actual lock object held in the lock set.
if  unlockcount    0
unlockcount   lockingroup getcount
list lgranted   granted
// start at the begining of the list when there is one
for  int index   0  unlockcount > 0
lock lockinset
if  firstgrant    null
if  sanitymanager debug
sanitymanager assert lockingroup equals firstgrant
lockinset   firstgrant
else
// index = lgranted.indexof(index, lgranted.size() - 1, lockingroup);
list   index   lgranted indexof lockingroup
if  sanitymanager debug
sanitymanager assert index     1
lockinset    lock  lgranted get index
unlockcount    lockinset unlock unlockcount
if  lockinset getcount      0
if  sanitymanager debug
if  unlockcount    0
sanitymanager throwassert     unlockcount
continue
if  firstgrant    lockinset
if  sanitymanager debug
if  unlockcount    0
sanitymanager throwassert     unlockcount
firstgrant   null
else
lgranted remove index
return true
/**
this routine can be called to see if a lock currently on the wait
list could be granted. if this lock has waiters ahead of it
then we do not jump over the waiter(s) even if we can be granted.
this avoids the first waiter being starved out.
*/
public boolean isgrantable
boolean nowaitersbeforeme
object  compatabilityspace
object  qualifier
if  isunlocked
return true
boolean grantlock      false
lockable lref   ref
list lgranted   granted
// check to see if the only locks on the granted queue that
// we are incompatible with are locks we own.
boolean selfcompatible   lref lockeralwayscompatible
int index   0
int endindex   firstgrant    null ? lgranted size     0
do
lock gl   firstgrant    null ?  lock  lgranted get index    firstgrant
boolean samespace
gl getcompatabilityspace   equals compatabilityspace
if  samespace    selfcompatible
// if it's one of our locks and we are always compatible
// with our own locks then yes, we can be granted.
grantlock   true
continue
else if   lref requestcompatible qualifier  gl getqualifier
// if we are not compatible with some already granted lock
// then we can't be granted, give up right away.
grantlock   false
break
else
// we are compatible with this lock, if it's our own or
// there are no other waiters then we can be granted.
if  samespace    nowaitersbeforeme
grantlock   true
while    index < endindex
return grantlock
/**
add a lock into this control, granted it if possible.
this can be entered in several states.
</ol>
<li>the lockable is locked (granted queue not empty), and there are no waiters (waiting queue is empty)
<li>the lockable is locked and there are waiters
<li>the lockable is locked and there are waiters and the first is potentially granted
<li>the lockable is unlocked and there are waiters and the first is potentially granted. logically the item is
still locked, it's just that the lock has just been released and the first waker has not woken up yet.
</ol>
this call is never entered when the object is unlocked and there are no waiters.
1) the lockable has just been unlocked,
*/
public lock addlock lockset ls  object compatabilityspace  object qualifier
if  sanitymanager debug
if     isunlocked       firstwaiter      null
sanitymanager throwassert     isunlocked          firstwaiter      null
// if there are other waiters for this lock then we
// will only grant this lock if we already hold a lock.
// this stops a lock being frozen out while compatible locks
// jump past it.
boolean grantlock   false
boolean otherwaiters    firstwaiter      null
lock lockitem   null
lockable lref   ref
// if we haven't been able to grant the lock yet then see if we hold a
// lock already that we are compatible with and there are no granted
// incompatible locks. if the object appears unlocked (due to a just
// released lock, but the first waiter hasn't woken yet)
// then we obviously don't hold a lock, so just join the wait queue.
boolean spacehasalock   false
boolean nograntatall   false
if   grantlock     isunlocked
boolean selfcompatible   lref lockeralwayscompatible
int index   0
int endindex   firstgrant    null ? granted size     0
do
lock gl   firstgrant    null ?  lock  granted get index    firstgrant
boolean samespace    gl getcompatabilityspace   equals compatabilityspace
// if it's one of our locks and we are always compatible with
// our own locks then yes, we can be granted.
if  samespace    selfcompatible
spacehasalock   true
if  nograntatall
break
if  qualifier    gl getqualifier
lockitem   gl
grantlock   true
continue
// if we are not compatible with some already granted lock
// then we can't be granted, give up right away.
if   lref requestcompatible qualifier  gl getqualifier
grantlock   false
lockitem   null
// we can't give up rightaway if spacehasalock is false
// because we need to ensure that canskip is set correctly
if  spacehasalock
break
nograntatall   true
// we are compatible with this lock, if it's our own or there
// are no other waiters then yes we can still be granted ...
if   nograntatall     samespace     otherwaiters
grantlock   true
while    index < endindex
if  lockitem    null
if  sanitymanager debug
if   grantlock
sanitymanager throwassert     lockitem
// we already held a lock of this type, just bump the lock count
lockitem count
return lockitem
if  grantlock
lockitem   new lock compatabilityspace  lref  qualifier
grant lockitem
return lockitem
activelock waitinglock   new activelock compatabilityspace  lref  qualifier
// if the object is already locked by this compatability space
// then this lock can be granted by skipping other waiters.
if  spacehasalock
waitinglock canskip   true
if  waiting    null
waiting   new java util linkedlist
// add lock to the waiting list
addwaiter waiting  waitinglock  ls
if  waitinglock canskip
lastpossibleskip   waitinglock
return waitinglock
protected boolean isunlocked
// if firstgrant is set then this object is locked
if  firstgrant    null
return false
list lgranted   granted
return  lgranted    null     lgranted isempty
/**
return the first lock in the wait line, null if the
line is empty.
*/
public activelock firstwaiter
if   waiting    null     waiting isempty
return null
return  activelock  waiting get 0
/**
get the next waiting lock (if any).
*/
activelock getnextwaiter activelock item  boolean remove  lockset ls
activelock nextwaitinglock   null
if  remove     waiting get 0     item
// item is at the head of the list and being removed,
// always return the next waiter
popfrontwaiter waiting  ls
nextwaitinglock   firstwaiter
else if   lastpossibleskip    null      lastpossibleskip    item
// there are potential locks that could be granted
// and the last one is not the lock we just looked at.
// need to find the first lock after the one passed
// in that has the canskip flag set.
int itemindex   waiting indexof item
int removeindex   remove ? itemindex    1
// skip the entry we just looked at.
/*list*/
// dli.advance();
// for (; !dli.atend(); dli.advance()) {
if  itemindex    waiting size     1
for  listiterator li   waiting listiterator itemindex   1   li hasnext
//activelock al = (activelock) dli.get();
activelock al    activelock  li next
if  al canskip
nextwaitinglock   al
break
if  remove
removewaiter waiting  removeindex  ls
else
if  remove
int count   removewaiter waiting  item  ls
if  sanitymanager debug
if  count    1
sanitymanager throwassert
count       item
waiting
if  remove     item    lastpossibleskip
lastpossibleskip   null
if  nextwaitinglock    null
if   nextwaitinglock setpotentiallygranted
nextwaitinglock   null
return nextwaitinglock
/**
return the lockable object controlled by me.
*/
public lockable getlockable
return ref
public lock getfirstgrant
return firstgrant
public list getgranted
return granted
public list getwaiting
return waiting
/**
give up waiting up on a lock
*/
protected void giveupwait object item  lockset ls
int count   removewaiter waiting  item  ls
if  item    lastpossibleskip
lastpossibleskip   null
if  sanitymanager debug
if  count    1
sanitymanager throwassert
count       item
waiting
/*
** deadlock support.
*/
/**
add the waiters of this lock into this dictionary object.
<br>
each waiting thread gets two entries in the hashtable
<ol>
<li>key=compatibility space - value=activelock
<li>key=activelock - value={lockcontrol for first waiter|activelock of previosue waiter}
</ol>
*/
public void addwaiters dictionary waiters
if   waiting    null     waiting isempty
return
object previous   this
for  listiterator li   waiting listiterator    li hasnext
activelock waitinglock     activelock  li next
object waiter   waitinglock getcompatabilityspace
waiters put waiter  waitinglock
waiters put waitinglock  previous
previous   waitinglock
/**
return a stack of the
held locks (lock objects) on this lockable.
*/
list getgrants
list ret
if  firstgrant    null
ret   new java util linkedlist
ret add firstgrant
else
ret   new java util linkedlist granted
return ret
/**
find a granted lock matching this space and qualifier
*/
public final lock getlock object compatabilityspace  object qualifier
if  isunlocked
return null
list lgranted   granted
int index   0
int endindex   firstgrant    null ? lgranted size     0
do
lock gl   firstgrant    null ?  lock  lgranted get index    firstgrant
if   gl getcompatabilityspace   equals compatabilityspace
continue
if  gl getqualifier      qualifier
return gl
while    index < endindex
return null
//exclude-start-lockdiag-
/**
* make a shallow clone of myself
*/
/* package */
public control shallowclone
return new lockcontrol this
//exclude-end-lockdiag-
/**
* add a lock request to a list of waiters.
*
* @param waiting	the list of waiters to add to
* @param lockitem	the lock request
* @param ls		the lockset
*/
private void addwaiter list waiting
lock lockitem
lockset ls
// add lock to the waiting list
waiting add lockitem
// maintain count of waiters
ls onemorewaiter
/**
* remove and return the first lock request from a list of waiters.
*
* @param waiting	the list of waiters to pop from
* @param ls		the lockset
*
* @return	the removed lock request
*/
private object popfrontwaiter list waiting  lockset ls
// maintain count of waiters
ls onelesswaiter
// remove and return the first lock request
return waiting remove 0
/**
* remove and return the lock request at the given index
* from a list of waiters.
*
* @param waiting	the list of waiters to pop from
* @param index		the index at which to remove the lock request
* @param ls		the lockset
*
* @return	the removed lock request
*/
private object removewaiter list waiting
int index
lockset ls
// maintain count of waiters
ls onelesswaiter
// remove and return the first lock request
return waiting remove index
/**
* remove and return the given lock request from a list of waiters.
*
* @param waiting	the list of waiters to pop from
* @param item		the item to remove
* @param ls		the lockset
*
* @return	the number of items removed
*/
private int removewaiter list waiting
object item
lockset ls
// maintain count of waiters
ls onelesswaiter
// remove item and return number of items removed
return waiting remove item  ? 1   0