/*
derby - class org.apache.derby.impl.store.raw.data.storedfieldheader
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl store raw data
import org apache derby iapi store raw recordhandle
import org apache derby iapi services sanity sanitymanager
import java io ioexception
import java io eofexception
import java io objectinput
import java io outputstream
import org apache derby iapi services io arrayinputstream
import org apache derby iapi services io compressednumber
import java io inputstream
/**
a class to provide static methods to manipulate fields in the field header.
a class storedpage uses to read/write field status and field data length.
no attributes exist in this class, this class provides a set of static
methods for writing field status and field data length, and for reading
field status and field data length.
<p><b>stored field header format</b><br>
the field header is broken into two sections.
only the status byte is required to be there.
<pre>
field header format:
+--------+-------------------+
| status | <fielddatalength> |
+--------+-------------------+
overflow page and overflow id are stored as field data.
if the overflow bit in status is set, the field data is the overflow
information.  when the overflow bit is not set in status, then,
fielddata is the actually user data for the field.
that means, field header consists only field status, and field data length.
a non-overflow field:
+--------+-------------------+-------------+
| status | <fielddatalength> | <fielddata> |
+--------+-------------------+-------------+
an overflow field:
+--------+-------------------+-----------------+--------------+
| status | <fielddatalength> | <overflow page> | <overflowid> |
+--------+-------------------+-----------------+--------------+
</pre>
<br><b>status</b><br>
the status is 1 byte, it indicates the state of the field.
a fieldheader can be in the following states:
null		- if the field is null, no field data length is stored
overflow	- indicates the field has been overflowed to another page.
overflow page and overflow id is stored at the end of the
user data. field data length must be a number greater or
equal to 0, indicating the length of the field that is stored
on the current page.
the format looks like this:
+--------+-----------------+---------------+------------+
|<status>|<fielddatalength>|<overflow page>|<overflowid>|
+--------+-----------------+---------------+------------+
overflowpage will be written as compressed long,
overflowid will be written as compressed int
nonexistent	- the field no longer exists,
e.g. column has been dropped during an alter table
extensible	- the field is of user defined data type.
the field may be tagged.
tagged		- the field is tagged if and only if it is extensible.
fixed		- the field is fixed if and only if it is used in the log
records for version 1.2 and higher.
<br><b>fielddatalength</b><br>
the fielddatalength is only set if the field is not null.  it is the length
of the field that is stored on the current page.
the fielddatalength is a variable length compressedint.
<br><b>overflowpage and overflowid</b><br>
the overflowpage is a variable length compressedlong, overflowid is a
variable length compressedint.
they are only stored when the field state is overflow.
and they are not stored in the field header.
instead, they are stored at the end of the field data.
the reason we do that is to save a copy if the field has to overflow.
<br> mt - mutable - immutable identity - thread aware
*/
public final class storedfieldheader
/**************************************************************************
* constants of the class
**************************************************************************
*/
// do not use 0x80, some code reads byte into an int without masking the
// sign bit, so do not use the high bit in the byte for a field status.
private		static final int field_initial		  0x00
public		static final int field_null			  0x01
public		static final int field_overflow		  0x02
private		static final int field_not_nullable	  0x04
public		static final int field_extensible	  0x08
public		static final int field_tagged		  0x10
protected	static final int field_fixed		  0x20
public		static final int field_nonexistent	   field_not_nullable   field_null
public static final int    stored_field_header_status_size   1
/**************************************************************************
* get accessors for testing bits in the status field.
**************************************************************************
*/
/**
get the status of the field
<br> mt - single thread required
*/
public static final boolean isnull int status
return   status   field_null     field_null
public static final boolean isoverflow int status
return   status   field_overflow     field_overflow
public static final boolean isnonexistent int status
return   status   field_nonexistent     field_nonexistent
public static final boolean isextensible int status
return   status   field_extensible     field_extensible
public static final boolean isnullornonexistent int status
// just need to check whether null bit is set.
// return ((status & field_nonexistent) == field_nonexistent);
return   status   field_null     0
public static final boolean istagged int status
//		if (sanitymanager.debug)
//			sanitymanager.assert(isextensible(status), "a field cannot be tagged if it is not extensible");
return   status   field_tagged     field_tagged
public static final boolean isfixed int status
return   status   field_fixed     field_fixed
public static final boolean isnullable int status
return   status   field_not_nullable     0
public static final int size
int status
int fielddatalength
int fielddatasize
if   status    field_null   field_fixed      0
// usual case - not-null, not-fixed
// warning - the following code hand inlined from
// compressednumber for performance.
//
// return(compressednumber.sizeint(fielddatalength) + 1);
//
if  fielddatalength <
compressednumber max_compressed_int_one_byte
// compressed form is 1 byte
return 2
else if  fielddatalength <
compressednumber max_compressed_int_two_bytes
// compressed form is 2 bytes
return 3
else
// compressed form is 4 bytes
return 5
else if   status   field_null     0
// field is null
return 1
else
// fixed length field
return  fielddatasize > 2  ? 5   3
/**************************************************************************
* set accessors for setting bits in the status field.
**************************************************************************
*/
public final static int setinitial
return field_initial
public final static int setnull int status  boolean isnull
if  isnull
status    field_null
else
status    ~field_null
return status
public final static int setoverflow int status  boolean isoverflow
if  isoverflow
status    field_overflow
else
status    ~field_overflow
return status
public final static int setnonexistent int status
status    field_nonexistent
return status
public final static int setextensible int status  boolean isextensible
if  isextensible
status    field_extensible
else
status    ~field_extensible
return status
public final static int settagged int status  boolean istagged
if  sanitymanager debug
sanitymanager assert isextensible status
if  istagged
status    field_tagged
else
status    ~field_tagged
return status
public final static int setfixed int status  boolean isfixed
if  isfixed
status    field_fixed
else
status    ~field_fixed
return status
/**************************************************************************
* routines used to write a field header to a outputstream
**************************************************************************
*/
/**
write out the field status and field data length
@exception ioexception thrown by potential i/o errors while writing
field header.
*/
public static final int write
outputstream out
int status
int fielddatalength
int fielddatasize
throws ioexception
int len   1
out write status
if  isnull status
return len
if  isfixed status
// if the field header is for log, we write it in compressed format,
// then we pad the field, so the total length is fixed.
if  fielddatasize > 2
int difflen
fielddatasize
compressednumber writeint out  fielddatalength
for  int i   difflen  i > 0  i
out write 0
len    fielddatasize 	   size of an int   4 bytes
else
// write the int out as a short
out write  fielddatalength >>> 8    0xff
out write  fielddatalength >>> 0    0xff
len    2 	   size of a short   2 bytes
// note: fixed version is used for logs only,
// the overflow information is stored at the end of the optional
// data, not in the field headers.
// that's why we are not writing overflow info here.
else
// if we are writing the fieldheader for the page,
// we write in compressed format
len    compressednumber writeint out  fielddatalength
return len
/**************************************************************************
* routines used to read a field header from an objectinput stream, array
**************************************************************************
*/
/**
read the field status
@exception ioexception thrown by potential i/o errors while reading
field header.
*/
public static final int readstatus objectinput in
throws ioexception
int status
if   status   in read    >  0
return status
else
throw new eofexception
public static final int readstatus
byte      page
int         offset
return page
/**
* read the length of the field and hdr.
* <p>
* optimized routine used to skip a field on a page.  it returns the
* total length of the field including the header portion.  it operates
* directly on the array and does no checking of it's own for limits on
* the array length, so an array out of bounds exception may be thrown -
* the routine is meant to be used to read a field from a page so this
* should not happen.
* <p>
*
* @return the length of the field on the page, including it's header.
*
* @param data      the array where the field is.
* @param offset    the offset in the array where the field begin, ie.
*                  the status byte is at data[offset].
*
* @exception  standardexception  standard exception policy.
**/
public static final int readtotalfieldlength
byte      data
int         offset
throws ioexception
if  sanitymanager debug
// this routine is meant to be called on the page, and fixed fields
// are only used in the log.
if  isfixed data
sanitymanager throwassert
if    data    field_null     field_null
int value   data
if   value   ~0x3f     0
// length is stored in this byte, we also know that the 0x80 bit
// was not set, so no need to mask off the sign extension from
// the byte to int conversion.
// account for 1 byte stored length of field + 1 for status.
return value   2
else if   value   0x80     0
// length stored in 2 bytes. only use low 6 bits from 1st byte.
if  sanitymanager debug
sanitymanager assert  value   0x40     0x40
// top 8 bits of 2 byte length is stored in this byte, we also
// know that the 0x80 bit was not set, so no need to mask off
// the sign extension from the 1st byte to int conversion.  need
// to mask the byte in data[offset + 1] to account for possible
// sign extension.
// add 3 to account for 2 byte length + 1 for status
return    value   0x3f  << 8     data   0xff     3
else
// length stored in 4 bytes.  only use low 7 bits from 1st byte.
if  sanitymanager debug
sanitymanager assert  value   0x80     0x80
// top 8 bits of 4 byte length is stored in this byte, we also
// know that the 0x80 bit was set, so need to mask off the
// sign extension from the 1st byte to int conversion.  need to
// mask the bytes from the next 3 bytes data[offset + 1,2,3] to
// account for possible sign extension.
// add 5 to account for 4 byte length + 1 added to all returns
return
value              0x7f  << 24
data   0xff  << 16
data   0xff  <<  8
data   0xff     5
else
return 1
public static final int readfieldlengthandsetstreamposition
byte              data
int                 offset
int                 status
int                 fielddatasize
arrayinputstream    ais
throws ioexception
if   status    field_null   field_fixed      0
// usual case-not null, not fixed.  length stored as compressed int.
//   return(compressednumber.readint(in));
int value   data
if   value   ~0x3f     0
// usual case.
// length is stored in this byte, we also know that the 0x80 bit
// was not set, so no need to mask off the sign extension from
// the byte to int conversion.
// nothing to do, value already has int to return.
else if   value   0x80     0
// length is stored in 2 bytes.  use low 6 bits from 1st byte.
if  sanitymanager debug
sanitymanager assert  value   0x40     0x40
// top 8 bits of 2 byte length is stored in this byte, we also
// know that the 0x80 bit was not set, so no need to mask off
// the sign extension from the 1st byte to int conversion.
// need to mask the byte in data[offset + 1] to account for
// possible sign extension.
value      value   0x3f  << 8     data   0xff
else
// length is stored in 4 bytes.  only low 7 bits from 1st byte.
if  sanitymanager debug
sanitymanager assert  value   0x80     0x80
// top 8 bits of 4 byte length is stored in this byte, we also
// know that the 0x80 bit was set, so need to mask off the
// sign extension from the 1st byte to int conversion.  need to
// mask the bytes from the next 3 bytes data[offset + 1,2,3] to
// account for possible sign extension.
// add 5 to account for 4 byte length + 1 added to all returns
value
value            0x7f  << 24
data   0xff  << 16
data   0xff  <<  8
data   0xff
ais setposition offset
return value
else if   status   field_null     0
ais setposition offset
return 0
else
int fielddatalength
// field data length is in a fixed size field, not compressed.
if  fielddatasize <  2
// read it in as short, because it was written out as short
fielddatalength
data   0xff  << 8     data   0xff
else
// fielddatalength = compressednumber.readint(in);
fielddatalength   data
if   fielddatalength   ~0x3f     0
// usual case.
// length is stored in this byte, we also know that the 0x80
// bit was not set, so no need to mask off the sign
// extension from the byte to int conversion.
// nothing to do, fielddatalength already has int to return.
else if   fielddatalength   0x80     0
// len is stored in 2 bytes.  use low 6 bits from 1st byte.
if  sanitymanager debug
sanitymanager assert  fielddatalength   0x40     0x40
// top 8 bits of 2 byte length is stored in this byte, we
// also know that the 0x80 bit was not set, so no need to
// mask off the sign extension from the 1st byte to int
// conversion.  need to mask the byte in data[offset + 1] to
// account for possible sign extension.
fielddatalength
fielddatalength   0x3f  << 8
data   0xff
else
// len is stored in 4 bytes.  only low 7 bits from 1st byte.
if  sanitymanager debug
sanitymanager assert  fielddatalength   0x80     0x80
// top 8 bits of 4 byte length is stored in this byte, we
// also know that the 0x80 bit was set, so need to mask off
// the sign extension from the 1st byte to int conversion.
// need to mask the bytes from the next 3 bytes
// data[offset + 1,2,3] to account for possible sign
// extension.
fielddatalength
fielddatalength    0x7f  << 24
data   0xff  << 16
data   0xff  <<  8
data   0xff
offset   offset   fielddatasize
ais setposition offset
return fielddatalength
/**
read the field data length
@exception ioexception thrown by potential i/o errors while reading
field header.
*/
public static final int readfielddatalength
objectinput in
int status
int fielddatasize
throws ioexception
if   status    field_null   field_fixed      0
// usual case-not null, not fixed.  length stored as compressed int.
return compressednumber readint in
else if   status   field_null     0
// field is null or non-existent.
return 0
else
int fielddatalength
// field data length is in a fixed size field, not compressed.
if  fielddatasize <  2
// read it in as short, because it was written out as short
int ch1   in read
int ch2   in read
if   ch1   ch2  < 0
throw new eofexception
fielddatalength     ch1 << 8     ch2 << 0
else
fielddatalength
compressednumber readint in
int difflen
fielddatasize
compressednumber sizeint fielddatalength
if  difflen    0
in skipbytes difflen
return fielddatalength
public static string todebugstring int status
if  sanitymanager debug
stringbuffer str   new stringbuffer 100
if  isnull status   str append
if  isoverflow status   str append
if  isnonexistent status   str append
if  isextensible status   str append
if  istagged status   str append
if  isfixed status   str append
if  isnullable status   str append
if  str length      0
str append
return str tostring
return null