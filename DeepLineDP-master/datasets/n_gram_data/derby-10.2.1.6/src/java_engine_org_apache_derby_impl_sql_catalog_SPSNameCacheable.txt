/*
derby - class org.apache.derby.impl.sql.catalog.spsnamecacheable
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl sql catalog
import org apache derby iapi services cache cacheable
import org apache derby iapi services cache cachemanager
import org apache derby iapi services stream headerprintwriter
import org apache derby iapi sql dictionary schemadescriptor
import org apache derby iapi sql dictionary spsdescriptor
import org apache derby iapi error standardexception
import org apache derby iapi services sanity sanitymanager
/**
* this class implements a cacheable for a datadictionary cache of
* sps descriptors, with the lookup key being the name/schema of the sps.
* assumes client passes in a string that includes the schema name.
* <p>
* the cache ensures that the class of the target sps is loaded
* if the sps is found in cache.  this is ensured by calling
* loadgeneratedclass() on the sps when it is added to the cache.
* each subsequent user of the sps cache will do its own load/unload
* on the class.  because the class manager/loader maintains reference
* counts on the classes it is handling, the user load/unload will
* just increment/decrement the use count.  only when the sps is
* uncached will it be unloaded.
*/
class spsnamecacheable implements cacheable
private tablekey 			identity
private spsdescriptor		spsd
private final datadictionaryimpl	dd
spsnamecacheable datadictionaryimpl dd
this dd   dd
/* cacheable interface */
/** @see cacheable#clearidentity */
public void clearidentity
if  spsd    null
dd spscacheentryremoved spsd
if  sanitymanager debug
if  sanitymanager debug_on
system out println   spsd getname
spsd   null
identity   null
/** @see cacheable#getidentity */
public object getidentity
return identity
/** @see cacheable#createidentity */
public cacheable createidentity object key  object createparameter
if  sanitymanager debug
if    key instanceof tablekey
sanitymanager throwassert
key getclass   getname
if    createparameter instanceof spsdescriptor
sanitymanager throwassert
createparameter getclass   getname
identity    tablekey key
spsd    spsdescriptor  createparameter
if  spsd    null
if  sanitymanager debug
if  sanitymanager debug_on
system out println   spsd getname
dd spscacheentryadded spsd
try
spsd loadgeneratedclass
catch  standardexception e
/*
** we cannot throw an exception here, and although
** we don't expect a problem, we'll put some debugging
** under sanity just in case.  note that even if we
** do get an exception here, everything else will work
** ok -- subsequent attempts to access the generated
** class for this sps will do a load themselves, and
** they will throw their exception back to the user.
*/
if  sanitymanager debug
system out println   spsd getname
system out println e
e printstacktrace
return this
else
return null
/**
* @see cacheable#setidentity
*
* @exception standardexception		thrown on error
*/
public cacheable setidentity object key  throws standardexception
if  sanitymanager debug
if    key instanceof tablekey
sanitymanager throwassert
key getclass   getname
identity    tablekey key
spsd   dd getuncachedspsdescriptor identity
if  spsd    null
if  sanitymanager debug
if  sanitymanager debug_on
system out println   spsd getname
dd spscacheentryadded spsd
try
spsd loadgeneratedclass
catch  standardexception e
/*
** we cannot throw an exception here, and although
** we don't expect a problem, we'll put some debugging
** under sanity just in case.  note that even if we
** do get an exception here, everything else will work
** ok -- subsequent attempts to access the generated
** class for this sps will do a load themselves, and
** they will throw their exception back to the user.
*/
if  sanitymanager debug
system out println   spsd getname
system out println e
e printstacktrace
return this
else
return null
/* cacheable interface */
/** @see cacheable#clean */
public void clean boolean forremove
return
/** @see cacheable#isdirty */
public boolean isdirty
return false
/**
* get the sps descriptor that is associated with this cacheable
*/
public spsdescriptor getspsdescriptor
return spsd
/**
* check the consistency of the table descriptor held by this tdcacheable
* versus an uncached table descriptor.
*
* @param uncachedspsd	the uncached descriptor to compare to
* @param identity		the identity of the table descriptor
* @param reportinconsistent	a headerprintwriter to send complaints to
*
* @return	true if the descriptors are the same, false if they're different
*
* @exception standardexception		thrown on error
*/
private boolean checkconsistency spsdescriptor uncachedspsd
object identity
headerprintwriter reportinconsistent
throws standardexception
boolean	retval   true
if  sanitymanager debug
if  uncachedspsd    null
reportinconsistent println
identity
retval   false
else
if
uncachedspsd gettext   equals spsd gettext
uncachedspsd getusingtext   equals spsd getusingtext
uncachedspsd getqualifiedname   equals spsd getqualifiedname
reportinconsistent println
identity
spsd
uncachedspsd
retval   false
return retval