/*
derby - class org.apache.derby.impl.store.access.btree.branchrow
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl store access btree
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi services io storable
import org apache derby iapi error standardexception
import org apache derby iapi store access rowutil
import org apache derby iapi store raw containerhandle
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi types sqllongint
import org apache derby iapi services io formatablebitset
/**
* implements row which is stored in the branch pages of a btree.  a non-suffix
* compressed branch row contains all of the columns of the leaf rows of a btree
* and contains an additional field at the end.  the extra field of a branch row
* in a branch page at level n, is the child page field pointing the page at
* level n-1 which has keys which follow or equal the branch row entry.
*
* there are 3 ways to use this class to produce a branch row:
*   createemptytemplate()
*      creates a empty row template
*   createbranchrowfromoldbranchrow()
*      creates a new row with reference to an old branch row.
*   createbranchrowfromoldleafrow()
*      creates a new row with reference to an old leaf row.
*/
public class branchrow
/* a dummy page number value (should not be compressable) */
public static final long dummy_page_number   0xffffffffffffffffl
/**
* the branch child page pointer.  all keys that follow or equal the
* key in this row can be found by following the child page pointer.
* a reference to this object will be placed in the last slot of branchrow,
* and this class expects that no-one will replace that reference.
*/
// private sqllongint      child_page = null;
/**
* the array of object to be used as the row.
*/
private datavaluedescriptor    branchrow      null
/*
** constructors of branchrow
*/
/**
constuctor for creating an "empty" branchrow template, suitable for reading
in a branchrow from disk.
**/
private branchrow
private branchrow btree btree
throws standardexception
sqllongint child_page
new sqllongint containerhandle invalid_page_number
branchrow     btree createbranchtemplate child_page
if  sanitymanager debug
sanitymanager assert
child_page      sqllongint  branchrow
/*
** the following methods implement the branchrow private interface.
*/
/**
* accessor for the child page field of the branch row.
*
* @return the child page object.
**/
private sqllongint getchildpage
// last column of branch row should be the child page pointer.
if  sanitymanager debug
sanitymanager assert branchrow    null
sanitymanager assert
branchrow instanceof sqllongint
return  sqllongint  branchrow
/*
** the following methods implement the branchrow public interface.
*/
/**
* create an empty branch row template suitable for reading branch rows in
* from disk. this routine will create newly allocated "empty" objects for
* every column in the template row.
*
* @exception standardexception standard exception policy.
*/
public static branchrow createemptytemplate btree   btree
throws standardexception
branchrow  newbranch     new branchrow btree
return new branchrow btree
/**
* create a new branch row, given a old branch row and a new child page.
* used by branchcontrolrow to manufacture new branch rows when splitting
* or growing the tree.
*
* there is no way to "copy" values of a template row, so this class just
* stores a reference to each of the columns of the indexable row passed
* in.  this is ok as all
* usages of this class when instantiated this way, have an old branch row
* from which they are creating a new branch row with the same key values,
* and a different child page number.
*
* warning - this branch row is only valid while the old branch row is
* valid, as it contains references to the columns of the old branch row.
* so use of the row should only provide read-only access to the objects
* of the old branch row which are referenced.
*/
public branchrow createbranchrowfromoldbranchrow long childpageno
branchrow newbranch   new branchrow
/* create new object array, and shallow copy all object references
* from old branch row to new branch row.
*/
newbranch branchrow   new datavaluedescriptor
system arraycopy
this branchrow  0  newbranch branchrow  0
newbranch branchrow length   1
/* now create a different child page pointer object and place it as
* last column in the new branch row.
*/
newbranch branchrow
new sqllongint childpageno
return newbranch
/**
* create a new branch row, given a old leaf row and a new child page.
* used by leafcontrolrow to manufacture new branch rows when splitting
* or growing the tree.
*
* there is no way to "copy" values of a template row, so this class just
* stores a referece to the indexable row passed in.  this is ok as all
* usages of this class when instantiated this way, have an old leaf row
* from which they are creating a new branch row with the same key values,
* and a different child page number.
*
* warning - this branch row is only valid while the old leaf row is
* valid, as it contains references to the columns of the old leaf row.
* so use of the row should only provide read-only access to the objects
* of the old leaf row which are referenced.
*/
public static branchrow createbranchrowfromoldleafrow
datavaluedescriptor   leafrow
long                    childpageno
branchrow newbranch   new branchrow
/* create new object array for the row, and copy all object references
* from old leaf row to new branch row.
*/
newbranch branchrow   new datavaluedescriptor
system arraycopy leafrow  0  newbranch branchrow  0  leafrow length
/* now create a different child page pointer object and place it as
* last column in the new branch row.
*/
newbranch branchrow
new sqllongint childpageno
return newbranch
/**
* return the branch row.
* <p>
* return the datavaluedescriptor array that represents the branch row,
* for use in raw store calls to fetch, insert, and update.
* <p>
*
* @return the branch row object array.
**/
protected datavaluedescriptor getrow
return this branchrow
/**
* set the page number field of the branch row to a new value.
*
* @param page_number the new page number.
**/
protected void setpagenumber long page_number
getchildpage   setvalue page_number
public string tostring
if  sanitymanager debug
return
rowutil tostring branchrow
getchildpage
else
return null