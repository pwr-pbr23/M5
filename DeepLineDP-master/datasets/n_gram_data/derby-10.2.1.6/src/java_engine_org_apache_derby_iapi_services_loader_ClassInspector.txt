/*
derby - class org.apache.derby.iapi.services.loader.classinspector
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby iapi services loader
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi error standardexception
import org apache derby iapi reference sqlstate
import java lang reflect
import java util stringtokenizer
import java util list
import java util arraylist
import java util nosuchelementexception
import java util collections
/**
methods to find out relationships between classes and methods within a class.
all class names within this interface are treated as java language class names,
e.g. int, com.foo.myclass, int[], java.lang.object[]. that is java internal
class names as defined in the class file format are not understood.
*/
public final class classinspector
private static final string primtypenames
// collect these as static, instead of each time allocates these new
// strings for every method resolution
private static final string nonprimtypenames
private final classfactory cf
/**
do not use! use the method in classfactory.
*/
public classinspector classfactory cf
this cf   cf
/**
* is the given object an instance of the named class?
*
* @param classname	the name of the class
* @param obj		the object to test to see if it's an instance
*			of the named class
*
* @return	true if obj is an instanceof classname, false if not
*/
public boolean instanceof string classname  object obj
throws classnotfoundexception
class clazz   getclass classname
// is classname an untyped null
if  clazz    null
return false
return clazz isinstance obj
/**
* is one named class assignable to another named class or interface?
*
* @param fromclassname	the name of the class to be assigned
* @param toclassname	the name of the class to be assigned to
*
* @return	true if an object of type fromclass can be assigned to an
*			object of type toclass, false if not.
*/
public boolean assignableto string fromclassname  string toclassname
try
class toclass   getclass toclassname
// is toclass an untyped null
if  toclass    null
return false
class fromclass   getclass fromclassname
// is fromclass an untyped null
if  fromclass    null
return  toclass isprimitive       toclass    void type
return toclass isassignablefrom fromclass
catch  classnotfoundexception cnfe
/* if either class can't be found, they can't be assigned */
return false
/**
* does the named class exist, and is it accessible?
*
* @param classname	the name of the class to test for existence
*
* @return	true if the class exists and is accessible, false if not
*/
public boolean accessible string classname
throws classnotfoundexception
class theclass   getclass classname
if  theclass    null
return false
/* classes must be public to be accessible */
if    modifier ispublic theclass getmodifiers
return false
return true
/**
* get the java name of the return type from a member representing
* a method or the type of a member representing a field.
*
* @param member		a member representing the method for
*						which we want the return type.
*
* @return	a java-language-style string describing the return type of
*			the method (for example, it returns "int" instead of "i".
*/
public string gettype member member
class type
if  member instanceof method
type     method  member  getreturntype
else if  member instanceof field
type     field  member  gettype
else if  member instanceof constructor
type     constructor  member  getdeclaringclass
else
type   void type
return classinspector readableclassname type
/**
* find a public method that implements a given signature.
* the signature is given using the full java class names of the types.
<br>
* a untyped null paramter is indicated by passing in an empty string ("")
* as its class name.
<br>
if receivertype respresents an interface then the methods of java.lang.object
arer included in the candidate list.
<br>
if the caller is simply checking to see that a public method with the
specified name exists, regardless of the signature, exists, then the
caller should pass in a null for parmtypes.  (this is useful for checking
the validity of a method alias when creating one.)
<br>
we use a two-pass algorithm to resolve methods.  in the first pass, we
use all "object" types to try to match a method.  if this fails, in the
second pass, an array of "primitive" types (if the parameter has one,
otherwise the same object type is used) is passed in, as well as the
"object" type array.  for each parameter of a method, we try to match it
against either the "object" type, or the "primitive" type.  of all the
qualified candidate methods found, we choose the closest one to the input
parameter types.  this involves comparing methods whose parameters are
mixed "object" and "primitive" types in the second pass.  this is
eventually handled in classconvertablefromto.
*
* @param receivertype	the class name of the receiver
* @param methodname	the name of the method
* @param parmtypes		an array of class names representing the
*						parameter types.  pass a zero-element array if
*						there are no parameters.  pass a null if it is
*						okay to match any signature.
* @param primparmtypes this is used in the second pass of the two-pass
*						method resolution algorithm.  use primitive type
*						if it has one, otherwise use same object type
* @param isparam		array of booleans telling whether parameter is a ?.
* @param staticmethod	find a static method.
@param repeatlastparameter if true the last parameter may be repeated any number of times (total count must be greater than one).
if false the laste parameter is matched as usual. this also requires an exact match on the last parameter type.
*
* @return	a member representing the matching method.  returns null
*			if no such method.
*
* @exception classnotfoundexception	one or more of the classes does
*										not exist.
* @exception standardexception			thrown on ambiguous method invocation.
*
* @see	member
* @see modifier
*/
public member findpublicmethod string receivertype
string methodname
string parmtypes
string primparmtypes
boolean isparam
boolean staticmethod
boolean repeatlastparameter
throws classnotfoundexception  standardexception
class receiverclass   getclass receivertype
if  receiverclass    null
return null
// primitives don't have methods
// note that arrays do since they are objects they have
// all the methods of java.lang.object
if  receiverclass isprimitive
return null
// if parmtypes is null, then the caller is simply
// looking to see if any public method with the
// specified name exists, regardless of its signature
if  parmtypes    null
method methods   receiverclass getmethods
for  int index   0  index < methods length  index
if  staticmethod
if   modifier isstatic methods getmodifiers
continue
if  methodname equals methods getname
// we found a match
return methods
// no match
return null
// convert the parameter types to classes
class paramclasses   new class
class primparamclasses   null
if  primparmtypes    null
primparamclasses   new class
for  int i   0  i < paramclasses length  i
paramclasses   getclass parmtypes
if  primparmtypes    null
continue
if  primparmtypes equals parmtypes       no separate primitive
primparamclasses   null
else
primparamclasses   getclass primparmtypes
// no overloading possible if there are no arguments, so perform
// an exact match lookup.
if  paramclasses length    0
try
method method   receiverclass getmethod methodname  paramclasses
if  staticmethod
if   modifier isstatic method getmodifiers
return null
return method
catch  nosuchmethodexception nsme2
// if we are an interface then the method could be defined on object
if   receiverclass isinterface
return null
// now the tricky method resolution
member methodlist   receiverclass getmethods
// if we have an interface we need to add the methods of object into the mix
if  receiverclass isinterface
member objectmethods   java lang object class getmethods
if  methodlist length    0
methodlist   objectmethods
else
member set   new member
system arraycopy methodlist  0  set  0  methodlist length
system arraycopy objectmethods  0  set  methodlist length  objectmethods length
methodlist   set
return resolvemethod receiverclass  methodname  paramclasses
primparamclasses  isparam  staticmethod  repeatlastparameter  methodlist
/**
* find a public field  for a class.
this follows the sematics of the java compiler for locating a field.
this means if a field fieldname exists in the class with package, private or
protected then an error is raised. even if the field hides a field fieldname
in a super-class/super--interface. see the jvm spec on fields.
*
* @param receivertype	the class name of the receiver
* @param fieldname		the name of the field
* @param staticfield	find a static field
*
* @return	a member representing the matching field.
* @exception standardexception	class or field does not exist or is not public or a security exception.
*
* @see	member
* @see modifier
*/
public member findpublicfield string receivertype
string fieldname
boolean staticfield
throws standardexception
exception e   null
try
class receiverclass   getclass receivertype
if  receiverclass    null
return null
if  receiverclass isarray      receiverclass isprimitive
// arrays don't have fields (the fake field 'length' is not returned here)
return null
int modifier   staticfield ?  modifier public   modifier static    modifier public
// look for a public field first
field publicfield   receiverclass getfield fieldname
if   publicfield getmodifiers     modifier     modifier
/*
if the class is an interface then we avoid looking for a declared field
that can hide a super-class's public field and not be accessable. this is because
a interface's fields are always public. this avoids a security check.
*/
if  receiverclass isinterface       publicfield getdeclaringclass   equals receiverclass
return publicfield
/*
now check to see if there is a declared field that hides the public field.
*/
try
field declaredfield   receiverclass getdeclaredfield fieldname
if  sanitymanager debug
if   declaredfield getmodifiers     modifier public     modifier public
sanitymanager throwassert     declaredfield
catch  nosuchfieldexception nsfe
// no field hides the public field in the super class
return publicfield
catch  classnotfoundexception cnfe
e   cnfe
catch  nosuchfieldexception nsfep
e   nsfep
catch  securityexception se
e   se
throw standardexception newexception
staticfield ? sqlstate lang_no_static_field_found   sqlstate lang_no_field_found
e  fieldname  receivertype
/**
* find a public constructor that implements a given signature.
* the signature is given using the full java class names of the types.
<br>
* a untyped null paramter is indicated by passing in an empty string ("")
* as its class name.
*
* @param receivertype	the class name of the receiver
* @param parmtypes		an array of class names representing the
*						parameter types.  pass a zero-element array if
*						there are no parameters.
* @param primparmtypes this is used in the second pass of the two-pass
*						method resolution algorithm.  use primitive type
*						if it has one, otherwise use same object type
* @param isparam		array of booleans telling whether parameter is a ?.
*
* @return	a member representing the matching constructor.  returns null
*			if no such constructor.
*
* @exception classnotfoundexception	one or more of the classes does
*										not exist.
* @exception standardexception			thrown on ambiguous constructor invocation.
*
* @see	member
* @see modifier
*/
public member findpublicconstructor string receivertype
string parmtypes
string primparmtypes
boolean isparam
throws classnotfoundexception  standardexception
class receiverclass   getclass receivertype
if  receiverclass    null
return null
// arrays, primitives, and interfaces do not have constructors
if  receiverclass isarray      receiverclass isprimitive      receiverclass isinterface
return null
// convert the parameter types to classes
class paramclasses   new class
class primparamclasses   null
if  primparmtypes    null
primparamclasses   new class
boolean unknownparameters   false
for  int i   0  i < paramclasses length  i
paramclasses   getclass parmtypes
if  paramclasses    null
unknownparameters   true
if  primparmtypes    null
continue
if  primparmtypes equals parmtypes       no separate primitive
primparamclasses   null
else
primparamclasses   getclass primparmtypes
try
if   unknownparameters     primparmtypes    null
// look for an exact match for first pass
member method   receiverclass getconstructor paramclasses
return method
catch  nosuchmethodexception nsme
// no overloading possible if there are no arguments
if  paramclasses length    0
return null
// now the tricky method resolution
// name is only used for debugging
return resolvemethod receiverclass     paramclasses
primparamclasses  isparam  false  false
receiverclass getconstructors
/**
* get the parameter types for a method described by a member as a string[].
*
* @param method	a member describing a method
*
* @return	a string[] describing the parameters of the method
*/
public string getparametertypes member method
class parameterclasses
if  method instanceof method
parameterclasses     method  method  getparametertypes
else
parameterclasses     constructor  method  getparametertypes
string parametertypes   new string
for  int i   0  i < parametertypes length  i
parametertypes   classinspector readableclassname parameterclasses
return parametertypes
/**
* determine whether a type is a java primitive, like int or boolean
*
* @param typename	the name of the java type
*
* @return	true if it's a primitive type
*/
public static boolean primitivetype string typename
for  int i   0  i < primtypenames length  i
if  typename equals primtypenames
return true
return false
/**
*  tricky function to resolve a method.  if primparamclasses is null
*  we know it's first pass.  first pass try to match as all "object"
*  types, second pass try to match any combination of "object" and
*  "primitive" types.  find the closest match among all the qualified
*  candidates.  if there's a tie, it's ambiguous.
*
*  @param receiverclass 	the class who holds the methods
*  @param methodname		the name of method
*	@param paramclasses		object type classes of input parameters
*  @param primparamclasses	primitive type classes or null
*  @param isparam			isparam (for ?) array
*  @param staticmethod		static method or not
*  @param methods			method stack
*  @return	the matched method
*
**/
private member resolvemethod
class receiverclass
string methodname
class paramclasses
class primparamclasses
boolean isparam
boolean staticmethod
boolean repeatlastparameter
member methods
throws standardexception
if  sanitymanager debug
if  sanitymanager debug_on
sanitymanager debug
methodname
paramclasses length    repeatlastparameter ?
for  int parmctr   0  parmctr < paramclasses length  parmctr
sanitymanager debug
parmctr
paramclasses    null ?     paramclasses getname
/* step through all the methods available in this class */
int candidateindex    1
boolean firsttimearound   true
boolean	ambiguous
boolean somethingchanged
do
ambiguous   false
somethingchanged   false
nextmethod 	for  int i   0  i < methods length  i
member currentmethod   methods
// on second and later times around there will be null entries
// also, don't compare ourself to ourself
if   currentmethod    null
i    candidateindex
continue
// must have the same number of parameters
class currentmethodparameters   currentmethod instanceof method ?
method  currentmethod  getparametertypes
constructor  currentmethod  getparametertypes
// only check the basic stuff once
if  firsttimearound
if  repeatlastparameter
// match any number of parameters greater or equal to
// the passed in number, but repeating the last type.
if  currentmethodparameters length < paramclasses length
methods   null     remove non applicable methods
continue
else
// regular match on parameter count
if  currentmethodparameters length    paramclasses length
methods   null     remove non applicable methods
continue
/* look only at methods that match the modifiers */
if  staticmethod     modifier isstatic currentmethod getmodifiers
methods   null     remove non applicable methods
continue
/* look only at methods with the right name */
if   methodname startswith
if     methodname equals currentmethod getname
methods   null     remove non applicable methods
continue
if  repeatlastparameter
// with n parameters requested check all parameters from n-1 to end are equal
// to the requested parameter.
for  int pr   paramclasses length   1  pr < currentmethodparameters length  pr
if   currentmethodparameters equals paramclasses
methods   null     remove non applicable methods
continue nextmethod
if  sanitymanager debug
if  sanitymanager debug_on
sanitymanager debug
currentmethod tostring
// can the required signature be converted to those of this method
if   signatureconvertablefromto paramclasses  primparamclasses
currentmethodparameters  isparam  false
if  sanitymanager debug
if  sanitymanager debug_on
sanitymanager debug
currentmethod tostring
methods   null     remove non applicable methods
continue
if  sanitymanager debug
if  sanitymanager debug_on
sanitymanager debug
/* is this the first match? */
if  candidateindex     1
candidateindex   i
if  sanitymanager debug
if  sanitymanager debug_on
sanitymanager debug
continue
/* not the first match, so find out which one, if either one,
* has the best match on the parameters.  (no narrowing
* conversions.)  15.11 of java language specification.
*/
member candidatemethod   methods
// if the candidate method is more specific than the current
// method then the candidate method is still the maximally specific method
// note at this point we could still have a ambiguous situation.
boolean candidatemoreorequal   ismethodmorespecificorequal
candidatemethod  currentmethod  isparam
boolean currentmoreorequal   ismethodmorespecificorequal
currentmethod  candidatemethod  isparam
if  candidatemoreorequal      currentmoreorequal
if  sanitymanager debug
if  sanitymanager debug_on
sanitymanager debug
methods   null     remove non applicable methods
continue
// if the current method is more specific than the candidiate
// method then it becomes the new maximally specific method
// note at this point we could still have a ambiguous situation.
if  currentmoreorequal      candidatemoreorequal
if  sanitymanager debug
if  sanitymanager debug_on
sanitymanager debug
methods   null     remove non applicable methods
candidateindex   i
somethingchanged   true
continue
/* we have seen an ambiguous situation; one of the cases may
* tie on each parameter.
*/
ambiguous   true
if  sanitymanager debug
if  sanitymanager debug_on
sanitymanager debug
firsttimearound   false
while  ambiguous    somethingchanged
if  sanitymanager debug
if  sanitymanager debug_on
sanitymanager debug
methodname
/* throw an exception here if the method invocation ambiguous */
if  ambiguous
/* put the parameter type names into a single string */
string	parmtypesstring
for  int i   0  i < paramclasses length  i
if  i    0
parmtypesstring
parmtypesstring     paramclasses    null ?     paramclasses getname
if  primparamclasses    null    primparamclasses    null
parmtypesstring        primparamclasses getname
throw standardexception newexception sqlstate lang_ambiguous_method_invocation
receiverclass getname
methodname
parmtypesstring
if  candidateindex     1
return null
if  sanitymanager debug
if  methods    null
sanitymanager throwassert     candidateindex
return methods
/**
get (load) the class for the given class name.
this method converts any java language class name
into a class object. this includes cases like string[]
and primitive types.
this will attempt to load the class from the application set.
@exception classnotfoundexception class cannot be found, or
a securityexception or linkageexception was thrown loading the class.
*/
public class getclass string classname  throws classnotfoundexception
if   classname    null
classname length      0
return null
int arraydepth   0
int classnamelength   classname length
int position   classnamelength   2
while   position >  0     classname substring position  position   2  equals
arraydepth
position    2
classnamelength    2
if  classnamelength <  0
// a bogus class name, let class.forname deal with the error.
return class forname classname
if  arraydepth    0
classname   classname substring 0  classnamelength
class baseclass   null
if  classnamelength > 3    classnamelength < 7
if    equals classname
baseclass   integer type
else if    equals classname
baseclass   short type
else if    equals classname
baseclass   boolean type
else if    equals classname
baseclass   byte type
else if    equals classname
baseclass   float type
else if    equals classname
baseclass   double type
else if    equals classname
baseclass   long type
else if    equals classname
baseclass   character type
else if    equals classname
baseclass   void type
if  baseclass    null
baseclass   cf loadapplicationclass classname
if  arraydepth    0
return baseclass
// need to create an actual instance of the array type
// and get its class from that. there is no other documented
// way to do this. while a getname() on an array class
// returns [[[lclassname; format it's not consistent
// with primitive types, e.g.
//
// integer.type.getname()   returns "int"
// class.forname(new int[0] returns "[i"
//
if  arraydepth    1
return array newinstance baseclass  0  getclass
return array newinstance baseclass  new int  getclass
/**
is method/constructor t more or equally specific than method u.
see the java language specification section 15.11.2.2.
*/
private boolean ismethodmorespecificorequal member t  member u  boolean isparam
class tc
class uc
if  t instanceof method
if   classconvertablefromto t getdeclaringclass    u getdeclaringclass    true
return false
tc     method  t  getparametertypes
uc     method  u  getparametertypes
else
tc     constructor  t  getparametertypes
uc     constructor  u  getparametertypes
return signatureconvertablefromto tc  null  uc  isparam  true
/**
*  can we convert a signature from fromtypes(primfromtypes) to totypes.
*  "mixtypes" is a flag to show if object/primitive type conversion is
*  possible; this is used for comparing two candidate methods in the
*  second pass of the two pass method resolution.
*
*  @param fromtypes	from types' classes
*	@param primfromtypes primitive from types or null
*	@param totypes		to types' classes
*	@param isparam		is parameter (?) or not
*	@param mixtypes		mixing object/primitive types for comparison
**/
private boolean signatureconvertablefromto class fromtypes  class primfromtypes
class totypes  boolean isparam
boolean mixtypes
// in the case repeatlastparameter was true, then the two methods may have
// different numbers of parameters. we need to compare only the non-repeated
// parameters, which is the number of input parameters.
int checkcount   fromtypes length
if  totypes length < checkcount
checkcount   totypes length
for  int i   0  i < checkcount  i
class fromclass   fromtypes
class toclass   totypes
// this means an untyped null was passed in. can only ever be in the
// from side as the null can only be in the signature passed in by
// the caller of findpublicmethod. any signatures of existing methods
// are always typed.
if  fromclass    null
// primitive types are only considered on
// the 2nd pass
if  toclass isprimitive
if   primfromtypes    null 		   first pass
isparam    null      isparam
return false
continue
if    classconvertablefromto fromclass  toclass  mixtypes
// primitive type, if any, also doesn't work
primfromtypes    null      primfromtypes    null
classconvertablefromto primfromtypes  toclass  mixtypes
return false
return true
/**
*  can we convert a fromclass to toclass.
*  "mixtypes" is a flag to show if object/primitive type conversion is
*  possible; this is used for comparing two candidate methods in the
*  second pass of the two pass method resolution.
*
*  @param fromclass	from class
*	@param toclass		to class
*	@param mixtypes		mixing object/primitive types for comparison
**/
protected boolean classconvertablefromto class fromclass  class toclass  boolean mixtypes
if  toclass isassignablefrom fromclass
return true
// when comparing two candidate methods to see which one is closer,
// we want to mix object type and primitive type, because they could
// both be chosen in the second pass.  but when deciding if a method
// is qualified (to be a candidate), we do not want to mix types at
// any time, the reason is that we can not do more than one step
// conversion: for example, input parameter is bigdecimal, we convert
// it to double for method resolution, we can not convert it again to
// double to match a method. "(paramtypes, primparamtypes)" already
// includes all the one-step conversions.  but at any time we do want
// to see if two primitives are convertable.
if     toclass isprimitive      fromclass isprimitive          mixtypes
return false
// there are nine predefined class objects to represent the eight
// primitive java types and void.  we also handle prim vs. non-prim
// conversion of the same type.  boolean and double are only convertable
// to themseleves.  void should never be seen here.  in the second pass
// we treat primitive type and the corrsponding non-primitive type
// uniformly
string fromname   fromclass getname    toname   toclass getname
if   fromclass    boolean type     fromname equals nonprimtypenames
if   toclass    boolean type     toname equals nonprimtypenames
return true
else if   fromclass    byte type     fromname equals nonprimtypenames
if   toclass    byte type     toname equals nonprimtypenames
// we never need to see if toclass is of wider "object" type,
// because a wider "object" type and a narrower "primitive"
// type can never both be candidate, eg, "int" and "long" can
// never both accomodate the same parameter; while "long" and
// "integer" can.
toclass    short type
toclass    integer type
toclass    long type
toclass    float type
toclass    double type
return true
else if   fromclass    character type     fromname equals nonprimtypenames
if   toclass    character type     toname equals nonprimtypenames
toclass    integer type
toclass    long type
toclass    float type
toclass    double type
return true
else if   fromclass    short type     fromname equals nonprimtypenames
if   toclass    short type     toname equals nonprimtypenames
toclass    integer type
toclass    long type
toclass    float type
toclass    double type
return true
else if   fromclass    integer type     fromname equals nonprimtypenames
if   toclass    integer type     toname equals nonprimtypenames
toclass    long type
toclass    float type
toclass    double type
return true
else if   fromclass    long type     fromname equals nonprimtypenames
if   toclass    long type     toname equals nonprimtypenames
toclass    float type
toclass    double type
return true
else if   fromclass    float type     fromname equals nonprimtypenames
if   toclass    float type     toname equals nonprimtypenames
toclass    double type
return true
else if   fromclass    double type     fromname equals nonprimtypenames
if   toclass    double type     toname equals nonprimtypenames
return true
return false
/**
* translate a jvm-style type descriptor to a java-language-style type
* name.
*
* @param clazz		the string that contains the jvm type name
*
* @return	the java-language-style type name
*/
public static string readableclassname class clazz
if   clazz isarray
return clazz getname
int arraydepth   0
do
arraydepth
clazz   clazz getcomponenttype
while  clazz isarray
stringbuffer sb   new stringbuffer clazz getname
for  int i   0  i < arraydepth  i
sb append
return sb tostring
/**
* determine whether or not the received class can be
* loaded.
*
* @param classname the name of the class in question
* @return true if classname can be loaded, false otherwise
*/
public static boolean classisloadable string classname
try
class forname classname
return true
catch  classnotfoundexception ce
return false
catch  linkageerror ce
return false
/**
* get the declaring class for a method.
*
* @param method	a member describing a method
*
* @return	a string with the declaring class
*
* @see member#getdeclaringclass
*/
public string getdeclaringclass member method
return method getdeclaringclass   getname