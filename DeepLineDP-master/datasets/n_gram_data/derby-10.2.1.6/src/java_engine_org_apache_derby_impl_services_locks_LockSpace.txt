/*
derby - class org.apache.derby.impl.services.locks.lockspace
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl services locks
import org apache derby iapi services locks lockable
import org apache derby iapi services locks limit
import org apache derby iapi util matchable
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi error standardexception
import java util hashtable
import java util enumeration
import java util dictionary
import java util hashmap
import java util iterator
/**
a lockspace represents the complete set of locks held within
a single compatability space, broken into groups of locks.
a lockspace is a hashtable keyed by the group reference,
the data for each key is a hashtable of lock's.
*/
class lockspace extends hashtable
private final object compatspace
// the object i live in
private final dictionary holder
private hashmap sparegroups   new hashmap
// the limit info.
private object callbackgroup
private int    limit
private int    nextlimitcall
private limit  callback
lockspace dictionary holder  object compatspace
super
this compatspace   compatspace
this holder   holder
/**
add a lock to a group.
*/
protected synchronized void addlock object group  lock lock
throws standardexception
lock lockingroup   null
hashmap dl    hashmap  get group
if  dl    null
dl   getgroupmap group
else if  lock getcount      1
lockingroup    lock  dl get lock
if  lockingroup    null
lockingroup   lock copy
dl put lockingroup  lockingroup
lockingroup count
if  inlimit
return
if   group equals callbackgroup
return
int groupsize   dl size
if  groupsize > nextlimitcall
inlimit   true
callback reached compatspace  group  limit
new locklist java util collections enumeration dl keyset      groupsize
inlimit   false
// see when the next callback should occur, if the callback
// failed to release a sufficent amount of locks then
// delay until another "limit" locks are obtained.
int newgroupsize   dl size
if  newgroupsize <  limit   2
nextlimitcall   limit
else if  newgroupsize <  nextlimitcall   2
nextlimitcall    limit
else
nextlimitcall    limit
private boolean inlimit
/**
unlock all the locks in a group and then remove the group.
*/
synchronized void unlockgroup lockset lset  object group
hashmap dl    hashmap  remove group
if  dl    null
return
for  iterator list   dl keyset   iterator    list hasnext
lset unlock  lock  list next    0
if   callbackgroup    null     isempty
holder remove compatspace
else if  group equals callbackgroup
nextlimitcall   limit
savegroup dl
private hashmap getgroupmap object group
hashmap sg   sparegroups
hashmap dl   null
for  int i   0  i < 3  i
dl   sg
if  dl    null
sg   null
break
if  dl    null
dl   new hashmap 5  0 8f
put group  dl
return dl
private void savegroup hashmap dl
hashmap sg   sparegroups
for  int i   0  i < 3  i
if  sg    null
sg   dl
dl clear
break
/**
unlock all locks in the group that match the key
*/
synchronized void unlockgroup lockset lset  object group  matchable key
hashmap dl    hashmap  get group
if  dl    null
return      no group at all
boolean allunlocked   true
for  iterator e   dl keyset   iterator    e hasnext
lock lock    lock  e next
if   key match lock getlockable
allunlocked   false
continue
lset unlock lock  0
e remove
if  allunlocked
remove group
savegroup dl
if   callbackgroup    null     isempty
holder remove compatspace
else if  group equals callbackgroup
nextlimitcall   limit
synchronized void transfer object oldgroup  object newgroup
hashmap from    hashmap  get oldgroup
if  from    null
return
hashmap to    hashmap  get newgroup
if  to    null
// simple case
put newgroup  from
clearlimit oldgroup
remove oldgroup
return
if  to size   < from size
// place the contents of to into from
mergegroups to  from
object oldto   put newgroup  from
if  sanitymanager debug
sanitymanager assert oldto    to
else
mergegroups from  to
clearlimit oldgroup
remove oldgroup
private void mergegroups hashmap from  hashmap into
for  iterator e   from keyset   iterator    e hasnext
object lock   e next
object locki   into get lock
if  locki    null
// lock is only in from list
into put lock  lock
else
// merge the locks
lock froml    lock  lock
lock intol    lock  locki
intol count    froml getcount
synchronized int unlockreference lockset lset  lockable ref  object qualifier  object group
// look for locks matching our reference and qualifier.
hashmap dl    hashmap  get group
if  dl    null
return 0
lock lockingroup
synchronized  lset
control control   lset getcontrol ref
if  control    null
return 0
lock setlock   control getlock compatspace  qualifier
if  setlock    null
return 0
lockingroup    lock  dl remove setlock
if  lockingroup    null
return 0
setlock   null
lset unlock lockingroup  1
if  lockingroup getcount      1
if  dl isempty
remove group
savegroup dl
if   callbackgroup    null     isempty
holder remove compatspace
else if  group equals callbackgroup
nextlimitcall   limit
return 1
// the lock item will be left in the group
lockingroup count
dl put lockingroup  lockingroup
return 1
/**
return true if locks are held in a group
*/
synchronized boolean arelocksheld object group
return   get group     null
synchronized boolean islockheld object group  lockable ref  object qualifier
// look for locks matching our reference and qualifier.
hashmap dl    hashmap  get group
if  dl    null
return false
object heldlock   dl get new lock compatspace  ref  qualifier
return  heldlock    null
synchronized void setlimit object group  int limit  limit callback
callbackgroup   group
this nextlimitcall   this limit   limit
this callback   callback
/**
clear a limit set by setlimit.
*/
synchronized void clearlimit object group
if  group equals callbackgroup
callbackgroup   null
nextlimitcall   limit   integer max_value
callback   null
if  isempty
holder remove compatspace
/**
return a count of the number of locks
held by this space. the argument bail
indicates at which point the counting
should bail out and return the current
count. this routine will bail if the
count is greater than bail. thus this
routine is intended to for deadlock
code to find the space with the
fewest number of locks.
*/
synchronized int deadlockcount int bail
int count   0
for  enumeration groups   elements    groups hasmoreelements
hashmap group    hashmap  groups nextelement
for  iterator locks   group keyset   iterator    locks hasnext
lock lock    lock  locks next
count    lock getcount
if  count > bail
return count
return count
/**
an enumeration that returns the the lockables
in a group.
*/
class locklist implements enumeration
private enumeration lockgroup
locklist enumeration lockgroup
this lockgroup   lockgroup
public boolean hasmoreelements
return lockgroup hasmoreelements
public object nextelement
return   lock  lockgroup nextelement    getlockable