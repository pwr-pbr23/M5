/*
derby - class org.apache.derby.impl.sql.compile.execspsnode
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package	org apache derby impl sql compile
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi services loader generatedclass
import org apache derby iapi error standardexception
import org apache derby iapi sql compile compilercontext
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi sql dictionary schemadescriptor
import org apache derby iapi sql dictionary spsdescriptor
import org apache derby iapi sql depend dependencymanager
import org apache derby iapi reference sqlstate
import org apache derby iapi sql execute constantaction
import org apache derby iapi sql execute execpreparedstatement
import org apache derby iapi types datatypedescriptor
import org apache derby iapi sql preparedstatement
import org apache derby iapi sql resultdescription
import org apache derby impl sql cursorinfo
import org apache derby iapi util bytearray
import java util enumeration
/**
* a execspsnode is the root of a querytree
* that represents an execute statement
* statement.  it is a tad abnormal.  duringa
* bind, it locates and retrieves the spsdescriptor
* for the particular statement.  at generate time,
* it generates the prepared statement for the
* stored prepared statement and returns it (i.e.
* it effectively replaces itself with the appropriate
* prepared statement).
*
* @author jamie
*/
public class execspsnode extends statementnode
private tablename			name
private spsdescriptor		spsd
private execpreparedstatement ps
/**
* initializer for a execspsnode
*
* @param newobjectname		the name of the table to be created
*
* @exception standardexception		thrown on error
*/
public void init
object 		newobjectname
this name    tablename  newobjectname
/**
* bind this execspsnode.  this means doing any static error
* checking that can be done before actually creating the table.
* for example, verifying that the resultcolumnlist does not
* contain any duplicate column names.
*
* @return	the bound query tree
*
* @exception standardexception		thrown on error
*/
public querytreenode bind   throws standardexception
/*
** grab the compiler context each time we bind just
** to make sure we have the write one (even though
** we are caching it).
*/
datadictionary dd   getdatadictionary
string schemaname   name getschemaname
schemadescriptor sd   getschemadescriptor name getschemaname
if  schemaname    null
name setschemaname sd getschemaname
if  sd getuuid      null
spsd   dd getspsdescriptor name gettablename    sd
if  spsd    null
throw standardexception newexception sqlstate lang_object_not_found     name
if  spsd gettype      spsd sps_type_trigger
throw standardexception newexception sqlstate lang_trigger_sps_cannot_be_execed  name
/*
** this execute statement is dependent on the
** stored prepared statement.  if for any reason
** the underlying statement is invalidated by
** the time we get to execution, the 'execute statement'
** will get invalidated when the underlying statement
** is invalidated.
*/
getcompilercontext   createdependency spsd
return this
/**
* spses are atomic if its underlying statement is
* atomic.
*
* @return true if the statement is atomic
*/
public boolean isatomic
if  sanitymanager debug
sanitymanager assert ps    null
return ps isatomic
/**
* do code generation for this statement.  overrides
* the normal generation path in statementnode.
*
* @param	ignored - ignored (he he)
*
* @return		a generatedclass for this statement
*
* @exception standardexception		thrown on error
*/
public generatedclass generate bytearray ignored  throws standardexception
//bug 4821 - commiting the nested transaction will release any bind time locks
//this way we won't get lock time out errors while trying to update sysstatement
//table during stale sps recompilation later in the getpreparedstatement() call.
if  spsd isvalid      false
getlanguageconnectioncontext   commitnestedtransaction
getlanguageconnectioncontext   beginnestedtransaction true
/*
** the following does a prepare on the underlying
** statement if necessary.  the returned statement
** is valid and its class is loaded up.
*/
ps   spsd getpreparedstatement
/*
** set the saved constants from the prepared statement.
** put them in the compilation context -- this is where
** they are expected.
*/
getcompilercontext   setsavedobjects ps getsavedobjects
getcompilercontext   setcursorinfo ps getcursorinfo
generatedclass gc   ps getactivationclass
return gc
/**
* make the result description.  really, we are just
* copying it from the stored prepared statement.
*
* @return	the description
*/
public resultdescription makeresultdescription
return ps getresultdescription
/**
* get information about this cursor.  for sps,
* this is info saved off of the original query
* tree (the one for the underlying query).
*
* @return	the cursor info
*/
public object getcursorinfo
return ps getcursorinfo
/**
* return a description of the ? parameters for the statement
* represented by this query tree.  just return the params
* stored with the prepared statement.
*
* @return	an array of datatypedescriptors describing the
*		? parameters for this statement.  it returns null
*		if there are no parameters.
*
* @exception standardexception on error
*/
public datatypedescriptor	getparametertypes   throws standardexception
return spsd getparams
/**
* create the constant information that will drive the guts of execution.
* this is assumed to be the first action on this node.
*
*/
public constantaction	makeconstantaction
return ps getconstantaction
/**
* we need a savepoint if we will do transactional work.
* we'll ask the underlying statement if it needs
* a savepoint and pass that back.  we have to do this
* after generation because getting the ps now might
* cause us to basically do ddl (for a stmt recompilation)
* which is explicitly banned during binding.  so the
* caller can only call this after generate() has retrieved
* the target ps.
*
* @return boolean	always true.
*/
public boolean needssavepoint
if  sanitymanager debug
sanitymanager assert ps    null
return ps needssavepoint
/** @see querytreenode#executestatementname */
public string executestatementname
return name gettablename
/** @see querytreenode#executeschemaname */
public string executeschemaname
return name getschemaname
/**
* get the name of the sps that is used
* to execute this statement.  only relevant
* for an execspsnode -- otherwise, returns null.
*
* @return the name of the underlying sps
*/
public string getspsname
return spsd getqualifiedname
/*
* shouldn't be called
*/
int activationkind
if  sanitymanager debug
sanitymanager throwassert
return statementnode need_param_activation
/////////////////////////////////////////////////////////////////////
//
// private
//
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
//
// misc
//
/////////////////////////////////////////////////////////////////////
public string statementtostring
return
// called after bind only
private final spsdescriptor getspsdescriptor
return spsd