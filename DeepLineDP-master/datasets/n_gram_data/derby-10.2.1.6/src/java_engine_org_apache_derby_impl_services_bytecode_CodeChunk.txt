/*
derby - class org.apache.derby.impl.services.bytecode.codechunk
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl services bytecode
import org apache derby iapi services classfile constant_index_info
import org apache derby iapi services classfile constant_utf8_info
import org apache derby iapi services classfile classformatoutput
import org apache derby iapi services classfile classholder
import org apache derby iapi services classfile classmember
import org apache derby iapi services classfile vmdescriptor
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi services classfile vmopcode
import org apache derby iapi services io arrayoutputstream
import java io ioexception
import java lang reflect modifier
import java util arrays
/**
* this class represents a chunk of code in a codeattribute.
* typically, a codeattribute represents the code in a method.
* if there is a try/catch block, each catch block will get its
* own code chunk.  this allows the catch blocks to all be put at
* the end of the generated code for a method, which eliminates
* the need to generate a jump around each catch block, which
* would be a forward reference.
*/
final class codechunk
/**
* starting point of the byte code stream in the underlying stream/array.
*/
private static final int code_offset   8
// the use of iload for the non-integer types is correct.
// we have to assume that the appropriate checks/conversions
// are defined on math operation results to ensure that
// the type is preserved when/as needed.
static final short load_variable
vmopcode iload 	   vm_byte
vmopcode iload 	   vm_short
vmopcode iload 	   vm_int
vmopcode lload 	   vm_long
vmopcode fload 	   vm_float
vmopcode dload 	   vm_double
vmopcode iload 	   vm_char
vmopcode aload	   vm_reference
static final short load_variable_fast
vmopcode iload_0 	   vm_byte
vmopcode iload_0 	   vm_short
vmopcode iload_0 	   vm_int
vmopcode lload_0 	   vm_long
vmopcode fload_0 	   vm_float
vmopcode dload_0 	   vm_double
vmopcode iload_0 	   vm_char
vmopcode aload_0	   vm_reference
// the istores for non-int types are how things work.
// it assumes that the appropriate casts are done
// on operations on non-ints to ensure that the values
// remain in the valid ranges.
static final short store_variable
vmopcode istore 	   vm_byte
vmopcode istore 	   vm_short
vmopcode istore 	   vm_int
vmopcode lstore 	   vm_long
vmopcode fstore 	   vm_float
vmopcode dstore 	   vm_double
vmopcode istore 	   vm_char
vmopcode astore	   vm_reference
static final short store_variable_fast
vmopcode istore_0 	   vm_byte
vmopcode istore_0 	   vm_short
vmopcode istore_0 	   vm_int
vmopcode lstore_0 	   vm_long
vmopcode fstore_0 	   vm_float
vmopcode dstore_0 	   vm_double
vmopcode istore_0 	   vm_char
vmopcode astore_0	   vm_reference
static final short array_access
vmopcode baload 	   vm_byte
vmopcode saload 	   vm_short
vmopcode iaload 	   vm_int
vmopcode laload 	   vm_long
vmopcode faload 	   vm_float
vmopcode daload 	   vm_double
vmopcode caload 	   vm_char
vmopcode aaload	   vm_reference
static final short array_store
vmopcode bastore 	   vm_byte
vmopcode sastore 	   vm_short
vmopcode iastore 	   vm_int
vmopcode lastore 	   vm_long
vmopcode fastore 	   vm_float
vmopcode dastore 	   vm_double
vmopcode castore 	   vm_char
vmopcode aastore	   vm_reference
static final short return_opcode
vmopcode ireturn      0   byte
vmopcode ireturn      1   short
vmopcode ireturn      2   int
vmopcode lreturn      3   long
vmopcode freturn      4   float
vmopcode dreturn      5   double
vmopcode ireturn      6   char
vmopcode areturn      7   reference
// the first dimension is the current vmtypeid
// the second dimension is the target vmtypeid
//
// the cells of the entry at [current,target] are:
// 0: operation
// 1: result type of operation
// if entry[1] = target, we are done. otherwise,
// you have to continue with entry[1] as the new current
// after generating the opcode listed (don't generate if it is nop).
// if entry[0] = bad, we can
static final short cast_conversion_info
/* current = vm_byte */
{
target   vm_byte           vmopcode nop  bcexpr vm_byte
target   vm_short          vmopcode nop  bcexpr vm_short
target   vm_int            vmopcode nop  bcexpr vm_int
target   vm_long           vmopcode nop  bcexpr vm_int
target   vm_float          vmopcode nop  bcexpr vm_int
target   vm_double         vmopcode nop  bcexpr vm_int
target   vm_char           vmopcode nop  bcexpr vm_char
target   vm_reference      vmopcode bad  bcexpr vm_reference
/* current = vm_short */
{
target   vm_byte           vmopcode nop  bcexpr vm_byte
target   vm_short          vmopcode nop  bcexpr vm_short
target   vm_int            vmopcode nop  bcexpr vm_int
target   vm_long           vmopcode nop  bcexpr vm_int
target   vm_float          vmopcode nop  bcexpr vm_int
target   vm_double         vmopcode nop  bcexpr vm_int
target   vm_char           vmopcode nop  bcexpr vm_char
target   vm_reference      vmopcode bad  bcexpr vm_reference
/* current = vm_int */
{
target   vm_byte           vmopcode i2b  bcexpr vm_byte
target   vm_short          vmopcode i2s  bcexpr vm_short
target   vm_int            vmopcode nop  bcexpr vm_int
target   vm_long           vmopcode i2l  bcexpr vm_long
target   vm_float          vmopcode i2f  bcexpr vm_float
target   vm_double         vmopcode i2d  bcexpr vm_double
target   vm_char           vmopcode i2b  bcexpr vm_char
target   vm_reference      vmopcode bad  bcexpr vm_reference
/* current = vm_long */
{
target   vm_byte           vmopcode l2i  bcexpr vm_int
target   vm_short          vmopcode l2i  bcexpr vm_int
target   vm_int            vmopcode l2i  bcexpr vm_int
target   vm_long           vmopcode nop  bcexpr vm_long
target   vm_float          vmopcode l2f  bcexpr vm_float
target   vm_double         vmopcode l2d  bcexpr vm_double
target   vm_char           vmopcode l2i  bcexpr vm_int
target   vm_reference      vmopcode bad  bcexpr vm_reference
/* current = vm_float */
{
target   vm_byte           vmopcode f2i  bcexpr vm_int
target   vm_short          vmopcode f2i  bcexpr vm_int
target   vm_int            vmopcode f2i  bcexpr vm_int
target   vm_long           vmopcode f2l  bcexpr vm_long
target   vm_float          vmopcode nop  bcexpr vm_float
target   vm_double         vmopcode f2d  bcexpr vm_double
target   vm_char           vmopcode f2i  bcexpr vm_int
target   vm_reference      vmopcode bad  bcexpr vm_reference
/* current = vm_double */
{
target   vm_byte           vmopcode d2i  bcexpr vm_int
target   vm_short          vmopcode d2i  bcexpr vm_int
target   vm_int            vmopcode d2i  bcexpr vm_int
target   vm_long           vmopcode d2l  bcexpr vm_long
target   vm_float          vmopcode d2f  bcexpr vm_float
target   vm_double         vmopcode nop  bcexpr vm_double
target   vm_char           vmopcode d2i  bcexpr vm_int
target   vm_reference      vmopcode bad  bcexpr vm_reference
/* current = vm_char */
{
target   vm_byte           vmopcode nop  bcexpr vm_byte
target   vm_short          vmopcode nop  bcexpr vm_short
target   vm_int            vmopcode nop  bcexpr vm_int
target   vm_long           vmopcode nop  bcexpr vm_int
target   vm_float          vmopcode nop  bcexpr vm_int
target   vm_double         vmopcode nop  bcexpr vm_int
target   vm_char           vmopcode nop  bcexpr vm_char
target   vm_reference      vmopcode bad  bcexpr vm_reference
/* current = vm_reference */
{
target   vm_byte           vmopcode bad  bcexpr vm_byte
target   vm_short          vmopcode bad  bcexpr vm_short
target   vm_int            vmopcode bad  bcexpr vm_int
target   vm_long           vmopcode bad  bcexpr vm_long
target   vm_float          vmopcode bad  bcexpr vm_float
target   vm_double         vmopcode bad  bcexpr vm_double
target   vm_char           vmopcode bad  bcexpr vm_char
target   vm_reference      vmopcode nop  bcexpr vm_reference
}
/**
* constant used by opcode_action to represent the
* common action of push one word, 1 byte
* for the instruction.
*/
private static final byte push1_1i    1  1
/**
* constant used by opcode_action to represent the
* common action of push two words, 1 byte
* for the instruction.
*/
private static final byte push2_1i    2  1
/**
* constant used by opcode_action to the opcode is
* not yet supported.
*/
private static final byte ns    0   1
/**
* value for opcode_action[opcode][0] to represent
* the number of words popped or pushed in variable.
*/
private static final byte variable_stack    128
/**
* array that provides two pieces of information about
* each vm opcode. each opcode has a two byte array.
* <p>
* the first element in the array [0] is the number of
* stack words (double/long count as two) pushed by the opcode.
* will be negative if the opcode pops values.
*
* <p>
* the second element in the array [1] is the number of bytes
* in the instruction stream that this opcode's instruction
* takes up, including the opocode.
*/
private static final byte opcode_action
{
nop  0                0  1
aconst_null  1     push1_1i
iconst_m1  2       push1_1i
iconst_0  3        push1_1i
iconst_1  4        push1_1i
iconst_2  5        push1_1i
iconst_3  6        push1_1i
iconst_4  7        push1_1i
iconst_5  8        push1_1i
lconst_0  9        push2_1i
lconst_1  10       push2_1i
fconst_0  11       push1_1i
fconst_1  12       push1_1i
fconst_2  13       push1_1i
dconst_0  14       push2_1i
dconst_1  15       push2_1i
bipush  16         1  2
sipush  17         1  3
ldc  18            1  2
ldc_w  19          1  3
ldc2_w  20         2  3
iload  21          1  2
lload  22          2  2
fload  23          1  2
dload  24          2  2
aload  25          1  2
iload_0  26      push1_1i
iload_1  27      push1_1i
iload_2  28      push1_1i
iload_3  29      push1_1i
lload_0  30      push2_1i
lload_1  31      push2_1i
lload_2  32      push2_1i
lload_3  33      push2_1i
fload_0  34      push1_1i
fload_1  35      push1_1i
fload_2  36      push1_1i
fload_3  37      push1_1i
dload_0  38      push2_1i
dload_1  39      push2_1i
dload_2  40      push2_1i
dload_3  41      push2_1i
aload_0  42      push1_1i
aload_1  43      push1_1i
aload_2  44      push1_1i
aload_3  45      push1_1i
iaload  46          1  1
laload  47         0  1
faload  48          1  1
daload  49         0  1
aaload  50          1  1
baload  51          1  1
caload  52          1  1
saload  53             1  1
istore  54             1  2
lstore  55             2  2
fstore  56             1  2
dstore  57             2  2
astore  58             1  2
istore_0  59           1  1
istore_1  60           1  1
istore_2  61           1  1
istore_3  62           1  1
lstore_0  63           2  1
lstore_1  64           2  1
lstore_2  65           2  1
lstore_3  66           2  1
fstore_0  67           1  1
fstore_1  68           1  1
fstore_2  69           1  1
fstore_3  70           1  1
dstore_0  71           2  1
dstore_1  72           2  1
dstore_2  73           2  1
dstore_3  74           2  1
astore_0  75           1  1
astore_1  76           1  1
astore_2  77           1  1
astore_3  78           1  1
iastore  79            3  1
lastore  80            4  1
fastore  81            3  1
dastore  82            4  1
aastore  83            3  1
bastore  84            3  1
castore  85            3  1
sastore  86            3  1
pop  87            1  1
pop2  88           2  1
dup  89         push1_1i
dup_x1  90      push1_1i
dup_x2  91      push1_1i
dup2  92        push2_1i
dup2_x1  93     push2_1i
dup2_x2  94     push2_1i
swap  95          0  1
iadd  96        ns
ladd  97        ns
fadd  98           1  1
dadd  99           2  1
isub  100        ns
lsub  101        ns
fsub  102           1  1
dsub  103           2  1
imul  104        ns
lmul  105        ns
fmul  106           1  1
dmul  107           2  1
idiv  108        ns
ldiv  109        ns
fdiv  110           1  1
ddiv  111           2  1
irem  112           1  1
lrem  113           2  1
frem  114           1  1
drem  115           2  1
ineg  116          0  1
lneg  117          0  1
fneg  118          0  1
dneg  119          0  1
ishl  120           1  1
lshl  121        ns
ishr  122        ns
lshr  123        ns
iushr  124        ns
lushr  125        ns
iand  126           1  1
land  127        ns
ior  128            1  1
lor  129         ns
ixor  130        ns
lxor  131        ns
iinc  132        ns
i2l  133        push1_1i
i2f  134          0  1
i2d  135        push1_1i
l2i  136           1  1
l2f  137           1  1
l2d  138          0  1
f2i  139          0  1
f2l  140        push2_1i
f2d  141        push1_1i
d2i  142           1  1
d2l  143          0  1
d2f  144           1  1
i2b  145          0  1
i2c  146          0  1
i2s  147          0  1
lcmp  148           ns
fcmpl  149             1  1
fcmpg  150             1  1
dcmpl  151             3  1
dcmpg  152             3  1
ifeq  153              1  vmopcode if_ins_length
ifne  154              1  vmopcode if_ins_length
iflt  155              1  vmopcode if_ins_length
ifge  156              1  vmopcode if_ins_length
ifgt  157              1  vmopcode if_ins_length
ifle  158              1  vmopcode if_ins_length
if_icmpeq  159      ns
if_icmpne  160      ns
if_icmplt  161      ns
if_icmpge  162      ns
if_icmpgt  163      ns
if_icmple  164      ns
if_acmpeq  165      ns
if_acmpne  166      ns
goto  167             0  vmopcode goto_ins_length
jsr  168            ns
ret  169            ns
tableswitch  170    ns
lookupswitch  171   ns
ireturn  172           1  1       strictly speaking all words on the stack are popped
lreturn  173           2  1       strictly speaking all words on the stack are popped
freturn  174           1  1       strictly speaking all words on the stack are popped
dreturn  175           2  1       strictly speaking all words on the stack are popped
areturn  176           1  1       strictly speaking all words on the stack are popped
return  177           0  1       strictly speaking all words on the stack are popped
getstatic  178               variable_stack  3
putstatic  179               variable_stack  3
getfield  180                variable_stack  3
putfield  181                variable_stack  3
invokevirtual  182           variable_stack  3
invokespecial  183           variable_stack  3
invokestatic  184            variable_stack  3
invokeinterface  185         variable_stack  5
xxxunusedxxx  186           ns
new  187                      1  3
newarray  188                 0  2
anewarray  189                0  3
arraylength  190              0  1
athrow  191                 ns
checkcast  192                0  3
instanceof  193               0  3
monitorenter  194           ns
monitorexit  195            ns
wide  196                   ns
multianewarray  197         ns
ifnull  198                    1  vmopcode if_ins_length
ifnonnull  199                 1  vmopcode if_ins_length
goto_w  200                  0  vmopcode goto_w_ins_length
jsr_w  201                  ns
breakpoint  202             ns
/**
* assume an ioexception means some limit of the class file
* format was hit
*
*/
private void limithit ioexception ioe
{
cb addlimitexceeded ioe tostring
}
/**
* add an instruction that has no operand.
* all opcodes are 1 byte large.
*/
void addinstr short opcode
try
cout putu1 opcode
catch  ioexception ioe
limithit ioe
}
if  sanitymanager debug
if  opcode_action    1
sanitymanager throwassert     opcode
opcode_action
}
}
/**
* add an instruction that has a 16 bit operand.
*/
void addinstru2 short opcode  int operand
try
cout putu1 opcode
cout putu2 operand
catch  ioexception ioe
limithit ioe
}
if  sanitymanager debug
if  opcode_action    3
sanitymanager throwassert     opcode
opcode_action
}
}
/**
* add an instruction that has a 32 bit operand.
*/
void addinstru4 short opcode  int operand
try
cout putu1 opcode
cout putu4 operand
catch  ioexception ioe
limithit ioe
}
if  sanitymanager debug
if  opcode_action    5
sanitymanager throwassert     opcode
opcode_action
}
}
/**
* add an instruction that has an 8 bit operand.
*/
void addinstru1 short opcode  int operand
try
cout putu1 opcode
cout putu1 operand
catch  ioexception ioe
limithit ioe
}
// only debug code from here.
if  sanitymanager debug
if  opcode_action    2
sanitymanager throwassert     opcode
opcode_action
}
}
/**
* this takes an instruction that has a narrow
* and a wide form for cpe access, and
* generates accordingly the right one.
* we assume the narrow instruction is what
* we were given, and that the wide form is
* the next possible instruction.
*/
void addinstrcpe short opcode  int cpenum
if  cpenum < 256
addinstru1 opcode  cpenum
}
else
addinstru2  short   opcode 1   cpenum
}
}
/**
* this takes an instruction that can be wrapped in
* a wide for large variable #s and does so.
*/
void addinstrwide short opcode  int varnum
if  varnum < 256
addinstru1 opcode  varnum
}
else
addinstr vmopcode wide
addinstru2 opcode  varnum
}
}
/**
* for adding an instruction with 3 operands, a u2 and two u1's.
* so far, this is used by vmopcode.invokeinterface.
*/
void addinstru2u1u1 short opcode  int operand1  short operand2
short operand3
try
cout putu1 opcode
cout putu2 operand1
cout putu1 operand2
cout putu1 operand3
catch  ioexception ioe
limithit ioe
}
if  sanitymanager debug
if  opcode_action    5
sanitymanager throwassert     opcode
opcode_action
}
}
/** get the current program counter */
int getpc
return cout size     pcdelta
}
/**
* return the complete instruction length for the
* passed in opcode. this will include the space for
* the opcode and its operand.
*/
private static int instructionlength short opcode
{
int instructionlength   opcode_action
if (sanitymanager.debug)
{
if  instructionlength < 0
sanitymanager throwassert     opcode
}
return instructionlength
}
/**
* the delta between cout.size() and the pc.
* for an initial code chunk this is -8 (code_offset)
* since 8 bytes are written.
* for a nested codechunk return by insertcodespace the delta
* corresponds to the original starting pc.
* @see #insertcodespace
*/
private final int pcdelta
/**
* the class we are generating code for, used to indicate that
* some limit was hit during code generation.
*/
final bcclass       cb
codechunk bcclass cb
this cb   cb
cout   new classformatoutput
try
cout putu2 0      max_stack  placeholder for now
cout putu2 0      max_locals  placeholder for now
cout putu4 0      code_length  placeholder 4 now
catch  ioexception ioe
limithit ioe
}
pcdelta     codechunk code_offset
}
/**
* return a codechunk that has limited visibility into
* this codechunk. used when a caller needs to insert instructions
* into an existing stream.
* @param pc
* @param bytecount
*/
private codechunk codechunk main  int pc  int bytecount
{
this cb   main cb
arrayoutputstream aos
new arrayoutputstream main cout getdata
try
aos setposition code_offset   pc
aos setlimit bytecount
catch  ioexception e
limithit e
}
cout   new classformatoutput aos
pcdelta   pc
}
private final classformatoutput cout
/**
* now that we have codebytes, fix the lengths fields in it
* to reflect what was stored.
* limits checked here are from these sections of the jvm spec.
* <ul>
* <li> 4.7.3 the code attribute
* <li> 4.10 limitations of the java virtual machine
* </ul>
*/
private void fixlengths bcmethod mb  int maxstack  int maxlocals  int codelength
byte codebytes   cout getdata
// max_stack is in bytes 0-1
if  mb    null    maxstack > 65535
cb addlimitexceeded mb     65535  maxstack
codebytes    byte  maxstack >> 8
codebytes    byte  maxstack
// max_locals is in bytes 2-3
if  mb    null    maxlocals > 65535
cb addlimitexceeded mb     65535  maxlocals
codebytes    byte  maxlocals >> 8
codebytes    byte  maxlocals
// code_length is in bytes 4-7
if  mb    null    codelength > vmopcode max_code_length
cb addlimitexceeded mb
vmopcode max_code_length  codelength
codebytes    byte  codelength >> 24
codebytes    byte  codelength >> 16
codebytes    byte  codelength >> 8
codebytes    byte  codelength
}
/**
* wrap up the entry and stuff it in the class,
* now that it holds all of the instructions and
* the exception table.
*/
void complete bcmethod mb  classholder ch
classmember method  int maxstack  int maxlocals
int codelength    getpc
classformatoutput out   cout
try
out putu2 0      exception_table_length
if  sanitymanager debug
if  sanitymanager debug_on
// add a single attribute - linenumbertable
// this add fake line numbers that are the pc offset in the method.
out putu2 1      attributes_count
int cpiutf   ch addutf8
out putu2 cpiutf
out putu4  codelength   4    2
out putu2 codelength
for  int i   0  i < codelength  i
out putu2 i
out putu2 i
}
else
out putu2 0      attributes_count
}
else
out putu2 0      attributes_count
// attributes is empty, a 0-element array.
}
catch  ioexception ioe
limithit ioe
}
fixlengths mb  maxstack  maxlocals  codelength
method addattribute    out
if (sanitymanager.debug)
{
// only validate if the class file format is valid.
// ok code length and guaranteed no errors building the class.
if   codelength <  vmopcode max_code_length
mb    null    mb cb limitmsg    null
{
// validate the alternate way to calculate the
// max stack agrees with the dynamic as the code
// is built way.
int walkedmaxstack   findmaxstack ch  0  codelength
if  walkedmaxstack    maxstack
{
sanitymanager throwassert
maxstack       walkedmaxstack
}
}
}
}
/**
* return the opcode at the given pc.
*/
short getopcode int pc
{
return  short   cout getdata     0xff
}
/**
* get the unsigned short value for the opcode at the program
* counter pc.
*/
private int getu2 int pc
{
byte codebytes   cout getdata
int u2p   code_offset   pc   1
return   codebytes   0xff  << 8     codebytes   0xff
}
/**
* get the unsigned 32 bit value for the opcode at the program
* counter pc.
*/
private int getu4 int pc
{
byte codebytes   cout getdata
int u4p   code_offset   pc   1
return    codebytes   0xff  << 24
codebytes   0xff  << 16
codebytes   0xff  << 8
codebytes   0xff
}
/**
* insert room for bytecount bytes after the instruction at pc
* and prepare to replace the instruction at pc. the instruction
* at pc is not modified by this call, space is allocated after it.
* the newly inserted space will be filled with nop instructions.
*
* returns a codechunk positioned at pc and available to write
* instructions upto (bytecode + length(existing instruction at pc) bytes.
*
* this chunk is left correctly positioned at the end of the code
* stream, ready to accept more code. its pc will have increased by
* additionalbytes.
*
* it is the responsibility of the caller to patch up any
* branches or gotos.
*
* @param pc
* @param additionalbytes
*/
codechunk insertcodespace int pc  int additionalbytes
{
short existingopcode   getopcode pc
int lengthofexistinginstruction
instructionlength existingopcode
if  additionalbytes > 0
{
// size of the current code after this pc.
int sizetomove    getpc     pc    lengthofexistinginstruction
// increase the code by the number of bytes to be
// inserted. these nops will be overwritten by the
// moved code by the system.arraycopy below.
// it's assumed that the number of inserted bytes
// is small, one or two instructions worth, so it
// won't be a performance issue.
for  int i   0  i < additionalbytes  i
addinstr vmopcode nop
// must get codebytes here as the array might have re-sized.
byte codebytes   cout getdata
int byteoffset   code_offset   pc   lengthofexistinginstruction
// shift the existing code stream down
system arraycopy
codebytes  byteoffset
codebytes  byteoffset   additionalbytes
sizetomove
// place nops in the space just freed by the move.
// this is not required, it ias assumed the caller
// will overwrite all the bytes they requested, but
// to be safe fill in with nops rather than leaving code
// that could break the verifier.
arrays fill codebytes  byteoffset  byteoffset   additionalbytes
byte  vmopcode nop
}
// the caller must overwrite the original instruction
// at pc, thus increase the range of the limit stream
// created to include those bytes.
additionalbytes    lengthofexistinginstruction
// now the caller needs to fill in the instructions
// that make up the modified bytecount bytes of bytecode stream.
// return a codechunk that can be used for this and
// is limited to only those bytes.
// the pc of the original code chunk is left unchanged.
return new codechunk this  pc  additionalbytes
}
/*
* * methods related to splitting the byte code chunks into sections that
* fit in the jvm's limits for a single method.
*/
/**
* for a block of byte code starting at program counter pc for codelength
* bytes return the maximum stack value, assuming a initial stack depth of
* zero.
*/
private int findmaxstack classholder ch  int pc  int codelength
final int endpc   pc   codelength
int stack = 0;
int maxstack   0
for    pc < endpc
short opcode = getopcode(pc);
int stackdelta = stackworddelta(ch, pc, opcode);
stack += stackdelta;
if  stack > maxstack
maxstack   stack
int[] cond_pcs = findconditionalpcs(pc, opcode);
if (cond_pcs != null) {
// an else block exists.
if (cond_pcs[3] != -1) {
int blockmaxstack   findmaxstack ch  cond_pcs
cond_pcs
if   stack   blockmaxstack  > maxstack
maxstack   stack   blockmaxstack
pc = cond_pcs[3];
continue;
}
}
pc += instructionlength(opcode);
}
return maxstack
}
/**
* return the number of stack words pushed (positive) or popped (negative)
* by this instruction.
*/
private int stackworddelta classholder ch  int pc  short opcode
if  sanitymanager debug
// this validates the opcode_action entry
instructionlength opcode
}
int stackdelta   opcode_action
if  stackdelta    variable_stack
stackdelta   getvariablestackdelta ch  pc  opcode
}
return stackdelta
}
/**
* get the type descriptor in the virtual machine format for the type
* defined by the constant pool index for the instruction at pc.
*/
private string gettypedescriptor classholder ch  int pc
int cpi   getu2 pc
// field reference or method reference
constant_index_info cii    constant_index_info  ch getentry cpi
// nameandtype reference
int nameandtype   cii geti2
cii    constant_index_info  ch getentry nameandtype
// utf8 descriptor
int descriptor   cii geti2
constant_utf8_info type    constant_utf8_info  ch getentry descriptor
string vmdescriptor   type tostring
return vmdescriptor
}
/**
* get the word count for a type descriptor in the format of the virual
* machine. for a method this returns the the word count for the return
* type.
*/
private static int getdescriptorwordcount string vmdescriptor
int width
if  vmdescriptor double equals vmdescriptor
width   2
else if  vmdescriptor long equals vmdescriptor
width   2
else if  vmdescriptor charat 0     vmdescriptor c_method
switch  vmdescriptor charat vmdescriptor length     1
case vmdescriptor c_double
case vmdescriptor c_long
width   2
break;
case vmdescriptor c_void
width   0
break;
default
width   1
break;
}
else
width   1
return width
}
/**
* get the number of words pushed (positive) or popped (negative) by this
* instruction. the instruction is a get/put field or a method call, thus
* the size of the words is defined by the field or method being access.
*/
private int getvariablestackdelta classholder ch  int pc  int opcode
string vmdescriptor   gettypedescriptor ch  pc
int width   codechunk getdescriptorwordcount vmdescriptor
int stackdelta   0
// stack delta depends on context.
switch  opcode
case vmopcode getstatic
stackdelta   width
break;
case vmopcode getfield
stackdelta   width   1     one for popped object ref
break;
case vmopcode putstatic
stackdelta    width
break;
case vmopcode putfield
stackdelta    width   1     one for pop object ref
break;
case vmopcode.invokevirtual:
case vmopcode.invokespecial:
stackdelta    1     for instance reference for method call
case vmopcode.invokestatic:
stackdelta     width   codechunk parameterwordcount vmdescriptor
// system.out.println("invoked non-interface " + stackdelta);
break;
case vmopcode.invokeinterface:
// third byte contains the number of arguments to be popped
stackdelta   width   getopcode pc   3
// system.out.println("invoked interface " + stackdelta);
break;
default
system out println
break;
}
return stackdelta
}
/**
* calculate the number of stack words in the arguments pushed for this
* method descriptor.
*/
private static int parameterwordcount string methoddescriptor
int wordcount   0
for  int i   1   i
switch  methoddescriptor charat i
case vmdescriptor c_endmethod
return wordcount
case vmdescriptor c_double
case vmdescriptor c_long
wordcount    2
break;
case vmdescriptor c_array
// skip while there are array symbols.
do
i
while  methoddescriptor charat i     vmdescriptor c_array
if  methoddescriptor charat i     vmdescriptor c_class
// an array is a reference, even an array of doubles.
wordcount    1
break;
}
// fall through to skip the lclassname; after the array.
case vmdescriptor c_class
// skip until ;
do
i
while  methoddescriptor charat i     vmdescriptor c_endclass
wordcount    1
break;
default
wordcount    1
break;
}
}
}
/**
* find the limits of a conditional block starting at the instruction with
* the given opcode at the program counter pc.
* <p>
* returns a six element integer array of program counters and lengths.
* <code. [0] - program counter of the if opcode (passed in as pc) [1] -
* program counter of the start of the then block [2] - length of the then
* block [3] - program counter of the else block, -1 if no else block
* exists. [4] - length of of the else block, -1 if no else block exists.
* [5] - program counter of the common end point. </code>
*
* looks for and handles conditionals that are written by the conditional
* class.
*
* @return null if the opcode is not the start of a conditional otherwise
*         the array of values.
*/
private int findconditionalpcs int pc  short opcode
switch  opcode
default
return null
case vmopcode ifnonnull
case vmopcode ifnull
case vmopcode ifeq
case vmopcode ifne
break;
}
int then_pc
int else_pc
int if_off   getu2 pc
if   if_off    8
getopcode pc   vmopcode if_ins_length     vmopcode goto_w
// 32 bit branch
then_pc   pc   vmopcode if_ins_length   vmopcode goto_w_ins_length
// get else pc from the 32 bit offset within the goto_w
// instruction remembering to add it to the pc of that
// instruction, not the original if.
else_pc   pc   vmopcode if_ins_length
getu4 pc   vmopcode if_ins_length
else
then_pc   pc   vmopcode if_ins_length
else_pc   pc   if_off
}
// need to look for the goto or goto_w at the
// end of the then block. there might not be
// one for the case when there is no else block.
// in that case the then block will just run into
// what we currently think the else pc.
int end_pc    1
for  int tpc   then_pc  tpc < else_pc
short opc   getopcode tpc
// need to handle conditionals
int innercond   findconditionalpcs tpc  opc
if  innercond    null
// skip to the end of this conditional
tpc   innercond     end_pc
continue;
}
if  opc    vmopcode goto
// not at the end of the then block
// so not our goto. shouldn't see this
// with the current code due to the
// skipping of the conditional above.
// but safe defensive programming.
if  tpc     else_pc   vmopcode goto_ins_length
continue;
end_pc   tpc   getu2 tpc
break;
else if  opc    vmopcode goto_w
// not at the end of the then block
// so not our goto. shouldn't see this
// with the current code due to the
// skipping of the conditional above.
// but safe defensive programming.
if  tpc     else_pc   vmopcode goto_w_ins_length
continue;
end_pc   tpc   getu4 tpc
break;
}
tpc    instructionlength opc
}
int else_len
int then_len
if  end_pc     1
// no else block;
end_pc   else_pc
else_pc    1
then_len   end_pc   then_pc
else_len    1
else
then_len   else_pc   then_pc
else_len   end_pc   else_pc
}
int ret   new int
ret   pc
ret   then_pc
ret   then_len
ret   else_pc
ret   else_len
ret   end_pc
return ret
}
/**
* attempt to split the current method by pushing a chunk of
* its code into a sub-method. the starting point of the split
* (split_pc) must correspond to a stack depth of zero. it is the
* reponsibility of the caller to ensure this.
* split is only made if there exists a chunk of code starting at
* pc=split_pc, whose stack depth upon termination is zero.
* the method will try to split a code section greater than
* optimalminlength but may split earlier if no such block exists.
* <p>
* the method is aimed at splitting methods that contain
* many independent statements.
* <p>
* if a split is possible this method will perform the split and
* create a void sub method, and move the code into the sub-method
* and setup this method to call the sub-method before continuing.
* this method's max stack and current pc will be correctly set
* as though the method had just been created.
*
* @param mb method for this chunk.
* @param ch class definition
* @param optimalminlength minimum length required for split
*/
final int splitzerostack bcmethod mb  classholder ch  final int split_pc
final int optimalminlength
int splitminlength   splitminlength mb
int stack = 0;
// maximum possible split seen that is less than
// the minimum.
int possiblesplitlength = -1;
// do not split until at least this point (inclusive)
// used to ensure no split occurs in the middle of
// a conditional.
int outerconditionalend_pc = -1;
int end_pc   getpc       pc will be positioned at the end
for  int pc   split_pc  pc < end_pc
short opcode = getopcode(pc);
int stackdelta = stackworddelta(ch, pc, opcode);
stack += stackdelta;
// cannot split a conditional but need to calculate
// the stack depth at the end of the conditional.
// each path through the conditional will have the
// same stack depth.
int[] cond_pcs = findconditionalpcs(pc, opcode);
if (cond_pcs != null) {
// an else block exists, skip the then block.
if (cond_pcs[3] != -1) {
pc = cond_pcs[3];
continue;
}
if  sanitymanager debug
if (outerconditionalend_pc != -1) {
if (cond_pcs[5] >= outerconditionalend_pc)
sanitymanager.throwassert("nested conditionals!");
}
}
if  outerconditionalend_pc     1
outerconditionalend_pc = cond_pcs[5];
}
}
pc += instructionlength(opcode);
// don't split in the middle of a conditional
if (outerconditionalend_pc != -1) {
if (pc > outerconditionalend_pc) {
// passed the outermost conditional
outerconditionalend_pc = -1;
}
continue;
}
if  stack    0
continue;
int splitlength   pc   split_pc
if  splitlength < optimalminlength
// record we do have a possible split.
possiblesplitlength   splitlength
continue;
}
// no point splitting to a method bigger
// than the vm can handle. save one for
// return instruction.
if  splitlength > bcmethod code_split_length   1
splitlength    1
}
else if  codechunk isreturn opcode
{
// don't handle a return in the middle of
// an instruction stream. don't think this
// is generated, but be safe.
splitlength    1
}
// if splitlenth was set to -1 above then there
// is no possible split at this instruction.
if  splitlength     1
{
// no earlier split at all
if  possiblesplitlength     1
return -1;
// decide if the earlier possible split is
// worth it.
if  possiblesplitlength <  splitminlength
return -1;
// ok go with the earlier split
splitlength   possiblesplitlength
}
// yes, we can split this big method into a smaller method!!
bcmethod submethod   startsubmethod mb     split_pc
splitlength
return splitcodeintosubmethod mb  ch  submethod
split_pc  splitlength
}
return -1;
}
/**
* start a sub method that we will split the portion of our current code to,
* starting from start_pc and including codelength bytes of code.
*
* return a bcmethod obtained from bcmethod.getnewsubmethod with the passed
* in return type and same parameters as mb if the code block to be moved
* uses parameters.
*/
private bcmethod startsubmethod bcmethod mb  string returntype
int split_pc  int blocklength
boolean needparameters   usesparameters mb  split_pc  blocklength
return mb getnewsubmethod returntype  needparameters
}
/**
* does a section of code use parameters.
* any load, exception aload_0 in an instance method, is
* seen as using parameters, as this complete byte code
* implementation does not use local variables.
*
*/
private boolean usesparameters bcmethod mb  int pc  int codelength
// does the method even have parameters?
if  mb parameters    null
return false
boolean isstatic    mb myentry getmodifier     modifier static     0
int endpc   pc   codelength
for    pc < endpc
short opcode = getopcode(pc);
switch  opcode
case vmopcode iload_0
case vmopcode lload_0
case vmopcode fload_0
case vmopcode dload_0
return true
case vmopcode aload_0
if  isstatic
return true
break;
case vmopcode iload_1
case vmopcode lload_1
case vmopcode fload_1
case vmopcode dload_1
case vmopcode aload_1
return true
case vmopcode iload_2
case vmopcode lload_2
case vmopcode fload_2
case vmopcode dload_2
case vmopcode aload_2
return true
case vmopcode iload_3
case vmopcode lload_3
case vmopcode fload_3
case vmopcode dload_3
case vmopcode aload_3
return true
case vmopcode iload
case vmopcode lload
case vmopcode fload
case vmopcode dload
case vmopcode aload
return true
default
break;
}
pc += instructionlength(opcode);
}
return false
}
/**
* split a block of code from this method into a sub-method
* and call it.
*
* returns the pc of this method just after the call
* to the sub-method.
* @param mb my method
* @param ch my class
* @param submethod sub-method code was pushed into
* @param split_pc program counter the split started at
* @param splitlength length of code split
*/
private int splitcodeintosubmethod bcmethod mb  classholder ch
bcmethod submethod  final int split_pc  final int splitlength
codechunk subchunk   submethod mycode
byte codebytes   cout getdata
// the code to be moved into the sub method
// as a block. this will correctly increase the
// program counter.
try
subchunk cout write codebytes  code_offset   split_pc  splitlength
catch  ioexception ioe
limithit ioe
}
// just cause the sub-method to return,
// fix up its maxstack and then complete it.
if  submethod myreturntype equals
subchunk addinstr vmopcode return
else
subchunk addinstr vmopcode areturn
// finding the max stack requires the class format to
// still be valid. if we have blown the number of constant
// pool entries then we can no longer guarantee that indexes
// into the constant pool in the code stream are valid.
if  cb limitmsg    null
return -1;
submethod maxstack   subchunk findmaxstack ch  0  subchunk getpc
submethod complete
return removepushedcode mb  ch  submethod  split_pc  splitlength
}
/**
* remove a block of code from this method that was pushed into a sub-method
* and call the sub-method.
*
* returns the pc of this method just after the call to the sub-method.
*
* @param mb
*            my method
* @param ch
*            my class
* @param submethod
*            sub-method code was pushed into
* @param split_pc
*            program counter the split started at
* @param splitlength
*            length of code split
*/
private int removepushedcode bcmethod mb  classholder ch
bcmethod submethod  final int split_pc  final int splitlength
// now need to fix up this method, create
// a new codechunk just to be clearer than
// trying to modify this chunk directly.
// total length of the code for this method before split
final int codelength   getpc
codechunk replacechunk   new codechunk mb cb
mb mycode   replacechunk
mb maxstack   0
byte codebytes   cout getdata
// write any existing code before the split point
// into the replacement chunk.
if  split_pc    0
try
replacechunk cout write codebytes  code_offset  split_pc
catch  ioexception ioe
limithit ioe
}
}
// call the sub method, will write into replacechunk.
mb callsubmethod submethod
int postsplit_pc   replacechunk getpc
// write the code remaining in this method into the replacement chunk
int remainingcodepc   split_pc   splitlength
int remainingcodelength   codelength   splitlength   split_pc
try
replacechunk cout write codebytes  code_offset   remainingcodepc
remainingcodelength
catch  ioexception ioe
limithit ioe
}
// finding the max stack requires the class format to
// still be valid. if we have blown the number of constant
// pool entries then we can no longer guarantee that indexes
// into the constant pool in the code stream are valid.
if  cb limitmsg    null
return -1;
mb maxstack   replacechunk findmaxstack ch  0  replacechunk getpc
return postsplit_pc
}
/**
* split an expression out of a large method into its own
* sub-method.
* <p>
* method call expressions are of the form:
* <ul>
* <li> expr.method(args) -- instance method call
* <li> method(args) -- static method call
* </ul>
* two special cases of instance method calls will be handled
* by the first incarnation of splitexpressionout.
* three categories:
* <ul>
* <li>this.method(args)
* <li>this.getter().method(args)
* </ul>
* these calls are choosen as they are easier sub-cases
* and map to the code generated for sql statements.
* future coders can expand the method to cover more cases.
* <p>
* this method will split out such expressions in sub-methods
* and replace the original code with a call to that submethod.
* <ul>
* <li>this.method(args) ->> this.sub1([parameters])
* <li>this.getter().method(args) ->> this.sub1([parameters])
* </ul>
* the assumption is of course that the call to the sub-method
* is much smaller than the code it replaces.
* <p>
* looking at the byte code for such calls they would look like
* (for an example three argument method):
* <code>
* this arg1 arg2 arg3 invoke // this.method(args)
* this invoke arg1 arg2 arg3 invoke // this.getter().metod(args)
* </code>
* the bytecode for the arguments can be arbitary long and
* consist of expressions, typical derby code for generated
* queries is deeply nested method calls.
* <br>
* if none of the arguments requred the parameters passed into
* the method, then in both cases the replacement bytecode
* would look like:
* <code>
* this.sub1();
* </code>
* parameter handling is just as in the method splitzerostack().
* <p>
* because the vm is a stack machine the original byte code
* sequences are self contained. the stack at the start of
* is sequence is n and at the end (after the method call) will
* be:
* <ul>
* <li> n - void method
* <li> n + 1 - method returning a single word
* <li> n + 2 - method returning a double word (java long or double)
* </ul>
* this code will handle the n+1 where the word is a reference,
* the typical case for generated code.
* <br>
* the code is self contained because in general the byte code
* for the arguments will push and pop values but never drop
* below the stack value at the start of the byte code sequence.
* e.g. in the examples the stack before the first arg will be
* n+1 (the objectref for the method call) and at the end of the
* byte code for arg1 will be n+2 or n+3 depending on if arg1 is
* a single or double word argument. during the execution of
* the byte code the stack may have had many arguments pushed
* and popped, but will never have dropped below n+1. thus the
* code for arg1 is independent of the stack's previous values
* and is self contained. this self-containment then extends to
* all the arguements, the method call itself and pushing the
* objectref for the method call, thus the complete
* sequence is self-contained.
* <br>
* the self-containment breaks in a few cases, take the simple
* method call this.method(3), the byte code for this could be:
* <code>
* push3 this swap invoke
* </code>
* in this case the byte code for arg1 (swap) is not self-contained
* and relies on earlier stack values.
* <p>
* how to identify "self-contained blocks of code".
* <br>
* we walk through the byte code and maintain a history of
* the program counter that indicates the start of the
* independent sequence each stack word depends on.
* thus for a aload_0 instruction which pushes 'this' the
* dependent pc is that of the this. if a dup instruction followed
* then the top-word is now dependent on the previous word (this)
* and thus the dependence of it is equal to the dependence of
* the previous word. this information is kept in earliestindeppc
* array as we process the instruction stream.
* <br>
* when a invoke instruction is seen for an instance method
* that returns a single or double word, the dependence of
* the returned value is the dependence of the word in the
* stack that is the objectref for the call. this complete
* sequence from the pc the objectref depended on to the
* invoke instruction is then a self contained sequence
* and can be split into a sub-method.
* <br>
* if the block is self-contained then it can be split, following
* similar logic to splitzerostack().
*
*  <p>
*  work in progress - incremental development
*  <br>
*  currently walks the method maintaining the
*  earliestindeppc array and identifies potential blocks
*  to splt, performs splits as required.
*  called by bcmethod but commented out in submitted code.
*  tested with local changes from calls in bcmethod.
*  splits generally work, though largecodegen shows
*  a problem that will be fixed before the code in
*  enabled for real.
*
*/
final int splitexpressionout final bcmethod mb  final classholder ch
final int optimalminlength
final int maxstack
{
// save the best block we have seen for splitting out.
int bestsplitpc    1
int bestsplitblocklength    1
string bestsplitrt   null
int splitminlength   splitminlength mb
// program counter of the earliest instruction
// that the word in the current active stack
// at the given depth depends on.
//
// some examples, n is the stack depth *after*
// the instruction.
// e.g.
// aload_0 - pushes this, is an instruction that
// pushes an independent value, so the current
// stack word depends on the pc of current instruction.
// earliestindeppc[n] = pc (that pushed the value).
//
// dup - duplicates the top word, so the duplicated
// top word will depend on the same pc as the word
// it was duplicated from.
// i.e. earliestindeppc[n]
//            = earliestindeppc[n-1];
//
// instance method call returning single word value.
// the top word will depend on the same pc as the
// objectref for the method call, which was at the
// same depth in this case.
// earliestindeppc[n] unchanged
//
// at any time earliestindeppc is only valid
// from 1 to n where n is the depth of the stack.
int earliestindeppc   new int
int stack = 0;
//todo: this conditional handling is copied from
//the splitzerostack code, need to check to see
// how it fits with the expression logic.
// do not split until at least this point (inclusive)
// used to ensure no split occurs in the middle of
// a conditional.
int outerconditionalend_pc = -1;
int end_pc   getpc
for (int pc = 0; pc < end_pc;) {
short opcode = getopcode(pc);
int stackdelta = stackworddelta(ch, pc, opcode);
stack += stackdelta;
// cannot split a conditional but need to calculate
// the stack depth at the end of the conditional.
// each path through the conditional will have the
// same stack depth.
int[] cond_pcs = findconditionalpcs(pc, opcode);
if (cond_pcs != null) {
// todo: this conditional handling was copied
// from splitzerostack, haven't looked in detail
// to see how a conditional should be handled
// with an expression split. so for the time
// being just bail.
if  true
return -1;
// an else block exists, skip the then block.
if (cond_pcs[3] != -1) {
pc = cond_pcs[3];
continue;
}
if (sanitymanager.debug)
{
if (outerconditionalend_pc != -1)
{
if (cond_pcs[5] >= outerconditionalend_pc)
sanitymanager.throwassert("nested conditionals!");
}
}
if (outerconditionalend_pc == -1)
{
outerconditionalend_pc = cond_pcs[5];
}
}
pc += instructionlength(opcode);
// don't split in the middle of a conditional
if (outerconditionalend_pc != -1) {
if (pc > outerconditionalend_pc) {
// passed the outermost conditional
outerconditionalend_pc = -1;
}
continue;
}
int opcode_pc = pc - instructionlength(opcode);
switch (opcode)
{
// any instruction we don't have any information
// on, we simply clear all evidence of independent
// starting points, and start again.
default
arrays fill earliestindeppc
0  stack   1   1
break;
// independent instructions do not change the stack depth
// and the independence of the top word picks up
// the independence of the previous word at the same
// position. ie. no change!
case vmopcode arraylength
case vmopcode nop
case vmopcode checkcast
case vmopcode d2l
case vmopcode dneg
case vmopcode f2i
break;
// independent instructions that push one word
case vmopcode aload_0
case vmopcode aload_1
case vmopcode aload_2
case vmopcode aload_3
case vmopcode aload
case vmopcode aconst_null
case vmopcode bipush
case vmopcode fconst_0
case vmopcode fconst_1
case vmopcode fconst_2
case vmopcode fload
case vmopcode iconst_0
case vmopcode iconst_1
case vmopcode iconst_2
case vmopcode iconst_3
case vmopcode iconst_4
case vmopcode iconst_5
case vmopcode iconst_m1
case vmopcode ldc
case vmopcode ldc_w
case vmopcode sipush
earliestindeppc   opcode_pc
break;
// independent instructions that push two words
case vmopcode dconst_0
case vmopcode dconst_1
case vmopcode lconst_0
case vmopcode lconst_1
case vmopcode ldc2_w
case vmopcode lload
case vmopcode lload_0
case vmopcode lload_1
case vmopcode lload_2
case vmopcode lload_3
earliestindeppc
earliestindeppc   opcode_pc
break;
// nothing to do for pop, obviously no
// code will be dependent on the popped words.
case vmopcode pop
case vmopcode pop2
break;
case vmopcode swap
earliestindeppc   earliestindeppc
break;
// push a value that depends on the previous value
case vmopcode i2l
earliestindeppc   earliestindeppc
break;
case vmopcode getfield
{
string vmdescriptor = gettypedescriptor(ch, opcode_pc);
int width   codechunk getdescriptorwordcount vmdescriptor
if  width    2
earliestindeppc   earliestindeppc
break;
}
case vmopcode.invokeinterface:
case vmopcode.invokevirtual:
{
//   ...,objectref[,word]*
//
// => ...
// => ...,word
// => ...,word1,word2
// width of the value returned by the method call.
string vmdescriptor = gettypedescriptor(ch, opcode_pc);
int width   codechunk getdescriptorwordcount vmdescriptor
// independence of this block is the independence
// of the objectref that invokved the method.
int selfcontainedblockstart
if  width    0
{
// objectref was at one more than the current depth
// no plan to split here though, as we are only
// splitting methods that return a reference.
selfcontainedblockstart    1
// earliestindeppc[stack + 1];
}
else if  width    1
{
// stack is unchanged, objectref was at
// the current stack depth
selfcontainedblockstart   earliestindeppc
}
else
{
// width == 2, objectref was one below the
// current stack depth.
// no plan to split here though, as we are only
// splitting methods that return a reference.
selfcontainedblockstart    1
// top two words depend on the objectref
// which was at the same depth of the first word
// of the 64 bit value.
earliestindeppc
earliestindeppc
}
if  selfcontainedblockstart     1
{
int blocklength   pc   selfcontainedblockstart
if  blocklength <  splitminlength
{
// no point splitting, too small
}
else if  blocklength >  vmopcode max_code_length   1
{
// too big to split into a single method
// (one for the return opcode)
}
else
{
// only split for a method that returns
// an class reference.
int me   vmdescriptor lastindexof
if  vmdescriptor charat me 1
{
string rt   vmdescriptor substring me   2
vmdescriptor length     1
// convert to external format.
rt   rt replace
if  blocklength >  optimalminlength
{
// split now!
bcmethod submethod   startsubmethod mb
rt  selfcontainedblockstart
blocklength
return splitcodeintosubmethod mb  ch  submethod
selfcontainedblockstart  blocklength
}
else if  blocklength > bestsplitblocklength
{
// save it, may split at this point
// if nothing better seen.
bestsplitpc   selfcontainedblockstart
bestsplitblocklength   blocklength
bestsplitrt   rt
}
}
}
}
break;
}
}
}
if  bestsplitblocklength     1
bcmethod submethod   startsubmethod mb
bestsplitrt  bestsplitpc
bestsplitblocklength
return splitcodeintosubmethod mb  ch  submethod
bestsplitpc  bestsplitblocklength
}
return -1;
}
/**
* see if the opcode is a return instruction.
* @param opcode opcode to be checked
* @return true for is a return instruction, false otherwise.
*/
private static boolean isreturn short opcode
{
switch (opcode)
{
case vmopcode return
case vmopcode areturn
case vmopcode ireturn
case vmopcode freturn
case vmopcode dreturn
case vmopcode lreturn
return true
default
return false
}
}
/**
* minimum split length for a sub-method. if the number of
* instructions to call the sub-method exceeds the length
* of the sub-method, then there's no point splitting.
* the number of bytes in the code stream to call
* a generated sub-method can take is based upon the number of method args.
* a method can have maximum of 255 words of arguments (section 4.10 jvm spec)
* which in the worst case would be 254 (one-word) parameters
* and this. for a sub-method the arguments will come from the
* parameters to the method, i.e. aload, iload etc.
* <br>
* this leads to this number of instructions.
* <ul>
* <li> 4 - 'this' and first 3 parameters have single byte instructions
* <li> (n-4)*2 - remaining parameters have two byte instructions
* <li> 3 for the invoke instruction.
* </ul>
*/
private static int splitminlength bcmethod mb
int min   1   3     for aload_0  this  and invoke instruction
if  mb parameters    null
int paramcount   mb parameters length
min    paramcount
if  paramcount > 3
min     paramcount   3
}
return min
}
/*
final int splitnonzerostack(bcmethod mb, classholder ch,
final int codelength, final int optimalminlength,
int maxstack) {
// program counter for the instruction that
// made the stack reach the given stack depth.
int[] stack_pcs = new int[maxstack+1];
arrays.fill(stack_pcs, -1);
int stack = 0;
// maximum possible split seen that is less than
// the minimum.
int possiblesplitlength = -1;
system.out.println("nz split + " + mb.getname());
// do not split until at least this point (inclusive)
// used to ensure no split occurs in the middle of
// a conditional.
int outerconditionalend_pc = -1;
int end_pc = 0 + codelength;
for (int pc = 0; pc < end_pc;) {
short opcode = getopcode(pc);
int stackdelta = stackworddelta(ch, pc, opcode);
stack += stackdelta;
// cannot split a conditional but need to calculate
// the stack depth at the end of the conditional.
// each path through the conditional will have the
// same stack depth.
int[] cond_pcs = findconditionalpcs(pc, opcode);
if (cond_pcs != null) {
// an else block exists, skip the then block.
if (cond_pcs[3] != -1) {
pc = cond_pcs[3];
continue;
}
if (sanitymanager.debug)
{
if (outerconditionalend_pc != -1)
{
if (cond_pcs[5] >= outerconditionalend_pc)
sanitymanager.throwassert("nested conditionals!");
}
}
if (outerconditionalend_pc == -1)
{
outerconditionalend_pc = cond_pcs[5];
}
}
pc += instructionlength(opcode);
// don't split in the middle of a conditional
if (outerconditionalend_pc != -1) {
if (pc > outerconditionalend_pc) {
// passed the outermost conditional
outerconditionalend_pc = -1;
}
continue;
}
if (stackdelta == 0)
continue;
// only split when the stack is having items popped
if (stackdelta > 0)
{
// pushing double word, clear out a
if (stackdelta == 2)
stack_pcs[stack - 1] = pc;
stack_pcs[stack] = pc;
continue;
}
int opcode_pc = pc - instructionlength(opcode);
// look for specific opcodes that have the capability
// of having a significant amount of code in a self
// contained block.
switch (opcode)
{
// this.method(a) construct
//  ...         -- stack n
//  push this -- stack n+1
//  push args -- stack n+1+a
//  call method -- stack n+r (r=0,1,2)
//
//  stackdelta = (n+r) - (n+1+a) = r-(1+a)
//  stack = n+r
//  need to determine n+1
//
//
//
//  this.a(<i2>, <i2>, <i3>)
//  returning int
//
//  stackdelta = -3 (this & 3 args popped, ret pushed)
//  initial depth n = 10
//  pc        - stack
//  100 ...       - stack 10
//  101 push this - stack 11
//  109 push i1   - stack 12
//  125 push i2   - stack 13
//  156 push i3   - stack 14
//  157 call      - stack 11
//
//  need stack_pcs[11] = stack_pcs[11 + -3]
//
// ref.method(args).method(args) ... method(args)
//
case vmopcode.invokeinterface:
case vmopcode.invokespecial:
case vmopcode.invokevirtual:
{
string vmdescriptor = gettypedescriptor(ch, opcode_pc);
int r = codechunk.getdescriptorwordcount(vmdescriptor);
// pc of the opcode that pushed the reference for
// this method call.
int ref_pc = stack_pcs[stack - r + 1];
if (getopcode(ref_pc) == vmopcode.aload_0) {
system.out.println("poss split " + (pc - ref_pc) + " @ " + ref_pc);
}
break;
}
case vmopcode.invokestatic:
string vmdescriptor = gettypedescriptor(ch, opcode_pc);
int r = codechunk.getdescriptorwordcount(vmdescriptor);
int p1_pc = stack_pcs[stack - r + 1];
system.out.println("poss static split " + (pc - p1_pc) + " @ " + p1_pc);
}
stack_pcs[stack] = opcode_pc;
}
return -1;
}*/
}