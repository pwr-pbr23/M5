/*
derby - class org.apache.derby.impl.store.raw.xact.transactiontableentry
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl store raw xact
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi services io formatable
import org apache derby iapi services io formatidutil
import org apache derby iapi services io storedformatids
import org apache derby iapi error standardexception
import org apache derby iapi sql conn languageconnectioncontext
import org apache derby iapi sql conn statementcontext
import org apache derby iapi store access transactioninfo
import org apache derby iapi store raw globaltransactionid
import org apache derby iapi store raw xact transactionid
import org apache derby iapi store raw log loginstant
import java io objectoutput
import java io objectinput
import java io ioexception
/**
transaction table entry is used to store all relavent information of a
transaction into the transaction table for the use of checkpoint, recovery,
transaction management during quiesce state, and for dumping transaction table.  only works
with the following classes: transactiontable, xactfactory, xact
<br>
during run time, whenever any transaction is started, it is put into the
transaction table.  whenever any transaction is closed, it is removed from
the transaction table.
*/
public class transactiontableentry implements formatable  transactioninfo  cloneable
{
// these fields are only populated if this tte has been read in from the
// log.  otherwise, they are gotten from the transaction object myxact.
private transactionid           xid
private globaltransactionid     gid
private loginstant              firstlog
private loginstant              lastlog
// this field is always present - it is 0 for read only transaction, this
// is a copy of the status from the xact (the copy is necessary as during
// recovery the xact is shared by all transaction table entries during
// redo and undo).
private int                     transactionstatus
// fields useful for returning transaction information if read from
// transaction log during recovery
private transient xact    myxact
private transient boolean update
private transient boolean recovery             is this a transaction read
// from the log during recovery?
private transient boolean needexclusion        in a quiesce state   this
// transaction needs to be
// barred from activation
// during quiesce state
private boolean isclone 		               am i a clone made for the
// transactionvti?
private transient languageconnectioncontext lcc
/* package */
// entry attribute
static final int update		  0x1
static final int recovery	  0x2
static final int exclude	  0x4
transactiontableentry
xact            xact
transactionid   tid
int             status
int             attribute
{
myxact                xact
xid                   tid
transactionstatus     status
update                 attribute   update       0
needexclusion          attribute   exclude      0
recovery               attribute   recovery     0
if (sanitymanager.debug)
{
sanitymanager assert tid    null
if  update    xact getfirstloginstant      null
{
sanitymanager.throwassert(
}
/*
if (!update && xact.getfirstloginstant() != null)
{
sanitymanager.throwassert(
"read only transaction has firstlog = " +
xact.getfirstloginstant());
}
*/
}
// normally, we don't need to remember the gid, firstlog and lastlog
// because myxact will have the same information.  however, in
// recovery, there is only one transaction taking on different identity
// as the log is replayed.  then each transaction table entry has keep
// its own identity and not rely on myxact.  these recovery
// transactions are materialized in the transaction table via a
// readobject in the checkpoint log record, or are added by
// addupdatetransaction when the log is scanned.
if  recovery
{
// make a copy of everything
if (sanitymanager.debug)
{
sanitymanager assert update
if  tid    xact getid
{
sanitymanager.throwassert(
tid       xact getid
}
}
gid           xact getglobalid
firstlog      xact getfirstloginstant
lastlog       xact getlastloginstant
}
}
/*
* formatable methods
*/
public transactiontableentry
public void writeexternal objectoutput out  throws ioexception
{
if (sanitymanager.debug)
{
sanitymanager assert  recovery
sanitymanager assert update
sanitymanager assert myxact getfirstloginstant      null
sanitymanager assert  isclone
}
// why is is safe to access first and last log instant in myxact while
// this is happening?  because we only writes out update transaction
// during run time.  when a read only transactions becomes an update
// transaction , or when an update transaction commits, the beginxact
// and endxact log record's dome method will try to change the
// transaction table entry's state to updat and non-update
// respectively.  that change needs to go thru the transaction table
// which is mutually exclusive to writing out the transaction table.
// since we are only looking at update transactions and it is "stuck"
// in update state in the middle of a transactiontable.writeexternal
// call, all the fields we access in myxact is stable (actually the xid
// is also stable but we already have it).
//
out writeobject xid
out writeobject myxact getglobalid
out writeobject myxact getfirstloginstant
out writeobject myxact getlastloginstant
out writeint transactionstatus
}
public void readexternal objectinput in
throws classnotfoundexception  ioexception
{
// the only time a transaction table entry is written out is to the
// log, so this must be read in during recovery.
if (sanitymanager.debug)
sanitymanager assert  isclone
xid    transactionid in readobject
gid    globaltransactionid in readobject
firstlog    loginstant in readobject
lastlog    loginstant in readobject
transactionstatus   in readint
update   true
recovery   true
needexclusion   true
if (sanitymanager.debug)
{
sanitymanager assert xid    null
sanitymanager assert firstlog    null
}
}
// set my transaction instance variable for a recovery transaction
void setxact xact xact
{
/*
resolve (mikem) - prepared transactions now call setxact() when they are
not in recovery.
if (sanitymanager.debug)
{
sanitymanager.assert(recovery,
"setting non-recovery transaction table entry xact");
sanitymanager.assert(!isclone, "cannot setxact with a clone");
}
*/
myxact   xact
}
/**
return my format identifier.
*/
public int gettypeformatid
return storedformatids raw_store_transaction_table_entry
}
public string tostring
{
if (sanitymanager.debug)
{
stringbuffer str   new stringbuffer 500
append    append getxid
append    append getgid
append    append getfirstlog
append    append getlastlog
append    append transactionstatus
append    append myxact
append    append update
append    append recovery
append    append isprepared
append    append needexclusion
append
return str tostring
}
else
return null
}
void updatetransactionstatus xact xact  int status  int attribute
{
if (sanitymanager.debug)
{
sanitymanager assert myxact    xact
sanitymanager assert  isclone
}
this update    attribute   update     0
}
void removeupdatetransaction
{
if (sanitymanager.debug)
sanitymanager assert  isclone
this update   false
transactionstatus   0
}
void unsetrecoverystatus
{
if (sanitymanager.debug)
sanitymanager assert  isclone
// resolve (mikem) - this is kind of ugly. move to a better place?
firstlog   null
this recovery   false
}
void preparetransaction
{
if (sanitymanager.debug)
sanitymanager assert  isclone
transactionstatus    xact end_prepared
}
/**************************************************************************
* get instance variables
**************************************************************************
*/
transactionid getxid
{
if (sanitymanager.debug)
{
sanitymanager assert xid    null
sanitymanager assert  isclone
}
return xid
}
public final globaltransactionid getgid
{
if (sanitymanager.debug)
sanitymanager assert  isclone
if  gid    null
return gid
if  myxact    null
return myxact getglobalid
return null
}
loginstant getfirstlog
{
if (sanitymanager.debug)
{
sanitymanager assert  isclone
if  recovery
{
sanitymanager assert
firstlog    null
}
else
{
sanitymanager assert
firstlog    null
myxact getfirstloginstant
}
}
if  firstlog    null
return firstlog
if  myxact    null
return myxact getfirstloginstant
return null
}
loginstant getlastlog
{
if (sanitymanager.debug)
sanitymanager assert  isclone
if  lastlog    null
return lastlog
if  myxact    null
return myxact getlastloginstant
return null
}
public final xact getxact
{
if (sanitymanager.debug)
sanitymanager assert  isclone
return myxact
}
int gettransactionstatus
{
if (sanitymanager.debug)
sanitymanager assert  isclone
return transactionstatus
}
boolean isupdate
{
if (sanitymanager.debug)
sanitymanager assert  isclone
return update
}
boolean isrecovery
{
if (sanitymanager.debug)
sanitymanager assert  isclone
return recovery
}
boolean isprepared
{
if (sanitymanager.debug)
sanitymanager assert  isclone
return  transactionstatus   xact end_prepared     0
}
public boolean needexclusion
{
if (sanitymanager.debug)
sanitymanager assert  isclone
return needexclusion
}
/**
methods of transactioninfo
*/
public string gettransactionidstring
{
if (sanitymanager.debug)
{
sanitymanager assert
recovery
sanitymanager assert myxact    null
sanitymanager assert isclone
}
transactionid t   myxact getidnocheck
return  t    null  ?     t tostring
}
public string getglobaltransactionidstring
{
if (sanitymanager.debug)
{
sanitymanager assert
recovery
sanitymanager assert myxact    null
sanitymanager assert isclone
}
globaltransactionid gid   myxact getglobalid
return  gid    null  ? null   gid tostring
}
public string getusernamestring
{
if (sanitymanager.debug)
sanitymanager assert isclone
getlcc
return  lcc    null  ? null   lcc getauthorizationid
}
public string gettransactiontypestring
{
if (sanitymanager.debug)
sanitymanager assert isclone
if  myxact    null
return null
else if  myxact gettransname      null
return myxact gettransname
else
return myxact getcontextid
}
public string gettransactionstatusstring
{
if (sanitymanager.debug)
sanitymanager assert isclone
return  myxact    null  ? null   myxact getstate
}
public string getstatementtextstring
{
if (sanitymanager.debug)
sanitymanager assert isclone
getlcc
if  lcc    null
{
statementcontext sc   lcc getstatementcontext
if  sc    null
return sc getstatementtext
}
return null
}
public string getfirstloginstantstring
{
if (sanitymanager.debug)
sanitymanager assert isclone
loginstant loginstant
myxact    null  ? null   myxact getfirstloginstant
return  loginstant    null  ? null   loginstant tostring
}
private void getlcc
{
if (sanitymanager.debug)
sanitymanager assert isclone
if  lcc    null    myxact    null    myxact xc    null
{
xactcontext xc   myxact xc
lcc    languageconnectioncontext
xc getcontextmanager   getcontext
languageconnectioncontext context_id
}
}
/**
cloneable
*/
protected object clone
{
try
{
object c   super clone
transactiontableentry c  isclone   true
return c
}
catch  clonenotsupportedexception e
{
// this should not happen, we are cloneable
if (sanitymanager.debug)
{
sanitymanager.throwassert(
e
}
return null
}
}
}