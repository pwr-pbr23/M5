/*
derby - class org.apache.derby.iapi.services.compiler.methodbuilder
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby iapi services compiler
/**
methodbuilder is used to generate the code for a method.
<p>
the code for a method is built in a way that corresponds to the
layout of the stack machine that is the java virtual machine.
values are pushed on the stack, moved about on the stack
and then popped off the stack by operations such as method
calls. an understanding of hoe the jvm operates is useful
before using this class.
<p>
all the method descriptions below are generating bytecode
to achieved the desired behaviour when the generated class
is loaded. none of this class's methods calls actually
invoke methods or create objects described by the callers.
*/
public interface methodbuilder
/**
* declare the method throws an exception.
must be called before any code is added
to the method.
*/
public void addthrownexception string exceptionclass
/**
* return the name of the method.
*/
public string getname
/**
indicate the method is complete. once this
call has been made the caller must discard
the reference to this object.
*/
public void complete
/**
push a parameter value.
<pre>
stack ...  =>
...,param_value
</pre>
@param id position of the parameter (zero based).
*/
public void getparameter int id
/**
push a byte constant onto the stack
<pre>
stack ...  =>
...,byte_value
</pre>
*/
public void push byte value
/**
push a boolean constant onto the stack
<pre>
stack ...  =>
...,boolean_value
</pre>
*/
public void push boolean value
/**
push a short constant onto the stack
<pre>
stack ...  =>
...,short_value
</pre>
*/
public void push short value
/**
push a int constant onto the stack
<pre>
stack ...  =>
...,int_value
</pre>
*/
public void push int value
/**
push a long constant onto the stack
<pre>
stack ...  =>
...,long_value
</pre>
*/
public void push long value
/**
push a float constant onto the stack
<pre>
stack ...  =>
...,float_value
</pre>
*/
public void push float value
/**
push a double constant onto the stack
<pre>
stack ...  =>
...,double_value
</pre>
*/
public void push double value
/**
push a string constant onto the stack
<pre>
stack ...  =>
...,string_value
</pre>
*/
public void push string value
/**
push a typed null onto the stack
<pre>
stack ...  =>
...,null
</pre>
*/
public void pushnull string classname
/**
push the contents of the local field onto the stack.
this call pushes the this instance required to access the field itself.
<pre>
stack ...  =>
...,field_value
</pre>
*/
public void getfield localfield field
/**
push the contents of the described field onto the stack.
this call requires the instance (reference) to be pushed by the caller.
<pre>
stack ...,field_ref  =>
...,field_value
</pre>
*/
public void getfield string declaringclass  string fieldname  string fieldtype
/**
push the contents of the described static field onto the stack.
<pre>
stack ...  =>
...,field_value
</pre>
*/
public void getstaticfield string declaringclass  string fieldname  string fieldtype
/**
pop the top stack value and store it in the local field.
this call pushes the this instance required to access the field itself.
this call does not leave any value on the stack.
<pre>
stack ...,value  =>
...
</pre>
*/
public void setfield localfield field
/**
pop the top stack value and store it in the local field.
this call pushes the this instance required to access the field itself.
like the java language 'field = value', this leaves the value on the stack.
<pre>
stack ...,value  =>
...,value
</pre>
*/
public void putfield localfield field
/**
pop the top stack value and store it in the instance field of this class.
this call pushes the this instance required to access the field itself.
like the java language 'field = value', this leaves the value on the stack.
<pre>
stack ...,value  =>
...,value
</pre>
*/
public void putfield string fieldname  string fieldtype
/**
pop the top stack value and store it in the field.
this call requires the instance to be pushed by the caller.
like the java language 'field = value', this leaves the value on the stack.
<pre>
stack ...,field_ref,value  =>
...,value
</pre>
*/
public void putfield string declaringclass  string fieldname  string fieldtype
/**
initiate a sequence that calls a constructor, equivalent to the new operator in java.
after this call, the caller must push any arguments and then complete the
construction with a call to pushnewcomplete(). only arguments to the constructor
can be pushed onto the stack between the pushnewstart() and pushnewcomplete() method
calls.
<pre>
stack ... => [unchanged]
...
</pre>
@param classname class name of object to be created.
*/
public void pushnewstart string classname
/**
complete the sequence that was started with pushnewstart().
pop the arguments to the constructor and push the reference
to the newly created object.
<pre>
stack ...,value* => [numargs number of values will be popped]
...,new_ref
</pre>
@param numargs number of arguments to the constructor (can be 0).
*/
public void pushnewcomplete int numargs
/**
create an instance of an array and push it onto the stack.
<pre>
stack ...  =>
...,array_ref
</pre>
@param classname - type of array.
@param size - number of elements in the array
*/
public void pushnewarray string classname  int size
/**
push this onto the stack.
<pre>
stack ...  =>
...,this_ref
</pre>
*/
public void pushthis
/**
upcast the top stack value. this is used for correct method resolution
by upcasting method parameters. it does not put any casting code into the
byte code stream. can only be used for refrences.
<pre>
stack ...,ref =>
...,ref
</pre>
*/
public void upcast string classname
/**
cast the top stack value. correctly down-casts a reference or casts
a primitive type (e.g. int to short).
<pre>
stack ...,value =>
...,cast_value
</pre>
@param classname type (primitive, interface or class) to cast to.
*/
public void cast string classname
/**
pop the top stack value and push a boolean that is the result of
an instanceof check on the popped reference.
<pre>
stack ...,ref =>
...,boolean_value
</pre>.
*/
public void isinstanceof string classname
/**
* pop the top value off the stack
<pre>
stack ..., value =>
...
</pre>.
*/
public void pop
/**
end a statement.
pops the top-word of the stack, if any.
must only be called if zero or one item exists
on the stack.
<pre>
stack value =>
:empty:
or
stack :empty: =>
:empty:
</pre>.
*/
public void endstatement
/**
return from a method, optionally with a value.
must only be called if zero or one item exists
on the stack. if the stack contains a single
value then that is popped and used as the returned value.
<pre>
stack value =>
:empty:
or
stack :empty: =>
:empty:
</pre>.
*/
public void methodreturn
/**
initiate a conditional sequence.
the top value on the stack (a reference) is popped and compared to 'null'.
if the value is null then the code following this call until the startelsecode()
will be executed at runtime, otherwise the code following startelsecode() until
the completeconditional() is called.
<br>
e.g.
<pre>
mb.callmethod(...); // pushes an object onto the stack
mb.conditionalifnull();
mb.push(3);
mb.startelsecode();
mb.push(5);
mb.completeconditional();
// at this point 3 or 5 will be on the stack
</pre>
each path through the ?: statement must leave the stack at the same depth
as the other.
<br>
if the if or else code pops values from the stack that were before the conditional
value, then they must use the same number of values from the stack.
<pre>
stack ...,ref =>
...
</pre>.
*/
public void conditionalifnull
/**
initiate a conditional sequence.
the top value on the stack must be a boolean and will be popped. if it
is true then the code following this call until the startelsecode()
will be executed at runtime, otherwise the code following startelsecode() until
the completeconditional() is called. see conditionalifnull() for example
and restrictions.
<pre>
stack ...,boolean_value =>
...
</pre>.
*/
public void conditionalif
/**
complete the true code path of a conditional.
*/
public void startelsecode
/**
complete a conditional which completes the false code path.
*/
public void completeconditional
/**
call a method. the instance (receiver or reference) for non-static methods
must be pushed by the caller. the instance (for non-static) and the arguments
are popped of the stack, and the return value (if any) is pushed onto the stack.
<br>
the type needs to be one of:
<ul>
<li> vmopcode.invokestatic - call a static method
<li> vmopcode.invokevirtual - call method declared in the class or super-class.
<li> vmopcode.invokeinterface - call a method declared in an interface
</ul>
<pre>
static methods
stack ...,value* => [numargs number of values will be popped]
...,return_value [void methods will not push a value]
non-static methods
stack ...,ref,value* => [numargs number of values will be popped]
...,return_value [void methods will not push a value]
</pre>
<br>
the type of the arguments to the methods must exactly match the declared types
of the parameters to the methods. if a argument is of the incorrect type the
caller must up cast it or down cast it.
@param type type of method invocation
@param declaringclass class or interface the method is declared in. if it is a non-static
method call then if declaringclass is null, the declared type is taken to be the
type of the reference that will be popped.
@param methodname name of the method
@param returntype class name or primitive type (including "void") of the return type of the method, can not be null.
@param numargs number of arguments to the method (can be 0).
*/
public int callmethod short type  string declaringclass  string methodname
string returntype  int numargs
/**
return an object that efficiently (to the implementation) describes a zero-argument method and
can be used with the single argument callmethod(). descriptions for the parameters to this
method are the same as the five argument callmethod(). this allows the caller to cache frequently
used methods. the returned object is only valid for use by this methodbuilder.
<br>
this call does not affect the stack.
*/
public object describemethod short opcode  string declaringclass  string methodname  string returntype
/**
call a method previously described by describemethod().
<pre>
static methods
stack ...,value* => [numargs number of values will be popped]
...,return_value [void methods will not push a value]
non-static methods
stack ...,ref,value* => [numargs number of values will be popped]
...,return_value [void methods will not push a value]
</pre>
*/
public int callmethod object methoddescriptor
/**
call super(). caller must only add this to a constructor.
<pre>
stack ... =>
...
</pre>
*/
public void callsuper
/**
pop an array refrence off the stack and push an element from that array.
<pre>
stack ...,array_ref =>
...,value
</pre>
@param element offset into the array (zero based)
*/
public void getarrayelement int element
/**
pop an array reference off the stack, store a value in the array at the passed in offset.
<pre>
stack ...,array_ref, value =>
...
</pre>
@param element offset into the array (zero based)
*/
public void setarrayelement int element
/**
swap the top two values on the stack.
<pre>
stack ...,valuea,valueb =>
...,valueb,valuea
</pre>
*/
public void swap
/**
duplicate the top value on the stack.
<pre>
stack ...,value =>
...,value,value
</pre>
*/
public void dup
/**
tell if statement number in this method builder hits limit.  this
method builder keeps a counter of how many statements are added to it.
caller should call this function every time it tries to add a statement
to this method builder (counter is increased by 1), then the function
returns whether the accumulated statement number hits a limit.
the reason of doing this is that java compiler has a limit of 64k code
size for each method.  we might hit this limit if an extremely long
insert statement is issued, for example (see beetle 4293).  counting
statement number is an approximation without too much overhead.
*/
public boolean statementnumhitlimit int nostatementsadded