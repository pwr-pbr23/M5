/*
derby - class org.apache.derby.impl.tools.ij.statementfinder
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl tools ij
import java io ioexception
import java io reader
/**
statementgrabber looks through an input stream for
the next jsql statement.  a statement is considered to
be any tokens up to the next semicolon or eof.
<p>
semicolons inside comments, strings, and delimited identifiers
are not considered to be statement terminators but to be
part of those tokens.
<p>
the only comment form currently recognized is the sql comment,
which begins with "--" and ends at the next eol.
<p>
strings and delimited identifiers are permitted to contain
newlines; the actual ij or jsql parsers will report errors when
those cases occur.
<p>
there are no escaped characters, i.e. "\n" is considered to
be two characters, '\' and 'n'.
@author ames
*/
public class statementfinder
private reader source
private stringbuffer statement   new stringbuffer
private int state
private boolean ateof   false
private boolean peekeof   false
private char peekchar
private boolean peeked   false
// state variables
private static final int in_statement   0
private static final int in_string   1
private static final int in_sqlcomment   2
private static final int end_of_statement   3
private static final int end_of_input   4
// special state-changing characters
private static final char minus
private static final char singlequote
private static final char doublequote
private static final char semicolon
private static final char newline
private static final char return
private static final char space
private static final char tab
private static final char formfeed
/**
the constructor does not assume the stream is data input
or buffered, so it will wrap it appropriately.
@param s the input stream for reading statements from.
*/
public statementfinder reader s
source   s
/**
reinit is used to redirect the finder to another stream.
the previous stream should not have been in a peek state.
@param s the input stream for reading statements from.
*/
public void reinit reader s
try
source close
catch  ioexception ioe
// just be quiet if it is already gone
source   s
state   in_statement
ateof   false
peekeof   false
peeked   false
public void close   throws ioexception
source close
/**
get the next statement in the input stream. returns it,
dropping its closing semicolon if it has one. if there is
no next statement, return a null.
@return the next statement in the input stream.
*/
public string nextstatement
boolean havesemi   false
char nextchar
// initialize fields for getting the next statement
statement setlength 0
if  state    end_of_input  return null
state   in_statement
// skip leading whitespace
nextchar   peekchar
if  peekeof
state   end_of_input
return null
if  whitespace nextchar
while  whitespace peekchar         peekeof
if  peekeof
state   end_of_input
return null
while  state    end_of_statement    state    end_of_input
// get the next character from the input
nextchar   readchar
if  ateof
state   end_of_input
break
switch nextchar
case minus
readsinglelinecomment nextchar
break
case singlequote
case doublequote
readstring nextchar
break
case semicolon
havesemi   true
state   end_of_statement
break
default
// keep going, just a normal character
break
if  havesemi
statement setlength statement length   1
return statement tostring
/**
determine if the given character is considered whitespace
@param c the character to consider
@return true if the character is whitespace
*/
private boolean whitespace char c
return  c    space
c    tab
c    return
c    newline
c    formfeed
/**
advance the source stream to the end of a comment if it
is on one, assuming the first character of
a potential single line comment has been found.
if it is not a comment, do not advance the stream.
<p>
the form of a single line comment is, in regexp, xx.*$,
where xx is two instances of commentchar.
@param commentchar the character whose duplication signifies
the start of the comment.
*/
private void readsinglelinecomment char commentchar
char nextchar
nextchar   peekchar
// if next char is eof, we are done.
if  peekeof    return
// if nextchar is not a minus, it was just a normal minus,
// nothing special to do
if  nextchar    commentchar  return
// we are really in a comment
readchar       grab the minus for real
state   in_sqlcomment
do
nextchar   peekchar
if  peekeof
// let the caller process the eof, don't read it
state   in_statement
return
switch  nextchar
case newline
case return
readchar       okay to process the character
state   in_statement
return
default
readchar       process the character  still in comment
break
while  state    in_sqlcomment      could be while true
/**
advance the stream to the end of the string.
assumes the opening delimiter of the string has been read.
this handles the sql ability to put the delimiter within
the string by doubling it, by reading those as two strings
sitting next to one another.  i.e, 'mary''s lamb' is read
by this class as two strings, 'mary' and 's lamb'.
<p>
the delimiter of the string is expected to be repeated at
its other end. if the other flavor of delimiter occurs within
the string, it is just a normal character within it.
<p>
all characters except the delimiter are permitted within the
string. if eof is hit before the closing delimiter is found,
the end of the string is assumed. parsers using this parser
will detect the error in that case and return appropriate messages.
@param stringdelimiter the starting and ending character
for the string being read.
*/
private void readstring char stringdelimiter
state   in_string
do
char nextchar   readchar
if  ateof
state   end_of_input
return
if  nextchar    stringdelimiter
// we've reached the end of the string
state   in_statement
return
// still in string
while  state    in_string      could be while true
private boolean ateof
return ateof
private boolean peekeof
return peekeof
/**
return the next character in the source stream and
append it to the statement buffer.
@return the next character in the source stream.
*/
private char readchar
if   peeked  peekchar
peeked   false
ateof   peekeof
if   ateof  statement append peekchar
return peekchar
/**
return the next character in the source stream, without
advancing.
@return the next character in the source stream.
*/
private char peekchar
peeked   true
char c
try
int cint
// remind: this is assuming a flat ascii source file.
// will need to beef it up at some future point to
// understand whether the stream is ascii or something else.
cint   source read
peekeof    cint     1
if   peekeof  c    char cint
catch  ioexception ie
throw ijexception ioexception ie
peekchar   c
return c