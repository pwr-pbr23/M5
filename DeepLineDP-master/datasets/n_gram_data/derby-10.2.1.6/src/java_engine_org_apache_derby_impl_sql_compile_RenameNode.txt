/*
derby - class org.apache.derby.impl.sql.compile.renamenode
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package	org apache derby impl sql compile
import org apache derby iapi reference sqlstate
import org apache derby iapi sql compile compilercontext
import org apache derby iapi sql dictionary conglomeratedescriptor
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi sql dictionary tupledescriptor
import org apache derby iapi sql dictionary schemadescriptor
import org apache derby iapi sql dictionary tabledescriptor
import org apache derby iapi sql dictionary columndescriptor
import org apache derby iapi sql dictionary columndescriptorlist
import org apache derby iapi sql dictionary constraintdescriptor
import org apache derby iapi sql dictionary constraintdescriptorlist
import org apache derby iapi sql dictionary checkconstraintdescriptor
import org apache derby iapi sql execute constantaction
import org apache derby iapi error standardexception
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi sql statementtype
/**
* a renamenode is the root of a querytree that represents a
* rename table/column/index statement.
*
* @author mamta satoor
*/
public class renamenode extends ddlstatementnode
protected tablename newtablename
// original name of the object being renamed
protected string oldobjectname
// original name for that object
protected string newobjectname
protected tabledescriptor	td
private long conglomeratenumber
/* you can rename using either alter table or rename command to
* rename a table/column. an index can only be renamed with rename
* command. usedaltertable flag is used to keep that information.
*/
protected boolean	usedaltertable
/* renamingwhat will be set to 1 if user is renaming a table.
* will be set to 2 if user is renaming a column and will be
* set to 3 if user is renaming an index
*/
protected int renamingwhat
/**
* initializer for a renamenode
*
* @param tablename the name of the table. this is the table which is
*		being renamed in case of rename table. in case of rename
*		column, the column being renamed belongs to this table.
*		in case of rename index, this is null because index name
*		is unique within a schema and doesn't have to be
*		associated with a table name
* @param oldobjectname this is either the name of column/index in case
*		of rename column/index. for rename table, this is null.
* @param newobjectname this is new name for table/column/index
* @param usedaltertable true-used alter table, false-used rename.
*		for rename index, this will always be false because
*		there is no alter table command to rename index
* @param renamingwhat rename a 1 - table, 2 - column, 3 - index
*
* @exception standardexception thrown on error
*/
public void init object tablename
object oldobjectname
object newobjectname
object usedaltertable
object renamingwhat
throws standardexception
this usedaltertable     boolean  usedaltertable  booleanvalue
this renamingwhat     integer  renamingwhat  intvalue
switch  this renamingwhat
case statementtype rename_table
initandcheck  tablename  tablename
this newtablename
maketablename getobjectname   getschemaname    string newobjectname
this oldobjectname   null
this newobjectname   this newtablename gettablename
break
case statementtype rename_column
/* coming from alter table path, tablename will
* be tablename object. coming from rename column
* path, tablename will be just a string.
*/
tablename actingobjectname
if  tablename instanceof tablename
actingobjectname    tablename  tablename
else
actingobjectname   maketablename null
string tablename
initandcheck actingobjectname
this oldobjectname    string oldobjectname
this newobjectname    string newobjectname
break
case statementtype rename_index
this oldobjectname    string oldobjectname
this newobjectname    string newobjectname
break
default
if  sanitymanager debug
sanitymanager throwassert
/**
* convert this object to a string.  see comments in querytreenode.java
* for how this should be done for tree printing.
*
* @return	this object as a string
*/
public string tostring
if  sanitymanager debug
switch  renamingwhat
case statementtype rename_table
return super tostring
getrelativename
newtablename
case statementtype rename_column
return super tostring
getrelativename         oldobjectname
newobjectname
case statementtype rename_index
return super tostring
oldobjectname
newobjectname
default
sanitymanager throwassert
return
else
return
public string statementtostring
if  usedaltertable
return
else
switch  renamingwhat
case statementtype rename_table
return
case statementtype rename_column
return
case statementtype rename_index
return
default
if  sanitymanager debug
sanitymanager throwassert
return
// we inherit the generate() method from ddlstatementnode.
/**
* bind this node.  this means doing any static error checking that
* can be done before actually renaming the table/column/index.
*
* for a table rename: looking up the from table, verifying it exists
* verifying it's not a system table, verifying it's not view
* and looking up to table, verifying it doesn't exist.
*
* for a column rename: looking up the table, verifying it exists,
* verifying it's not a system table, verifying it's not view, verifying
* the from column exists, verifying the to column doesn't exist.
*
* for a index rename: looking up the table, verifying it exists,
* verifying it's not a system table, verifying it's not view, verifying
* the from index exists, verifying the to index doesn't exist.
*
* @return	the bound query tree
*
* @exception standardexception		thrown on error
*/
public querytreenode bind   throws standardexception
compilercontext			cc   getcompilercontext
datadictionary			dd   getdatadictionary
conglomeratedescriptor	cd
schemadescriptor sd
/* in case of rename index, the only thing we get from parser is
* current and new index names with no information about the
* table it belongs to. this is because index names are unique
* within a schema and hence then is no need to qualify an index
* name with a table name which we have to do for rename column.
* but from the index name, using the data dictionary, you can
* find the table it belongs to. since most of the checking
* in bind is done using table descriptor, in the following if
* statement, we are trying to get the table information from the
* index name so it is available for the rest of he bind code.
*/
tablename basetable
if  renamingwhat    statementtype rename_index
sd   getschemadescriptor  string null
conglomeratedescriptor indexdescriptor
dd getconglomeratedescriptor oldobjectname  sd  false
if  indexdescriptor    null
throw standardexception newexception
sqlstate lang_index_not_found  oldobjectname
/* get the table descriptor */
td   dd gettabledescriptor indexdescriptor gettableid
initandcheck maketablename td getschemaname
td getname
else
sd   getschemadescriptor
td   gettabledescriptor
//throw an exception if user is attempting a rename on temporary table
if  td gettabletype      tabledescriptor global_temporary_table_type
throw standardexception newexception sqlstate lang_not_allowed_for_declared_global_temp_table
switch  this renamingwhat
case statementtype rename_table
/* verify that new table name does not exist in the database */
tabledescriptor td   gettabledescriptor newobjectname  sd
if  td    null
throw descriptorexistsexception td  sd
renametablebind dd
break
case statementtype rename_column
renamecolumnbind dd
break
case statementtype rename_index
conglomeratedescriptor conglomdesc   dd getconglomeratedescriptor newobjectname  sd  false
if  conglomdesc    null
throw descriptorexistsexception conglomdesc  sd
break
default
if  sanitymanager debug
sanitymanager throwassert
break
conglomeratenumber   td getheapconglomerateid
/* get the base conglomerate descriptor */
cd   td getconglomeratedescriptor conglomeratenumber
/* statement is dependent on the tabledescriptor and conglomeratedescriptor */
cc createdependency td
cc createdependency cd
return this
/**
* return true if the node references session schema tables (temporary or permanent)
*
* @return	true if references session schema tables, else false
*
* @exception standardexception		thrown on error
*/
public boolean referencessessionschema
throws standardexception
//if rename is on a session schema table, then return true.
if  issessionschema td getschemaname      existing table with rename action
return true
//new name in rename action
if  renamingwhat    statementtype rename_table    issessionschema getschemadescriptor
return true
return false
//do any checking needs to be done at bind time for rename table
private void renametablebind datadictionary dd
throws standardexception
/* verify that there are no check constraints on the table */
constraintdescriptorlist constraintdescriptorlist   dd getconstraintdescriptors td
int size
constraintdescriptorlist    null ? 0   constraintdescriptorlist size
constraintdescriptor constraintdescriptor
// go through all the constraints defined on the table
for  int index   0  index < size  index
constraintdescriptor   constraintdescriptorlist elementat index
// if it is a check constraint, error
if  constraintdescriptor getconstrainttype      datadictionary check_constraint
throw standardexception newexception
sqlstate lang_provider_has_dependent_object
td getname
constraintdescriptor getconstraintname
//do any checking needs to be done at bind time for rename column
private void renamecolumnbind datadictionary dd
throws standardexception
columndescriptor columndescriptor   td getcolumndescriptor oldobjectname
/* verify that old column name does exist in the table */
if  columndescriptor    null
throw standardexception newexception sqlstate lang_column_not_found_in_table
oldobjectname  getfullname
/* verify that new column name does not exist in the table */
columndescriptor cd   td getcolumndescriptor newobjectname
if  cd    null
throw descriptorexistsexception cd  td
/* verify that there are no check constraints using the column being renamed */
constraintdescriptorlist constraintdescriptorlist
dd getconstraintdescriptors td
int size
constraintdescriptorlist    null ? 0   constraintdescriptorlist size
constraintdescriptor constraintdescriptor
columndescriptorlist checkconstraintcdl
int	checkconstraintcdlsize
// go through all the constraints defined on the table
for  int index   0  index < size  index
constraintdescriptor   constraintdescriptorlist elementat index
// if it is a check constraint, verify that column being
// renamed is not used in it's sql
if  constraintdescriptor getconstrainttype      datadictionary check_constraint
checkconstraintcdl   constraintdescriptor getcolumndescriptors
checkconstraintcdlsize   checkconstraintcdl size
for  int index2   0  index2 < checkconstraintcdlsize  index2
if  checkconstraintcdl elementat  index2      columndescriptor
throw standardexception newexception
sqlstate lang_rename_column_will_break_check_constraint
oldobjectname
constraintdescriptor getconstraintname
/**
* create the constant information that will drive the guts of execution
*
* @exception standardexception		thrown on failure
*/
public constantaction	makeconstantaction
throws standardexception
return	getgenericconstantactionfactory   getrenameconstantaction getfullname
getrelativename
oldobjectname
newobjectname
getschemadescriptor
td getuuid
usedaltertable
renamingwhat
private standardexception descriptorexistsexception tupledescriptor tuple
tupledescriptor parent
return
standardexception newexception sqlstate lang_object_already_exists_in_object
tuple getdescriptortype
tuple getdescriptorname
parent getdescriptortype
parent getdescriptorname