/*
derby - class org.apache.derby.impl.drda.decryptionmanager
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl drda
import java security keypairgenerator
import java security keypair
import javax crypto keyagreement
import javax crypto spec dhparameterspec
import javax crypto interfaces dhpublickey
import javax crypto spec dhpublickeyspec
import javax crypto spec secretkeyspec
import javax crypto cipher
import javax crypto spec ivparameterspec
import java security spec algorithmparameterspec
import java security keyfactory
import java security publickey
import java sql sqlexception
import java math biginteger
import org apache derby shared common sanity sanitymanager
/**
* this class is used to decrypt password and/or userid.
* it uses diffie_hellman algorithm to get the publick key and secret key, and then
* des encryption is done using certain token (based on security mechanism) and
* this side's own public key. basically, this class is called when using a security
* mechanism that encrypts user id and password (eusridpwd). this class uses ibm jce
* to do diffie_hellman algorithm and des encryption.
*/
class decryptionmanager
// drda's diffie-hellman agreed public value: prime.
private static final byte modulusbytes__
byte 0xc6   byte 0x21   byte 0x12   byte 0xd7
byte 0x3e   byte 0xe6   byte 0x13   byte 0xf0
byte 0x94   byte 0x7a   byte 0xb3   byte 0x1f
byte 0x0f   byte 0x68   byte 0x46   byte 0xa1
byte 0xbf   byte 0xf5   byte 0xb3   byte 0xa4
byte 0xca   byte 0x0d   byte 0x60   byte 0xbc
byte 0x1e   byte 0x4c   byte 0x7a   byte 0x0d
byte 0x8c   byte 0x16   byte 0xb3   byte 0xe3
//the prime value in biginteger form. it has to be in biginteger form because this
//is the form used in jce library.
private static final biginteger modulus__
new biginteger  1  modulusbytes__
//  drda's diffie-hellman agreed public value: base.
private static final byte basebytes__
byte 0x46   byte 0x90   byte 0xfa   byte 0x1f
byte 0x7b   byte 0x9e   byte 0x1d   byte 0x44
byte 0x42   byte 0xc8   byte 0x6c   byte 0x91
byte 0x14   byte 0x60   byte 0x3f   byte 0xde
byte 0xcf   byte 0x07   byte 0x1e   byte 0xdc
byte 0xec   byte 0x5f   byte 0x62   byte 0x6e
byte 0x21   byte 0xe2   byte 0x56   byte 0xae
byte 0xd9   byte 0xea   byte 0x34   byte 0xe4
// the base value in biginteger form. it has to be in biginteger form because
//this is the form used in ibm jce library.
private static final biginteger base__
new biginteger  1  basebytes__
//drda's diffie-hellman agreed exponential length
private static final int exponential_length__   255
private keypairgenerator keypairgenerator_
private keypair keypair_
private keyagreement keyagreement_
private dhparameterspec paramspec_
// random number generator (prng) algorithm
private final static string sha_1_prng_algorithm
private final static int secmec_usrssbpwd_seed_len   8      seed length
/**
* encryptionmanager constructor. in this constructor,dhparameterspec,
* keypairgenerator, keypair, and keyagreement  are initialized.
*
* @throws sqlexception that wraps any error
*/
decryptionmanager    throws sqlexception
try
if  java security security getprovider        null     ibmjce is not installed  install it
java security security addprovider   java security provider  class forname    newinstance
paramspec_   new dhparameterspec  modulus__  base__  exponential_length__
keypairgenerator_   keypairgenerator getinstance
keypairgenerator_ initialize   algorithmparameterspec paramspec_
keypair_   keypairgenerator_ generatekeypair
keyagreement_   keyagreement getinstance
keyagreement_ init  keypair_ getprivate
catch  java lang classnotfoundexception e
throw new sqlexception
e getmessage
catch  java lang illegalaccessexception e
throw new sqlexception
e getmessage
catch  java lang instantiationexception e
throw new sqlexception
e getmessage
catch  java security nosuchproviderexception e
throw new sqlexception
e getmessage
catch  java security nosuchalgorithmexception e
throw new sqlexception
e getmessage
catch  java security invalidalgorithmparameterexception e
throw new sqlexception
e getmessage
catch  java security invalidkeyexception e
throw new sqlexception
e getmessage
/**
* this method generates the public key and returns it. this
* shared public key is the application server's connection key and will
* be exchanged with the application requester's connection key. this connection
* key will be put in the sectkn in accsecrd command and send to the application
* requester.
*
* @return  a byte array that is the application server's public key
*/
public byte obtainpublickey
//the encoded public key
byte publicenc     keypair_ getpublic   getencoded
//we need to get the plain form public key because drda accepts plain form
//public key only.
biginteger apub     dhpublickey  keypair_ getpublic    gety
byte apubkey   apub tobytearray
//the following lines of code is to adjust the length of the key. publickey
//in jce is in the form of biginteger and it's a signed value. when tranformed
//to a byte array form, normally this array is 32 bytes. however, if the
//value happens to take up all 32 x 8 bits and it is positive, an extra
//bit is needed and then a 33 byte array will be returned. since drda can't
//recogize the 33 byte key, we check the length here, if the length is 33,
//we will just trim off the first byte (0) and get the rest of 32 bytes.
if  apubkey length    33    apubkey  0
byte newkey   new byte
for  int i 0  i < newkey length  i
newkey   apubkey
return newkey
//the following lines of code is to adjust the length of the key. occasionally,
//the length of the public key is less than 32, the reason of this is that the 0 byte
//in the beginning is somehow not returned. so we check the length here, if the length
//is less than 32, we will pad 0 in the beginning to make the public key 32 bytes
if  apubkey length < 32
byte newkey   new byte
int i
for  i 0  i < 32 apubkey length  i
newkey   0
for  int j i  j<newkey length  j
newkey   apubkey
return newkey
return apubkey
/**
* this method is used to calculate the decryption token. des encrypts the
* data using a token and the generated shared private key. the token used
* depends on the type of security mechanism being used:
* usrencpwd - the userid is used as the token. the usrid is zero-padded to
* 8 bytes if less than 8 bytes or truncated to 8 bytes if greater than 8 bytes.
* eusridpwd - the middle 8 bytes of the server's connection key is used as
* the token.  decryption needs to use exactly the same token as encryption.
*
* @param  securitymechanism security mechanism
* @param  initvector  userid or server(this side)'s connection key
* @return byte[]  the decryption token
*/
private byte calculatedecryptiontoken  int securitymechanism  byte initvector
byte token   new byte
//usrencpwd, the userid is used as token
if  securitymechanism    7
if  initvector length < 8      shorter than 8 bytes  zero padded to 8 bytes
for  int i 0  i<initvector length  i
token   initvector
for  int i initvector length  i<8  i
token   0
else      longer than 8 bytes  truncated to 8 bytes
for  int i 0  i<8  i
token   initvector
//eusridpwd - the middle 8 bytes of the server's connection key is used as
//the token.
else if  securitymechanism    9
for  int i   0  i < 8  i
token   initvector
return token
/**
* this method generates a secret key using the application requester's
* public key, and decrypts the usreid/password with the middle 8 bytes of
* the generated secret key and a decryption token. then it returns the
* decrypted data in a byte array.
*
* @param ciphertext        the byte array form userid/password to decrypt.
* @param securitymechanism security mechanism
* @param initvector        the byte array which is used to calculate the
*                          decryption token for initializing the cipher
* @param sourcepublickey   application requester (encrypter)'s public key.
* @return the decrypted data (plain text) in a byte array.
*/
public byte decryptdata  byte ciphertext
int    securitymechanism
byte initvector
byte sourcepublickey  throws sqlexception
byte plaintext   null
byte token   calculatedecryptiontoken  securitymechanism  initvector
try
//initiate a diffie_hellman keyfactory object.
keyfactory keyfac   keyfactory getinstance
//use server's public key to initiate a dhpublickeyspec and then use
//this dhpublickeyspec to initiate a publickey object
biginteger publickey   new biginteger  1  sourcepublickey
dhpublickeyspec dhkeyspec   new dhpublickeyspec  publickey  modulus__  base__
publickey pubkey   keyfac generatepublic  dhkeyspec
//execute the first phase of dh keyagreement protocal.
keyagreement_ dophase  pubkey  true
//generate the shared secret key. the application requestor's shared secret
//key should be exactly the same as the application server's shared secret
//key
byte sharedsecret   keyagreement_ generatesecret
byte newkey   new byte
//we adjust the length here. if the length of secret key is 33 and the first byte is 0,
//we trim off the frist byte. if the length of secret key is less than 32, we will
//pad 0 to the beginning of the byte array tho make the secret key 32 bytes.
if  sharedsecret length    33    sharedsecret    0
for  int i 0  i<newkey length  i
newkey   sharedsecret
if  sharedsecret length < 32
int i
for  i 0  i< 32   sharedsecret length   i
newkey   0
for  int j i  j<sharedsecret length  j
newkey   sharedsecret
//the data encryption standard (des) is going to be used to encrypt userid
//and password. des is a block cipher; it encrypts data in 64-bit blocks.
//drda encryption uses des cbc mode as defined by the fips standard
//des cbc requires an encryption key and an 8 byte token to encrypt the data.
//the middle 8 bytes of diffie-hellman shared private key is used as the
//encryption key. the following code retrieves middle 8 bytes of the shared
//private key.
byte key   new byte
//if secret key is not 32, we will use the adjust length secret key
if  sharedsecret length  32
for  int i 0  i< 8 i
key   sharedsecret
else if  sharedsecret length  33    sharedsecret length < 32
for  int i 0  i< 8 i
key   newkey
else
throw new sqlexception      sharedsecret length
// make parity bit right, even number of 1's
byte temp
int changeparity
for  int i 0  i<8  i
temp   key
changeparity   1
for  int j 0  j<8  j
if  temp < 0
changeparity   1   changeparity
temp    byte   temp << 1
if  changeparity    1
if   key   1     0
key    0xfe
else
key    1
//use this encryption key to initiate a secretkeyspec object
secretkeyspec deskey   new secretkeyspec  key
//we use des in cbc mode because this is the mode used in drda. the
//encryption mode has to be consistent for encryption and decryption.
//cbc mode requires an initialization vector(iv) parameter. in cbc mode
//we need to initialize the cipher object with an iv, which can be supplied
// using the javax.crypto.spec.ivparameterspec class.
cipher cipher  cipher getinstance
//generate a ivparameterspec object and use it to initiate the
//cipher object.
ivparameterspec ivparam   new ivparameterspec  token
//initiate the cipher using encryption mode, encryption key and the
//iv parameter.
cipher init  javax crypto cipher decrypt_mode  deskey ivparam
//execute the final phase of encryption
plaintext   cipher dofinal  ciphertext
catch  java security nosuchproviderexception e
throw new sqlexception
e getmessage
catch  java security nosuchalgorithmexception e
throw new sqlexception
e getmessage
catch  java security spec invalidkeyspecexception e
throw new sqlexception
catch  java security invalidkeyexception e
throw new sqlexception
e getmessage
catch  javax crypto nosuchpaddingexception e
throw new sqlexception
e getmessage
catch  javax crypto badpaddingexception e
throw new sqlexception
e getmessage
catch  java security invalidalgorithmparameterexception e
throw new sqlexception
e getmessage
catch  javax crypto illegalblocksizeexception e
throw new sqlexception
e getmessage
return plaintext
/**
* this method generates an 8-byte random seed.
*
* required for the secmec_usrssbpwd security mechanism
*
* @return a random 8-byte seed.
*/
protected static byte generateseed   throws sqlexception
java security securerandom securerandom   null
try
// we're verifying that we can instantiate a randon number
// generator (prng).
securerandom
java security securerandom getinstance sha_1_prng_algorithm
catch  java security nosuchalgorithmexception nsae
throw new sqlexception
nsae getmessage
byte randomseedbytes   new byte
securerandom setseed securerandom generateseed
secmec_usrssbpwd_seed_len
securerandom nextbytes randomseedbytes
// return the 8-byte generated random seed
return randomseedbytes
/*********************************************************************
* resolve:                                                          *
* the methods and static vars below should go into some 'shared'    *
* package when the capability is put back in (stringutil.java).     *
*********************************************************************/
private static char hex_table
/**
convert a byte array to a string with a hexidecimal format.
the string may be converted back to a byte array using fromhexstring.
<br>
for each byte (b) two characaters are generated, the first character
represents the high nibble (4 bits) in hexidecimal (<code>b & 0xf0</code>),
the second character represents the low nibble (<code>b & 0x0f</code>).
<br>
the byte at <code>data[offset]</code> is represented by the first two characters in the returned string.
@param	data	byte array
@param	offset	starting byte (zero based) to convert.
@param	length	number of bytes to convert.
@return the string (with hexidecimal format) form of the byte array
*/
protected static string tohexstring byte data  int offset  int length
stringbuffer s   new stringbuffer length 2
int end   offset length
for  int i   offset  i < end  i
int high_nibble    data   0xf0  >>> 4
int low_nibble    data   0x0f
s append hex_table
s append hex_table
return s tostring
/**
convert a string into a byte array in hex format.
<br>
for each character (b) two bytes are generated, the first byte
represents the high nibble (4 bits) in hexidecimal (<code>b & 0xf0</code>),
the second byte
represents the low nibble (<code>b & 0x0f</code>).
<br>
the character at <code>str.charat(0)</code> is represented by the first two bytes
in the returned string.
@param	str string
@param	offset	starting character (zero based) to convert.
@param	length	number of characters to convert.
@return the byte[]  (with hexidecimal format) form of the string (str)
*/
protected static byte tohexbyte string str  int offset  int length
byte data   new byte
int end   offset length
for  int i   offset  i < end  i
char ch   str charat i
int high_nibble    ch   0xf0  >>> 4
int low_nibble    ch   0x0f
data    byte high_nibble
data    byte low_nibble
return data