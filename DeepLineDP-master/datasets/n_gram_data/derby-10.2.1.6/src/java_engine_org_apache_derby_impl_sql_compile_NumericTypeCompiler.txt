/*
derby - class org.apache.derby.impl.sql.compile.numerictypecompiler
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl sql compile
import org apache derby iapi sql conn languageconnectioncontext
import org apache derby iapi services context contextservice
import org apache derby iapi services loader classfactory
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi services info jvminfo
import org apache derby iapi services io storedformatids
import org apache derby iapi error standardexception
import org apache derby iapi types datatypedescriptor
import org apache derby iapi types datatypedescriptor
import org apache derby iapi types datavaluefactory
import org apache derby iapi types numberdatavalue
import org apache derby iapi types typeid
import org apache derby iapi sql compile typecompiler
import org apache derby iapi reference classname
import org apache derby iapi reference limits
import org apache derby iapi reference sqlstate
import org apache derby iapi services compiler localfield
import org apache derby iapi services compiler methodbuilder
/**
* this class implements typeid for the sql numeric datatype.
*
* @author jeff lichtman
*/
public final class numerictypecompiler extends basetypecompiler
/** @see typecompiler#interfacename */
public string interfacename
return classname numberdatavalue
/**
* @see typecompiler#getcorrespondingprimitivetypename
*/
public string getcorrespondingprimitivetypename
/* only numerics and booleans get mapped to java primitives */
int formatid   getstoredformatidfromtypeid
switch  formatid
case storedformatids double_type_id
return
case storedformatids int_type_id
return
case storedformatids longint_type_id
return
case storedformatids real_type_id
return
case storedformatids smallint_type_id
return
case storedformatids tinyint_type_id
return
case storedformatids decimal_type_id
default
if  sanitymanager debug
sanitymanager throwassert
formatid
return null
/**
* get the method name for getting out the corresponding primitive
* java type.
*
* @return string		the method call name for getting the
*						corresponding primitive java type.
*/
public string getprimitivemethodname
int formatid   getstoredformatidfromtypeid
switch  formatid
case storedformatids double_type_id
return
case storedformatids int_type_id
return
case storedformatids longint_type_id
return
case storedformatids real_type_id
return
case storedformatids smallint_type_id
return
case storedformatids tinyint_type_id
return
case storedformatids decimal_type_id
default
if  sanitymanager debug
sanitymanager throwassert
formatid
return null
/**
* @see typecompiler#getcasttocharwidth
*/
public int getcasttocharwidth datatypedescriptor dts
int formatid   getstoredformatidfromtypeid
switch  formatid
case storedformatids decimal_type_id
// need to have space for '-' and decimal point.
return dts getprecision     2
case storedformatids double_type_id
return typecompiler double_maxwidth_as_char
case storedformatids int_type_id
return typecompiler int_maxwidth_as_char
case storedformatids longint_type_id
return typecompiler longint_maxwidth_as_char
case storedformatids real_type_id
return typecompiler real_maxwidth_as_char
case storedformatids smallint_type_id
return typecompiler smallint_maxwidth_as_char
case storedformatids tinyint_type_id
return typecompiler tinyint_maxwidth_as_char
default
if  sanitymanager debug
sanitymanager throwassert
formatid
return 0
/**
* @see typecompiler#resolvearithmeticoperation
*
* @exception standardexception		thrown on error
*/
public datatypedescriptor
resolvearithmeticoperation datatypedescriptor lefttype
datatypedescriptor righttype
string operator
throws standardexception
numerictypecompiler highertc
datatypedescriptor	highertype
boolean				nullable
int					precision  scale  maximumwidth
/*
** check the right type to be sure it's a number.  by convention,
** we call this method off the typeid of the left operand, so if
** we get here, we know the left operand is a number.
*/
if  sanitymanager debug
sanitymanager assert lefttype gettypeid   isnumerictypeid
typeid lefttypeid   lefttype gettypeid
typeid righttypeid   righttype gettypeid
boolean supported   true
if      righttypeid isnumerictypeid
supported   false
if  typecompiler mod_op equals operator
switch  lefttypeid getjdbctypeid
case java sql types tinyint
case java sql types smallint
case java sql types integer
case java sql types bigint
break
default
supported   false
break
switch  righttypeid getjdbctypeid
case java sql types tinyint
case java sql types smallint
case java sql types integer
case java sql types bigint
break
default
supported   false
break
if   supported
throw standardexception newexception sqlstate lang_binary_operator_not_supported
operator
lefttype gettypeid   getsqltypename
righttype gettypeid   getsqltypename
/*
** take left as the higher precedence if equal
*/
if  righttypeid typeprecedence   > lefttypeid typeprecedence
highertype   righttype
highertc    numerictypecompiler  gettypecompiler righttypeid
else
highertype   lefttype
highertc    numerictypecompiler  gettypecompiler lefttypeid
/* the calculation of precision and scale should be based upon
* the type with higher precedence, which is going to be the result
* type, this is also to be consistent with maximumwidth.  beetle 3906.
*/
precision   highertc getprecision operator  lefttype  righttype
scale   highertc getscale operator  lefttype  righttype
if  highertype gettypeid   isdecimaltypeid
maximumwidth    scale > 0  ? precision   3   precision   1
/*
** be careful not to overflow
*/
if  maximumwidth < precision
maximumwidth   integer max_value
else
maximumwidth   highertype getmaximumwidth
/* the result is nullable if either side is nullable */
nullable   lefttype isnullable      righttype isnullable
/*
** the higher type does not have the right nullability.  create a
** new datatypedescriptor that has the correct type and nullability.
**
** it's ok to call the implementation of the datatypedescriptorfactory
** here, because we're in the same package.
*/
return new datatypedescriptor
highertype gettypeid
precision
scale
nullable
maximumwidth
/** @see typecompiler#comparable */
public boolean comparable typeid othertype
boolean forequals
classfactory cf
return numbercomparable othertype  forequals  cf
/** @see typecompiler#convertible */
public boolean convertible typeid othertype  boolean fordatatypefunction
return  numberconvertible othertype  fordatatypefunction
/**
* tell whether this type (numeric) is compatible with the given type.
*
* @param othertype     the typeid of the other type.
*/
public boolean compatible typeid othertype
// numbers can only be compatible with other numbers.
return  othertype isnumerictypeid
/** @see typecompiler#storable */
public boolean storable typeid othertype  classfactory cf
return numberstorable gettypeid    othertype  cf
/**
return the method name to get a derby datavaluedescriptor
object of the correct type. this implementation returns "getdatavalue".
*/
protected string datavaluemethodname
if  getstoredformatidfromtypeid      storedformatids decimal_type_id
return
else
return super datavaluemethodname
protected string nullmethodname
int formatid   getstoredformatidfromtypeid
switch  formatid
case storedformatids decimal_type_id
return
case storedformatids double_type_id
return
case storedformatids int_type_id
return
case storedformatids longint_type_id
return
case storedformatids real_type_id
return
case storedformatids smallint_type_id
return
case storedformatids tinyint_type_id
return
default
if  sanitymanager debug
sanitymanager throwassert
formatid
return null
/**
* get the precision of the operation involving
* two of the same types.  only meaningful for
* decimals, which override this.
*
* @param operator a string representing the operator,
*		null means no operator, just a type merge
* @param lefttype the left type
* @param righttype the left type
*
* @return	the resultant precision
*/
private int getprecision string operator
datatypedescriptor lefttype
datatypedescriptor righttype
// only meaningful for decimal
if  getstoredformatidfromtypeid      storedformatids decimal_type_id
return lefttype getprecision
long lscale    long lefttype getscale
long rscale    long righttype getscale
long lprec    long lefttype getprecision
long rprec    long righttype getprecision
long val
/*
** null means datatype merge.  take the maximum
** left of decimal digits plus the scale.
*/
if  operator    null
val   this getscale operator  lefttype  righttype
math max lprec   lscale  rprec   rscale
else if  operator equals typecompiler times_op
val   lprec   rprec
else if  operator equals typecompiler sum_op
val   lprec   lscale   rprec   rscale
this getscale operator  lefttype  righttype
else if  operator equals typecompiler divide_op
val   math min numberdatavalue max_decimal_precision_scale
this getscale operator  lefttype  righttype    lprec   lscale   rprec
/*
** avg, -, +
*/
else
/*
** take max scale and max left of decimal
** plus one.
*/
val   this getscale operator  lefttype  righttype
math max lprec   lscale  rprec   rscale    1
if  val > limits db2_max_decimal_precision_scale
// then, like db2, just set it to the max possible.
val   limits db2_max_decimal_precision_scale
if  val > integer max_value
val   integer max_value
val   math min numberdatavalue max_decimal_precision_scale  val
return  int val
/**
* get the scale of the operation involving
* two of the same types.  since we don't really
* have a good way to pass the resultant scale
* and precision around at execution time, we
* will model that bigdecimal does by default.
* this is good in most cases, though we would
* probably like to use something more sophisticated
* for division.
*
* @param operator a string representing the operator,
*		null means no operator, just a type merge
* @param lefttype the left type
* @param righttype the left type
*
* @return	the resultant precision
*/
private int getscale string operator
datatypedescriptor lefttype
datatypedescriptor righttype
// only meaningful for decimal
if  getstoredformatidfromtypeid      storedformatids decimal_type_id
return lefttype getscale
long val
long lscale    long lefttype getscale
long rscale    long righttype getscale
long lprec    long lefttype getprecision
long rprec    long righttype getprecision
/*
** retain greatest scale, take sum of left
** of decimal
*/
if  typecompiler times_op equals operator
val   lscale   rscale
else if  typecompiler divide_op equals operator
/*
** take max left scale + right precision - right scale + 1,
** or 4, whichever is biggest
*/
languageconnectioncontext lcc    languageconnectioncontext
contextservice getcontext languageconnectioncontext context_id
// scale: 31 - left precision + left scale - right scale
val   math max numberdatavalue max_decimal_precision_scale   lprec   lscale   rscale  0
else if  typecompiler avg_op equals operator
val   math max math max lscale  rscale
numberdatavalue min_decimal_divide_scale
/*
** sum, -, + all take max(lscale,rscale)
*/
else
val   math max lscale  rscale
if  val > integer max_value
val   integer max_value
val   math min numberdatavalue max_decimal_precision_scale  val
return  int val
public void generatedatavalue methodbuilder mb
localfield field
if   jvminfo j2me    gettypeid   isdecimaltypeid
// cast the value to a number (from bigdecimal) for method resolution
// for j2me there is no implementation of number for decimal
// so values are handled as thier original type, which is just
// a string for decimal constants from the parser.
mb upcast
super generatedatavalue mb  field