/*
derby - class org.apache.derby.impl.services.cache.cacheditem
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl services cache
import org apache derby iapi services cache cacheable
import org apache derby iapi services cache cacheablefactory
import org apache derby iapi services cache cachemanager
import org apache derby iapi error standardexception
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi services context contextservice
/**
a generic class to represent the cache related infomation of a cached object (cacheable).
<p><pre>
the relationship between isvalid and settingidentity can be explain by the
following life cycle of a cached item.
stage		   1	2	3
----------------------
isvalid	        f	t	t
settingidentity	x	t	f
in stage 1, the cacheditem is created but it is invalid and has an entry
that is just a holder object with no identity.
in stage 2, the identity has been set and the item is being created or
being faulted into the cache.
in stage 3, the item found in the cacheditem entry
</pre> <p>
remove is set if this item is being removed out of existance, not just
being evicted from the cache.  when the last referece to it release it from
the cache, it will be removed.
<br>
recentlyused is set whenever this item is accessed (via a keep() call).
it is reset by the clockhand as it sweeps around the cache looking for
victims to evict.
<p>mt - must be mt-safe and work with cache manager.  every method that
access (set or get) instance variables is synchronized on the cached item
object.  the following method waits so it should not be called by the cache
manager inside a sync block: clean(), waitfor(), create(), remove().
(resolve: need to move these from the cache manager to here)
@see org.apache.derby.impl.services.cache
@see cacheable
*/
public final class cacheditem
private static final int valid              0x00000001
private static final int remove_requested   0x00000002
private static final int setting_identity   0x00000004
private static final int remove_ok          0x00000008
private static final int recently_used      0x00000010
/*
** fields
*/
/**
does entry (the cacheable) have an identity.
<br> mt - single thread required : synchronization provided by cache manager.
*/
private int state
/**
the current keep count on the entry.
<br> mt - single thread required : synchronization provided by cache manager.
*/
private int	keepcount
/**
the cacheable object being represented.
<br> mutable - content dynamic
*/
private cacheable	entry
/**
create a cacheditem in the not valid state.
*/
public cacheditem
/**
keep the cached object after a search.
*/
public void keepaftersearch
keepcount
setused true
public void keepforcreate
if  sanitymanager debug
sanitymanager assert  iskept
sanitymanager assert  isvalid
keepcount   1
state    setting_identity
public void unkeepforcreate
settingidentitycomplete
unkeep
public void keepforclean
if  sanitymanager debug
sanitymanager assert isvalid
keepcount
/**
unkeep the cached object.
<p>mt - not synchronized, only modified single threaded by the cache manager
@return if the object is still kept after this call.
*/
public synchronized boolean unkeep
boolean unkept     keepcount    0
if  sanitymanager debug
sanitymanager assert keepcount >  0
return unkept      state   remove_requested     0
/**
is the cached object kept?
<p>mt - not synchronized, only accessed single threaded by the cache manager
*/
public final boolean iskept
return keepcount    0
/**
clean the cached object
<p>mt -		<br>
the wait will not release the lock on the cache manager, so the
cache manager should not waitfor clean inside a sync block or
the whole cache will freeze
@param forremove if true, get rid of the backend persistent store object
@exception standardexception error thrown while writing cacheable
object to disk
*/
public void clean boolean forremove  throws standardexception
entry clean forremove
/**
set the state of the to-be removed flag.
*/
public synchronized void setremovestate
state    remove_requested
/**
does the cached object have a valid identity.
*/
public final synchronized boolean isvalid
return  state   valid     0
/**
set the valid state of the cached object.
*/
public synchronized void setvalidstate boolean flag
if  flag
state    valid
else
state    ~valid
state    ~ remove_requested   remove_ok
setused flag
/**
get the cached object.
*/
public cacheable getentry
return entry
/**
make entry (the cacheable) take on a new identity.
*/
public cacheable takeonidentity cachemanager cm  cacheablefactory holderfactory
object key  boolean forcreate  object createparameter
throws standardexception
// tell the object it needs to create itself
cacheable oldentry   entry
if  oldentry    null
oldentry   holderfactory newcacheable cm
if  forcreate
entry   oldentry createidentity key  createparameter
else
entry   oldentry setidentity key
if  entry    null
// item was found or created
if  sanitymanager debug
sanitymanager assert entry getidentity   equals key
return entry
entry   oldentry
return null
public synchronized void settingidentitycomplete
// notify all waiters that this item has finished setting its identity,
// successfully or not.
state    ~setting_identity
notifyall
/**
allow use of the cacheable entry.
*/
public synchronized cacheable use   throws standardexception
while   state   setting_identity     0
try
if  sanitymanager debug
sanitymanager debug
wait
catch  interruptedexception ie
throw standardexception interrupt ie
// see if the setting of this identity failed ...
if   isvalid
return null
if  sanitymanager debug
if  sanitymanager debug_on
sanitymanager debug
keepcount
return entry
/**
*/
public void remove boolean removenow  throws standardexception
if   removenow
synchronized  this
while   state   remove_ok     0
try
wait
catch  interruptedexception ie
throw standardexception interrupt ie
clean true
public synchronized void notifyremover
if  sanitymanager debug
sanitymanager assert  state   remove_requested     0
sanitymanager assert iskept
state    remove_ok
notifyall
/**
the clock hand has swept past this entry.
*/
public synchronized void setused boolean flag
if  flag
state    recently_used
else
state    ~recently_used
/**
has the cached object been referenced (kept) since the last sweep of
the clock hand?
*/
public synchronized boolean recentlyused
return  state   recently_used     0