/*
derby - class org.apache.derby.iapi.sql.compile.joinstrategy
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby iapi sql compile
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi sql dictionary conglomeratedescriptor
import org apache derby iapi store access transactioncontroller
import org apache derby iapi services compiler methodbuilder
import org apache derby iapi error standardexception
/**
* a joinstrategy represents a strategy like nested loop, hash join,
* merge join, etc.  it tells the optimizer whether the strategy is
* feasible in a given situation, how much the strategy costs, whether
* the strategy requires the data from the source result sets to be ordered,
* etc.
*/
public interface joinstrategy
/**
* is this join strategy feasible under the circumstances?
*
* @param innertable	the inner table of the join
* @param predlist		the predicatelist for the join
* @param optimizer		the optimizer to use
*
* @return	true means the strategy is feasible, false means it isn't
*
* @exception standardexception		thrown on error
*/
boolean feasible optimizable innertable
optimizablepredicatelist predlist
optimizer optimizer
throws standardexception
/**
* is it ok to use bulk fetch with this join strategy?
*/
boolean bulkfetchok
/**
* should we just ignore bulk fetch with this join strategy?
*/
boolean ignorebulkfetch
/**
* returns true if the base cost of scanning the conglomerate should be
* multiplied by the number of outer rows.
*/
boolean multiplybasecostbyouterrows
/**
* get the base predicates for this join strategy.  the base predicates
* are the ones that can be used while scanning the table.  for some
* join strategies (for example, nested loop), all predicates are base
* predicates.  for other join strategies (for example, hash join),
* the base predicates are those that involve comparisons with constant
* expressions.
*
* also, order the base predicates according to the order in the
* proposed conglomerate descriptor for the inner table.
*
* @param predlist	the predicate list to pull from.
* @param basepredicates	the list to put the base predicates in.
* @param innertable	the inner table of the join
*
* @return	the base predicate list.  if no predicates are pulled,
*			it may return the source predlist without doing anything.
*
* @exception standardexception		thrown on error
*/
optimizablepredicatelist getbasepredicates
optimizablepredicatelist predlist
optimizablepredicatelist basepredicates
optimizable innertable
throws standardexception
/**
* get the extra selectivity of the non-base predicates (those that were
* left in the predicate list by getbasepredicates() that are not
* applied to the scan of the base conglomerate.
*
* note: for some types of join strategy, it may not remove any predicates
* from the original predicate list.  the join strategy is expected to
* know when it does this, and to return 1.0 as the extra selectivity
* in these cases.
*
* @param innertable	the inner table of the join.
* @param predlist	the original predicate list that was passed to
*					getbasepredicates(), from which some base predicates
*					may have been pulled.
*
* @return	the extra selectivity due to non-base predicates
*/
double nonbasepredicateselectivity optimizable innertable
optimizablepredicatelist predlist
throws standardexception
/**
* put back and base predicates that were removed from the list by
* getbasepredicates (see above).
*
* note: those join strategies that treat all predicates as base
*		 predicates may treat the get and put methods as no-ops.
*
* @param predlist	the list of predicates to put the base predicates
*					back in.
* @param basepredicates	the base predicates to put back in the list.
*
* @exception standardexception		thrown on error
*/
void putbasepredicates optimizablepredicatelist predlist
optimizablepredicatelist basepredicates
throws standardexception
/**
* get the estimated cost for the join.
*
* @param predlist		the predicate list for the join
* @param innertable	the inner table to join with
* @param cd			the conglomerate descriptor (if appropriate) to get
*						the cost of
* @param outercost		the estimated cost of the part of the plan outer
*						to the inner table
* @param optimizer		the optimizer to use to help estimate the cost
* @param costestimate	the estimated cost of doing a single scan of the
*						inner table, to be filled in with the cost of
*						doing the join.
*
* @exception standardexception		thrown on error
*/
void estimatecost optimizable innertable
optimizablepredicatelist predlist
conglomeratedescriptor cd
costestimate outercost
optimizer optimizer
costestimate costestimate
throws standardexception
/**
* @param userspecifiedcapacity
* @param maxmemorypertable maximum number of bytes per table
* @param perrowusage number of bytes per row
*
* @return the maximum number of rows that can be handled by this join strategy
*/
public int maxcapacity  int userspecifiedcapacity
int maxmemorypertable
double perrowusage
/** get the name of this join strategy */
string getname
/** get the costing type, for use with storecostcontroller.getscancost */
int scancosttype
/**
* get the name of the result set method for base table scans
*
* @param bulkfetch		true means bulk fetch is being done on the inner
*						table
*/
string resultsetmethodname boolean bulkfetch
/**
* get the name of the join result set method for the join
*/
string joinresultsetmethodname
/**
* get the name of the join result set method for the half outerjoin
*/
string halfouterjoinresultsetmethodname
/**
* get the appropriate arguments to the scan for this type of join.
*
* @param tc	the transactioncontroller
* @param mb	the method to generate the arguments in
* @param innertable	the inner table of the join
* @param storerestrictionlist	the predicate list to be evaluated in the
*								store
* @param nonstorerestrictionlist	the predicate list to be evaluated
*									outside of the store
* @param acb	the expression class builder for the activation class
*				we're building
* @param bulkfetch	the amount of bulk fetch to do
* @param resultrowallocator	a completed method to allocate the result row
* @param colrefitem	the item number of the column reference bit map
* @param lockmode		the lock mode to use when scanning the table
*						(see transactioncontroller).
* @param tablelocked	whether or not the table is marked (in sys.systables)
*						as always using table locking
* @param isolationlevel		isolation level specified (or not) for scans
* @param maxmemorypertable	max memory per table
*
* @return	count of the expressions pushed to use as the parameters to the
*			result set for the inner table
*
* @exception standardexception		thrown on error
*/
int getscanargs transactioncontroller tc
methodbuilder mb
optimizable innertable
optimizablepredicatelist storerestrictionlist
optimizablepredicatelist nonstorerestrictionlist
expressionclassbuilderinterface acb
int bulkfetch
methodbuilder resultrowallocator
int colrefitem
int indexcolitem
int lockmode
boolean tablelocked
int isolationlevel
int maxmemorypertable
throws standardexception
/**
* divide up the predicates into different lists for different phases
* of the operation. when this method is called, all of the predicates
* will be in restrictionlist.  the effect of this method is to
* remove all of the predicates from restrictionlist except those that
* will be pushed down to the store as start/stop predicates or
* qualifiers.  the remaining predicates will be put into
* nonbasetablerestrictionlist.
*
* all predicate lists will be ordered as necessary for use with
* the conglomerate.
*
* some operations (like hash join) materialize results, and so
* require requalification of rows when doing a non-covering index
* scan.  the predicates to use for requalification are copied into
* basetablerestrictionlist.
*
* @param innertable	the inner table of the join
* @param originalrestrictionlist	initially contains all predicates.
*									this method removes predicates from
*									this list and moves them to other
*									lists, as appropriate.
* @param storerestrictionlist	to be filled in with predicates to
*								be pushed down to store.
* @param nonstorerestrictionlist	to be filled in with predicates
*									that are not pushed down to the
*									store.
* @param requalificationrestrictionlist	copy of predicates used to
*											re-qualify rows, if necessary.
* @param dd			the datadictionary
*
* @exception standardexception		thrown on error
*/
void divideuppredicatelists
optimizable innertable
optimizablepredicatelist originalrestrictionlist
optimizablepredicatelist storerestrictionlist
optimizablepredicatelist nonstorerestrictionlist
optimizablepredicatelist requalificationrestrictionlist
datadictionary			 dd
throws standardexception
/**
* is this a form of hash join?
*
* @return whether or not this strategy is a form
* of hash join.
*/
public boolean ishashjoin
/**
* is materialization built in to the join strategy?
*
* @return whether or not materialization is built in to the join strategy
*/
public boolean doesmaterialization