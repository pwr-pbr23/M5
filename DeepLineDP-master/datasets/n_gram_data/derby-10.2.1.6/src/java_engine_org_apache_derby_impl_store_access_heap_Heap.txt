/*
derby - class org.apache.derby.impl.store.access.heap.heap
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl store access heap
import java io objectoutput
import java io objectinput
import java io ioexception
import java util properties
import org apache derby iapi reference sqlstate
import org apache derby iapi services io arrayinputstream
import org apache derby iapi services io formatablebitset
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi services io formatable
import org apache derby iapi services io formatidutil
import org apache derby iapi services io storable
import org apache derby iapi services io storedformatids
import org apache derby iapi error standardexception
import org apache derby iapi store access conglomerate conglomerate
import org apache derby iapi store access conglomerate logicalundo
import org apache derby iapi store access conglomerate transactionmanager
import org apache derby iapi store access conglomerate scanmanager
import org apache derby iapi store access conglomerate transactionmanager
import org apache derby iapi store access accessfactoryglobals
import org apache derby iapi store access conglomeratecontroller
import org apache derby iapi store access dynamiccompiledopenconglominfo
import org apache derby iapi store access qualifier
import org apache derby iapi store access rowlocationretrowsource
import org apache derby iapi store access rowutil
import org apache derby iapi store access staticcompiledopenconglominfo
import org apache derby iapi store access storecostcontroller
import org apache derby iapi store access transactioncontroller
import org apache derby iapi store raw containerkey
import org apache derby iapi store raw containerhandle
import org apache derby iapi store raw lockingpolicy
import org apache derby iapi store raw transaction
import org apache derby iapi store raw page
import org apache derby iapi store raw rawstorefactory
import org apache derby iapi store raw recordhandle
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi services cache classsize
import org apache derby iapi types datatype
import org apache derby impl store access conglomerate conglomerateutil
import org apache derby impl store access conglomerate genericconglomerate
import org apache derby impl store access conglomerate openconglomerate
import org apache derby impl store access conglomerate openconglomeratescratchspace
import java sql resultset
import java sql sqlexception
/**
* @format_id access_heap_v1_id
*
* @purpose   the tag that describes the on disk representation of the heap
*            conglomerate object.  the heap conglomerate object is stored in
*            a field of a row in the conglomerate directory.
*
* @upgrade   this format was made obsolete in the kimono release.
*
* @disk_layout
*     containerid(long)
*     segmentid(int)
**/
/**
* @format_id access_heap_v2_id
*
* @purpose   the tag that describes the on disk representation of the heap
*            conglomerate object.  the heap conglomerate object is stored in
*            a field of a row in the conglomerate directory.
*
* @upgrade   the format id of this object is currently always read from disk
*            as a separate column in the conglomerate directory.  to read
*            a conglomerate object from disk and upgrade it to the current
*            version do the following:
*
*                format_id = get format id from a separate column
*                upgradable conglom_obj = instantiate empty obj(format_id)
*                read in conglom_obj from disk
*                conglom = conglom_obj.upgradetocurrent();
*
* @disk_layout
*     format_of_this_conlgomerate(byte[])
*     containerid(long)
*     segmentid(int)
*     number_of_columns(int)
*     array_of_format_ids(byte[][])
**/
/**
a heap object corresponds to an instance of a heap conglomerate.  it caches
information which makes it fast to open heap controllers from it.
**/
public final class heap
extends    genericconglomerate
implements conglomerate  staticcompiledopenconglominfo
/*
** fields of heap.
*/
protected containerkey id
/**
* the format id's of each of the columns in the heap table.
**/
int    format_ids
private static final int base_memory_usage   classsize estimatebasefromcatalog  heap class
private static final int container_key_memory_usage   classsize estimatebasefromcatalog  containerkey class
public int estimatememoryusage
int sz   base_memory_usage
if  null    id
sz    container_key_memory_usage
if  null    format_ids
sz    format_ids length classsize getintsize
return sz
end of estimatememoryusage
/*
** methods of heap.
*/
/* constructors for this class: */
/**
* zero arg constructor for monitor to create empty object.
**/
public heap
/* private/protected methods of this class: */
/**
* create a heap conglomerate.
* <p>
* create a heap conglomerate.  this method is called from the heap factory
* to create a new instance of a heap.
* <p>
*
* @exception  standardexception  standard exception policy.
**/
protected void create
transaction             rawtran
int                     segmentid
long                    input_containerid
datavaluedescriptor   template
properties              properties
int                     tmpflag
throws standardexception
// create a container for the heap table with
// default minimumrecordsize to be at least
// minimum_record_size_default (12),
// to guarantee there is enough room for updates
// of the row.
// here we only take care of the case that
// that the properties are set with the create
// statement.  for the case when properties are
// not set with the create statement, it is taken
// care of in filecontainer.java: createinfofromprop().
if  properties    null
string value   properties getproperty
rawstorefactory minimum_record_size_parameter
int minimumrecordsize
value    null  ?
rawstorefactory minimum_record_size_default
integer parseint value
if  minimumrecordsize < rawstorefactory minimum_record_size_default
properties put
rawstorefactory minimum_record_size_parameter
integer tostring
rawstorefactory minimum_record_size_default
// create a container for the heap with default page size.
long containerid
rawtran addcontainer
segmentid  input_containerid
containerhandle mode_default  properties  tmpflag
// make sure the container was actually created.
if  containerid < 0
throw standardexception newexception
sqlstate heap_cant_create_container
// keep track of what segment the container's in.
id   new containerkey segmentid  containerid
// heap requires a template representing every column in the table.
if   template    null      template length    0
throw standardexception newexception
sqlstate heap_could_not_create_conglomerate
// get format id's from each column in template and store it in the
// conglomerate state.
this format_ids   conglomerateutil createformatids template
// need to open the container and insert the row.  since we are
// creating it no need to bother with locking since no one can get
// to it until after we have created it and returned it's id.
containerhandle container   null
page            page        null
try
container
rawtran opencontainer
id   lockingpolicy  null
containerhandle mode_forupdate
istemporary   ? containerhandle mode_temp_is_kept   0
// row in slot 0 of heap page 1 which is just a single column with
// the heap entry.
datavaluedescriptor control_row   new datavaluedescriptor
control_row   this
page
container getpage containerhandle first_page_number
page insertatslot
page first_slot_number
control_row
formatablebitset  null
logicalundo  null
page insert_overflow
accessfactoryglobals heap_overflow_threshold
page unlatch
page   null
// don't include the control row in the estimated row count.
container setestimatedrowcount 0     unused flag    0
finally
if  container    null
container close
if  page   null
page unlatch
/**
* create a heap conglomerate during the boot process.
* <p>
* manufacture a heap conglomerate out of "thin" air, to boot strap
* the system.  create an in-memory heap conglomerate with the input
* parameters, the caller will use this to open the conglomerate
* conglomerate and read the "real" values from disk.  conglom-conglom
* is always on segment 0.
*
*
* @param containerid the container id of the conglomerate.
* @param template    object array describing the columns of the heap.
**/
public void boot_create
long                    containerid
datavaluedescriptor   template
id   new containerkey 0  containerid
this format_ids   conglomerateutil createformatids template
/*
** methods of conglomerate
*/
/**
* add a column to the heap conglomerate.
* <p>
* this routine update's the in-memory object version of the heap
* conglomerate to have one more column of the type described by the
* input template column.
*
* @param column_id        the column number to add this column at.
* @param template_column  an instance of the column to be added to table.
*
* @exception  standardexception  standard exception policy.
**/
public void addcolumn
transactionmanager  xact_manager
int                 column_id
storable            template_column
throws standardexception
// need to open the container and update the row containing the
// serialized format of the heap.
containerhandle container   null
page            page        null
transaction     rawtran     xact_manager getrawstorexact
try
container
rawtran opencontainer
id
rawtran newlockingpolicy
lockingpolicy mode_container
transactioncontroller isolation_serializable  true
containerhandle mode_forupdate
istemporary   ? containerhandle mode_temp_is_kept   0
if  column_id    format_ids length
if  sanitymanager debug
sanitymanager throwassert
column_id
format_ids length
format_ids
throw standardexception newexception
sqlstate heap_template_mismatch
new long column_id
new long this format_ids length
// create a new array, and copy old values to it.
int old_format_ids   format_ids
format_ids                new int
system arraycopy
old_format_ids  0  format_ids  0  old_format_ids length
// add the new column
format_ids
template_column gettypeformatid
// row in slot 0 of heap page 1 which is just a single column with
// the heap entry.
datavaluedescriptor control_row   new datavaluedescriptor
control_row   this
page
container getpage containerhandle first_page_number
page updateatslot
page first_slot_number
control_row
formatablebitset  null
page unlatch
page   null
finally
if  container    null
container close
if  page   null
page unlatch
return
/**
drop this heap.
@see conglomerate#drop
@exception standardexception standard exception policy.
**/
public void drop transactionmanager xact_manager
throws standardexception
xact_manager getrawstorexact   dropcontainer id
/**
* retrieve the maximum value row in an ordered conglomerate.
* <p>
* returns true and fetches the rightmost row of an ordered conglomerate
* into "fetchrow" if there is at least one row in the conglomerate.  if
* there are no rows in the conglomerate it returns false.
* <p>
* non-ordered conglomerates will not implement this interface, calls
* will generate a standardexception.
* <p>
* resolve - this interface is temporary, long term equivalent (and more)
* functionality will be provided by the openbackwardscan() interface.
*
* @param conglomid       the identifier of the conglomerate
*                        to open the scan for.
*
* @param open_mode       specifiy flags to control opening of table.
*                        openmode_forupdate - if set open the table for
*                        update otherwise open table shared.
* @param lock_level      one of (mode_table, mode_record, or mode_none).
*
* @param isolation_level the isolation level to lock the conglomerate at.
*                        one of (isolation_read_committed or
*                        isolation_serializable).
*
* @param scancolumnlist  a description of which columns to return from
*                        every fetch in the scan.  template,
*                        and scancolumnlist work together
*                        to describe the row to be returned by the scan -
*                        see rowutil for description of how these three
*                        parameters work together to describe a "row".
*
* @param fetchrow        the row to retrieve the maximum value into.
*
* @return boolean indicating if a row was found and retrieved or not.
*
* @exception  standardexception  standard exception policy.
**/
public boolean fetchmaxonbtree
transactionmanager      xact_manager
transaction             rawtran
long                    conglomid
int                     open_mode
int                     lock_level
lockingpolicy           locking_policy
int                     isolation_level
formatablebitset                 scancolumnlist
datavaluedescriptor   fetchrow
throws standardexception
// no support for max on a heap table.
throw standardexception newexception
sqlstate heap_unimplemented_feature
/**
* get the id of the container of the conglomerate.
* <p>
* will have to change when a conglomerate could have more than one
* container.  the containerkey is a combination of the container id
* and segment id.
*
* @return the containerkey.
**/
public final containerkey getid
return id
public final long getcontainerid
return id getcontainerid
/**
* return dynamic information about the conglomerate to be dynamically
* reused in repeated execution of a statement.
* <p>
* the dynamic info is a set of variables to be used in a given
* scancontroller or conglomeratecontroller.  it can only be used in one
* controller at a time.  it is up to the caller to insure the correct
* thread access to this info.  the type of info in this is a scratch
* template for btree traversal, other scratch variables for qualifier
* evaluation, ...
* <p>
*
* @return the dynamic information.
*
* @param conglomid the identifier of the conglomerate to open.
*
* @exception  standardexception  standard exception policy.
**/
public dynamiccompiledopenconglominfo getdynamiccompiledconglominfo
long        conglomid
throws standardexception
return new openconglomeratescratchspace format_ids
/**
* return static information about the conglomerate to be included in a
* a compiled plan.
* <p>
* the static info would be valid until any ddl was executed on the
* conglomid, and would be up to the caller to throw away when that
* happened.  this ties in with what language already does for other
* invalidation of static info.  the type of info in this would be
* containerid and array of format id's from which templates can be created.
* the info in this object is read only and can be shared among as many
* threads as necessary.
* <p>
*
* @return the static compiled information.
*
* @param conglomid the identifier of the conglomerate to open.
*
* @exception  standardexception  standard exception policy.
**/
public staticcompiledopenconglominfo getstaticcompiledconglominfo
transactioncontroller   tc
long                    conglomid
throws standardexception
return this
/**
* is this conglomerate temporary?
* <p>
*
* @return whether conglomerate is temporary or not.
**/
public boolean istemporary
return id getsegmentid      containerhandle temporary_segment
/**
* bulk load into the conglomerate.
* <p>
*
* @see conglomerate#load
*
* @exception  standardexception  standard exception policy.
**/
public long load
transactionmanager      xact_manager
boolean                 createconglom
rowlocationretrowsource rowsource
throws standardexception
long num_rows_loaded   0
heapcontroller heapcontroller   new heapcontroller
try
num_rows_loaded
heapcontroller load
xact_manager
this
createconglom
rowsource
finally
// done with this heap controller.
heapcontroller close
return num_rows_loaded
/**
* open a heap controller.
* <p>
*
* @see conglomerate#open
*
* @exception  standardexception  standard exception policy.
**/
public conglomeratecontroller open
transactionmanager              xact_manager
transaction                     rawtran
boolean                         hold
int                             open_mode
int                             lock_level
lockingpolicy                   locking_policy
staticcompiledopenconglominfo   static_info
dynamiccompiledopenconglominfo  dynamic_info
throws standardexception
openconglomerate open_conglom   new openheap
if  open_conglom init
containerhandle  null
this
this format_ids
xact_manager
rawtran
hold
open_mode
lock_level
locking_policy
dynamic_info     null
throw standardexception newexception
sqlstate heap_container_not_found
new long id getcontainerid    tostring
heapcontroller heapcontroller   new heapcontroller
heapcontroller init open_conglom
return heapcontroller
/**
* open a heap scan controller.
* <p>
*
* @see conglomerate#openscan
*
* @exception  standardexception  standard exception policy.
**/
public scanmanager openscan
transactionmanager              xact_manager
transaction                     rawtran
boolean                         hold
int                             open_mode
int                             lock_level
lockingpolicy                   locking_policy
int                             isolation_level
formatablebitset				scancolumnlist
datavaluedescriptor	        startkeyvalue
int                             startsearchoperator
qualifier                       qualifier
datavaluedescriptor	        stopkeyvalue
int                             stopsearchoperator
staticcompiledopenconglominfo   static_info
dynamiccompiledopenconglominfo  dynamic_info
throws standardexception
// heap scans do not suppport start and stop scan positions (these
// only make sense for ordered storage structures).
if   rowutil isrowempty startkeyvalue
rowutil isrowempty stopkeyvalue
throw standardexception newexception
sqlstate heap_unimplemented_feature
openconglomerate open_conglom   new openheap
if  open_conglom init
containerhandle  null
this
this format_ids
xact_manager
rawtran
hold
open_mode
lock_level
locking_policy
dynamic_info     null
throw standardexception newexception
sqlstate heap_container_not_found
new long id getcontainerid
heapscan heapscan   new heapscan
heapscan init
open_conglom
scancolumnlist
startkeyvalue
startsearchoperator
qualifier
stopkeyvalue
stopsearchoperator
return heapscan
public void purgeconglomerate
transactionmanager              xact_manager
transaction                     rawtran
throws standardexception
openconglomerate        open_for_ddl_lock     null
heapcontroller          heapcontroller        null
transactionmanager      nested_xact           null
try
open_for_ddl_lock   new openheap
// open table in intended exclusive mode in the top level
// transaction, this will stop any ddl from happening until
// purge of whole table is finished.
if  open_for_ddl_lock init
containerhandle  null
this
this format_ids
xact_manager
rawtran
false
transactioncontroller openmode_forupdate
transactioncontroller mode_record

null     null
throw standardexception newexception
sqlstate heap_container_not_found
new long id getcontainerid
// perform all the "real" work in a non-readonly nested user
// transaction, so that as work is completed on each page resources
// can be released.  must be careful as all locks obtained in nested
// transaction will conflict with parent transaction - so this call
// must be made only if parent transaction can have no conflicting
// locks on the table, otherwise the purge will fail with a self
// deadlock.
nested_xact    transactionmanager
xact_manager startnestedusertransaction false
// now open the table in a nested user transaction so that each
// page worth of work can be committed after it is done.
openconglomerate open_conglom   new openheap
if  open_conglom init
containerhandle  null
this
this format_ids
nested_xact
nested_xact getrawstorexact
true
transactioncontroller openmode_forupdate
transactioncontroller mode_record
nested_xact getrawstorexact   newlockingpolicy
lockingpolicy mode_record
transactioncontroller isolation_repeatable_read  true
null     null
throw standardexception newexception
sqlstate heap_container_not_found
new long id getcontainerid    tostring
heapcontroller   new heapcontroller
heapcontroller init open_conglom
page page     open_conglom getcontainer   getfirstpage
boolean purgingdone   false
while  page    null
long pageno   page getpagenumber
purgingdone   heapcontroller purgecommitteddeletes page
if  purgingdone
page   null
// commit xact to free resouurces asap, commit will
// unlatch the page if it has not already been unlatched
// by a remove.
open_conglom getxactmgr   commitnosync
transactioncontroller release_locks
// the commit closes the underlying container, so let
// the heapcontroller know this has happened.  usually
// the transaction takes care of this, but this controller
// is internal, so the transaction does not know about it.
heapcontroller closeforendtransaction false
// the commit will close the underlying
open_conglom reopen
else
page unlatch
page   null
page   open_conglom getcontainer   getnextpage pageno
finally
if  open_for_ddl_lock    null
open_for_ddl_lock close
if  heapcontroller    null
heapcontroller close
if  nested_xact    null
nested_xact commitnosync transactioncontroller release_locks
nested_xact destroy
return
public void compressconglomerate
transactionmanager              xact_manager
transaction                     rawtran
throws standardexception
openconglomerate        open_conglom      null
heapcontroller          heapcontroller    null
try
open_conglom   new openheap
// open table in intended exclusive mode in the top level
// transaction, this will stop any ddl from happening until
// purge of whole table is finished.
if  open_conglom init
containerhandle  null
this
this format_ids
xact_manager
rawtran
false
transactioncontroller openmode_forupdate
transactioncontroller mode_table
rawtran newlockingpolicy
lockingpolicy mode_container
transactioncontroller isolation_repeatable_read  true
null     null
throw standardexception newexception
sqlstate heap_container_not_found
new long id getcontainerid
heapcontroller   new heapcontroller
heapcontroller init open_conglom
open_conglom getcontainer   compresscontainer
finally
if  open_conglom    null
open_conglom close
return
/**
* open a heap compress scan.
* <p>
*
* @see conglomerate#defragmentconglomerate
*
* @exception  standardexception  standard exception policy.
**/
public scanmanager defragmentconglomerate
transactionmanager              xact_manager
transaction                     rawtran
boolean                         hold
int                             open_mode
int                             lock_level
lockingpolicy                   locking_policy
int                             isolation_level
throws standardexception
openconglomerate open_conglom   new openheap
if  open_conglom init
containerhandle  null
this
this format_ids
xact_manager
rawtran
hold
open_mode
lock_level
rawtran newlockingpolicy
lockingpolicy mode_record
transactioncontroller isolation_repeatable_read  true
null     null
throw standardexception newexception
sqlstate heap_container_not_found
new long id getcontainerid
heapcompressscan heap_compress_scan   new heapcompressscan
heap_compress_scan init
open_conglom


0


0
return heap_compress_scan
/**
* return an open storecostcontroller for the conglomerate.
* <p>
* return an open storecostcontroller which can be used to ask about
* the estimated row counts and costs of scancontroller and
* conglomeratecontroller operations, on the given conglomerate.
* <p>
* @param xact_manager the transactioncontroller under which this
*                     operation takes place.
* @param rawtran  raw transaction context in which scan is managed.
*
* @return the open storecostcontroller.
*
* @exception  standardexception  standard exception policy.
*
* @see storecostcontroller
**/
public storecostcontroller openstorecost
transactionmanager  xact_manager
transaction         rawtran
throws standardexception
openheap open_conglom   new openheap
if  open_conglom init
containerhandle  null
this
this format_ids
xact_manager
rawtran
false
containerhandle mode_readonly
transactioncontroller mode_table
lockingpolicy  null
dynamiccompiledopenconglominfo  null     null
throw standardexception newexception
sqlstate heap_container_not_found
new long id getcontainerid
heapcostcontroller heapcost   new heapcostcontroller
heapcost init open_conglom
return heapcost
/**
* print this heap.
**/
public string tostring
return  id    null  ?     id tostring
/**************************************************************************
* public methods of staticcompiledopenconglominfo interface:
**************************************************************************
*/
/**
* return the "conglomerate".
* <p>
* for heap just return "this", which both implements conglomerate and
* staticcompiledopenconglominfo.
* <p>
*
* @return this
**/
public datavaluedescriptor getconglom
return this
/**************************************************************************
* methods of storable (via conglomerate)
* storable interface, implies externalizable, typedformat
**************************************************************************
*/
/**
* return my format identifier.
*
* @see org.apache.derby.iapi.services.io.typedformat#gettypeformatid
**/
public int gettypeformatid
return storedformatids access_heap_v2_id
/**
* return whether the value is null or not.
*
* @see org.apache.derby.iapi.services.io.storable#isnull
**/
public boolean isnull
return id    null
/**
* restore the in-memory representation to the null value.
*
* @see org.apache.derby.iapi.services.io.storable#restoretonull
*
**/
public void restoretonull
id   null
/**
* store the stored representation of the column value in the stream.
*
**/
public void writeexternal objectoutput out  throws ioexception
// write the format id of this conglomerate
formatidutil writeformatidinteger out  this gettypeformatid
out writeint  int  id getsegmentid
out writelong id getcontainerid
// write number of columns in heap.
out writeint format_ids length
// write out array of format id's
conglomerateutil writeformatidarray format_ids  out
/**
* restore the in-memory representation from the stream.
*
* @see java.io.externalizable#readexternal
**/
public void readexternal objectinput in  throws ioexception
// read the format id of this conglomerate.
formatidutil readformatidinteger in
int segmentid   in readint
long containerid   in readlong
id   new containerkey segmentid  containerid
// read the number of columns in the heap.
int num_columns   in readint
// read the array of format ids.
format_ids   conglomerateutil readformatidarray num_columns  in
public void readexternalfromarray arrayinputstream in  throws ioexception
// read the format id of this conglomerate.
formatidutil readformatidinteger in
int segmentid   in readint
long containerid   in readlong
id   new containerkey segmentid  containerid
// read the number of columns in the heap.
int num_columns   in readint
// read the array of format ids.
format_ids   conglomerateutil readformatidarray num_columns  in