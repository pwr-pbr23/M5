/*
derby - class org.apache.derby.impl.sql.execute.createtriggerconstantaction
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl sql execute
import org apache derby iapi store access transactioncontroller
import org apache derby iapi sql conn languageconnectioncontext
import org apache derby iapi sql execute constantaction
import org apache derby iapi sql dictionary datadescriptorgenerator
import org apache derby iapi sql dictionary datadictionary
import org apache derby iapi sql dictionary schemadescriptor
import org apache derby iapi sql dictionary spsdescriptor
import org apache derby iapi sql dictionary tabledescriptor
import org apache derby iapi sql dictionary triggerdescriptor
import org apache derby iapi types datavaluefactory
import org apache derby iapi sql depend dependencymanager
import org apache derby iapi sql execute executionfactory
import org apache derby iapi sql activation
import org apache derby iapi error standardexception
import org apache derby iapi reference sqlstate
import org apache derby iapi services context contextservice
import org apache derby iapi services sanity sanitymanager
import org apache derby catalog uuid
import java sql timestamp
/**
* this class  describes actions that are always performed for a
* create trigger statement at execution time.
*
*	@author jamie
*/
class createtriggerconstantaction extends ddlsingletableconstantaction
private string					triggername
private string					triggerschemaname
private tabledescriptor			triggertable 		   null after readexternal
private uuid					triggertableid 		   set in readexternal
private int						eventmask
private boolean					isbefore
private boolean					isrow
private boolean					isenabled
private boolean					referencingold
private boolean					referencingnew
private uuid					whenspsid
private string					whentext
private uuid					actionspsid
private string					actiontext
private string					originalactiontext
private string					oldreferencingname
private string					newreferencingname
private uuid					spscompschemaid
private timestamp				creationtimestamp
private int					referencedcols
// constructors
/**
*	make the constantaction for a create trigger statement.
*
* @param triggerschemaname	name for the schema that trigger lives in.
* @param triggername	name of trigger
* @param eventmask		triggerdescriptor.trigger_event_xxxx
* @param isbefore		is this a before (as opposed to after) trigger
* @param isrow			is this a row trigger or statement trigger
* @param isenabled		is this trigger enabled or disabled
* @param triggertable	the table upon which this trigger is defined
* @param whenspsid		the sps id for the when clause (may be null)
* @param whentext		the text of the when clause (may be null)
* @param actionspsid	the spsid for the trigger action (may be null)
* @param actiontext	the text of the trigger action
* @param spscompschemaid	the compilation schema for the action and when
*							spses.   if null, will be set to the current default
*							schema
* @param creationtimestamp	when was this trigger created?  if null, will be
*						set to the time that executeconstantaction() is invoked
* @param referencedcols	what columns does this trigger reference (may be null)
* @param originalactiontext the original user text of the trigger action
* @param referencingold whether or not old appears in referencing clause
* @param referencingnew whether or not new appears in referencing clause
* @param oldreferencingname old referencing table name, if any, that appears in referencing clause
* @param newreferencingname new referencing table name, if any, that appears in referencing clause
*/
createtriggerconstantaction
string				triggerschemaname
string				triggername
int					eventmask
boolean				isbefore
boolean 			isrow
boolean 			isenabled
tabledescriptor		triggertable
uuid				whenspsid
string				whentext
uuid				actionspsid
string				actiontext
uuid				spscompschemaid
timestamp			creationtimestamp
int				referencedcols
string				originalactiontext
boolean				referencingold
boolean				referencingnew
string				oldreferencingname
string				newreferencingname
super triggertable getuuid
this triggername   triggername
this triggerschemaname   triggerschemaname
this triggertable   triggertable
this eventmask   eventmask
this isbefore   isbefore
this isrow   isrow
this isenabled   isenabled
this whenspsid   whenspsid
this whentext   whentext
this actionspsid   actionspsid
this actiontext   actiontext
this spscompschemaid   spscompschemaid
this creationtimestamp   creationtimestamp
this referencedcols   referencedcols
this originalactiontext   originalactiontext
this referencingold   referencingold
this referencingnew   referencingnew
this oldreferencingname   oldreferencingname
this newreferencingname   newreferencingname
if  sanitymanager debug
sanitymanager assert triggerschemaname    null
sanitymanager assert triggername    null
sanitymanager assert triggertable    null
sanitymanager assert actiontext    null
/**
* this is the guts of the execution-time logic for create trigger.
*
* @see constantaction#executeconstantaction
*
* @exception standardexception		thrown on failure
*/
public void	executeconstantaction activation activation
throws standardexception
spsdescriptor				whenspsd   null
spsdescriptor				actionspsd
languageconnectioncontext lcc   activation getlanguageconnectioncontext
datadictionary dd   lcc getdatadictionary
dependencymanager dm   dd getdependencymanager
transactioncontroller tc   lcc gettransactionexecute
/*
** indicate that we are about to modify the data dictionary.
**
** we tell the data dictionary we're done writing at the end of
** the transaction.
*/
dd startwriting lcc
schemadescriptor triggersd   getschemadescriptorforcreate dd  activation  triggerschemaname
if  spscompschemaid    null
schemadescriptor def   lcc getdefaultschema
if  def getuuid      null
// descriptor for default schema is stale,
// look it up in the dictionary
def   dd getschemadescriptor def getdescriptorname    tc
false
spscompschemaid   def getuuid
if  sanitymanager debug
sanitymanager assert spscompschemaid    null
string tabname
if  triggertable    null
triggertableid   triggertable getuuid
tabname   triggertable getname
else
tabname       triggertableid
/* we need to get table descriptor again.  we simply can't trust the
* one we got at compile time, the lock on system table was released
* when compile was done, and the table might well have been dropped.
*/
triggertable   dd gettabledescriptor triggertableid
if  triggertable    null
throw standardexception newexception
sqlstate lang_table_not_found_during_execution
tabname
/* lock the table for ddl.  otherwise during our execution, the table
* might be changed, even dropped.  beetle 4269
*/
locktableforddl tc  triggertable getheapconglomerateid    true
/* get triggertable again for correctness, in case it's changed before
* the lock is aquired
*/
triggertable   dd gettabledescriptor triggertableid
if  triggertable    null
throw standardexception newexception
sqlstate lang_table_not_found_during_execution
tabname
/*
** send an invalidate on the table from which
** the triggering event emanates.  this it
** to make sure that dml statements on this table
** will be recompiled.  do this before we create
** our trigger spses lest we invalidate them just
** after creating them.
*/
dm invalidatefor triggertable  dependencymanager create_trigger  lcc
/*
** lets get our trigger id up front, we'll use it when
** we create our spses.
*/
uuid tmptriggerid   dd getuuidfactory   createuuid
actionspsid    actionspsid    null  ?
dd getuuidfactory   createuuid     actionspsid
datadescriptorgenerator ddg   dd getdatadescriptorgenerator
/*
** create the trigger descriptor first so the trigger action
** compilation can pick up the relevant trigger especially in
** the case of self triggering.
*/
triggerdescriptor triggerd
ddg newtriggerdescriptor
triggersd
tmptriggerid
triggername
eventmask
isbefore
isrow
isenabled
triggertable
whenspsd    null ? null   whenspsd getuuid
actionspsid
creationtimestamp    null ? new timestamp system currenttimemillis      creationtimestamp
referencedcols
originalactiontext
referencingold
referencingnew
oldreferencingname
newreferencingname
dd adddescriptor triggerd  triggersd
datadictionary systriggers_catalog_num  false
tc
/*
** if we have a when action we create it now.
*/
if  whentext    null
whenspsd   createsps lcc  ddg  dd  tc  tmptriggerid  triggersd
whenspsid  spscompschemaid  whentext  true  triggertable
/*
** create the trigger action
*/
actionspsd   createsps lcc  ddg  dd  tc  tmptriggerid  triggersd
actionspsid  spscompschemaid  actiontext  false  triggertable
/*
** make underlying spses dependent on the trigger.
*/
if  whenspsd    null
dm adddependency triggerd  whenspsd  lcc getcontextmanager
dm adddependency triggerd  actionspsd  lcc getcontextmanager
dm adddependency triggerd  triggertable  lcc getcontextmanager
dm adddependency actionspsd  triggertable  lcc getcontextmanager
//store trigger's dependency on various privileges in the dependeny system
storeviewtriggerdependenciesonprivileges activation  triggerd
/*
** create an sps that is used by the trigger.
*/
private spsdescriptor createsps
languageconnectioncontext	lcc
datadescriptorgenerator 	ddg
datadictionary				dd
transactioncontroller		tc
uuid						triggerid
schemadescriptor			sd
uuid						spsid
uuid						compschemaid
string						text
boolean						iswhen
tabledescriptor				triggertable
throws standardexception
if  text    null
return null
/*
** note: the format of this string is very important.
** dont change it arbitrarily -- see sps code.
*/
string spsname
iswhen ?
triggerid       triggertable getuuid   tostring
spsdescriptor spsd   new spsdescriptor dd  spsname
spsid    null  ?
dd getuuidfactory   createuuid
spsid
sd getuuid
compschemaid    null ?
lcc getdefaultschema   getuuid
compschemaid
spsdescriptor sps_type_trigger
true 				   it is valid
text 				   the text
true   	   no defaults
/*
** prepared the stored prepared statement
** and release the activation class -- we
** know we aren't going to execute statement
** after create it, so for now we are finished.
*/
spsd prepareandrelease lcc  triggertable
dd addspsdescriptor spsd  tc  true
return spsd
public string tostring
return constructtostring    triggername