/*
derby - class org.apache.derby.impl.store.raw.log.flushedscan
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl store raw log
import org apache derby iapi reference sqlstate
import org apache derby iapi reference messageid
import org apache derby impl store raw log logcounter
import org apache derby impl store raw log logrecord
import org apache derby impl store raw log streamlogscan
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi error standardexception
import org apache derby iapi services i18n messageservice
import org apache derby iapi store raw log loginstant
import org apache derby iapi store raw log logfactory
import org apache derby iapi store raw xact transactionid
import org apache derby iapi services io arrayinputstream
import org apache derby io storagerandomaccessfile
import java io ioexception
/**
scan the the log which is implemented by a series of log files.n
this log scan knows how to move across log file if it is positioned at
the boundary of a log file and needs to getnextrecord.
<pre>
4 bytes - length of user data, i.e. n
8 bytes - long representing log instant
n bytes of supplied data
4 bytes - length of user data, i.e. n
</pre>
*/
public class flushedscan implements streamlogscan
private storagerandomaccessfile scan 		   an output stream to the log file
logtofile logfactory  				   log factory knows how to to skip
// from log file to log file
boolean open 						   true if the scan is open
long currentlogfilenumber  			   the log file the scan is currently on
long currentlogfilefirstunflushedposition
// the length of the unflushed portion
// of the current log file. this is the
// length of the file for all but the
// last log file.
long currentinstant 				   the log instant the scan is
// currently on - only valid after a
// successful getnextrecord
long firstunflushed    1 			   scan until we reach the first
// unflushed byte in the log.
long firstunflushedfilenumber
long firstunflushedfileposition
//resolve: this belongs in a shared place.
static final int log_rec_len_byte_length   4
public flushedscan logtofile logfactory  long startat
throws standardexception
if  sanitymanager debug
sanitymanager assert startat    logcounter invalid_log_instant
try
currentlogfilenumber   logcounter getlogfilenumber startat
this logfactory   logfactory
scan    logfactory getlogfileatposition startat
setfirstunflushed
open   true
currentinstant   logcounter invalid_log_instant     set at getnextrecord
catch  ioexception ioe
throw logfactory markcorrupt
standardexception newexception sqlstate log_io_error  ioe
/*
** methods of logscan
*/
/**
read a log record into the byte array provided.  resize the input
stream byte array if necessary.
@return the length of the data written into data, or -1 if the end of the
scan has been reached.
@exception standardexception standard cloudscape error policy
*/
public logrecord getnextrecord arrayinputstream input
transactionid tranid
int groupmask
throws standardexception
try
boolean candidate
int peekamount   logrecord formatoverhead     logrecord maxgroupstoredsize
if  tranid    null
peekamount    logrecord maxtransactionidstoredsize tranid
int readamount 		   the number of bytes actually read
logrecord lr
do
if   open     positiontonextrecord
return null
int checklength
// this log record is a candidate unless proven otherwise
lr   null
candidate   true
readamount    1
currentinstant   scan readlong
byte data   input getdata
if  data length < nextrecordlength
// make a new array of sufficient size and reset the arrary
// in the input stream
data   new byte
input setdata data
if  logfactory databaseencrypted
scan readfully data  0  nextrecordlength
int len   logfactory decrypt data  0  nextrecordlength  data  0
if  sanitymanager debug
sanitymanager assert len    nextrecordlength
input setlimit 0  len
else    no need to decrypt  only get the group and tid if we filter
if  groupmask    0    tranid    null
// no filter, get the whole thing
scan readfully data  0  nextrecordlength
input setlimit 0  nextrecordlength
else
// read only enough so that group and the tran id is in
// the data buffer.  group is stored as compressed int
// and tran id is stored as who knows what.  read min
// of peekamount or nextrecordlength
readamount    nextrecordlength > peekamount  ?
peekamount   nextrecordlength
// in the data buffer, we now have enough to peek
scan readfully data  0  readamount
input setlimit 0  readamount
lr    logrecord  input readobject
if  groupmask    0    tranid    null
if  groupmask    0     groupmask   lr group       0
candidate   false     no match  throw this log record out
if  candidate    tranid    null
transactionid tid   lr gettransactionid
if   tid equals tranid      nomatch
candidate   false     throw this log record out
// if this log record is not filtered out, we need to read
// in the rest of the log record to the input buffer.
// except if it is an encrypted database, in which case the
// entire log record have already be read in for
// decryption.
if  candidate     logfactory databaseencrypted
// read the rest of the log into the buffer
if  sanitymanager debug
sanitymanager assert readamount > 0
if  readamount < nextrecordlength
// need to remember where we are because the log
// record may have read part of it off the input
// stream already and that position is lost when we
// set limit again.
int inputposition   input getposition
scan readfully data  readamount
nextrecordlength readamount
input setlimit 0  nextrecordlength
input setposition inputposition
if  candidate    logfactory databaseencrypted
checklength   scan readint
if  sanitymanager debug
sanitymanager assert checklength    nextrecordlength
else    chances are  we haven't read all of the log record  skip it
// the starting record position is in the currentinstant,
// calculate the next record starting position using that
// and the nextrecordlength
long nextrecordstartposition
logcounter getlogfileposition currentinstant
nextrecordlength   logtofile log_record_overhead
scan seek nextrecordstartposition
while  candidate    false
return lr
catch  classnotfoundexception cnfe
throw logfactory markcorrupt
standardexception newexception sqlstate log_corrupted  cnfe
catch  ioexception ioe
throw logfactory markcorrupt
standardexception newexception sqlstate log_io_error  ioe
/**
reset the scan to the given loginstant.
@param instant the position to reset to
@exception ioexception scan cannot access the log at the new position.
*/
public void resetposition loginstant instant  throws ioexception
if  sanitymanager debug
sanitymanager throwassert
/**
get the log instant that is right after the record just retrived
@return invalid_log_instant if this is not a forward scan or, no
record have been returned yet or the scan has completed.
*/
public long getlogrecordend
if  sanitymanager debug
sanitymanager throwassert
return logcounter invalid_log_instant
/**
returns true if there is partially writen log records before the crash
in the last log file. partiall wrires are identified during forward
scans for log recovery.
*/
public boolean islogendfuzzy
if  sanitymanager debug
sanitymanager throwassert
return false
/**
return the log instant (as an integer) the scan is currently on - this is the log
instant of the log record that was returned by getnextrecord.
*/
public long getinstant
return currentinstant
/**
return the log instant the scan is currently on - this is the log
instant of the log record that was returned by getnextrecord.
*/
public loginstant getloginstant
if  currentinstant    logcounter invalid_log_instant
return null
else
return new logcounter currentinstant
/**
close the scan.
*/
public void close
if  scan    null
try
scan close
catch  ioexception ioe
scan   null
currentinstant   logcounter invalid_log_instant
open   false
/*
private methods.
*/
private void setfirstunflushed
throws standardexception  ioexception
loginstant firstunflushedinstant
logfactory getfirstunflushedinstant
firstunflushed     logcounter firstunflushedinstant  getvalueaslong
firstunflushedfilenumber   logcounter getlogfilenumber firstunflushed
firstunflushedfileposition   logcounter getlogfileposition firstunflushed
setcurrentlogfilefirstunflushedposition
private void setcurrentlogfilefirstunflushedposition
throws ioexception
/*
note we get the currentlogfilelength without synchronization.
this is safe because one of the following cases apply:
<ol>
<li> the end of the flushed section of the log is in another file.
in this case the end of the current file will not change.
<li> the end of the log is in this file. in this case we
end our scan at the firstunflushedinstant and do not use
currentlogfilelength.
</ol>
*/
if  currentlogfilenumber    firstunflushedfilenumber
currentlogfilefirstunflushedposition   firstunflushedfileposition
else if  currentlogfilenumber < firstunflushedfilenumber
currentlogfilefirstunflushedposition   scan length
else
// resolve
throw new ioexception
messageservice gettextmessage messageid log_bad_start_instant
private void switchlogfile
throws standardexception
try
readnextrecordlength   false
scan close
scan   null
scan   logfactory getlogfileatbeginning   currentlogfilenumber
setcurrentlogfilefirstunflushedposition
catch  ioexception ioe
throw logfactory markcorrupt
standardexception newexception sqlstate log_io_error  ioe
/**
the length of the next record. read from scan and set by
currentlogfilehasunflushedrecord. this is used to retain the length of a
log record in the case currentlogfilehasunflushedrecord reads the length
and determines that some bytes in the log record are not yet flushed.
*/
int nextrecordlength
/**
flag to indicate that the length of the next log record has been read by
currentlogfilehasunflushedrecord.
this flag gets reset in two ways:
<ol>
<li> currentlogfilehasunflushedrecord determines that the entire log
record is flushed and returns true. in this case getnextrecord reads and
returns the log record.
<li> we switch log files --due to a partial log record at the end of an
old log file.
</ol>
*/
boolean readnextrecordlength
private boolean currentlogfilehasunflushedrecord
throws ioexception
if  sanitymanager debug
sanitymanager assert scan    null
long curpos   scan getfilepointer
if   readnextrecordlength
if  curpos   log_rec_len_byte_length >
currentlogfilefirstunflushedposition
return false
nextrecordlength   scan readint
curpos  4
readnextrecordlength   true
if  nextrecordlength  0  return false
int bytesneeded
nextrecordlength   log_rec_len_byte_length
if  curpos   bytesneeded > currentlogfilefirstunflushedposition
return false
else
readnextrecordlength   false
return true
private boolean positiontonextrecord
throws standardexception  ioexception
//if the flushed section of the current log file contains our record we
//simply return.
if  currentlogfilehasunflushedrecord    return true
//update our cached copy of the first unflushed instant.
setfirstunflushed
//in the call to setfirstunflushed, we may have noticed that the current
//log file really does contain our record. if so we simply return.
if  currentlogfilehasunflushedrecord    return true
//our final chance of finding a record is if we are not scanning the log
//file with the last flushed instant we can switch logfiles. note that
//we do this in a loop to cope with empty log files.
while currentlogfilenumber < firstunflushedfilenumber
switchlogfile
if  currentlogfilehasunflushedrecord    return true
//the log contains no more flushed log records so we return false.
currentinstant   logcounter invalid_log_instant
return false