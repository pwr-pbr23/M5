/*
derby - class org.apache.derby.impl.store.raw.data.d_diagnosticutil
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl store raw data
import org apache derby iapi services context contextservice
import org apache derby iapi services diag diagnosticable
import org apache derby iapi services diag diagnosticutil
import org apache derby iapi services monitor monitor
import org apache derby iapi error standardexception
import org apache derby iapi store access accessfactory
import org apache derby iapi store access conglomeratecontroller
import org apache derby iapi store access transactioncontroller
import org apache derby iapi store raw containerhandle
import org apache derby iapi store raw containerkey
import org apache derby iapi store raw page
import org apache derby iapi store raw transaction
import org apache derby iapi store raw rawstorefactory
// import com.ibm.db2j.impl.basicservices.testservice.testtemplate.t_multiiterations;
// import com.ibm.db2j.impl.basicservices.testservice.testtemplate.t_fail;
import org apache derby iapi reference property
// import java.util.properties;
// debugging:
/**
this class provides some utility functions used to debug on disk structures
of the store.
**/
public class d_diagnosticutil
/* constructors for this class: */
/**
* no arg constructor.
**/
public d_diagnosticutil
/* private/protected methods of this class: */
/**
* given a database name come up with a module.
* <p>
*
* @return the store module associated with given database name.
*
* @param db_name name of the database.
*
* @exception  standardexception  standard exception policy.
**/
private static object getmodulefromdbname string db_name
throws standardexception
object   store_module   null
object db   monitor findservice property database_module  db_name
// resolve (mikem) - find a single way to find the current
// accessfactory that works both for ij and unit tests.
if  db    null
// maybe it is a module test - try this hack:
store_module   monitor findservice accessfactory module  db_name
else
// find the accessfactory
store_module   monitor findservicemodule db  accessfactory module
return store_module
/* public methods of this class: */
/**
* given a database name and conglomid print out diagnostic info.
* <p>
* print diagnostic information about a particular conglomerate, can be
* called for either a btree or heap conglomerate.  this routine
* prints out the string to "system.out"; "ij", depending on it's
* configuration, will only print out a fixed length (default 128 bytes),
* so having ij print the string can be a problem.
* <p>
*
* can be called from ij to find out info about conglomid 19 in database
* 'msgdb' by using the following syntax:
*
maximumdisplaywidth 9000;
create function d_conglomid_print(dbname varchar(128), conglomid int)
returns varchar(32000) returns null on null input
external name
'org.apache.derby.impl.store.raw.data.d_diagnosticutil.diag_conglomid_print'
language java parameter style java;
values d_conglomid_print('msgdb', 19);
com.ibm.db2j.protocol.basicservices.diagnostic.t_diagnosticable::
diag_conglomid_print('msgdb', 19);
*
* resolve - an interface that takes a table name would be nice.
*
* @param db_name   name of the database
* @param conglomid conglomerate id of the conglomerate to debug
*
* @exception  standardexception  standard exception policy.
**/
public static string diag_conglomid_print string db_name  long conglomid
throws standardexception
try
system out println diag_conglomid db_name  conglomid
catch  throwable t
t printstacktrace
return
/**
* given a database name and conglomid, return diagnositic string.
* <p>
* return a string with diagnostic information about a particular
* conglomerate, can be called for any type of conglomerate (some types
* may not return any info though).
* <p>
* can be called from ij to find out info about conglomid 19 in database
* 'msgdb' by using the following syntax:
*
*     values
*     com.ibm.db2j.protocol.basicservices.diagnostic.t_diagnosticable::
*     diag_conglomid('msgdb', 19);
maximumdisplaywidth 9000;
create function diag_conglomid(dbname varchar(128), conglomid int)
returns varchar(32000) returns null on null input
external name
'org.apache.derby.impl.store.raw.data.d_diagnosticutil.diag_conglomid'
language java parameter style java;
values diag_conglomid('msgdb', 19);
com.ibm.db2j.protocol.basicservices.diagnostic.t_diagnosticable::
diag_conglomid_print('msgdb', 19);
*
* resolve - an interface that takes a table name would be nice.
*
* @param db_name   name of the database
* @param conglomid conglomerate id of the conglomerate to debug
*
* @exception  standardexception  standard exception policy.
**/
public static string diag_conglomid string db_name  long conglomid
throws standardexception
string          ret_string     null
accessfactory   store_module   null
store_module    accessfactory  getmodulefromdbname db_name
if  store_module    null
transactioncontroller tc
store_module gettransaction
contextservice getfactory   getcurrentcontextmanager
conglomeratecontroller open_table
tc openconglomerate
conglomid  false  0  transactioncontroller mode_table
transactioncontroller isolation_serializable
open_table debugconglomerate
diagnosticable diag_obj   diagnosticutil finddiagnostic open_table
ret_string   diag_obj diag
open_table close
else
system.out.println(
db_name
return ret_string
/**
* dump raw contents of a page.
* <p>
* a utility routine that can be called from an ij session that will
* dump the raw contents of a page, in the raw store dump format.
*
* @param db_name       name of the database
* @param segmentid     segmentid of the table (usually 0)
* @param containerid   containerid of the table (not conglomid)
* @param pagenumber    pagenumber of page to dump.
*
**/
public static void diag_dump_page
string  db_name
long    segmentid
long    containerid
long    pagenumber
transaction xact   null
try
object module   getmodulefromdbname db_name
rawstorefactory store_module    rawstorefactory
monitor findservicemodule module  rawstorefactory module
xact   store_module startinternaltransaction contextservice getfactory   getcurrentcontextmanager
containerkey id   new containerkey segmentid  containerid
containerhandle container
xact opencontainer id
containerhandle mode_readonly
page page   container getpage pagenumber
if  page    null
system out println page tostring
page unlatch
else
system out println     pagenumber
xact abort
xact close
xact   null
catch  standardexception se
se printstacktrace
finally
if  xact    null
try
xact abort
xact close
catch  standardexception se
/**
* given a database name and conglomid, return container id.
* <p>
* return the containerid of a given conglomerate id.
* <p>
* can be called from ij to find out info about conglomid 19 in database
* 'msgdb' by using the following syntax:
*
values
com.ibm.db2j.protocol.basicservices.diagnostic.t_diagnosticable).
diag_containerid_to_conglomid('msgdb', 924300359390);
*
* resolve - an interface that takes a table name would be nice.
*
* @param db_name       name of the database
* @param containerid   container id of the conglomerate to look up
*
* @exception  standardexception  standard exception policy.
**/
public static long diag_containerid_to_conglomid
string          db_name
long            containerid
throws standardexception
// find the accessfactory
object store_module   getmodulefromdbname db_name
return diag_containerid_to_conglomid store_module  containerid
public static long diag_containerid_to_conglomid
object   module
long            containerid
string          ret_string     null
accessfactory   store_module   null
long            conglom_id     long min_value
// find the accessfactory
store_module    accessfactory
monitor getservicemodule module  accessfactory module
if  store_module    null
try
transactioncontroller tc
store_module gettransaction
contextservice getfactory   getcurrentcontextmanager
conglom_id   tc findconglomid containerid
catch  throwable t
t printstacktrace
// on error just return the initialized bad value conglom_id
else
// during access boot this does not exist, assume for now that
// is why we got here.  resolve - it would be nice if we could
// actuallly figure that is why we failed.
/*
system.out.println(
"could not find module for module: " + module);
*/
return conglom_id
/**
* given a database name and containerid, return conglomerate id.
* <p>
* return the conglomerate id of a given conainer id.
* <p>
* can be called from ij to find out info about conglomid 19 in database
* 'msgdb' by using the following syntax:
*
values
com.ibm.db2j.protocol.basicservices.diagnostic.t_diagnosticable).
diag_conglomid_to_containerid('msgdb', 19);
*
* resolve - an interface that takes a table name would be nice.
*
* @param db_name   name of the database
* @param conglomid conglomerate id of the conglomerate to debug
*
* @exception  standardexception  standard exception policy.
**/
public static long diag_conglomid_to_containerid
string          db_name
long            conglomid
throws standardexception
string          ret_string     null
object   store_module   null
long            conglom_id     long min_value
// find the accessfactory
store_module   getmodulefromdbname db_name
return diag_conglomid_to_containerid store_module  conglomid
public static long diag_conglomid_to_containerid
object   module
long            conglomid
string          ret_string     null
accessfactory   store_module   null
long            container_id   long min_value
// find the accessfactory
store_module    accessfactory
monitor getservicemodule module  accessfactory module
if  store_module    null
try
transactioncontroller tc
store_module gettransaction
contextservice getfactory   getcurrentcontextmanager
container_id   tc findcontainerid conglomid
catch  throwable t
t printstacktrace
// on error just return the initialized bad value conglom_id
else
// during access boot this does not exist, assume for now that
// is why we got here.  resolve - it would be nice if we could
// actuallly figure that is why we failed.
/*
system.out.println(
"could not find module for module: " + module);
*/
return container_id