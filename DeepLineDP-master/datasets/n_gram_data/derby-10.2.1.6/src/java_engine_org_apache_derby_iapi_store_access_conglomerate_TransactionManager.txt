/*
derby - class org.apache.derby.iapi.store.access.conglomerate.transactionmanager
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby iapi store access conglomerate
import org apache derby iapi services daemon serviceable
import org apache derby iapi store access accessfactory
import org apache derby iapi store access conglomeratecontroller
import org apache derby iapi store access sortcontroller
import org apache derby iapi store access transactioncontroller
import org apache derby iapi store raw lockingpolicy
import org apache derby iapi store raw page
import org apache derby iapi store raw transaction
import org apache derby iapi error standardexception
/**
the transactionmanager interface provides methods on the transaction needed
by an access method implementer, but should not be visible to clients of a
transactioncontroller.
<p>
@see transactioncontroller
**/
public interface transactionmanager extends transactioncontroller
/**
* constant used for the lock_level argument to openconglomerate() and
* openscan() calls.  pass in mode_none if you want no table or row locks.
* this is currently only supported from within access.
**/
static final int mode_none        5
/**
* release lock immediately after getting lock.
**/
public static final int lock_instant_duration     1
/**
* hold lock until end of transaction.
**/
public static final int lock_commit_duration      2
/**
* allow lock to be released manually prior to end transaction.
**/
public static final int lock_manual_duration      3
/**
* add to the list of post commit work.
* <p>
* add to the list of post commit work that may be processed after this
* transaction commits.  if this transaction aborts, then the post commit
* work list will be thrown away.  no post commit work will be taken out
* on a rollback to save point.
* <p>
* this routine simply delegates the work to the rawstore transaction.
*
* @param work  the post commit work to do.
*
**/
public void addpostcommitwork serviceable work
/**
* the scanmanager.close() method has been called on "scan".
* <p>
* take whatever cleanup action is appropriate to a closed scan.  it is
* likely this routine will remove references to the scan object that it
* was maintaining for cleanup purposes.
*
**/
public void closeme scanmanager scan
/**
* the conglomeratecontroller.close() method has been called on
* "conglom_control".
* <p>
* take whatever cleanup action is appropriate to a closed
* conglomeratecontroller.  it is likely this routine will remove
* references to the conglomeratecontroller object that it was maintaining
* for cleanup purposes.
**/
public void closeme conglomeratecontroller conglom_control
/**
* the sortcontroller.close() method has been called on "sort_control".
* <p>
* take whatever cleanup action is appropriate to a closed
* sortcontroller.  it is likely this routine will remove
* references to the sortcontroller object that it was maintaining
* for cleanup purposes.
**/
public void closeme sortcontroller sort_control
/**
* get reference to access factory which started this transaction.
* <p>
*
* @return the accessfactory which started this transaction.
**/
public accessfactory getaccessmanager
/**
* get an internal transaction.
* <p>
* start an internal transaction.  an internal transaction is a completely
* separate transaction from the current user transaction.  all work done
* in the internal transaction must be physical (ie. it can be undone
* physically by the rawstore at the page level, rather than logically
* undone like btree insert/delete operations).  the rawstore guarantee's
* that in the case of a system failure all open internal transactions are
* first undone in reverse order, and then other transactions are undone
* in reverse order.
* <p>
* internal transactions are meant to implement operations which, if
* interupted before completion will cause logical operations like tree
* searches to fail.  this special undo order insures that the state of
* the tree is restored to a consistent state before any logical undo
* operation which may need to search the tree is performed.
* <p>
*
* @return the new internal transaction.
*
* @exception  standardexception  standard exception policy.
**/
public transactionmanager getinternaltransaction
throws standardexception
/**
* get the transaction from the transaction manager.
* <p>
* access methods often need direct access to the "transaction" - ie. the
* raw store transaction, so give access to it.
*
* @return the raw store transaction.
*
* @exception  standardexception  standard exception policy.
**/
public transaction getrawstorexact
throws standardexception
/**
* do work necessary to maintain the current position in all the scans.
* <p>
* the latched page in the conglomerate "congomid" is changing, do
* whatever is necessary to maintain the current position of all the
* scans open in this transaction.
* <p>
* for some conglomerates this may be a no-op.
* <p>
*
* @param conglom   conglomerate object of the conglomerate being changed.
* @param page      page in the conglomerate being changed.
*
* @exception  standardexception  standard exception policy.
**/
public void savescanpositions conglomerate conglom  page page
throws standardexception