/*
derby - class org.apache.derby.impl.store.access.sort.scan
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl store access sort
import org apache derby iapi reference sqlstate
import org apache derby iapi store access backingstorehashtable
import org apache derby iapi services io formatablebitset
import org apache derby iapi services i18n messageservice
import org apache derby iapi services io storable
import org apache derby iapi types orderable
import org apache derby iapi types rowlocation
import org apache derby iapi error standardexception
import org apache derby iapi store access conglomerate conglomerate
import org apache derby iapi store access conglomerate scanmanager
import org apache derby iapi store access qualifier
import org apache derby iapi store access scancontroller
import org apache derby iapi store access scaninfo
import org apache derby iapi store raw page
import org apache derby iapi types datavaluedescriptor
import java util properties
/**
abstract base class for all sort classes which return rows from the
sort.  subclasses must implement fetch, next, and close.
**/
public abstract class scan implements scanmanager  scaninfo
/*
* methods of scancontroller
*/
/**
* a call to allow client to indicate that current row does not qualify.
* <p>
* indicates to the scancontroller that the current row does not
* qualify for the scan.  if the isolation level of the scan allows,
* this may result in the scan releasing the lock on this row.
* <p>
* note that some scan implimentations may not support releasing locks on
* non-qualifying rows, or may delay releasing the lock until sometime
* later in the scan (ie. it may be necessary to keep the lock until
* either the scan is repositioned on the next row or page).
* <p>
* this call should only be made while the scan is positioned on a current
* valid row.
* <p>
* this call does not make sense for sort scans.
*
* @exception  standardexception  standard exception policy.
**/
public void didnotqualify
throws standardexception
/**
* fetch the next n rows from the table.
* <p>
* currently unimplemented for sorts.
* <p>
**/
public int fetchnextgroup
datavaluedescriptor     row_array
rowlocation               rowloc_array
throws standardexception
throw standardexception newexception
sqlstate sort_improper_scan_method
public int fetchnextgroup
datavaluedescriptor     row_array
rowlocation               old_rowloc_array
rowlocation               new_rowloc_array
throws standardexception
throw standardexception newexception
sqlstate sort_improper_scan_method
/**
* insert all rows that qualify for the current scan into the input
* hash table.
* <p>
* currently unimplemented for sorts.
* <p>
**/
public void fetchset
long                    max_rowcnt
int                   key_column_numbers
backingstorehashtable   hash_table
throws standardexception
throw standardexception newexception
sqlstate sort_improper_scan_method
/**
returns true if the current position of the scan still qualifies
under the set of qualifiers passed to the openscan().
@see scancontroller#doescurrentpositionqualify
**/
public boolean doescurrentpositionqualify
throws standardexception
return true
/**
fetch the location of the current position in the scan.
@see scancontroller#fetchlocation
**/
public void fetchlocation rowlocation templatelocation
throws standardexception
throw standardexception newexception
sqlstate sort_improper_scan_method
/**
* return scaninfo object which describes performance of scan.
* <p>
* return scaninfo object which contains information about the current
* scan.
* <p>
* currently the scaninfo does not have any performance data.
*
* @see scaninfo
*
* @return the scaninfo object which contains info about current scan.
*
* @exception  standardexception  standard exception policy.
**/
public scaninfo getscaninfo
throws standardexception
return this
/**
* get the total estimated number of rows in the container.
* <p>
* the number is a rough estimate and may be grossly off.  in general
* the server will cache the row count and then occasionally write
* the count unlogged to a backing store.  if the system happens to
* shutdown before the store gets a chance to update the row count it
* may wander from reality.
* <p>
* this call is currently only supported on heap conglomerates, it
* will throw an exception if called on btree conglomerates.
*
* @return the total estimated number of rows in the conglomerate.
*
* @exception  standardexception  standard exception policy.
**/
public long getestimatedrowcount
throws standardexception
throw standardexception newexception
sqlstate sort_improper_scan_method
/**
* set the total estimated number of rows in the container.
* <p>
* often, after a scan, the client of rawstore has a much better estimate
* of the number of rows in the container than what store has.  for
* instance if we implement some sort of update statistics command, or
* just after a create index a complete scan will have been done of the
* table.  in this case this interface allows the client to set the
* estimated row count for the container, and store will use that number
* for all future references.
* <p>
* this call is currently only supported on heap conglomerates, it
* will throw an exception if called on btree conglomerates.
*
* @param count the estimated number of rows in the container.
*
* @exception  standardexception  standard exception policy.
**/
public void setestimatedrowcount long count
throws standardexception
throw standardexception newexception
sqlstate sort_improper_scan_method
/**
returns true if the current position of the scan is at a
deleted row.
@see scancontroller#iscurrentpositiondeleted
**/
public boolean iscurrentpositiondeleted
throws standardexception
throw standardexception newexception
sqlstate sort_improper_scan_method
/**
* return whether this is a keyed conglomerate.
* <p>
*
* @return whether this is a keyed conglomerate.
**/
public boolean iskeyed
return false
/**
* return whether this scan is table locked.
*
* @return whether this is table locked.
**/
public boolean istablelocked
return true
/**
delete the row at the current position of the scan.
@see scancontroller#delete
**/
public boolean delete
throws standardexception
throw standardexception newexception
sqlstate sort_improper_scan_method
/**
reposition the current scan.
@see scancontroller#reopenscan
**/
public void reopenscan
datavaluedescriptor   startkeyvalue
int                     startsearchoperator
qualifier               qualifier
datavaluedescriptor   stopkeyvalue
int                     stopsearchoperator
throws standardexception
throw standardexception newexception
sqlstate sort_improper_scan_method
/**
reposition the current scan.  this call is semantically the same as if
the current scan had been closed and a openscan() had been called instead.
the scan is reopened against the same conglomerate, and the scan
is reopened with the same "scan column list", "hold" and "forupdate"
parameters passed in the original openscan.
@exception standardexception standard exception policy.
**/
public void reopenscanbyrowlocation
rowlocation startrowlocation
qualifier qualifier
throws standardexception
throw standardexception newexception
sqlstate sort_improper_scan_method
/**
replace the entire row at the current position of the scan.
@see scancontroller#replace
**/
public boolean replace
datavaluedescriptor   val
formatablebitset                 validcolumns
throws standardexception
throw standardexception newexception
sqlstate sort_improper_scan_method
/**
return a row location object of the correct type to be
used in calls to fetchlocation.
@see scancontroller#newrowlocationtemplate
**/
public rowlocation newrowlocationtemplate
throws standardexception
throw standardexception newexception
sqlstate sort_improper_scan_method
/**
*@see scancontroller#positionatrowlocation
*/
public boolean positionatrowlocation rowlocation rl
throws standardexception
throw standardexception newexception
sqlstate sort_improper_scan_method
/*
** methods of scanmanager
*/
/**
* do work necessary to maintain the current position in the scan.
* <p>
* the latched page in the conglomerate "congomid" is changing, do
* whatever is necessary to maintain the current position of the scan.
* for some conglomerates this may be a no-op.
* <p>
*
* @param conglom   conglomerate object of the conglomerate being changed.
* @param page      page in the conglomerate being changed.
*
* @exception  standardexception  standard exception policy.
**/
public void saveposition conglomerate conglom  page page
throws standardexception
// resolve (mikem), under the current implementation all scans within
// a transaction are called rather than just the ones with the right
// conglomid.  for now just have sort scans ignore the call.
return
/*
* methods of scaninfo
*/
/**
* return all information gathered about the scan.
* <p>
* this routine returns a list of properties which contains all information
* gathered about the scan.  if a property is passed in, then that property
* list is appeneded to, otherwise a new property object is created and
* returned.
* <p>
* currently sort scans doesn't track any information.
*
* @param prop   property list to fill in.
*
* @exception  standardexception  standard exception policy.
**/
public properties getallscaninfo properties prop
throws standardexception
if  prop    null
prop   new properties
prop put
messageservice gettextmessage sqlstate store_rts_scan_type
messageservice gettextmessage sqlstate store_rts_sort
return prop