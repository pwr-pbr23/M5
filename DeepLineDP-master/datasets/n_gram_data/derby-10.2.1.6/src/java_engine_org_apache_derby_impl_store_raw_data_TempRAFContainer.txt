/*
derby - class org.apache.derby.impl.store.raw.data.temprafcontainer
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl store raw data
import org apache derby impl store raw data basecontainerhandle
import org apache derby impl store raw data basepage
import org apache derby iapi services cache cacheable
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi error standardexception
import org apache derby iapi store raw xact rawtransaction
import org apache derby iapi store raw containerhandle
import org apache derby iapi store raw containerkey
import org apache derby iapi store raw page
import org apache derby iapi store raw log loginstant
import org apache derby iapi store raw data rawcontainerhandle
import org apache derby io storagefactory
import org apache derby io storagefile
import java io ioexception
/**
needssync is never true - done
an exception never marks the store as corrupt
clean() does not stubbify
preallocate() does nothing - done
getfilename() returns a file in the tmp directory - done
flushall does nothing - done
file descriptor is never synced
*/
class temprafcontainer extends rafcontainer
protected int inusecount
temprafcontainer basedatafilefactory factory
super factory
/**
@exception standardexception standard cloudscape error policy
*/
public cacheable setidentity object key  throws standardexception
containerkey newidentity    containerkey  key
if  newidentity getsegmentid      containerhandle temporary_segment
rafcontainer realcontainer   new rafcontainer datafactory
return realcontainer setident newidentity
return super setidentity newidentity
/**
@exception standardexception standard cloudscape error policy
*/
public cacheable createidentity object key  object createparameter  throws standardexception
containerkey newidentity    containerkey  key
if  newidentity getsegmentid      containerhandle temporary_segment
rafcontainer realcontainer   new rafcontainer datafactory
return realcontainer createidentity newidentity  createparameter
return createident newidentity  createparameter
/**
@exception standardexception standard cloudscape error policy
*/
public void removecontainer loginstant instant  boolean leavestub  throws standardexception
// discard all of my pages in the cache
pagecache discard identity
synchronized this
// prevent anybody from looking at this container again
setdroppedstate true
setcommitteddropstate true
setdirty false
needssync   false
removefile getfilename identity  false  false  false
/**
preallocate page.  since we don't sync when we write page anyway, no
need to preallocate page.
*/
protected int preallocate long lastpreallocpagenum  int preallocsize
return 0
/**
write the page, if it's within range of the current page range of the container.
if we do write it then don't request that it be synced.
@exception standardexception standard cloudscape error policy
*/
protected void writepage long pagenumber  byte pagedata  boolean syncpage  throws ioexception  standardexception
if   this getdroppedstate
super writepage pagenumber  pagedata  false
needssync   false
storagefile getfilename containerkey identity  boolean stub
boolean errorok  boolean tryalternatepath
return privgetfilename  identity  stub  errorok  tryalternatepath
protected storagefile privgetfilename containerkey identity  boolean stub
boolean errorok  boolean tryalternatepath
return datafactory storagefactory newstoragefile  datafactory storagefactory gettempdir
identity getcontainerid
/**
add a page without locking the container, only one user will be accessing this
table at a time.
@exception standardexception standard cloudscape error policy
*/
public page addpage basecontainerhandle handle  boolean isoverflow  throws standardexception
basepage newpage   newpage handle   rawtransaction  null  handle  isoverflow
if  sanitymanager debug
sanitymanager assert newpage islatched
return newpage
/**
@exception standardexception standard cloudscape error policy
*/
public void truncate basecontainerhandle handle  throws standardexception
// stop anyone from writing any of my pages out
synchronized this
setdroppedstate true
setcommitteddropstate true
setdirty false
needssync   false
// discard all of my pages in the cache
while  pagecache discard identity     true
removefile getfilename identity  false  true  false
createident identity  this
addpage handle  false  unlatch
/**
lock the container and mark the container as in-use by this container handle.
@param droppedok if true, use this container even if it is dropped.,
@return true if the container can be used, false if it has been dropped
since the lock was requested and droppedok is not true.
@exception standardexception i cannot be opened for update.
*/
protected boolean use basecontainerhandle handle  boolean forupdate
boolean droppedok
throws standardexception
if  super use handle  forupdate  droppedok
inusecount
return true
return false
/**
discontinue use of this container. note that the unlockcontainer
call made from this method may not release any locks. the container
lock may be held until the end of the transaction.
*/
protected void letgo basecontainerhandle handle
inusecount
super letgo handle
/**
returns true if only a single handle is connected to this container.
*/
public boolean issingleuser
return inusecount    1