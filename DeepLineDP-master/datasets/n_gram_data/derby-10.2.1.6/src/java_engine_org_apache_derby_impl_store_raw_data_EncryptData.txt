/*
derby - class org.apache.derby.impl.store.raw.data.encryptdata
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl store raw data
import org apache derby iapi reference sqlstate
import org apache derby iapi services context contextmanager
import org apache derby iapi services daemon serviceable
import org apache derby iapi services sanity sanitymanager
import org apache derby iapi error standardexception
import org apache derby iapi store raw data rawcontainerhandle
import org apache derby iapi store raw containerkey
import org apache derby iapi store raw lockingpolicy
import org apache derby iapi store raw transaction
import org apache derby iapi store raw xact rawtransaction
import org apache derby iapi store raw containerhandle
import org apache derby iapi store access transactioncontroller
import org apache derby io storagefactory
import org apache derby io storagefile
import org apache derby iapi util reusefactory
import java security accesscontroller
import java security privilegedaction
/**
* this class is used to encrypt all the containers in the data segment with a
* new encryption key when password/key is changed or when an existing database
* is reconfigured for encryption.
*
* encryption of existing data in the data segments is done by doing the
* following:
*  find all the containers in data segment (seg0) and encrypt all of them
*  with the new  encryption key, the process for each container is:
*   1.write a log record to indicate that the container is getting encrypted.
*   2.read all the pages of the container through the page cache and
*       encrypt each page with new encryption key and then write to a
*       temporary file(n<cid>.dat) in the data segment itself.
*   3.	rename the current container file (c<cid>.dat) to
*                                         another file (o<cid>.dat)
*   4.	rename the new encrypted version of the file (n<cid).dat) to be
*                                    the current container file (c<cid>.dat).
*   5.	all the old version of  the container (o<cid>.dat) files are removed
*      after a successful checkpoint with a new key or on a rollback.
*
* 	@author  suresh thalamati
*/
public class encryptdata implements privilegedaction
private basedatafilefactory datafactory
private storagefactory storagefactory
private storagefile oldfiles
private int nooldfiles   0
/* privileged actions */
private static final int storage_file_exists_action   1
private static final int storage_file_delete_action   2
private static final int storage_file_rename_action   3
private int actioncode
private storagefile actionstoragefile
private storagefile actiondeststoragefile
public encryptdata basedatafilefactory datafactory
this datafactory   datafactory
this storagefactory   datafactory getstoragefactory
/*
* find all the all the containers stored in the data directory and
* encrypt them.
* @param t the transaction that is used to configure the database
*          with new encryption properties.
* @exception standardexception standard derby error policy
*/
public void encryptallcontainers rawtransaction t
throws standardexception
/*
* list of containers that needs to be encrypted are identified by
* simply reading the list of files in seg0.
*/
string files   datafactory getcontainernames
if  files    null
oldfiles   new storagefile
nooldfiles   0
long segmentid   0
// loop through all the files in seg0 and
// encrypt all valid containers.
for  int f   files length 1  f >  0   f
long containerid
try
containerid
long parselong files substring 1
files length    4    16
catch  throwable th
// ignore errors from parse, it just means
// that someone put a file in seg0 that we
// didn't expect.  continue with the next one.
continue
containerkey ckey   new containerkey segmentid
containerid
oldfiles   encryptcontainer t  ckey
// old versions of the container files will
// be removed after the (re)encryption of database
// is completed.
else
if  sanitymanager debug
sanitymanager throwassert
/** encrypt a container.
* @param t    the transaction that is used to configure the database
*             with new encryption properties.
* @param ckey the key of the container that is being encrypted.
* @return     file handle to the old copy  of the container.
* @exception standardexception standard derby error policy
*/
private storagefile encryptcontainer rawtransaction  t
containerkey    ckey
throws standardexception
lockingpolicy cl
t newlockingpolicy
lockingpolicy mode_container
transactioncontroller isolation_serializable
true
if  sanitymanager debug
sanitymanager assert cl    null
rawcontainerhandle containerhdl    rawcontainerhandle
t opencontainer ckey  cl  containerhandle mode_forupdate
if  sanitymanager debug
sanitymanager assert containerhdl    null
encryptcontaineroperation lop
new encryptcontaineroperation containerhdl
t loganddo lop
// flush the log to reduce the window between where
// the encrypted container is created & synced and the
// log record for it makes it to disk. if we fail during
// encryption of the container, log record will make sure
// container is restored to the original state and
// any temporary files are cleaned up.
datafactory flush t getlastloginstant
// encrypt the container.
string newfilepath   getfilepath ckey  false
storagefile newfile   storagefactory newstoragefile newfilepath
containerhdl encryptcontainer newfilepath
containerhdl close
/*
* replace the current container file with the new container file after
* keeping a copy of the current container file, it will be removed on
* after a checkpoint with new key or on a rollback this copy will be
* replace the container file to bring the database back to the
* state before encryption process started.
*/
// discard pages in the cache related to this container.
if   datafactory getpagecache   discard ckey
if  sanitymanager debug
sanitymanager throwassert
ckey
// get rid of the container entry from conatainer cache
if   datafactory getcontainercache   discard ckey
if  sanitymanager debug
sanitymanager throwassert
ckey
storagefile currentfile    datafactory getcontainerpath ckey   false
storagefile oldfile   getfile ckey  true
if   privrename currentfile  oldfile
throw standardexception
newexception sqlstate rawstore_error_renaming_file
currentfile  oldfile
// now replace current container file with the new file.
if   privrename newfile  currentfile
throw standardexception
newexception sqlstate rawstore_error_renaming_file
newfile  currentfile
return oldfile
/**
* get file handle to a container file that is used to keep
* temporary versions of the container file.
*/
private storagefile getfile containerkey containerid  boolean old
string path   getfilepath containerid  old
return storagefactory newstoragefile getfilepath containerid
old
/**
* get path to a container file that is used to keep temporary versions of
* the container file.
*/
private string getfilepath containerkey containerid  boolean old
stringbuffer sb   new stringbuffer
sb append containerid getsegmentid
sb append storagefactory getseparator
sb append old ?
sb append long tohexstring containerid getcontainerid
sb append
return sb tostring
private boolean isoldcontainerfile string filename
// all old versions of the conatainer files
// start with prefix "o" and ends with ".dat"
if  filename startswith       filename endswith
return true
else
return false
private storagefile getfile string ctrfilename
long segmentid   0
stringbuffer sb   new stringbuffer
sb append segmentid
sb append storagefactory getseparator
sb append ctrfilename
return storagefactory newstoragefile sb tostring
/* restore the contaier to the state it was before
* it was encrypted with new encryption key. this function is
* called during undo of the encryptcontaineroperation log record
* incase of a error/crash before database was successfuly configured with
* new encryption properties.
* @param ckey the key of the container that needs to be restored.
* @exception standardexception standard derby error policy
*/
void restorecontainer containerkey containerid
throws standardexception
// get rid of the container entry from conatainer cache,
// this will make sure there are no file opens on the current
// container file.
if   datafactory getcontainercache   discard containerid
if  sanitymanager debug
sanitymanager throwassert
containerid
storagefile currentfile   datafactory getcontainerpath containerid
false
storagefile oldfile   getfile containerid  true
storagefile newfile   getfile containerid  false
// if backup of the original container file exists, replace the
// container with the backup copy.
if  privexists oldfile
if  privexists currentfile
// rename the current container file to be the new file.
if   privrename currentfile  newfile
throw standardexception
newexception sqlstate rawstore_error_renaming_file
currentfile  newfile
if   privrename oldfile  currentfile
throw standardexception
newexception sqlstate rawstore_error_renaming_file
oldfile  currentfile
// if the new copy of the container file exists, remove it.
if  privexists newfile
if   privdelete newfile
throw standardexception newexception
sqlstate unable_to_delete_file
newfile
/*
* remove all the old version (encrypted with old key or
* un-encrypted) of the containers stored in the data directory .
*
* @param inrecovery  <code> true </code>, if cleanup is
*                    happening during recovery.
* @exception standardexception standard derby error policy
*/
public void removeoldversionofcontainers boolean inrecovery
throws standardexception
if  inrecovery
// find the old version of the container files
// and delete them
string files   datafactory getcontainernames
if  files    null
// loop through all the files in seg0 and
// delete all old copies of the containers.
for  int i   files length 1  i >  0   i
// if it is a old version of the container file
// delete it.
if  isoldcontainerfile files
storagefile oldfile   getfile files
if   privdelete oldfile
throw standardexception newexception
sqlstate file_cannot_remove_file
oldfile
else
// delete all the old version of the containers.
for  int i   0   i < nooldfiles   i
if   privdelete oldfiles
throw standardexception newexception
sqlstate file_cannot_remove_file
oldfiles
private synchronized boolean privexists storagefile file
actioncode   storage_file_exists_action
actionstoragefile   file
object ret   accesscontroller doprivileged this
actionstoragefile   null
return   boolean  ret  booleanvalue
private synchronized boolean privdelete storagefile file
actioncode   storage_file_delete_action
actionstoragefile   file
object ret   accesscontroller doprivileged this
actionstoragefile   null
return   boolean  ret  booleanvalue
private synchronized boolean privrename storagefile fromfile
storagefile destfile
actioncode   storage_file_rename_action
actionstoragefile   fromfile
actiondeststoragefile   destfile
object ret   accesscontroller doprivileged this
actionstoragefile   null
actiondeststoragefile   null
return   boolean  ret  booleanvalue
// privilegedaction method
public object run
switch actioncode
case storage_file_exists_action
return reusefactory getboolean actionstoragefile exists
case storage_file_delete_action
return reusefactory getboolean actionstoragefile delete
case storage_file_rename_action
return reusefactory getboolean
actionstoragefile renameto actiondeststoragefile
return null