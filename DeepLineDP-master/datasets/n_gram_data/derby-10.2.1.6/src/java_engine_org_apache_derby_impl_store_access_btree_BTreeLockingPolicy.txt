/*
derby - class org.apache.derby.impl.store.access.btree.btreelockingpolicy
licensed to the apache software foundation (asf) under one or more
contributor license agreements.  see the notice file distributed with
this work for additional information regarding copyright ownership.
the asf licenses this file to you under the apache license, version 2.0
(the "license"); you may not use this file except in compliance with
the license.  you may obtain a copy of the license at
http://www.apache.org/licenses/license-2.0
unless required by applicable law or agreed to in writing, software
distributed under the license is distributed on an "as is" basis,
without warranties or conditions of any kind, either express or implied.
see the license for the specific language governing permissions and
limitations under the license.
*/
package org apache derby impl store access btree
import org apache derby iapi error standardexception
import org apache derby iapi store access conglomerate transactionmanager
import org apache derby iapi store access conglomeratecontroller
import org apache derby iapi store raw fetchdescriptor
import org apache derby iapi store raw page
import org apache derby iapi store raw recordhandle
import org apache derby iapi types datavaluedescriptor
import org apache derby iapi types rowlocation
/**
the generic.btree directory wants to know as little about locking as possible,
in order to make the code usuable by multiple implementations.  but the
generic code will make calls to abstract lock calls implemented by concrete
btree implementations.  concrete implementations like b2i understand locking,
and needs informatation specific to the implementation to make the lock calls.
<p>
this class is created and owned by the concrete application, but is passed
into and returned from the generic code when lock calls are made.
concrete implementations which do not need lock calls can just pass a null
pointer where a btreelockingpolicy is requested.
<p>
there are 2 types of lock interfaces, lockscan*() and locknonscan*().
<p>
the lockscan*() interfaces assume that the caller gets a "scan lock" on the
page before requesting any row locks on the page.  this is either done by
makeing a lockscan() call followed by row lock requests, or it can be done
in one operation by calling lockscanrow() and requesting the scan lock be
obtained before getting the row lock.  upon return from these interfaces
the row lock requested is guaranteed to have been obtained on the correct
key for the row requested.  these interfaces handle the special case of
unique indexes where the rowlocation can change while waiting on the lock
(see implementation for details), basically the lock is retryed after waiting
if the rowlocation has changed.
<p>
the locknonscan*() interfaces assume that no "scan lock" exists.  if these
routines return that the latch was released while waiting to obtain the
lock, then the caller must requeue the lock request after taking appropriate
action.  this action usually involves researching the tree to make sure
that the correct key is locked with latches held.  because no scan lock is
held the original row could have disappeared from the table.  these interfaces
do not handle the special case of unique indexes where the rowlocation can
change while waiting on the lock, as the row may disappear when the latch
is released to wait on the lock - thus it is necessary that the caller retry
the lock if the interface returns that the latch was released.
**/
public interface btreelockingpolicy
/**************************************************************************
* abstract protected lockscan*() locking methods of btree:
*     lockscan                 - lock the scan page
*     lockscanforreclaimspace  - lock page for reclaiming deleted rows.
*     lockscanrow              - lock row and possibly the scan page
*     unlockscan               - unlock the scan page
*     unlockscanrecordafterread- unlock the scan record
**************************************************************************
*/
/**
* lock the current leaf page.
* <p>
* logically lock the record id's on a leaf page.  this protocol is used
* by splits/row purgers and scans to coordinate between themselves.
* <p>
* anyone who wants to either move rows off of a btree page or, purge
* them from existence must first call this routine with "forupdate"
* true.  this will result in a lock request which will block on other
* processes which cannot work if rows move off the page or disappear.
* it is expected that the this routine will only be called for update
* by very short term internal transactions which will commit immediately
* after doing their work and give up the exclusive lock quickly.
* <p>
* currently scans can position themselves in one of 2 ways, either by
* saving the record handle of a record when they give up the latch on
* the page, or by saving the entire row.  if they save the record handle
* then they must call this routine with "forupdate" false, to get a
* lock which will protect the record handle they are using from moving
* off the page or disapearing.  this is also why aborts of inserts must
* be done by marking the rows deleted, rather than purging them.
* it is expected that scanner's will release this lock once they move
* off the page they are looking at.  they do this by calling
* unlockscan().
* <p>
* this lock enforces the same lock/latch protocol as btree row locks.
* on return the lock has been obtained.  return status indicates if the
* lock was waited for, which will mean a latch(s) were dropped while
* waiting.
* in general a false status means that the caller will either have
* to research the tree unless some protocol has been implemented that
* insures that the row will not have moved while the latch was dropped.
* <p>
* this routine requests a special row on the record_id_protection_handle
* row id.  if the lock is granted the routine will return true.
* if the lock cannot be granted nowait, then the routine will release
* the latch on "current_leaf" and "aux_control_row" (if
* aux_control_row is non-null), and then it will request a wait lock on
* the row.
*
* @param current_leaf      the lock is associated with this page in the
*                          btree.  this control row is unlatched if the
*                          routine has to wait on the lock.
* @param aux_control_row   if non-null, this control row is unlatched
*                          if the routine has to wait on the lock.
* @param forupdate         whether to wait for lock.
* @param lock_operation    for what operation are we requesting the lock,
*                          this should be one of the following 4 options:
*                          lock_read [read lock],
*                          (lock_ins | lock_upd) [ lock for insert],
*                          (lock_insert_prevkey | lock_upd) [lock for
*                          previous key to insert],
*                          (lock_upd) [lock for delete or replace]
*
* @exception  standardexception  standard exception policy.
**/
abstract public boolean lockscan
leafcontrolrow          current_leaf
controlrow              aux_control_row
boolean                 forupdate
int                     lock_operation
throws standardexception
/**
* lock a control row page for reclaiming deleted rows.
* <p>
* when reclaiming deleted rows during split need to get an exclusive
* scan lock on the page, which will mean there are no other scans
* positioned on the page.  if there are other scans positioned, just
* give up on reclaiming space now.
*
* @return true if lock was granted nowait, else false and not lock was
*         granted.
*
* @exception  standardexception  standard exception policy.
**/
abstract public boolean lockscanforreclaimspace
leafcontrolrow          current_leaf
throws standardexception
/**
* lock a btree row to determine if it is a committed deleted row.
* <p>
* request an exclusive lock on the row located at the given slot, nowait.
* return true if the lock is granted, otherwise false.
* <p>
*
* @param open_btree        the conglomerate we are locking.
* @param leaf              the leaf page with the row to lock.
* @param template          empty full template row, to read row into.
* @param slot_no           the slot of row on "current_leaf"
*
* @exception  standardexception  standard exception policy.
**/
abstract public boolean lockscancommitteddeletedrow
openbtree               open_btree
leafcontrolrow          leaf
datavaluedescriptor   template
fetchdescriptor         lock_fetch_desc
int                     slot_no
throws standardexception
/**
* lock a row as part of doing the scan.
* <p>
* lock the row at the given slot (or the previous row if slot is 0).
* get the scan lock on the page if "request_scan_lock" is true.
* <p>
* if this routine returns true all locks were acquired while maintaining
* the latch on leaf.  if this routine returns false, locks may or may
* not have been acquired, and the routine should be called again after
* the client has researched the tree to reget the latch on the
* appropriate page.
* (p>
* as a side effect stores the value of the record handle of the current
* scan lock.
*
* @return whether locks were acquired without releasing latch on leaf.
*
* @param open_btree        the open_btree to associate latches with -
*                          used if routine has to scan backward.
* @param btree             the conglomerate info.
* @param pos               description of position of row to lock.
* @param request_scan_lock whether to request the page scan lock, should
*                          only be requested once per page in the scan.
* @param lock_template     a scratch area to use to read in rows.
* @param previous_key_lock is this a previous key lock call?
* @param forupdate         is the scan for update or for read only.
* @param lock_operation    for what operation are we requesting the lock,
*                          this should be one of the following 4 options:
*                          lock_read [read lock],
*                          (lock_ins | lock_upd) [ lock for insert],
*                          (lock_insert_prevkey | lock_upd) [lock for
*                          previous key to insert],
*                          (lock_upd) [lock for delete or replace]
*
* @exception  standardexception  standard exception policy.
**/
abstract public boolean lockscanrow
openbtree               open_btree
btree                   btree
btreerowposition        pos
boolean                 request_scan_lock
fetchdescriptor         lock_fetch_desc
datavaluedescriptor   lock_template
rowlocation             lock_row_loc
boolean                 previous_key_lock
boolean                 forupdate
int                     lock_operation
throws standardexception
/**
* release read lock on a row.
*
* @param pos               data structure that defines the current position
*                          in the scan to be unlocked.
*
* @param forupdate         is the scan for update or for read only.
*
* @exception  standardexception  standard exception policy.
**/
abstract public void unlockscanrecordafterread
btreerowposition        pos
boolean                 forupdate
throws standardexception
/**
* release the lock gotten by calling lockscan.  this call can only be
* made to release read scan locks, write scan locks must be held until
* end of transaction.
* <p>
*
* @param page_number   page number of page that lockscan was called on.
*
**/
abstract public void unlockscan long page_number
/**************************************************************************
* abstract protected locknonscan*() locking methods of btree:
*
*     locknonscanpreviousrow   - lock the row previous to the current
*     locknonscanrow           - lock the input row
*     locknonscanrowonpage     - lock the given row on the page.
**************************************************************************
*/
/**
* lock the previous key.
* <p>
* given the current latched page and slot number, lock the logically
* previous key in the table.  there are 3 cases:
* <p>
* slotnumber > 1                       - just lock (slotnumber - 1)
* (slotnumber == 1) && (leftmost leaf) - this is the first key in the
*                                        table, so lock a "magic" firstkey.
* (slotnumber == 1) && !(leftmost leaf)- traverse left in the tree looking
*                                        for a previous key.
* <p>
* on successful return from this routine appropriate locking will have
* been done.  all locks and latches are requested nowait, if any
* lock/latch cannot be granted this routine releases the current_leaf
* latch and any latches it may have acquired and returns "false."
* <p>
* all extra latches that may have been gotten will have been released.
* <p>
* this routine will find the "previous row" to the (current_leaf,
* current_slot), walking left in the tree as necessary, and first request
* the lock on that row nowait.  if that lock can not be granted,
* then it will release all latches that it has acquired up to that point
* including the latched current_leaf passed into the routine, and request
* the lock wait.  once the lock has been granted the routine will return
* and it is up to the caller to research the tree to find where the
* row may have ended up.
* <p>
* if routine returns true, lock was granted nowait, current leaf
* remains latched, and was never unlatched.  if routine returns false,
* lock was granted wait, current leaf is not latched, row may have
* moved in the btree so caller must research to find the row.
*
*
* @param btree             the conglomerate we are locking.
* @param current_leaf      latched current leaf where "current" key is.
* @param current_slot      the slot of row on "current_leaf"
* @param lock_template     empty full template row, to read row into.
* @param open_btree        the open_btree to associate latches with -
*                          used if routine has to scan backward.
* @param lock_operation    for what operation are we requesting the lock,
*                          this should be one of the following 4 options:
*                          lock_read [read lock],
*                          (lock_ins | lock_upd) [ lock for insert],
*                          (lock_insert_prevkey | lock_upd) [lock for
*                          previous key to insert],
*                          (lock_upd) [lock for delete or replace]
* @param lock_duration     for what duration should the lock be held,
*                          if instant_duration, then the routine will
*                          guarantee that lock was acquired while holding
*                          the latch, but then immediately release the
*                          lock.  if commit_duration or manual_duration
*                          then the lock be held when routine returns
*                          successfully.
*
* @exception  standardexception  standard exception policy.
**/
abstract public boolean locknonscanpreviousrow
btree                   btree
leafcontrolrow          current_leaf
int                     current_slot
fetchdescriptor         lock_fetch_desc
datavaluedescriptor   lock_template
rowlocation             lock_row_loc
openbtree               open_btree
int                     lock_operation
int                     lock_duration
throws standardexception
/**
* lock a btree row (row in memory).  meant to be used if caller
* has the entire row objectified.
* <p>
* lock a btree row, enforcing the standard lock/latch protocol.
* on return the row is locked.  return status indicates if the lock
* was waited for, which will mean a latch was dropped while waiting.
* in general a false status means that the caller will either have
* to research the tree unless some protocol has been implemented that
* insures that the row will not have moved while the latch was dropped.
* <p>
* this routine request a row lock nowait on the in-memory row
* "current_row.".  if the lock is granted the routine will return true.
* if the lock cannot be granted nowait, then the routine will release
* the latch on "current_leaf" (if current_leaf is non-null) and
* "aux_leaf" (if aux_leaf is non-null), and then it will request a wait
* lock on the row.
*
*
* @param btree             the conglomerate we are locking.
* @param current_leaf      if non-null, this leaf is unlatched if the
*                          routine has to wait on the lock.
* @param aux_leaf          if non-null, this leaf is unlatched if the
*                          routine has to wait on the lock.
* @param current_row       in memory, objectified "current" row.
* @param lock_operation    for what operation are we requesting the lock,
*                          this should be one of the following 4 options:
*                          lock_read [read lock],
*                          (lock_ins | lock_upd) [ lock for insert],
*                          (lock_insert_prevkey | lock_upd) [lock for
*                          previous key to insert],
*                          (lock_upd) [lock for delete or replace]
*
* @exception  standardexception  standard exception policy.
**/
abstract public boolean locknonscanrow
btree                   btree
leafcontrolrow          current_leaf
leafcontrolrow          aux_leaf
datavaluedescriptor   current_row
int                     lock_operation
throws standardexception
/**
* lock the row at the given slot.
* <p>
* if this routine returns true all locks were acquired while maintaining
* the latch on leaf.  if this routine returns false, locks may or may
* not have been acquired, and the routine should be called again after
* the client has researched the tree to reget the latch on the
* appropriate page.
*
* @return whether locks were acquired without releasing latch on leaf.
*
* @param btree             the conglomerate info.
* @param leaf              the control row of the current leaf to lock.
* @param slot              the slot position of the row to lock.
* @param lock_template     a scratch area to use to read in rows.
* @param lock_operation    for what operation are we requesting the lock,
*                          this should be one of the following 4 options:
*                          lock_read [read lock],
*                          (lock_ins | lock_upd) [ lock for insert],
*                          (lock_insert_prevkey | lock_upd) [lock for
*                          previous key to insert],
*                          (lock_upd) [lock for delete or replace]
*
* @exception  standardexception  standard exception policy.
**/
abstract public boolean locknonscanrowonpage
btree                   btree
leafcontrolrow          leaf
int                     slot
fetchdescriptor         lock_fetch_desc
datavaluedescriptor   lock_template
rowlocation             lock_row_loc
int                     lock_operation
throws standardexception