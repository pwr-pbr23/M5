/**
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hive common
import java io ioexception
import java net uri
import java util bitset
import java util list
import org apache hadoop conf configuration
import org apache hadoop fs filestatus
import org apache hadoop fs filesystem
import org apache hadoop fs path
import org apache hadoop util shell shellcommandexecutor
/**
* collection of file manipulation utilities common across hive.
*/
public final class fileutils
/**
* variant of path.makequalified that qualifies the input path against the default file system
* indicated by the configuration
*
* this does not require a filesystem handle in most cases - only requires the filesystem uri.
* this saves the cost of opening the filesystem - which can involve rpcs - as well as cause
* errors
*
* @param path
*          path to be fully qualified
* @param conf
*          configuration file
* @return path qualified relative to default file system
*/
public static path makequalified path path  configuration conf  throws ioexception
if   path isabsolute
// in this case we need to get the working directory
// and this requires a filesystem handle. so revert to
// original method.
return path makequalified filesystem get conf
uri fsuri   filesystem getdefaulturi conf
uri pathuri   path touri
string scheme   pathuri getscheme
string authority   pathuri getauthority
// validate/fill-in scheme and authority. this follows logic
// identical to filesystem.get(uri, conf) - but doesn't actually
// obtain a file system handle
if  scheme    null
// no scheme - use default file system uri
scheme   fsuri getscheme
authority   fsuri getauthority
if  authority    null
authority
else
if  authority    null
// no authority - use default one if it applies
if  scheme equals fsuri getscheme       fsuri getauthority      null
authority   fsuri getauthority
else
authority
return new path scheme  authority  pathuri getpath
private fileutils
// prevent instantiation
public static string makepartname list<string> partcols  list<string> vals
return makepartname partcols  vals  null
/**
* makes a valid partition name.
* @param partcols the partition keys' names
* @param vals the partition values
* @param defaultstr
*         the default name given to a partition value if the respective value is empty or null.
* @return an escaped, valid partition name.
*/
public static string makepartname list<string> partcols  list<string> vals
string defaultstr
stringbuilder name   new stringbuilder
for  int i   0  i < partcols size    i
if  i > 0
name append path separator
name append escapepathname  partcols get i   tolowercase    defaultstr
name append
name append escapepathname vals get i   defaultstr
return name tostring
// note: this is for generating the internal path name for partitions. users
// should always use the metastore api to get the path name for a partition.
// users should not directly take partition values and turn it into a path
// name by themselves, because the logic below may change in the future.
//
// in the future, it's ok to add new chars to the escape list, and old data
// won't be corrupt, because the full path name in metastore is stored.
// in that case, hive will continue to read the old data, but when it creates
// new partitions, it will use new names.
static bitset chartoescape   new bitset 128
static
for  char c   0  c <    c
chartoescape set c
/**
* ascii 01-1f are http control characters that need to be escaped.
* \u000a and \u000d are \n and \r, respectively.
*/
char clist   new char
for  char c   clist
chartoescape set c
static boolean needsescaping char c
return c >  0    c < chartoescape size      chartoescape get c
public static string escapepathname string path
return escapepathname path  null
/**
* escapes a path name.
* @param path the path to escape.
* @param defaultpath
*          the default name for the path, if the given path is empty or null.
* @return an escaped path name.
*/
public static string escapepathname string path  string defaultpath
// __hive_default_null__ is the system default value for null and empty string.
// todo: we should allow user to specify default partition or hdfs file location.
if  path    null    path length      0
if  defaultpath    null
//previously, when path is empty or null and no default path is specified,
// __hive_default_partition__ was the return value for escapepathname
return
else
return defaultpath
stringbuilder sb   new stringbuilder
for  int i   0  i < path length    i
char c   path charat i
if  needsescaping c
sb append
sb append string format     int  c
else
sb append c
return sb tostring
public static string unescapepathname string path
stringbuilder sb   new stringbuilder
for  int i   0  i < path length    i
char c   path charat i
if  c         i   2 < path length
int code    1
try
code   integer valueof path substring i   1  i   3   16
catch  exception e
code    1
if  code >  0
sb append  char  code
i    2
continue
sb append c
return sb tostring
/**
* recursively lists status for all files starting from a particular directory (or individual file
* as base case).
*
* @param fs
*          file system
*
* @param filestatus
*          starting point in file system
*
* @param results
*          receives enumeration of all files found
*/
public static void liststatusrecursively filesystem fs  filestatus filestatus
list<filestatus> results  throws ioexception
if  filestatus isdir
for  filestatus stat   fs liststatus filestatus getpath
liststatusrecursively fs  stat  results
else
results add filestatus
/**
* archive all the files in the inputfiles into outputfile
*
* @param inputfiles
* @param outputfile
* @throws ioexception
*/
public static void tar string parentdir  string inputfiles  string outputfile
throws ioexception
stringbuffer tarcommand   new stringbuffer
tarcommand append     parentdir
tarcommand append
tarcommand append     outputfile
for  int i   0  i < inputfiles length  i
tarcommand append     inputfiles
string shellcmd          tarcommand tostring
shellcommandexecutor shexec   new shellcommandexecutor shellcmd
shexec execute
int exitcode   shexec getexitcode
if  exitcode    0
throw new ioexception     outputfile
exitcode