/**
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hive serde2 lazybinary
import java util arrays
import java util linkedhashmap
import java util map
import org apache commons logging log
import org apache commons logging logfactory
import org apache hadoop hive serde2 lazy bytearrayref
import org apache hadoop hive serde2 lazybinary lazybinaryutils recordinfo
import org apache hadoop hive serde2 lazybinary lazybinaryutils vint
import org apache hadoop hive serde2 lazybinary objectinspector lazybinarymapobjectinspector
import org apache hadoop hive serde2 objectinspector mapobjectinspector
import org apache hadoop hive serde2 objectinspector primitiveobjectinspector
/**
* lazybinarymap is serialized as follows: start a b c b c b c end bytes[] ->
* |--------|---|---|---|---| ... |---|---|
*
* section a is the null-bytes. suppose the map has n key-value pairs, then
* there are (n*2+7)/8 bytes used as null-bytes. each bit corresponds to a key
* or a value and it indicates whether that key or value is null (0) or not null
* (1).
*
* after a, all the bytes are actual serialized data of the map, which are
* key-value pairs. b represent the keys and c represent the values. each of
* them is again a lazybinaryobject.
*
*/
public class lazybinarymap extends
lazybinarynonprimitive<lazybinarymapobjectinspector>
private static log log   logfactory getlog lazybinarymap class getname
/**
* whether the data is already parsed or not.
*/
boolean parsed
/**
* the size of the map. only valid when the data is parsed. -1 when the map is
* null.
*/
int mapsize   0
/**
* the beginning position and length of key[i] and value[i]. only valid when
* the data is parsed.
*/
int keystart
int keylength
int valuestart
int valuelength
/**
* whether valueobjects[i]/keyobjects[i] is initialized or not.
*/
boolean keyinited
boolean valueinited
/**
* whether valueobjects[i]/keyobjects[i] is null or not this could not be
* inferred from the length of the object. in particular, a 0-length string is
* not null.
*/
boolean keyisnull
boolean valueisnull
/**
* the keys are stored in an array of lazyprimitives.
*/
lazybinaryprimitive<?  ?> keyobjects
/**
* the values are stored in an array of lazyobjects. value[index] will start
* from keyend[index] + 1, and ends before keystart[index+1] - 1.
*/
lazybinaryobject valueobjects
protected lazybinarymap lazybinarymapobjectinspector oi
super oi
/**
* set the row data for this lazybinarymap.
*
* @see lazybinaryobject#init(bytearrayref, int, int)
*/
@override
public void init bytearrayref bytes  int start  int length
super init bytes  start  length
parsed   false
/**
* adjust the size of arrays: keystart, keylength valuestart, valuelength
* keyinited, keyisnull valueinited, valueisnull.
*/
protected void adjustarraysize int newsize
if  keystart    null    keystart length < newsize
keystart   new int
keylength   new int
valuestart   new int
valuelength   new int
keyinited   new boolean
keyisnull   new boolean
valueinited   new boolean
valueisnull   new boolean
keyobjects   new lazybinaryprimitive<?  ?>
valueobjects   new lazybinaryobject
boolean nullmapkey   false
vint vint   new lazybinaryutils vint
recordinfo recordinfo   new lazybinaryutils recordinfo
/**
* parse the byte[] and fill keystart, keylength, keyisnull valuestart,
* valuelength and valueisnull.
*/
private void parse
byte bytes   this bytes getdata
// get the vint that represents the map size
lazybinaryutils readvint bytes  start  vint
mapsize   vint value
if  0    mapsize
parsed   true
return
// adjust arrays
adjustarraysize mapsize
// find out the null-bytes
int mapbytestart   start   vint length
int nullbytecur   mapbytestart
int nullbyteend   mapbytestart    mapsize   2   7    8
int lastelementbyteend   nullbyteend
// parsing the keys and values one by one
for  int i   0  i < mapsize  i
// parse a key
keyisnull   true
if   bytes    1 <<   i   2  % 8       0
keyisnull   false
lazybinaryutils checkobjectbyteinfo   mapobjectinspector  oi
getmapkeyobjectinspector    bytes  lastelementbyteend  recordinfo
keystart   lastelementbyteend   recordinfo elementoffset
keylength   recordinfo elementsize
lastelementbyteend   keystart   keylength
else if   nullmapkey
nullmapkey   true
log warn
// parse a value
valueisnull   true
if   bytes    1 <<   i   2   1  % 8       0
valueisnull   false
lazybinaryutils checkobjectbyteinfo   mapobjectinspector  oi
getmapvalueobjectinspector    bytes  lastelementbyteend
recordinfo
valuestart   lastelementbyteend   recordinfo elementoffset
valuelength   recordinfo elementsize
lastelementbyteend   valuestart   valuelength
// move onto the next null byte
if  3     i % 4
nullbytecur
arrays fill keyinited  0  mapsize  false
arrays fill valueinited  0  mapsize  false
parsed   true
/**
* get the value object with the index without checking parsed.
*
* @param index
*          the index into the array starting from 0
*/
private lazybinaryobject uncheckedgetvalue int index
if  valueisnull
return null
if   valueinited
valueinited   true
if  valueobjects    null
valueobjects   lazybinaryfactory
createlazybinaryobject   mapobjectinspector  oi
getmapvalueobjectinspector
valueobjects init bytes  valuestart  valuelength
return valueobjects
/**
* get the value in the map for the key.
*
* if there are multiple matches (which is possible in the serialized format),
* only the first one is returned.
*
* the most efficient way to get the value for the key is to serialize the key
* and then try to find it in the array. we do linear search because in most
* cases, user only wants to get one or two values out of the map, and the
* cost of building up a hashmap is substantially higher.
*
* @param key
*          the key object that we are looking for.
* @return the corresponding value object, or null if not found
*/
public object getmapvalueelement object key
if   parsed
parse
// search for the key
for  int i   0  i < mapsize  i
lazybinaryprimitive<?  ?> lazykeyi   uncheckedgetkey i
if  lazykeyi    null
continue
// getwritableobject() will convert lazyprimitive to actual primitive
// writable objects.
object keyi   lazykeyi getwritableobject
if  keyi    null
continue
if  keyi equals key
// got a match, return the value
lazybinaryobject v   uncheckedgetvalue i
return v    null ? v   v getobject
return null
/**
* get the key object with the index without checking parsed.
*
* @param index
*          the index into the array starting from 0
*/
private lazybinaryprimitive<?  ?> uncheckedgetkey int index
if  keyisnull
return null
if   keyinited
keyinited   true
if  keyobjects    null
// keys are always primitive
keyobjects   lazybinaryfactory
createlazybinaryprimitiveclass  primitiveobjectinspector    mapobjectinspector  oi
getmapkeyobjectinspector
keyobjects init bytes  keystart  keylength
return keyobjects
/**
* cachedmap is reused for different calls to getmap(). but each lazybinarymap
* has a separate cachedmap so we won't overwrite the data by accident.
*/
linkedhashmap<object  object> cachedmap
/**
* return the map object representing this lazybinarymap. note that the
* keyobjects will be writable primitive objects.
*
* @return the map object
*/
public map<object  object> getmap
if   parsed
parse
if  cachedmap    null
// use linkedhashmap to provide deterministic order
cachedmap   new linkedhashmap<object  object>
else
cachedmap clear
// go through each element of the map
for  int i   0  i < mapsize  i
lazybinaryprimitive<?  ?> lazykey   uncheckedgetkey i
if  lazykey    null
continue
object key   lazykey getobject
// do not overwrite if there are duplicate keys
if  key    null     cachedmap containskey key
lazybinaryobject lazyvalue   uncheckedgetvalue i
object value    lazyvalue    null ? null   lazyvalue getobject
cachedmap put key  value
return cachedmap
/**
* get the size of the map represented by this lazybinarymap.
*
* @return the size of the map
*/
public int getmapsize
if   parsed
parse
return mapsize