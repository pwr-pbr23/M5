/**
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hive ql optimizer index
import java io serializable
import java util iterator
import java util linkedhashmap
import java util list
import java util map
import java util stack
import org apache hadoop hive ql exec columninfo
import org apache hadoop hive ql exec filesinkoperator
import org apache hadoop hive ql exec filteroperator
import org apache hadoop hive ql exec groupbyoperator
import org apache hadoop hive ql exec operator
import org apache hadoop hive ql exec rowschema
import org apache hadoop hive ql exec selectoperator
import org apache hadoop hive ql lib node
import org apache hadoop hive ql lib nodeprocessor
import org apache hadoop hive ql lib nodeprocessorctx
import org apache hadoop hive ql parse semanticexception
import org apache hadoop hive ql plan aggregationdesc
import org apache hadoop hive ql plan exprnodecolumndesc
import org apache hadoop hive ql plan exprnodeconstantdesc
import org apache hadoop hive ql plan exprnodedesc
import org apache hadoop hive ql plan exprnodegenericfuncdesc
import org apache hadoop hive ql plan filterdesc
import org apache hadoop hive ql plan groupbydesc
/**
* factory of methods used by {@link rewritegbusingindex}
* to determine if the rewrite optimization can be applied to the input query.
*
*/
public final class rewritecanapplyprocfactory
private static rewritecanapplyctx canapplyctx   null
private rewritecanapplyprocfactory
//this prevents the class from getting instantiated
/**
* check for conditions in filteroperator that do not meet rewrite criteria.
*/
private static class checkfilterproc implements nodeprocessor
public object process node nd  stack<node> stack  nodeprocessorctx ctx
object    nodeoutputs  throws semanticexception
filteroperator operator    filteroperator nd
canapplyctx    rewritecanapplyctx ctx
filterdesc conf    filterdesc operator getconf
//the filter operator should have a predicate of exprnodegenericfuncdesc type.
//this represents the comparison operator
exprnodegenericfuncdesc oldengfd    exprnodegenericfuncdesc  conf getpredicate
if oldengfd    null
canapplyctx setwhrclausecolsfetchexception true
//the predicate should have valid left and right columns
list<string> collist   oldengfd getcols
if collist    null    collist size      0
canapplyctx setwhrclausecolsfetchexception true
//add the predicate columns to rewritecanapplyctx's predcolrefs list to check later
//if index keys contain all filter predicate columns and vice-a-versa
for  string col   collist
canapplyctx getpredicatecolumnslist   add col
return null
public static checkfilterproc canapplyonfilteroperator
return new checkfilterproc
/**
* check for conditions in groupbyoperator that do not meet rewrite criteria.
*
*/
private static class checkgroupbyproc implements nodeprocessor
public object process node nd  stack<node> stack  nodeprocessorctx ctx
object    nodeoutputs  throws semanticexception
groupbyoperator operator    groupbyoperator nd
canapplyctx    rewritecanapplyctx ctx
//for each group-by clause in query, only one groupbyoperator of the
//gby-rs-gby sequence is stored in  getgroupoptoinputtables
//we need to process only this operator
//also, we do not rewrite for cases when same query branch has multiple group-by constructs
if canapplyctx getparsecontext   getgroupoptoinputtables   containskey operator
canapplyctx isqueryhasgroupby
canapplyctx setqueryhasgroupby true
groupbydesc conf    groupbydesc  operator getconf
list<aggregationdesc> aggrlist   conf getaggregators
if aggrlist    null    aggrlist size   > 0
for  aggregationdesc aggregationdesc   aggrlist
canapplyctx setaggfunccnt canapplyctx getaggfunccnt     1
//in the current implementation, we do not support more than 1 agg funcs in group-by
if canapplyctx getaggfunccnt   > 1
return false
string aggfunc   aggregationdesc getgenericudafname
if     equals aggfunc
canapplyctx setaggfuncisnotcount true
else
list<exprnodedesc> para   aggregationdesc getparameters
//for a valid aggregation, it needs to have non-null parameter list
if para    null
canapplyctx setaggfunccolsfetchexception true
else if para size      0
//count(*) case
canapplyctx setcountonallcols true
canapplyctx setaggfunction
else
assert para size    1
for int i 0  i< para size    i
exprnodedesc expr   para get i
if expr instanceof exprnodecolumndesc
//add the columns to rewritecanapplyctx's selectcolumnslist list
//to check later if index keys contain all select clause columns
//and vice-a-versa. we get the select column 'actual' names only here
//if we have a agg func along with group-by
//selectoperator has internal names in its collist data structure
canapplyctx getselectcolumnslist   add
exprnodecolumndesc  expr  getcolumn
//add the columns to rewritecanapplyctx's aggfunccollist list to check later
//if columns contained in agg func are index key columns
canapplyctx getaggfunccollist   add
exprnodecolumndesc  expr  getcolumn
canapplyctx setaggfunction
exprnodecolumndesc  expr  getcolumn
else if expr instanceof exprnodeconstantdesc
//count(1) case
canapplyctx setcountofone true
canapplyctx setaggfunction
//we need to have non-null group-by keys for a valid group-by operator
list<exprnodedesc> keylist   conf getkeys
if keylist    null    keylist size      0
canapplyctx setgbykeysfetchexception true
for  exprnodedesc expr   keylist
checkexpression expr
return null
private void checkexpression exprnodedesc expr
if expr instanceof exprnodecolumndesc
//add the group-by keys to rewritecanapplyctx's gbkeynamelist list to check later
//if all keys are from index columns
canapplyctx getgbkeynamelist   addall expr getcols
else if expr instanceof exprnodegenericfuncdesc
exprnodegenericfuncdesc funcexpr    exprnodegenericfuncdesc expr
list<exprnodedesc> childexprs   funcexpr getchildexprs
for  exprnodedesc childexpr   childexprs
if childexpr instanceof exprnodecolumndesc
canapplyctx getgbkeynamelist   addall expr getcols
canapplyctx getselectcolumnslist   add   exprnodecolumndesc  childexpr  getcolumn
else if childexpr instanceof exprnodegenericfuncdesc
checkexpression childexpr
public static checkgroupbyproc canapplyongroupbyoperator
return new checkgroupbyproc
/**
* check for conditions in selectoperator that do not meet rewrite criteria.
*/
private static class checkselectproc implements nodeprocessor
public object process node nd  stack<node> stack  nodeprocessorctx ctx
object    nodeoutputs  throws semanticexception
selectoperator operator    selectoperator nd
canapplyctx    rewritecanapplyctx ctx
list<operator<? extends serializable>> childrenlist   operator getchildoperators
operator<? extends serializable> child   childrenlist get 0
if child instanceof filesinkoperator
map<string  string> internaltoalias   new linkedhashmap<string  string>
rowschema rs   operator getschema
//to get the internal to alias mapping
list<columninfo> sign   rs getsignature
for  columninfo columninfo   sign
internaltoalias put columninfo getinternalname    columninfo getalias
//if filteroperator predicate has internal column names,
//we need to retrieve the 'actual' column names to
//check if index keys contain all filter predicate columns and vice-a-versa
iterator<string> preditr   canapplyctx getpredicatecolumnslist   iterator
while preditr hasnext
string predcol   preditr next
string newpredcol
if internaltoalias get predcol     null
newpredcol   internaltoalias get predcol
canapplyctx getpredicatecolumnslist   remove predcol
canapplyctx getpredicatecolumnslist   add newpredcol
return null
public static checkselectproc canapplyonselectoperator
return new checkselectproc