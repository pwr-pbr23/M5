/**
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hive ql index
import java util arraylist
import java util hashmap
import java util hashset
import java util linkedhashmap
import java util list
import java util map
import java util set
import java util stack
import org apache hadoop hive ql exec exprnodeevaluator
import org apache hadoop hive ql exec exprnodeevaluatorfactory
import org apache hadoop hive ql exec functionregistry
import org apache hadoop hive ql exec udf
import org apache hadoop hive ql lib defaultgraphwalker
import org apache hadoop hive ql lib defaultruledispatcher
import org apache hadoop hive ql lib dispatcher
import org apache hadoop hive ql lib graphwalker
import org apache hadoop hive ql lib node
import org apache hadoop hive ql lib nodeprocessor
import org apache hadoop hive ql lib nodeprocessorctx
import org apache hadoop hive ql lib rule
import org apache hadoop hive ql parse semanticexception
import org apache hadoop hive ql plan exprnodecolumndesc
import org apache hadoop hive ql plan exprnodeconstantdesc
import org apache hadoop hive ql plan exprnodedesc
import org apache hadoop hive ql plan exprnodegenericfuncdesc
import org apache hadoop hive ql udf generic genericudf
import org apache hadoop hive serde2 objectinspector objectinspector
import org apache hadoop hive serde2 objectinspector objectinspectorutils
import org apache hadoop hive serde2 typeinfo typeinfofactory
import org apache hadoop hive ql udf generic genericudfbridge
import org apache commons logging log
import org apache commons logging logfactory
import org apache hadoop util reflectionutils
/**
* indexpredicateanalyzer decomposes predicates, separating the parts
* which can be satisfied by an index from the parts which cannot.
* currently, it only supports pure conjunctions over binary expressions
* comparing a column reference with a constant value.  it is assumed
* that all column aliases encountered refer to the same table.
*/
public class indexpredicateanalyzer
private static final log log   logfactory getlog indexpredicateanalyzer class getname
private set<string> udfnames
private set<string> allowedcolumnnames
public indexpredicateanalyzer
udfnames   new hashset<string>
/**
* registers a comparison operator as one which can be satisfied
* by an index search.  unless this is called, analyzepredicate
* will never find any indexable conditions.
*
* @param udfname name of comparison operator as returned
* by either {@link genericudfbridge#getudfname} (for simple udf's)
* or udf.getclass().getname() (for generic udf's).
*/
public void addcomparisonop string udfname
udfnames add udfname
/**
* clears the set of column names allowed in comparisons.  (initially, all
* column names are allowed.)
*/
public void clearallowedcolumnnames
allowedcolumnnames   new hashset<string>
/**
* adds a column name to the set of column names allowed.
*
* @param columnname name of column to be allowed
*/
public void allowcolumnname string columnname
if  allowedcolumnnames    null
clearallowedcolumnnames
allowedcolumnnames add columnname
/**
* analyzes a predicate.
*
* @param predicate predicate to be analyzed
*
* @param searchconditions receives conditions produced by analysis
*
* @return residual predicate which could not be translated to
* searchconditions
*/
public exprnodedesc analyzepredicate
exprnodedesc predicate
final list<indexsearchcondition> searchconditions
map<rule  nodeprocessor> oprules   new linkedhashmap<rule  nodeprocessor>
nodeprocessor nodeprocessor   new nodeprocessor
@override
public object process node nd  stack<node> stack
nodeprocessorctx procctx  object    nodeoutputs
throws semanticexception
// we can only push down stuff which appears as part of
// a pure conjunction:  reject or, case, etc.
for  node ancestor   stack
if  nd    ancestor
break
if   functionregistry isopand  exprnodedesc  ancestor
return nd
return analyzeexpr  exprnodedesc  nd  searchconditions  nodeoutputs
dispatcher disp   new defaultruledispatcher
nodeprocessor  oprules  null
graphwalker ogw   new defaultgraphwalker disp
arraylist<node> topnodes   new arraylist<node>
topnodes add predicate
hashmap<node  object> nodeoutput   new hashmap<node  object>
try
ogw startwalking topnodes  nodeoutput
catch  semanticexception ex
throw new runtimeexception ex
exprnodedesc residualpredicate    exprnodedesc  nodeoutput get predicate
return residualpredicate
private exprnodedesc analyzeexpr
exprnodedesc expr
list<indexsearchcondition> searchconditions
object    nodeoutputs
if    expr instanceof exprnodegenericfuncdesc
return expr
if  functionregistry isopand expr
assert nodeoutputs length    2
exprnodedesc residual1    exprnodedesc  nodeoutputs
exprnodedesc residual2    exprnodedesc  nodeoutputs
if  residual1    null
return residual2
if  residual2    null
return residual1
list<exprnodedesc> residuals   new arraylist<exprnodedesc>
residuals add residual1
residuals add residual2
return new exprnodegenericfuncdesc
typeinfofactory booleantypeinfo
functionregistry getgenericudfforand
residuals
string udfname
exprnodegenericfuncdesc funcdesc    exprnodegenericfuncdesc  expr
if  funcdesc getgenericudf   instanceof genericudfbridge
genericudfbridge func    genericudfbridge  funcdesc getgenericudf
udfname   func getudfname
else
udfname   funcdesc getgenericudf   getclass   getname
if   udfnames contains udfname
return expr
exprnodedesc child1   extractconstant  exprnodedesc  nodeoutputs
exprnodedesc child2   extractconstant  exprnodedesc  nodeoutputs
exprnodecolumndesc columndesc   null
exprnodeconstantdesc constantdesc   null
if   child1 instanceof exprnodecolumndesc
child2 instanceof exprnodeconstantdesc
// col <op> constant
columndesc    exprnodecolumndesc  child1
constantdesc    exprnodeconstantdesc  child2
else if   child2 instanceof exprnodecolumndesc
child1 instanceof exprnodeconstantdesc
// constant <op> col
columndesc    exprnodecolumndesc  child2
constantdesc    exprnodeconstantdesc  child1
if  columndesc    null
return expr
if  allowedcolumnnames    null
if   allowedcolumnnames contains columndesc getcolumn
return expr
searchconditions add
new indexsearchcondition
columndesc
udfname
constantdesc
expr
// we converted the expression to a search condition, so
// remove it from the residual predicate
return null
private exprnodedesc extractconstant exprnodedesc expr
if    expr instanceof exprnodegenericfuncdesc
return expr
exprnodeconstantdesc folded   foldconstant   exprnodegenericfuncdesc  expr
return folded    null ? expr   folded
private exprnodeconstantdesc foldconstant exprnodegenericfuncdesc func
genericudf udf   func getgenericudf
if   functionregistry isdeterministic udf     functionregistry isstateful udf
return null
try
// if the udf depends on any external resources, we can't fold because the
// resources may not be available at compile time.
if  udf instanceof genericudfbridge
udf internal   reflectionutils newinstance   genericudfbridge  udf  getudfclass    null
if  internal getrequiredfiles      null    internal getrequiredjars      null
return null
else
if  udf getrequiredfiles      null    udf getrequiredjars      null
return null
for  exprnodedesc child   func getchildexprs
if  child instanceof exprnodeconstantdesc
continue
else if  child instanceof exprnodegenericfuncdesc
if  foldconstant  exprnodegenericfuncdesc  child     null
continue
return null
exprnodeevaluator evaluator   exprnodeevaluatorfactory get func
objectinspector output   evaluator initialize null
object constant   evaluator evaluate null
object java   objectinspectorutils copytostandardjavaobject constant  output
return new exprnodeconstantdesc java
catch  exception e
return null
/**
* translates search conditions back to exprnodedesc form (as
* a left-deep conjunction).
*
* @param searchconditions (typically produced by analyzepredicate)
*
* @return exprnodedesc form of search conditions
*/
public exprnodedesc translatesearchconditions
list<indexsearchcondition> searchconditions
exprnodedesc expr   null
for  indexsearchcondition searchcondition   searchconditions
if  expr    null
expr   searchcondition getcomparisonexpr
continue
list<exprnodedesc> children   new arraylist<exprnodedesc>
children add expr
children add searchcondition getcomparisonexpr
expr   new exprnodegenericfuncdesc
typeinfofactory booleantypeinfo
functionregistry getgenericudfforand
children
return expr