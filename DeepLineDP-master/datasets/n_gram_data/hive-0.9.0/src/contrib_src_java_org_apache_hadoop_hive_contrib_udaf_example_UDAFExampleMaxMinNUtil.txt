/**
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hive contrib udaf example
import java util arraylist
import java util collections
import java util comparator
import java util list
import org apache hadoop hive ql exec udafevaluator
/**
* the utility class for udafmaxn and udafminn.
*/
public final class udafexamplemaxminnutil
/**
* this class stores the information during an aggregation.
*
* note that this class has to have a public constructor, so that hive can
* serialize/deserialize this class using reflection.
*/
public static class state
arraylist<double> a     this arraylist holds the max min n
int n     this is the n
/**
* the base class of the udafevaluator for udafmaxn and udafminn.
* we just need to override the getascending function to make it work.
*/
public abstract static class evaluator implements udafevaluator
private state state
public evaluator
state   new state
init
/**
* reset the state.
*/
public void init
state a   new arraylist<double>
state n   0
/**
*  returns true in udafmaxn, and false in udafminn.
*/
protected abstract boolean getascending
/**
* iterate through one row of original data.
* this function will update the internal max/min buffer if the internal buffer is not full,
* or the new row is larger/smaller than the current max/min n.
*/
public boolean iterate double o  int n
boolean ascending   getascending
state n   n
if  o    null
boolean doinsert   state a size   < n
if   doinsert
double last   state a get state a size   1
if  ascending
doinsert   o < last
else
doinsert   o > last
if  doinsert
binaryinsert state a  o  ascending
if  state a size   > n
state a remove state a size   1
return true
/**
* get partial aggregation results.
*/
public state terminatepartial
// this is sql standard - max_n of zero items should be null.
return state a size      0 ? null   state
/** two pointers are created to track the maximal elements in both o and maxnarray.
*  the smallest element is added into temparraylist
*  consider the sizes of o and maxnarray may be different.
*/
public boolean merge state o
if  o    null
state n   o n
state a   sortedmerge o a  state a  getascending    o n
return true
/**
* terminates the max n lookup and return the final result.
*/
public arraylist<double> terminate
// this is sql standard - return state.maxnarray, or null if the size is zero.
return state a size      0 ? null   state a
/**
* returns a comparator based on whether the order is ascending or not.
* has a dummy parameter to make sure generics can infer the type correctly.
*/
static <t extends comparable<t>> comparator<t> getcomparator boolean ascending  t dummy
comparator<t> comp
if  ascending
comp   new comparator<t>
public int compare t o1  t o2
return o1 compareto o2
else
comp   new comparator<t>
public int compare t o1  t o2
return o2 compareto o1
return comp
/**
* insert an element into an ascending/descending array, and keep the order.
* @param ascending
*            if true, the array is sorted in ascending order,
*            otherwise it is in descending order.
*
*/
static <t extends comparable<t>> void binaryinsert list<t> list  t value  boolean ascending
int position   collections binarysearch list  value  getcomparator ascending   t null
if  position < 0
position     position    1
list add position  value
/**
* merge two ascending/descending array and keep the first n elements.
* @param ascending
*            if true, the array is sorted in ascending order,
*            otherwise it is in descending order.
*/
static <t extends comparable<t>> arraylist<t> sortedmerge list<t> a1  list<t> a2
boolean ascending  int n
comparator<t> comparator   getcomparator ascending   t null
int n1   a1 size
int n2   a2 size
int p1   0     the current element in a1
int p2   0     the current element in a2
arraylist<t> output   new arraylist<t> n
while  output size   < n     p1 < n1    p2 < n2
if  p1 < n1
if  p2    n2    comparator compare a1 get p1   a2 get p2   < 0
output add a1 get p1
if  output size      n
break
if  p2 < n2
if  p1    n1    comparator compare a2 get p2   a1 get p1   < 0
output add a2 get p2
return output
// no instantiation.
private udafexamplemaxminnutil