/**
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hive ql optimizer
import java io serializable
import java util arraylist
import java util hashmap
import java util list
import java util map
import java util stack
import org apache hadoop hive conf hiveconf
import org apache hadoop hive ql context
import org apache hadoop hive ql exec abstractmapjoinoperator
import org apache hadoop hive ql exec operator
import org apache hadoop hive ql exec operatorfactory
import org apache hadoop hive ql exec selectoperator
import org apache hadoop hive ql exec task
import org apache hadoop hive ql exec taskfactory
import org apache hadoop hive ql exec unionoperator
import org apache hadoop hive ql lib node
import org apache hadoop hive ql lib nodeprocessor
import org apache hadoop hive ql lib nodeprocessorctx
import org apache hadoop hive ql optimizer genmrproccontext genmrmapjoinctx
import org apache hadoop hive ql optimizer genmrproccontext genmapredctx
import org apache hadoop hive ql optimizer unionproc unionproccontext
import org apache hadoop hive ql parse errormsg
import org apache hadoop hive ql parse parsecontext
import org apache hadoop hive ql parse semanticexception
import org apache hadoop hive ql plan filesinkdesc
import org apache hadoop hive ql plan mapjoindesc
import org apache hadoop hive ql plan mapredwork
import org apache hadoop hive ql plan planutils
import org apache hadoop hive ql plan tabledesc
/**
* operator factory for mapjoin processing.
*/
public final class mapjoinfactory
public static int getpositionparent abstractmapjoinoperator<? extends mapjoindesc> op  stack<node> stack
int pos   0
int size   stack size
assert size >  2    stack get size   1     op
operator<? extends serializable> parent    operator<? extends serializable>  stack
get size   2
list<operator<? extends serializable>> parop   op getparentoperators
pos   parop indexof parent
assert pos < parop size
return pos
/**
* tablescan followed by mapjoin.
*/
public static class tablescanmapjoin implements nodeprocessor
@override
public object process node nd  stack<node> stack  nodeprocessorctx procctx
object    nodeoutputs  throws semanticexception
abstractmapjoinoperator<mapjoindesc> mapjoin    abstractmapjoinoperator<mapjoindesc>  nd
genmrproccontext ctx    genmrproccontext  procctx
// find the branch on which this processor was invoked
int pos   getpositionparent mapjoin  stack
map<operator<? extends serializable>  genmapredctx> mapcurrctx   ctx
getmapcurrctx
genmapredctx mapredctx   mapcurrctx get mapjoin getparentoperators   get
pos
task<? extends serializable> currtask   mapredctx getcurrtask
mapredwork currplan    mapredwork  currtask getwork
operator<? extends serializable> currtopop   mapredctx getcurrtopop
string curraliasid   mapredctx getcurraliasid
operator<? extends serializable> reducer   mapjoin
hashmap<operator<? extends serializable>  task<? extends serializable>> optaskmap   ctx
getoptaskmap
task<? extends serializable> opmaptask   optaskmap get reducer
ctx setcurrtopop currtopop
ctx setcurraliasid curraliasid
ctx setcurrtask currtask
// if the plan for this reducer does not exist, initialize the plan
if  opmaptask    null
assert currplan getreducer      null
genmapredutils initmapjoinplan mapjoin  ctx  false  false  false  pos
else
// the current plan can be thrown away after being merged with the
// original plan
genmapredutils joinplan mapjoin  null  opmaptask  ctx  pos  false
false  false
currtask   opmaptask
ctx setcurrtask currtask
mapcurrctx put mapjoin  new genmapredctx ctx getcurrtask    ctx
getcurrtopop    ctx getcurraliasid
return null
/**
* reducesink followed by mapjoin.
*/
public static class reducesinkmapjoin implements nodeprocessor
@override
public object process node nd  stack<node> stack  nodeprocessorctx procctx
object    nodeoutputs  throws semanticexception
abstractmapjoinoperator<mapjoindesc> mapjoin    abstractmapjoinoperator<mapjoindesc>  nd
genmrproccontext opprocctx    genmrproccontext  procctx
parsecontext parsectx   opprocctx getparsectx
mapredwork cplan   genmapredutils getmapredwork parsectx
task<? extends serializable> redtask   taskfactory get cplan  parsectx
getconf
task<? extends serializable> currtask   opprocctx getcurrtask
// find the branch on which this processor was invoked
int pos   getpositionparent mapjoin  stack
boolean local    pos      mapjoin getconf     getposbigtable    ? false
true
genmapredutils splittasks mapjoin  currtask  redtask  opprocctx  false
local  pos
currtask   opprocctx getcurrtask
hashmap<operator<? extends serializable>  task<? extends serializable>> optaskmap   opprocctx
getoptaskmap
task<? extends serializable> opmaptask   optaskmap get mapjoin
// if the plan for this reducer does not exist, initialize the plan
if  opmaptask    null
assert cplan getreducer      null
optaskmap put mapjoin  currtask
opprocctx setcurrmapjoinop null
else
// the current plan can be thrown away after being merged with the
// original plan
genmapredutils joinplan mapjoin  currtask  opmaptask  opprocctx  pos
false  false  false
currtask   opmaptask
opprocctx setcurrtask currtask
return null
/**
* mapjoin followed by select.
*/
public static class mapjoin implements nodeprocessor
/**
* create a task by splitting the plan below the join. the reason, we have
* to do so in the processing of select and not mapjoin is due to the
* walker. while processing a node, it is not safe to alter its children
* because that will decide the course of the walk. it is perfectly fine to
* muck around with its parents though, since those nodes have already been
* visited.
*/
@override
public object process node nd  stack<node> stack  nodeprocessorctx procctx
object    nodeoutputs  throws semanticexception
selectoperator sel    selectoperator  nd
abstractmapjoinoperator<mapjoindesc> mapjoin    abstractmapjoinoperator<mapjoindesc>  sel getparentoperators   get
0
assert sel getparentoperators   size      1
genmrproccontext ctx    genmrproccontext  procctx
parsecontext parsectx   ctx getparsectx
// is the mapjoin followed by a reducer
list<abstractmapjoinoperator<? extends mapjoindesc>> listmapjoinops   parsectx
getlistmapjoinopsnoreducer
if  listmapjoinops contains mapjoin
ctx setcurraliasid null
ctx setcurrtopop null
map<operator<? extends serializable>  genmapredctx> mapcurrctx   ctx
getmapcurrctx
mapcurrctx put  operator<? extends serializable>  nd  new genmapredctx
ctx getcurrtask    null  null
return null
ctx setcurrmapjoinop mapjoin
task<? extends serializable> currtask   ctx getcurrtask
genmrmapjoinctx mjctx   ctx getmapjoinctx mapjoin
if  mjctx    null
mjctx   new genmrmapjoinctx
ctx setmapjoinctx mapjoin  mjctx
mapredwork mjplan   genmapredutils getmapredwork parsectx
task<? extends serializable> mjtask   taskfactory get mjplan  parsectx
getconf
tabledesc tt_desc   planutils getintermediatefiletabledesc planutils
getfieldschemasfromrowschema mapjoin getschema
// generate the temporary file
context basectx   parsectx getcontext
string tasktmpdir   basectx getmrtmpfileuri
// add the path to alias mapping
mjctx settasktmpdir tasktmpdir
mjctx setttdesc tt_desc
mjctx setrootmapjoinop sel
sel setparentoperators null
// create a file sink operator for this file name
operator<? extends serializable> fs_op   operatorfactory get
new filesinkdesc tasktmpdir  tt_desc  parsectx getconf   getboolvar
hiveconf confvars compressintermediate    mapjoin getschema
assert mapjoin getchildoperators   size      1
mapjoin getchildoperators   set 0  fs_op
list<operator<? extends serializable>> parentoplist   new arraylist<operator<? extends serializable>>
parentoplist add mapjoin
fs_op setparentoperators parentoplist
currtask adddependenttask mjtask
ctx setcurrtask mjtask
ctx setcurraliasid null
ctx setcurrtopop null
map<operator<? extends serializable>  genmapredctx> mapcurrctx   ctx
getmapcurrctx
mapcurrctx put  operator<? extends serializable>  nd  new genmapredctx
ctx getcurrtask    null  null
return null
/**
* mapjoin followed by mapjoin.
*/
public static class mapjoinmapjoin implements nodeprocessor
@override
public object process node nd  stack<node> stack  nodeprocessorctx procctx
object    nodeoutputs  throws semanticexception
abstractmapjoinoperator<? extends mapjoindesc> mapjoin    abstractmapjoinoperator<? extends mapjoindesc>  nd
genmrproccontext ctx    genmrproccontext  procctx
ctx getparsectx
abstractmapjoinoperator<? extends mapjoindesc> oldmapjoin   ctx getcurrmapjoinop
genmrmapjoinctx mjctx   ctx getmapjoinctx mapjoin
if  mjctx    null
mjctx setoldmapjoin oldmapjoin
else
ctx setmapjoinctx mapjoin  new genmrmapjoinctx null  null  null
oldmapjoin
ctx setcurrmapjoinop mapjoin
// find the branch on which this processor was invoked
int pos   getpositionparent mapjoin  stack
map<operator<? extends serializable>  genmapredctx> mapcurrctx   ctx
getmapcurrctx
genmapredctx mapredctx   mapcurrctx get mapjoin getparentoperators   get
pos
task<? extends serializable> currtask   mapredctx getcurrtask
mapredwork currplan    mapredwork  currtask getwork
mapredctx getcurraliasid
operator<? extends serializable> reducer   mapjoin
hashmap<operator<? extends serializable>  task<? extends serializable>> optaskmap   ctx
getoptaskmap
task<? extends serializable> opmaptask   optaskmap get reducer
ctx setcurrtask currtask
// if the plan for this reducer does not exist, initialize the plan
if  opmaptask    null
assert currplan getreducer      null
genmapredutils initmapjoinplan mapjoin  ctx  true  false  false  pos
else
// the current plan can be thrown away after being merged with the
// original plan
genmapredutils joinplan mapjoin  currtask  opmaptask  ctx  pos  false
true  false
currtask   opmaptask
ctx setcurrtask currtask
mapcurrctx put mapjoin  new genmapredctx ctx getcurrtask    null  null
return null
/**
* union followed by mapjoin.
*/
public static class unionmapjoin implements nodeprocessor
@override
public object process node nd  stack<node> stack  nodeprocessorctx procctx
object    nodeoutputs  throws semanticexception
genmrproccontext ctx    genmrproccontext  procctx
parsecontext parsectx   ctx getparsectx
unionproccontext uctx   parsectx getuctx
// union was map only - no special processing needed
if  uctx ismaponlysubq
return  new tablescanmapjoin
process nd  stack  procctx  nodeoutputs
unionoperator currunion   ctx getcurrunionop
assert currunion    null
ctx getuniontask currunion
abstractmapjoinoperator<mapjoindesc> mapjoin    abstractmapjoinoperator<mapjoindesc>  nd
// find the branch on which this processor was invoked
int pos   getpositionparent mapjoin  stack
map<operator<? extends serializable>  genmapredctx> mapcurrctx   ctx
getmapcurrctx
genmapredctx mapredctx   mapcurrctx get mapjoin getparentoperators   get
pos
task<? extends serializable> currtask   mapredctx getcurrtask
mapredwork currplan    mapredwork  currtask getwork
operator<? extends serializable> reducer   mapjoin
hashmap<operator<? extends serializable>  task<? extends serializable>> optaskmap   ctx
getoptaskmap
task<? extends serializable> opmaptask   optaskmap get reducer
// union result cannot be a map table
boolean local    pos     mapjoin getconf    getposbigtable    ? false
true
if  local
throw new semanticexception errormsg invalid_mapjoin_table getmsg
// if the plan for this reducer does not exist, initialize the plan
if  opmaptask    null
assert currplan getreducer      null
ctx setcurrmapjoinop mapjoin
genmapredutils initmapjoinplan mapjoin  ctx  true  true  false  pos
ctx setcurrunionop null
else
// the current plan can be thrown away after being merged with the
// original plan
task<? extends serializable> utask   ctx getuniontask
ctx getcurrunionop    getutask
if  utask getid   equals opmaptask getid
genmapredutils joinplan mapjoin  null  opmaptask  ctx  pos  false
false  true
else
genmapredutils joinplan mapjoin  utask  opmaptask  ctx  pos  false
false  true
currtask   opmaptask
ctx setcurrtask currtask
mapcurrctx put mapjoin  new genmapredctx ctx getcurrtask    ctx
getcurrtopop    ctx getcurraliasid
return null
public static nodeprocessor gettablescanmapjoin
return new tablescanmapjoin
public static nodeprocessor getunionmapjoin
return new unionmapjoin
public static nodeprocessor getreducesinkmapjoin
return new reducesinkmapjoin
public static nodeprocessor getmapjoin
return new mapjoin
public static nodeprocessor getmapjoinmapjoin
return new mapjoinmapjoin
private mapjoinfactory
// prevent instantiation