/**
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hive ql index bitmap
import java util arraylist
import java util hashmap
import java util linkedhashmap
import java util list
import java util map
import java util set
import org apache commons logging log
import org apache commons logging logfactory
import org apache hadoop conf configuration
import org apache hadoop hive conf hiveconf
import org apache hadoop hive metastore api fieldschema
import org apache hadoop hive metastore api index
import org apache hadoop hive metastore api storagedescriptor
import org apache hadoop hive metastore api table
import org apache hadoop hive ql driver
import org apache hadoop hive ql exec task
import org apache hadoop hive ql hooks readentity
import org apache hadoop hive ql hooks writeentity
import org apache hadoop hive ql index hiveindexquerycontext
import org apache hadoop hive ql index hiveindexedinputformat
import org apache hadoop hive ql index indexpredicateanalyzer
import org apache hadoop hive ql index indexsearchcondition
import org apache hadoop hive ql index tablebasedindexhandler
import org apache hadoop hive ql metadata hiveexception
import org apache hadoop hive ql metadata hiveutils
import org apache hadoop hive ql metadata partition
import org apache hadoop hive ql metadata virtualcolumn
import org apache hadoop hive ql optimizer indexutils
import org apache hadoop hive ql parse parsecontext
import org apache hadoop hive ql plan exprnodedesc
import org apache hadoop hive ql plan partitiondesc
import org apache hadoop hive ql udf generic genericudfopequal
import org apache hadoop hive ql udf generic genericudfopequalorgreaterthan
import org apache hadoop hive ql udf generic genericudfopequalorlessthan
import org apache hadoop hive ql udf generic genericudfopgreaterthan
import org apache hadoop hive ql udf generic genericudfoplessthan
/**
* index handler for the bitmap index. bitmap index uses an ewah-compressed
* bitmap to represent the values in a table.
*/
public class bitmapindexhandler extends tablebasedindexhandler
private configuration configuration
private static final log log   logfactory getlog bitmapindexhandler class getname
@override
public void generateindexquery list<index> indexes  exprnodedesc predicate
parsecontext pctx  hiveindexquerycontext querycontext
map<index  exprnodedesc> indexpredicates    decomposepredicate
predicate
indexes
querycontext
if  indexpredicates    null
log info
querycontext setquerytasks null
return     abort if we couldn't pull out anything from the predicate
list<bitmapinnerquery> iqs   new arraylist<bitmapinnerquery> indexes size
int i   0
for  index index   indexes
exprnodedesc indexpredicate   indexpredicates get index
if  indexpredicate    null
iqs add new bitmapinnerquery
index getindextablename
indexpredicate
i
// setup tablescanoperator to change input format for original query
querycontext setindexinputformat hiveindexedinputformat class getname
// build reentrant ql for index query
stringbuilder qlcommand   new stringbuilder
string tmpfile   pctx getcontext   getmrtmpfileuri
qlcommand append                       ql includes " around file name
qlcommand append
qlcommand append
bitmapquery head   iqs get 0
for   i   1  i < iqs size    i
head   new bitmapouterquery   i  head  iqs get i
qlcommand append head tostring
qlcommand append     head getalias
// generate tasks from index query string
log info     qlcommand tostring
hiveconf queryconf   new hiveconf pctx getconf    bitmapindexhandler class
hiveconf setboolvar queryconf  hiveconf confvars compressresult  false
driver driver   new driver queryconf
driver compile qlcommand tostring    false
querycontext setindexintermediatefile tmpfile
querycontext addadditionalsemanticinputs driver getplan   getinputs
querycontext setquerytasks driver getplan   getroottasks
/**
* split the predicate into the piece we can deal with (pushed), and the one we can't (residual)
* @param predicate
* @param index
* @return
*/
private map<index  exprnodedesc> decomposepredicate exprnodedesc predicate  list<index> indexes
hiveindexquerycontext querycontext
map<index  exprnodedesc> indexpredicates   new hashmap<index  exprnodedesc>
// compute overall residual
indexpredicateanalyzer analyzer   getindexpredicateanalyzer indexes  querycontext getquerypartitions
list<indexsearchcondition> searchconditions   new arraylist<indexsearchcondition>
exprnodedesc residualpredicate   analyzer analyzepredicate predicate  searchconditions
// pass residual predicate back out for further processing
querycontext setresidualpredicate residualpredicate
if  searchconditions size      0
return null
for  index index   indexes
arraylist<index> in   new arraylist<index> 1
in add index
analyzer   getindexpredicateanalyzer in  querycontext getquerypartitions
searchconditions   new arraylist<indexsearchcondition>
// split predicate into pushed (what we can handle), and residual (what we can't handle)
// pushed predicate from translatesearchconditions is stored for the current index
// this ensures that we apply all possible predicates to each index
analyzer analyzepredicate predicate  searchconditions
if  searchconditions size      0
indexpredicates put index  null
else
indexpredicates put index  analyzer translatesearchconditions searchconditions
return indexpredicates
/**
* instantiate a new predicate analyzer suitable for determining
* whether we can use an index, based on rules for indexes in
* where clauses that we support
*
* @return preconfigured predicate analyzer for where queries
*/
private indexpredicateanalyzer getindexpredicateanalyzer list<index> indexes  set<partition> querypartitions
indexpredicateanalyzer analyzer   new indexpredicateanalyzer
analyzer addcomparisonop genericudfopequal class getname
analyzer addcomparisonop genericudfoplessthan class getname
analyzer addcomparisonop genericudfopequalorlessthan class getname
analyzer addcomparisonop genericudfopgreaterthan class getname
analyzer addcomparisonop genericudfopequalorgreaterthan class getname
// only return results for columns in the list of indexes
for  index index   indexes
list<fieldschema> columnschemas   index getsd   getcols
for  fieldschema column   columnschemas
analyzer allowcolumnname column getname
// partitioned columns are treated as if they have indexes so that the partitions
// are used during the index query generation
for  partition part   querypartitions
if  part getspec   isempty
continue     empty partitions are from whole tables  so we don't want to add them in
for  string column   part getspec   keyset
analyzer allowcolumnname column
return analyzer
@override
public void analyzeindexdefinition table basetable  index index
table indextable  throws hiveexception
storagedescriptor storagedesc   index getsd
if  this usesindextable      indextable    null
storagedescriptor indextablesd   storagedesc deepcopy
list<fieldschema> indextblcols   indextablesd getcols
fieldschema bucketfilename   new fieldschema
indextblcols add bucketfilename
fieldschema offsets   new fieldschema
indextblcols add offsets
fieldschema bitmaps   new fieldschema
indextblcols add bitmaps
indextable setsd indextablesd
@override
protected task<?> getindexbuildermapredtask set<readentity> inputs  set<writeentity> outputs
list<fieldschema> indexfield  boolean partitioned
partitiondesc indextblpartdesc  string indextablename
partitiondesc basetablepartdesc  string basetablename  string dbname  throws hiveexception
hiveconf builderconf   new hiveconf getconf    bitmapindexhandler class
hiveconf setboolvar builderconf  hiveconf confvars hiverowoffset  true
string indexcols   hiveutils getunparsedcolumnnamesfromfieldschema indexfield
//form a new insert overwrite query.
stringbuilder command  new stringbuilder
linkedhashmap<string  string> partspec   indextblpartdesc getpartspec
command append     hiveutils unparseidentifier indextablename
if  partitioned    indextblpartdesc    null
command append
list<string> ret   getpartkvpairstringarray partspec
for  int i   0  i < ret size    i
string partkv   ret get i
command append partkv
if  i < ret size     1
command append
command append
command append
command append indexcols
command append
command append virtualcolumn filename getname
command append
command append virtualcolumn blockoffset getname
command append
command append
command append virtualcolumn rowoffset getname
command append
command append     hiveutils unparseidentifier basetablename
linkedhashmap<string  string> basepartspec   basetablepartdesc getpartspec
if basepartspec    null
command append
list<string> pkv   getpartkvpairstringarray basepartspec
for  int i   0  i < pkv size    i
string partkv   pkv get i
command append partkv
if  i < pkv size     1
command append
command append
command append virtualcolumn filename getname
command append
command append virtualcolumn blockoffset getname
for  fieldschema fieldschema   indexfield
command append
command append hiveutils unparseidentifier fieldschema getname
// require clusterby rowoffset if map-size aggregation is off.
// todo: make this work without map side aggregation
if   builderconf get    null  equals
throw new hiveexception
task<?> roottask   indexutils createroottask builderconf  inputs  outputs
command   linkedhashmap<string  string>  partspec  indextablename  dbname
return roottask
@override
/**
* no lower bound on bitmap index query size, so this will always return true
*/
public boolean checkquerysize long querysize  hiveconf hiveconf
return true
@override
public boolean usesindextable
return true