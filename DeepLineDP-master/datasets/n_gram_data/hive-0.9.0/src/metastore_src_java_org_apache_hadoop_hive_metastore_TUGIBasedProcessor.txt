/**
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hive metastore
import java io ioexception
import java lang reflect invocationtargetexception
import java lang reflect method
import java net socket
import java security privilegedexceptionaction
import java util hashmap
import java util list
import java util map
import org apache hadoop hive metastore api thrifthivemetastore iface
import org apache hadoop hive metastore api thrifthivemetastore processor
import org apache hadoop hive metastore api thrifthivemetastore set_ugi_args
import org apache hadoop hive metastore api thrifthivemetastore set_ugi_result
import org apache hadoop hive shims hadoopshims
import org apache hadoop hive shims shimloader
import org apache hadoop hive thrift tugicontainingtransport
import org apache hadoop security usergroupinformation
import org apache thrift processfunction
import org apache thrift tapplicationexception
import org apache thrift tbase
import org apache thrift texception
import org apache thrift protocol tmessage
import org apache thrift protocol tmessagetype
import org apache thrift protocol tprotocol
import org apache thrift protocol tprotocolexception
import org apache thrift protocol tprotocolutil
import org apache thrift protocol ttype
/** tugibasedprocessor is used in unsecure mode for thrift metastore client server communication.
*  this processor checks whether the first rpc call after connection is set up is set_ugi()
*  through which client sends ugi to server. processor then perform all subsequent rpcs on the
*  connection using ugi.doas() so all actions are performed in client user context.
*  note that old clients will never call set_ugi() and thus ugi will never be received on server
*  side, in which case server exhibits previous behavior and continues as usual.
*/
public class tugibasedprocessor<i extends iface> extends tsetipaddressprocessor<iface>
private final i iface
private final map<string   org apache thrift processfunction<i  ? extends  tbase<? ?>>>
functions
private final hadoopshims shim
@suppresswarnings
public tugibasedprocessor i iface  throws securityexception  nosuchfieldexception
illegalargumentexception  illegalaccessexception  nosuchmethodexception
invocationtargetexception
super iface
this iface   iface
// todo get rid of following reflection after thrift-1465 is fixed.
method map   processor class getdeclaredmethod   map class
map setaccessible true
this functions    map<string   processfunction<i  ? extends  tbase<? ?>>>
map invoke null  new hashmap<string  processfunction<i  ? extends tbase<? ?>>>
shim   shimloader gethadoopshims
@override
public boolean process final tprotocol in  final tprotocol out  throws texception
setipaddress in
final tmessage msg   in readmessagebegin
final processfunction<i  ? extends  tbase<? ?>> fn   functions get msg name
if  fn    null
tprotocolutil skip in  ttype struct
in readmessageend
tapplicationexception x   new tapplicationexception tapplicationexception unknown_method
msg name
out writemessagebegin new tmessage msg name  tmessagetype exception  msg seqid
x write out
out writemessageend
out gettransport   flush
return true
tugicontainingtransport ugitrans    tugicontainingtransport in gettransport
// store ugi in transport if the rpc is set_ugi
if  msg name equalsignorecase
try
handlesetugi ugitrans  fn  msg  in  out
catch  texception e
throw e
catch  exception e
throw new texception e getcause
return true
usergroupinformation clientugi   ugitrans getclientugi
if  null    clientugi
// at this point, transport must contain client ugi, if it doesn't then its an old client.
fn process msg seqid  in  out  iface
return true
else      found ugi  perform doas
privilegedexceptionaction<void> pvea   new privilegedexceptionaction<void>
public void run
try
fn process msg seqid in  out  iface
return null
catch  texception te
throw new runtimeexception te
try
shim doas clientugi  pvea
return true
catch  runtimeexception rte
if  rte getcause   instanceof texception
throw  texception rte getcause
throw rte
catch  interruptedexception ie
throw new runtimeexception ie      unexpected
catch  ioexception ioe
throw new runtimeexception ioe      unexpected
private void handlesetugi tugicontainingtransport ugitrans
processfunction<i  ? extends  tbase<? ?>> fn  tmessage msg  tprotocol iprot  tprotocol oprot
throws texception  securityexception  nosuchmethodexception  illegalargumentexception
illegalaccessexception  invocationtargetexception
usergroupinformation clientugi   ugitrans getclientugi
if  null    clientugi
throw new texception new illegalstateexception
clientugi getusername
// todo get rid of following reflection after thrift-1465 is fixed.
method method   fn getclass   getdeclaredmethod    new class<?>
method setaccessible true
set_ugi_args args    set_ugi_args method invoke fn  new object
try
args read iprot
catch  tprotocolexception e
iprot readmessageend
tapplicationexception x   new tapplicationexception tapplicationexception protocol_error
e getmessage
oprot writemessagebegin new tmessage msg name  tmessagetype exception  msg seqid
x write oprot
oprot writemessageend
oprot gettransport   flush
return
iprot readmessageend
// todo get rid of following reflection after thrift-1465 is fixed.
method   fn getclass   getdeclaredmethod    iface class  set_ugi_args class
method setaccessible true
set_ugi_result result    set_ugi_result method invoke fn  iface args
list<string> principals   result getsuccess
// store the ugi in transport and then continue as usual.
ugitrans setclientugi shim createremoteuser principals remove principals size   1
principals
oprot writemessagebegin new tmessage msg name  tmessagetype reply  msg seqid
result write oprot
oprot writemessageend
oprot gettransport   flush
@override
protected void setipaddress final tprotocol in
tugicontainingtransport ugitrans    tugicontainingtransport in gettransport
socket socket   ugitrans getsocket
if  socket    null
setipaddress socket