/**
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hive ql io
import java io datainputstream
import java io eofexception
import java io ioexception
import java io inputstream
import org apache hadoop conf configurable
import org apache hadoop conf configuration
import org apache hadoop fs fsdatainputstream
import org apache hadoop fs filesystem
import org apache hadoop fs path
import org apache hadoop io compress compressioncodec
import org apache hadoop io compress compressioncodecfactory
import org apache hadoop io serializer deserializer
import org apache hadoop io serializer serialization
import org apache hadoop mapred fileinputformat
import org apache hadoop mapred filesplit
import org apache hadoop mapred inputsplit
import org apache hadoop mapred jobconf
import org apache hadoop mapred recordreader
import org apache hadoop mapred reporter
import org apache hadoop util reflectionutils
/**
* an {@link org.apache.hadoop.mapred.inputformat} for plain files with
* {@link deserializer} records.
*/
public class flatfileinputformat<t> extends
fileinputformat<void  flatfileinputformat rowcontainer<t>>
/**
* a work-around until hadoop-1230 is fixed.
*
* allows boolean next(k,v) to be called by reference but still allow the
* deserializer to create a new object (i.e., row) on every call to next.
*/
public static class rowcontainer<t>
t row
/**
* an implementation of serializationcontext is responsible for looking up the
* serialization implementation for the given recordreader. potentially based
* on the configuration or some other mechanism
*
* the serializationfactory does not give this functionality since: 1.
* requires serialization implementations to be specified in the configuration
* a-priori (although same as setting a serializationcontext) 2. does not
* lookup the actual subclass being deserialized. e.g., for serializable does
* not have a way of configuring the actual java class being
* serialized/deserialized.
*/
public static interface serializationcontext<s> extends configurable
/**
* an {@link serialization} object for objects of type s.
*
* @return a serialization object for this context
*/
serialization<s> getserialization   throws ioexception
/**
* produces the specific class to deserialize.
*/
class<? extends s> getrealclass   throws ioexception
/**
* the jobconf keys for the serialization implementation.
*/
public static final string serializationimplkey
/**
* an implementation of {@link serializationcontext} that reads the
* serialization class and specific subclass to be deserialized from the
* jobconf.
*
*/
public static class serializationcontextfromconf<s> implements
flatfileinputformat serializationcontext<s>
/**
* the jobconf keys for the class that is being deserialized.
*/
public static final string serializationsubclasskey
/**
* implements configurable so it can use the configuration to find the right
* classes note: reflectionutils will automatigically call setconf with the
* right configuration.
*/
private configuration conf
public void setconf configuration conf
this conf   conf
public configuration getconf
return conf
/**
* @return the actual class being deserialized.
* @exception does
*              not currently throw ioexception
*/
public class<s> getrealclass   throws ioexception
return  class<s>  conf getclass serializationsubclasskey  null
object class
/**
* looks up and instantiates the serialization object
*
* important to note here that we are not relying on the hadoop
* serializationfactory part of the serialization framework. this is because
* in the case of non-writable objects, we cannot make any assumptions about
* the uniformity of the serialization class apis - i.e., there may not be a
* "write" method call and a subclass may need to implement its own
* serialization classes. the serializationfactory currently returns the
* first (de)serializer that is compatible with the class to be
* deserialized; in this context, that assumption isn't necessarily true.
*
* @return the serialization object for this context
* @exception does
*              not currently throw any ioexception
*/
public serialization<s> getserialization   throws ioexception
class<serialization<s>> tclass    class<serialization<s>>  conf getclass
serializationimplkey  null  serialization class
return tclass    null ? null    serialization<s>  reflectionutils
newinstance tclass  conf
/**
* an {@link recordreader} for plain files with {@link deserializer} records
*
* reads one row at a time of type r. r is intended to be a base class of
* something such as: record, writable, text, ...
*
*/
public class flatfilerecordreader<r> implements
recordreader<void  flatfileinputformat rowcontainer<r>>
/**
* an interface for a helper class for instantiating {@link serialization}
* classes.
*/
/**
* the stream in use - is fsin if not compressed, otherwise, it is dcin.
*/
private final datainputstream in
/**
* the decompressed stream or null if the input is not decompressed.
*/
private final inputstream dcin
/**
* the underlying stream.
*/
private final fsdatainputstream fsin
/**
* for calculating progress.
*/
private final long end
/**
* the constructed deserializer.
*/
private final deserializer<r> deserializer
/**
* once eof is reached, stop calling the deserializer.
*/
private boolean iseof
/**
* the jobconf which contains information needed to instantiate the correct
* deserializer.
*/
private final configuration conf
/**
* the actual class of the row's we are deserializing, not just the base
* class.
*/
private final class<r> realrowclass
/**
* flatfilerecordreader constructor constructs the underlying stream
* (potentially decompressed) and creates the deserializer.
*
* @param conf
*          the jobconf
* @param split
*          the split for this file
*/
public flatfilerecordreader configuration conf  filesplit split  throws ioexception
final path path   split getpath
filesystem filesys   path getfilesystem conf
compressioncodecfactory compressioncodecs   new compressioncodecfactory
conf
final compressioncodec codec   compressioncodecs getcodec path
this conf   conf
fsin   filesys open path
if  codec    null
dcin   codec createinputstream fsin
in   new datainputstream dcin
else
dcin   null
in   fsin
iseof   false
end   split getlength
// instantiate a serializationcontext which this will use to lookup the
// serialization class and the
// actual class being deserialized
serializationcontext<r> sinfo
class<serializationcontext<r>> sinfoclass    class<serializationcontext<r>>  conf
getclass serializationcontextimplkey
serializationcontextfromconf class
sinfo    serializationcontext<r> reflectionutils newinstance sinfoclass  conf
// get the serialization object and the class being deserialized
serialization<r> serialization   sinfo getserialization
realrowclass    class<r>  sinfo getrealclass
deserializer   serialization getdeserializer realrowclass
deserializer open in
/**
* the jobconf key of the serializationcontext to use.
*/
public static final string serializationcontextimplkey
/**
* @return null
*/
public void createkey
return null
/**
* @return a new r instance.
*/
public rowcontainer<r> createvalue
rowcontainer<r> r   new rowcontainer<r>
r row    r reflectionutils newinstance realrowclass  conf
return r
/**
* returns the next row # and value.
*
* @param key
*          - void as these files have a value only
* @param value
*          - the row container which is always re-used, but the internal
*          value may be set to a new object
* @return whether the key and value were read. true if they were and false
*         if eof
* @exception ioexception
*              from the deserializer
*/
public synchronized boolean next void key  rowcontainer<r> value  throws ioexception
if  iseof    in available      0
iseof   true
return false
// the deserializer is responsible for actually reading each record from
// the stream
try
value row   deserializer deserialize value row
if  value row    null
iseof   true
return false
return true
catch  eofexception e
iseof   true
return false
public synchronized float getprogress   throws ioexception
// this assumes no splitting
if  end    0
return 0 0f
else
// gives progress over uncompressed stream
// assumes deserializer is not buffering itself
return math min 1 0f  fsin getpos      float   end
public synchronized long getpos   throws ioexception
// assumes deserializer is not buffering itself
// position over uncompressed stream. not sure what
// effect this has on stats about job
return fsin getpos
public synchronized void close   throws ioexception
// assuming that this closes the underlying streams
deserializer close
protected boolean issplittable filesystem fs  path filename
return false
@override
public recordreader<void  rowcontainer<t>> getrecordreader inputsplit split
jobconf job  reporter reporter  throws ioexception
reporter setstatus split tostring
return new flatfilerecordreader<t> job   filesplit  split