/**
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hive ql metadata
import java io ioexception
import java util arraylist
import java util collections
import java util hashset
import java util list
import java util map
import java util set
import org apache commons logging log
import org apache commons logging logfactory
import org apache hadoop fs filestatus
import org apache hadoop fs filesystem
import org apache hadoop fs path
import org apache hadoop hive conf hiveconf
import org apache hadoop hive metastore metastoreutils
import org apache hadoop hive metastore warehouse
import org apache hadoop hive metastore api metaexception
import org apache hadoop hive metastore api nosuchobjectexception
import org apache hadoop hive ql metadata checkresult partitionresult
import org apache thrift texception
/**
* verify that the information in the metastore matches what is on the
* filesystem. return a checkresult object containing lists of missing and any
* unexpected tables and partitions.
*/
public class hivemetastorechecker
public static final log log   logfactory getlog hivemetastorechecker class
private final hive hive
private final hiveconf conf
public hivemetastorechecker hive hive
super
this hive   hive
conf   hive getconf
/**
* check the metastore for inconsistencies, data missing in either the
* metastore or on the dfs.
*
* @param dbname
*          name of the database, if not specified the default will be used.
* @param tablename
*          table we want to run the check for. if null we'll check all the
*          tables in the database.
* @param partitions
*          list of partition name value pairs, if null or empty check all
*          partitions
* @param result
*          fill this with the results of the check
* @throws hiveexception
*           failed to get required information from the metastore.
* @throws ioexception
*           most likely filesystem related
*/
public void checkmetastore string dbname  string tablename
list<? extends map<string  string>> partitions  checkresult result
throws hiveexception  ioexception
if  dbname    null      equalsignorecase dbname
dbname   metastoreutils default_database_name
try
if  tablename    null      equals tablename
// no table specified, check all tables and all partitions.
list<string> tables   hive gettablesfordb dbname
for  string currenttablename   tables
checktable dbname  currenttablename  null  result
findunknowntables dbname  tables  result
else if  partitions    null    partitions isempty
// only one table, let's check all partitions
checktable dbname  tablename  null  result
else
// check the specified partitions
checktable dbname  tablename  partitions  result
collections sort result getpartitionsnotinms
collections sort result getpartitionsnotonfs
collections sort result gettablesnotinms
collections sort result gettablesnotonfs
catch  metaexception e
throw new hiveexception e
catch  texception e
throw new hiveexception e
/**
* check for table directories that aren't in the metastore.
*
* @param dbname
*          name of the database
* @param tables
*          list of table names
* @param result
*          add any found tables to this
* @throws hiveexception
*           failed to get required information from the metastore.
* @throws ioexception
*           most likely filesystem related
* @throws metaexception
*           failed to get required information from the metastore.
* @throws nosuchobjectexception
*           failed to get required information from the metastore.
* @throws texception
*           thrift communication error.
*/
void findunknowntables string dbname  list<string> tables  checkresult result
throws ioexception  metaexception  texception  hiveexception
set<path> dbpaths   new hashset<path>
set<string> tablenames   new hashset<string> tables
for  string tablename   tables
table table   hive gettable dbname  tablename
// hack, instead figure out a way to get the db paths
string isexternal   table getparameters   get
if  isexternal    null       equalsignorecase isexternal
dbpaths add table getpath   getparent
for  path dbpath   dbpaths
filesystem fs   dbpath getfilesystem conf
filestatus statuses   fs liststatus dbpath
for  filestatus status   statuses
if  status isdir       tablenames contains status getpath   getname
result gettablesnotinms   add status getpath   getname
/**
* check the metastore for inconsistencies, data missing in either the
* metastore or on the dfs.
*
* @param dbname
*          name of the database
* @param tablename
*          name of the table
* @param partitions
*          partitions to check, if null or empty get all the partitions.
* @param result
*          result object
* @throws hiveexception
*           failed to get required information from the metastore.
* @throws ioexception
*           most likely filesystem related
* @throws metaexception
*           failed to get required information from the metastore.
*/
void checktable string dbname  string tablename
list<? extends map<string  string>> partitions  checkresult result
throws metaexception  ioexception  hiveexception
table table   null
try
table   hive gettable dbname  tablename
catch  hiveexception e
result gettablesnotinms   add tablename
return
list<partition> parts   new arraylist<partition>
boolean findunknownpartitions   true
if  table ispartitioned
if  partitions    null    partitions isempty
// no partitions specified, let's get all
parts   hive getpartitions table
else
// we're interested in specific partitions,
// don't check for any others
findunknownpartitions   false
for  map<string  string> map   partitions
partition part   hive getpartition table  map  false
if  part    null
partitionresult pr   new partitionresult
pr settablename tablename
pr setpartitionname warehouse makepartpath map
result getpartitionsnotinms   add pr
else
parts add part
checktable table  parts  findunknownpartitions  result
/**
* check the metastore for inconsistencies, data missing in either the
* metastore or on the dfs.
*
* @param table
*          table to check
* @param parts
*          partitions to check
* @param result
*          result object
* @param findunknownpartitions
*          should we try to find unknown partitions?
* @throws ioexception
*           could not get information from filesystem
* @throws hiveexception
*           could not create partition object
*/
void checktable table table  list<partition> parts
boolean findunknownpartitions  checkresult result  throws ioexception
hiveexception
path tablepath   table getpath
filesystem fs   tablepath getfilesystem conf
if   fs exists tablepath
result gettablesnotonfs   add table gettablename
return
set<path> partpaths   new hashset<path>
// check that the partition folders exist on disk
for  partition partition   parts
if  partition    null
// most likely the user specified an invalid partition
continue
path partpath   partition getpartitionpath
fs   partpath getfilesystem conf
if   fs exists partpath
partitionresult pr   new partitionresult
pr setpartitionname partition getname
pr settablename partition gettable   gettablename
result getpartitionsnotonfs   add pr
for  int i   0  i < partition getspec   size    i
partpaths add partpath makequalified fs
partpath   partpath getparent
if  findunknownpartitions
findunknownpartitions table  partpaths  result
/**
* find partitions on the fs that are unknown to the metastore.
*
* @param table
*          table where the partitions would be located
* @param partpaths
*          paths of the partitions the ms knows about
* @param result
*          result object
* @throws ioexception
*           thrown if we fail at fetching listings from the fs.
*/
void findunknownpartitions table table  set<path> partpaths
checkresult result  throws ioexception
path tablepath   table getpath
// now check the table folder and see if we find anything
// that isn't in the metastore
set<path> allpartdirs   new hashset<path>
getallleafdirs tablepath  allpartdirs
// don't want the table dir
allpartdirs remove tablepath
// remove the partition paths we know about
allpartdirs removeall partpaths
// we should now only have the unexpected folders left
for  path partpath   allpartdirs
filesystem fs   partpath getfilesystem conf
string partitionname   getpartitionname fs makequalified tablepath
partpath
if  partitionname    null
partitionresult pr   new partitionresult
pr setpartitionname partitionname
pr settablename table gettablename
result getpartitionsnotinms   add pr
/**
* get the partition name from the path.
*
* @param tablepath
*          path of the table.
* @param partitionpath
*          path of the partition.
* @return partition name, for example partitiondate=2008-01-01
*/
private string getpartitionname path tablepath  path partitionpath
string result   null
path currpath   partitionpath
while  currpath    null     tablepath equals currpath
if  result    null
result   currpath getname
else
result   currpath getname     path separator   result
currpath   currpath getparent
return result
/**
* recursive method to get the leaf directories of a base path. example:
* base/dir1/dir2 base/dir3
*
* this will return dir2 and dir3 but not dir1.
*
* @param basepath
*          start directory
* @param alldirs
*          this set will contain the leaf paths at the end.
* @throws ioexception
*           thrown if we can't get lists from the fs.
*/
private void getallleafdirs path basepath  set<path> alldirs
throws ioexception
getallleafdirs basepath  alldirs  basepath getfilesystem conf
private void getallleafdirs path basepath  set<path> alldirs  filesystem fs
throws ioexception
filestatus statuses   fs liststatus basepath
if  statuses length    0
alldirs add basepath
for  filestatus status   statuses
if  status isdir
getallleafdirs status getpath    alldirs  fs