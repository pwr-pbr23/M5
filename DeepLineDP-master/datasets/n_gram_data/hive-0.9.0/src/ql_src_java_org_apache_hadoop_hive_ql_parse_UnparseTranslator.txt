/**
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hive ql parse
import java util arraylist
import java util list
import java util map
import java util navigablemap
import java util treemap
import org antlr runtime tokenrewritestream
import org apache hadoop hive ql metadata hiveutils
/**
* unparsetranslator is used to "unparse" objects such as views when their
* definition is stored.
*/
class unparsetranslator
// key is token start index
private final navigablemap<integer  translation> translations
private final list<copytranslation> copytranslations
private boolean enabled
public unparsetranslator
translations   new treemap<integer  translation>
copytranslations   new arraylist<copytranslation>
/**
* enable this translator.
*/
void enable
enabled   true
/**
* @return whether this translator has been enabled
*/
boolean isenabled
return enabled
/**
* register a translation to be performed as part of unparse.
* if the translation overlaps with any previously
* registered translation, then it must be either
* identical or a prefix (in which cases it is ignored),
* or else it must extend the existing translation (i.e.
* the existing translation must be a prefix of the new translation).
* all other overlap cases result in assertion failures.
*
* @param node
*          target node whose subtree is to be replaced
*
* @param replacementtext
*          text to use as replacement
*/
void addtranslation astnode node  string replacementtext
if   enabled
return
if  node getorigin      null
// this node was parsed while loading the definition of another view
// being referenced by the one being created, and we don't want
// to track any expansions for the underlying view.
return
int tokenstartindex   node gettokenstartindex
int tokenstopindex   node gettokenstopindex
translation translation   new translation
translation tokenstopindex   tokenstopindex
translation replacementtext   replacementtext
// sanity check for overlap with regions already being expanded
assert  tokenstopindex >  tokenstartindex
map entry<integer  translation> existingentry
existingentry   translations floorentry tokenstartindex
boolean prefix   false
if  existingentry    null
if  existingentry getkey   equals tokenstartindex
if  existingentry getvalue   tokenstopindex    tokenstopindex
if  existingentry getvalue   replacementtext equals replacementtext
// exact match for existing mapping: somebody is doing something
// redundant, but we'll let it pass
return
else if  tokenstopindex > existingentry getvalue   tokenstopindex
// is existing mapping a prefix for new mapping? if so, that's also
// redundant, but in this case we need to expand it
prefix   replacementtext startswith
existingentry getvalue   replacementtext
assert prefix
else
// new mapping is a prefix for existing mapping:  ignore it
prefix   existingentry getvalue   replacementtext startswith
replacementtext
assert prefix
return
if   prefix
assert  existingentry getvalue   tokenstopindex < tokenstartindex
if   prefix
existingentry   translations ceilingentry tokenstartindex
if  existingentry    null
assert  existingentry getkey   > tokenstopindex
// it's all good: create a new entry in the map (or update existing one)
translations put tokenstartindex  translation
/**
* register a translation for an tabname.
*
* @param node
*          source node (which must be an tabname) to be replaced
*/
void addtablenametranslation astnode tablename
if   enabled
return
if  tablename gettoken   gettype      hiveparser identifier
addidentifiertranslation tablename
return
assert  tablename gettoken   gettype      hiveparser tok_tabname
assert  tablename getchildcount   <  2
addidentifiertranslation  astnode tablename getchild 0
if  tablename getchildcount      2
addidentifiertranslation  astnode tablename getchild 1
/**
* register a translation for an identifier.
*
* @param node
*          source node (which must be an identifier) to be replaced
*/
void addidentifiertranslation astnode identifier
if   enabled
return
assert  identifier gettoken   gettype      hiveparser identifier
string replacementtext   identifier gettext
replacementtext   basesemanticanalyzer unescapeidentifier replacementtext
replacementtext   hiveutils unparseidentifier replacementtext
addtranslation identifier  replacementtext
/**
* register a "copy" translation in which a node will be translated into
* whatever the translation turns out to be for another node (after
* previously registered translations have already been performed).  deferred
* translations are performed in the order they are registered, and follow
* the same rules regarding overlap as non-copy translations.
*
* @param targetnode node whose subtree is to be replaced
*
* @param sourcenode the node providing the replacement text
*
*/
void addcopytranslation astnode targetnode  astnode sourcenode
if   enabled
return
if  targetnode getorigin      null
return
copytranslation copytranslation   new copytranslation
copytranslation targetnode   targetnode
copytranslation sourcenode   sourcenode
copytranslations add copytranslation
/**
* apply all translations on the given token stream.
*
* @param tokenrewritestream
*          rewrite-capable stream
*/
void applytranslations tokenrewritestream tokenrewritestream
for  map entry<integer  translation> entry   translations entryset
tokenrewritestream replace
entry getkey
entry getvalue   tokenstopindex
entry getvalue   replacementtext
for  copytranslation copytranslation   copytranslations
string replacementtext   tokenrewritestream tostring
copytranslation sourcenode gettokenstartindex
copytranslation sourcenode gettokenstopindex
string currenttext   tokenrewritestream tostring
copytranslation targetnode gettokenstartindex
copytranslation targetnode gettokenstopindex
if  currenttext equals replacementtext
// copy is a nop, so skip it--this is important for avoiding
// spurious overlap assertions
continue
// call addtranslation just to get the assertions for overlap
// checking.
addtranslation copytranslation targetnode  replacementtext
tokenrewritestream replace
copytranslation targetnode gettokenstartindex
copytranslation targetnode gettokenstopindex
replacementtext
private static class translation
int tokenstopindex
string replacementtext
@override
public string tostring
return     tokenstopindex       replacementtext
private static class copytranslation
astnode targetnode
astnode sourcenode