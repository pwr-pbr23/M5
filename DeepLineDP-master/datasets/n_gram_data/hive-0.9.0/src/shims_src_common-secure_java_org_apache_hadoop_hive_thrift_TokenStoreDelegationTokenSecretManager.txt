/**
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hive thrift
import java io bytearrayinputstream
import java io bytearrayoutputstream
import java io datainputstream
import java io dataoutputstream
import java io ioexception
import java lang reflect method
import java util arrays
import java util hashmap
import java util iterator
import java util list
import java util map
import org apache commons codec binary base64
import org apache hadoop io writable
import org apache hadoop security token token
import org apache hadoop security token delegation abstractdelegationtokensecretmanager
import org apache hadoop security token delegation delegationkey
import org apache hadoop security token delegation hivedelegationtokensupport
import org apache hadoop util daemon
import org apache hadoop util stringutils
import org slf4j logger
import org slf4j loggerfactory
/**
* extension of {@link delegationtokensecretmanager} to support alternative to default in-memory
* token management for fail-over and clustering through plug-able token store (zookeeper etc.).
* delegation tokens will be retrieved from the store on-demand and (unlike base class behavior) not
* cached in memory. this avoids complexities related to token expiration. the security token is
* needed only at the time the transport is opened (as opposed to per interface operation). the
* assumption therefore is low cost of interprocess token retrieval (for random read efficient store
* such as zookeeper) compared to overhead of synchronizing per-process in-memory token caches.
* the wrapper incorporates the token store abstraction within the limitations of current
* hive/hadoop dependency (.20s) with minimum code duplication.
* eventually this should be supported by hadoop security directly.
*/
public class tokenstoredelegationtokensecretmanager extends delegationtokensecretmanager
private static final logger logger
loggerfactory getlogger tokenstoredelegationtokensecretmanager class getname
final private long keyupdateinterval
final private long tokenremoverscaninterval
private thread tokenremoverthread
final private delegationtokenstore tokenstore
public tokenstoredelegationtokensecretmanager long delegationkeyupdateinterval
long delegationtokenmaxlifetime  long delegationtokenrenewinterval
long delegationtokenremoverscaninterval
delegationtokenstore sharedstore
super delegationkeyupdateinterval  delegationtokenmaxlifetime  delegationtokenrenewinterval
delegationtokenremoverscaninterval
this keyupdateinterval   delegationkeyupdateinterval
this tokenremoverscaninterval   delegationtokenremoverscaninterval
this tokenstore   sharedstore
protected delegationtokenidentifier gettokenidentifier token<delegationtokenidentifier> token
throws ioexception
// turn bytes back into identifier for cache lookup
bytearrayinputstream buf   new bytearrayinputstream token getidentifier
datainputstream in   new datainputstream buf
delegationtokenidentifier id   createidentifier
id readfields in
return id
protected map<integer  delegationkey> reloadkeys
// read keys from token store
string allkeys   tokenstore getmasterkeys
map<integer  delegationkey> keys
new hashmap<integer  delegationkey> allkeys length
for  string keystr   allkeys
delegationkey key   new delegationkey
try
decodewritable key  keystr
keys put key getkeyid    key
catch  ioexception ex
logger error    ex
synchronized  this
super allkeys clear
super allkeys putall keys
return keys
@override
public byte retrievepassword delegationtokenidentifier identifier  throws invalidtoken
delegationtokeninformation info   this tokenstore gettoken identifier
if  info    null
throw new invalidtoken     identifier
// must reuse super as info.getpassword is not accessible
synchronized  this
try
super currenttokens put identifier  info
return super retrievepassword identifier
finally
super currenttokens remove identifier
@override
public delegationtokenidentifier canceltoken token<delegationtokenidentifier> token
string canceller  throws ioexception
delegationtokenidentifier id   gettokenidentifier token
logger info   id
this tokenstore removetoken id
return id
/**
* create the password and add it to shared store.
*/
@override
protected byte createpassword delegationtokenidentifier id
byte password
delegationtokeninformation info
synchronized  this
password   super createpassword id
// add new token to shared store
// need to persist expiration along with password
info   super currenttokens remove id
if  info    null
throw new illegalstateexception
this tokenstore addtoken id  info
return password
@override
public long renewtoken token<delegationtokenidentifier> token
string renewer  throws invalidtoken  ioexception
// since renewal is kerberos authenticated token may not be cached
final delegationtokenidentifier id   gettokenidentifier token
delegationtokeninformation tokeninfo   this tokenstore gettoken id
if  tokeninfo    null
throw new invalidtoken     id      no token found
// ensure associated master key is available
if   super allkeys containskey id getmasterkeyid
logger info
id getmasterkeyid
reloadkeys
// reuse super renewal logic
synchronized  this
super currenttokens put id   tokeninfo
try
return super renewtoken token  renewer
finally
super currenttokens remove id
public static string encodewritable writable key  throws ioexception
bytearrayoutputstream bos   new bytearrayoutputstream
dataoutputstream dos   new dataoutputstream bos
key write dos
dos flush
return base64 encodebase64urlsafestring bos tobytearray
public static void decodewritable writable w  string idstr  throws ioexception
datainputstream in   new datainputstream new bytearrayinputstream base64 decodebase64 idstr
w readfields in
/**
* synchronize master key updates / sequence generation for multiple nodes.
* note: {@link abstractdelegationtokensecretmanager} keeps currentkey private, so we need
* to utilize this "hook" to manipulate the key through the object reference.
* this .20s workaround should cease to exist when hadoop supports token store.
*/
@override
protected void logupdatemasterkey delegationkey key  throws ioexception
int keyseq   this tokenstore addmasterkey encodewritable key
// update key with assigned identifier
delegationkey keywithseq   new delegationkey keyseq  key getexpirydate    key getkey
string keystr   encodewritable keywithseq
this tokenstore updatemasterkey keyseq  keystr
decodewritable key  keystr
logger info    key getkeyid
super logupdatemasterkey key
@override
public synchronized void startthreads   throws ioexception
try
// updatecurrentkey needs to be called to initialize the master key
// (there should be a null check added in the future in rollmasterkey)
// updatecurrentkey();
method m   abstractdelegationtokensecretmanager class getdeclaredmethod
m setaccessible true
m invoke this
catch  exception e
throw new ioexception    e
running   true
tokenremoverthread   new daemon new expiredtokenremover
tokenremoverthread start
@override
public synchronized void stopthreads
if  logger isdebugenabled
logger debug
running   false
if  tokenremoverthread    null
tokenremoverthread interrupt
/**
* remove expired tokens. replaces logic in {@link abstractdelegationtokensecretmanager}
* that cannot be reused due to private method access. logic here can more efficiently
* deal with external token store by only loading into memory the minimum data needed.
*/
protected void removeexpiredtokens
long now   system currenttimemillis
iterator<delegationtokenidentifier> i   tokenstore getalldelegationtokenidentifiers
iterator
while  i hasnext
delegationtokenidentifier id   i next
if  now > id getmaxdate
this tokenstore removetoken id      no need to look at token info
else
// get token info to check renew date
delegationtokeninformation tokeninfo   tokenstore gettoken id
if  tokeninfo    null
if  now > tokeninfo getrenewdate
this tokenstore removetoken id
/**
* extension of rollmasterkey to remove expired keys from store.
* @throws ioexception
*/
protected void rollmasterkeyext   throws ioexception
map<integer  delegationkey> keys   reloadkeys
int currentkeyid   super currentid
hivedelegationtokensupport rollmasterkey tokenstoredelegationtokensecretmanager this
list<delegationkey> keysafterroll   arrays aslist getallkeys
for  delegationkey key   keysafterroll
keys remove key getkeyid
if  key getkeyid      currentkeyid
tokenstore updatemasterkey currentkeyid  encodewritable key
for  delegationkey expiredkey   keys values
logger info    expiredkey getkeyid
tokenstore removemasterkey expiredkey getkeyid
/**
* cloned from {@link abstractdelegationtokensecretmanager} to deal with private access
* restriction (there would not be an need to clone the remove thread if the remove logic was
* protected/extensible).
*/
protected class expiredtokenremover extends thread
private long lastmasterkeyupdate
private long lasttokencachecleanup
@override
public void run
logger info
tokenremoverscaninterval
60   1000
try
while  running
long now   system currenttimemillis
if  lastmasterkeyupdate   keyupdateinterval < now
try
rollmasterkeyext
lastmasterkeyupdate   now
catch  ioexception e
logger error
stringutils stringifyexception e
if  lasttokencachecleanup   tokenremoverscaninterval < now
removeexpiredtokens
lasttokencachecleanup   now
try
thread sleep 5000      5 seconds
catch  interruptedexception ie
logger
error
ie
catch  throwable t
logger error
t  t
runtime getruntime   exit  1