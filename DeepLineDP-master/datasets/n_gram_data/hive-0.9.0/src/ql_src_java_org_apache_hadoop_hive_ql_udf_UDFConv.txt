/**
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hive ql udf
import java util arrays
import org apache hadoop hive ql exec description
import org apache hadoop hive ql exec udf
import org apache hadoop io intwritable
import org apache hadoop io text
/**
* udfconv.
*
*/
@description name
value
extended
public class udfconv extends udf
private final text result   new text
private final byte value   new byte
/**
* divide x by m as if x is an unsigned 64-bit integer. examples:
* unsignedlongdiv(-1, 2) == long.max_value unsignedlongdiv(6, 3) == 2
* unsignedlongdiv(0, 5) == 0
*
* @param x
*          is treated as unsigned
* @param m
*          is treated as signed
*/
private long unsignedlongdiv long x  int m
if  x >  0
return x   m
// let uval be the value of the unsigned long with the same bits as x
// two's complement => x = uval - 2*max - 2
// => uval = x + 2*max + 2
// now, use the fact: (a+b)/c = a/c + b/c + (a%c+b%c)/c
return x   m   2    long max_value   m    2   m
x % m   2    long max_value % m    2 % m    m
/**
* decode val into value[].
*
* @param val
*          is treated as an unsigned 64-bit integer
* @param radix
*          must be between min_radix and max_radix
*/
private void decode long val  int radix
arrays fill value   byte  0
for  int i   value length   1  val    0  i
long q   unsignedlongdiv val  radix
value    byte   val   q   radix
val   q
/**
* convert value[] into a long. on overflow, return -1 (as mysql does). if a
* negative digit is found, ignore the suffix starting there.
*
* @param radix
*          must be between min_radix and max_radix
* @param frompos
*          is the first element that should be conisdered
* @return the result should be treated as an unsigned 64-bit integer.
*/
private long encode int radix  int frompos
long val   0
long bound   unsignedlongdiv  1   radix  radix      possible overflow once
// val
// exceeds this value
for  int i   frompos  i < value length    value >  0  i
if  val >  bound
// check for overflow
if  unsignedlongdiv  1   value  radix  < val
return  1
val   val   radix   value
return val
/**
* convert the bytes in value[] to the corresponding chars.
*
* @param radix
*          must be between min_radix and max_radix
* @param frompos
*          is the first nonzero element
*/
private void byte2char int radix  int frompos
for  int i   frompos  i < value length  i
value    byte  character touppercase character fordigit value
radix
/**
* convert the chars in value[] to the corresponding integers. convert invalid
* characters to -1.
*
* @param radix
*          must be between min_radix and max_radix
* @param frompos
*          is the first nonzero element
*/
private void char2byte int radix  int frompos
for  int i   frompos  i < value length  i
value    byte  character digit value  radix
/**
* convert numbers between different number bases. if tobase>0 the result is
* unsigned, otherwise it is signed.
*
*/
public text evaluate text n  intwritable frombase  intwritable tobase
if  n    null    frombase    null    tobase    null
return null
int frombs   frombase get
int tobs   tobase get
if  frombs < character min_radix    frombs > character max_radix
math abs tobs  < character min_radix
math abs tobs  > character max_radix
return null
byte num   n getbytes
boolean negative    num
int first   0
if  negative
first   1
// copy the digits in the right side of the array
for  int i   1  i <  n getlength     first  i
value   num
char2byte frombs  value length   n getlength     first
// do the conversion by going through a 64 bit integer
long val   encode frombs  value length   n getlength     first
if  negative    tobs > 0
if  val < 0
val    1
else
val    val
if  tobs < 0    val < 0
val    val
negative   true
decode val  math abs tobs
// find the first non-zero digit or the last digits if all are zero.
for  first   0  first < value length   1    value    0  first
byte2char math abs tobs   first
if  negative    tobs < 0
value
result set value  first  value length   first
return result