/**
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hive ql lib
import java io serializable
import java util arraylist
import java util collection
import java util hashmap
import java util hashset
import java util list
import java util set
import java util stack
import org apache hadoop hive ql exec conditionaltask
import org apache hadoop hive ql exec task
import org apache hadoop hive ql parse semanticexception
/**
* base class for operator graph walker this class takes list of starting ops
* and walks them one by one. it maintains list of walked operators
* (dispatchedlist) and a list of operators that are discovered but not yet
* dispatched
*/
public class taskgraphwalker implements graphwalker
public class taskgraphwalkercontext
private final hashmap<node  object> remap
public taskgraphwalkercontext hashmap<node  object> remap
this remap   remap
public void addtodispatchlist node dispatchedobj
if dispatchedobj    null
retmap put dispatchedobj  null
protected stack<node> opstack
private final list<node> towalk   new arraylist<node>
private final hashmap<node  object> retmap   new hashmap<node  object>
private final dispatcher dispatcher
private final  taskgraphwalkercontext walkerctx
/**
* constructor.
*
* @param disp
*          dispatcher to call for each op encountered
*/
public taskgraphwalker dispatcher disp
dispatcher   disp
opstack   new stack<node>
walkerctx   new taskgraphwalkercontext retmap
/**
* @return the towalk
*/
public list<node> gettowalk
return towalk
/**
* @return the donelist
*/
public set<node> getdispatchedlist
return retmap keyset
/**
* dispatch the current operator.
*
* @param nd
*          node being walked
* @param ndstack
*          stack of nodes encountered
* @throws semanticexception
*/
public void dispatch node nd  stack<node> ndstack taskgraphwalkercontext walkerctx  throws semanticexception
object nodeoutputs   null
if  nd getchildren      null
nodeoutputs   new object
nodeoutputs   walkerctx
int i   1
for  node child   nd getchildren
nodeoutputs   retmap get child
else
nodeoutputs   new object
nodeoutputs   walkerctx
object retval   dispatcher dispatch nd  ndstack  nodeoutputs
retmap put nd  retval
public void dispatch node nd  stack<node> ndstack  throws semanticexception
object nodeoutputs   null
if  nd getchildren      null
nodeoutputs   new object
int i   1
for  node child   nd getchildren
nodeoutputs   retmap get child
object retval   dispatcher dispatch nd  ndstack  nodeoutputs
retmap put nd  retval
/**
* starting point for walking.
*
* @throws semanticexception
*/
public void startwalking collection<node> startnodes
hashmap<node  object> nodeoutput  throws semanticexception
towalk addall startnodes
while  towalk size   > 0
node nd   towalk remove 0
walk nd
if  nodeoutput    null
nodeoutput put nd  retmap get nd
/**
* walk the current operator and its descendants.
*
* @param nd
*          current operator in the graph
* @throws semanticexception
*/
public void walk node nd  throws semanticexception
if   nd instanceof task
throw new semanticexception
if  getdispatchedlist   contains nd
return
if  opstack empty      nd    opstack peek
opstack push nd
list<task<? extends serializable>> nexttasklist   null
set<task<? extends serializable>> nexttaskset   new hashset<task<? extends serializable>>
list<task<? extends serializable>> tasklistinconditionaltask   null
if nd instanceof conditionaltask
//for conditional task, next task list should return the children tasks of each task, which
//is contained in the conditional task.
tasklistinconditionaltask     conditionaltask  nd  getlisttasks
for task<? extends serializable> tsk  tasklistinconditionaltask
list<task<? extends serializable>> childtask   tsk getchildtasks
if childtask    null
nexttaskset addall tsk getchildtasks
//convert the set into list
if nexttaskset size  >0
nexttasklist   new arraylist<task<? extends serializable>>
for task<? extends serializable> tsk nexttaskset
nexttasklist add tsk
else
//for other tasks, just return its children tasks
nexttasklist     task<? extends serializable> nd  getchildtasks
if   nexttasklist    null
getdispatchedlist   containsall nexttasklist
dispatch nd  opstack this walkerctx
opstack pop
return
// add children, self to the front of the queue in that order
gettowalk   add 0  nd
gettowalk   removeall nexttasklist
gettowalk   addall 0  nexttasklist