/**
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hive ql optimizer physical
import java io serializable
import java util arraylist
import java util hashmap
import java util linkedhashmap
import java util list
import java util map
import java util stack
import org apache hadoop hive ql context
import org apache hadoop hive ql exec conditionaltask
import org apache hadoop hive ql exec mapredlocaltask
import org apache hadoop hive ql exec operator
import org apache hadoop hive ql exec task
import org apache hadoop hive ql exec taskfactory
import org apache hadoop hive ql exec utilities
import org apache hadoop hive ql lib defaultgraphwalker
import org apache hadoop hive ql lib defaultruledispatcher
import org apache hadoop hive ql lib dispatcher
import org apache hadoop hive ql lib graphwalker
import org apache hadoop hive ql lib node
import org apache hadoop hive ql lib nodeprocessor
import org apache hadoop hive ql lib nodeprocessorctx
import org apache hadoop hive ql lib rule
import org apache hadoop hive ql lib ruleregexp
import org apache hadoop hive ql lib taskgraphwalker
import org apache hadoop hive ql parse parsecontext
import org apache hadoop hive ql parse semanticexception
import org apache hadoop hive ql plan conditionalresolver
import org apache hadoop hive ql plan conditionalresolvercommonjoin
import org apache hadoop hive ql plan conditionalresolverskewjoin
import org apache hadoop hive ql plan conditionalwork
import org apache hadoop hive ql plan mapredlocalwork
import org apache hadoop hive ql plan mapredwork
import org apache hadoop hive ql plan conditionalresolvercommonjoin conditionalresolvercommonjoinctx
import org apache hadoop hive ql plan conditionalresolverskewjoin conditionalresolverskewjoinctx
/**
* an implementation of physicalplanresolver. it iterator each mapredtask to see whether the task
* has a local map work if it has, it will move the local work to a new local map join task. then it
* will make this new generated task depends on current task's parent task and make current task
* depends on this new generated task.
*/
public class mapjoinresolver implements physicalplanresolver
@override
public physicalcontext resolve physicalcontext pctx  throws semanticexception
// create dispatcher and graph walker
dispatcher disp   new localmapjointaskdispatcher pctx
taskgraphwalker ogw   new taskgraphwalker disp
// get all the tasks nodes from root task
arraylist<node> topnodes   new arraylist<node>
topnodes addall pctx roottasks
// begin to walk through the task tree.
ogw startwalking topnodes  null
return pctx
/**
* iterator each tasks. if this task has a local work,create a new task for this local work, named
* mapredlocaltask. then make this new generated task depends on current task's parent task, and
* make current task depends on this new generated task
*/
class localmapjointaskdispatcher implements dispatcher
private physicalcontext physicalcontext
public localmapjointaskdispatcher physicalcontext context
super
physicalcontext   context
private void processcurrenttask task<? extends serializable> currtask
conditionaltask conditionaltask  throws semanticexception
// get current mapred work and its local work
mapredwork mapredwork    mapredwork  currtask getwork
mapredlocalwork localwork   mapredwork getmaplocalwork
if  localwork    null
// get the context info and set up the shared tmp uri
context ctx   physicalcontext getcontext
string tmpfileuri   utilities generatetmpuri ctx getlocaltmpfileuri    currtask getid
localwork settmpfileuri tmpfileuri
string hdfstmpuri   utilities generatetmpuri ctx getmrtmpfileuri    currtask getid
mapredwork settmphdfsfileuri hdfstmpuri
// create a task for this local work; right now, this local work is shared
// by the original mapredtask and this new generated mapredlocaltask.
mapredlocaltask localtask    mapredlocaltask  taskfactory get localwork  physicalcontext
getparsecontext   getconf
// set the backup task from curr task
localtask setbackuptask currtask getbackuptask
localtask setbackupchildrentasks currtask getbackupchildrentasks
currtask setbackupchildrentasks null
currtask setbackuptask null
if  currtask gettasktag      task converted_mapjoin
localtask settasktag task converted_local_mapjoin
else
localtask settasktag task local_mapjoin
// replace the map join operator to local_map_join operator in the operator tree
// and return all the dummy parent
localmapjoinprocctx  localmapjoinprocctx  adjustlocaltask localtask
list<operator<? extends serializable>> dummyops   localmapjoinprocctx getdummyparentop
// create new local work and setup the dummy ops
mapredlocalwork newlocalwork   new mapredlocalwork
newlocalwork setdummyparentop dummyops
newlocalwork settmpfileuri tmpfileuri
newlocalwork setinputfilechangesensitive localwork getinputfilechangesensitive
mapredwork setmaplocalwork newlocalwork
// get all parent tasks
list<task<? extends serializable>> parenttasks   currtask getparenttasks
currtask setparenttasks null
if  parenttasks    null
for  task<? extends serializable> tsk   parenttasks
// make new generated task depends on all the parent tasks of current task.
tsk adddependenttask localtask
// remove the current task from its original parent task's dependent task
tsk removedependenttask currtask
else
// in this case, current task is in the root tasks
// so add this new task into root tasks and remove the current task from root tasks
if  conditionaltask    null
physicalcontext addtoroottask localtask
physicalcontext removefromroottask currtask
else
// set list task
list<task<? extends serializable>> listtask   conditionaltask getlisttasks
conditionalwork conditionalwork   conditionaltask getwork
int index   listtask indexof currtask
listtask set index  localtask
// set list work
list<serializable> listwork    list<serializable>  conditionalwork getlistworks
index   listwork indexof mapredwork
listwork set index   serializable  localwork
conditionalwork setlistworks listwork
conditionalresolver resolver   conditionaltask getresolver
if  resolver instanceof conditionalresolverskewjoin
// get bigkeysdirtotaskmap
conditionalresolverskewjoinctx context    conditionalresolverskewjoinctx  conditionaltask
getresolverctx
hashmap<string  task<? extends serializable>> bigkeysdirtotaskmap   context
getdirtotaskmap
// to avoid concurrent modify the hashmap
hashmap<string  task<? extends serializable>> newbigkeysdirtotaskmap   new hashmap<string  task<? extends serializable>>
// reset the resolver
for  map entry<string  task<? extends serializable>> entry   bigkeysdirtotaskmap
entryset
task<? extends serializable> task   entry getvalue
string key   entry getkey
if  task equals currtask
newbigkeysdirtotaskmap put key  localtask
else
newbigkeysdirtotaskmap put key  task
context setdirtotaskmap newbigkeysdirtotaskmap
conditionaltask setresolverctx context
else if  resolver instanceof conditionalresolvercommonjoin
// get bigkeysdirtotaskmap
conditionalresolvercommonjoinctx context    conditionalresolvercommonjoinctx  conditionaltask
getresolverctx
hashmap<string  task<? extends serializable>> aliastowork   context getaliastotask
// to avoid concurrent modify the hashmap
hashmap<string  task<? extends serializable>> newaliastowork   new hashmap<string  task<? extends serializable>>
// reset the resolver
for  map entry<string  task<? extends serializable>> entry   aliastowork entryset
task<? extends serializable> task   entry getvalue
string key   entry getkey
if  task equals currtask
newaliastowork put key  localtask
else
newaliastowork put key  task
context setaliastotask newaliastowork
conditionaltask setresolverctx context
// make current task depends on this new generated localmapjointask
// now localtask is the parent task of the current task
localtask adddependenttask currtask
@override
public object dispatch node nd  stack<node> stack  object    nodeoutputs
throws semanticexception
task<? extends serializable> currtask    task<? extends serializable>  nd
// not map reduce task or not conditional task, just skip
if  currtask ismapredtask
if  currtask instanceof conditionaltask
// get the list of task
list<task<? extends serializable>> tasklist     conditionaltask  currtask  getlisttasks
for  task<? extends serializable> tsk   tasklist
if  tsk ismapredtask
this processcurrenttask tsk    conditionaltask  currtask
else
this processcurrenttask currtask  null
return null
// replace the map join operator to local_map_join operator in the operator tree
private localmapjoinprocctx adjustlocaltask mapredlocaltask task
throws semanticexception
localmapjoinprocctx localmapjoinprocctx   new localmapjoinprocctx task  physicalcontext
getparsecontext
map<rule  nodeprocessor> oprules   new linkedhashmap<rule  nodeprocessor>
oprules put new ruleregexp        localmapjoinprocfactory getjoinproc
// the dispatcher fires the processor corresponding to the closest
// matching rule and passes the context along
dispatcher disp   new defaultruledispatcher localmapjoinprocfactory getdefaultproc
oprules  localmapjoinprocctx
graphwalker ogw   new defaultgraphwalker disp
// iterator the reducer operator tree
arraylist<node> topnodes   new arraylist<node>
topnodes addall task getwork   getaliastowork   values
ogw startwalking topnodes  null
return localmapjoinprocctx
public physicalcontext getphysicalcontext
return physicalcontext
public void setphysicalcontext physicalcontext physicalcontext
this physicalcontext   physicalcontext
/**
* a container of current task and parse context.
*/
public static class localmapjoinprocctx implements nodeprocessorctx
private task<? extends serializable> currenttask
private parsecontext parsectx
private list<operator<? extends serializable>> dummyparentop   null
private boolean isfollowedbygroupby
public localmapjoinprocctx task<? extends serializable> task  parsecontext parsectx
currenttask   task
this parsectx   parsectx
dummyparentop   new arraylist<operator<? extends serializable>>
isfollowedbygroupby   false
public task<? extends serializable> getcurrenttask
return currenttask
public void setcurrenttask task<? extends serializable> currenttask
this currenttask   currenttask
public boolean isfollowedbygroupby
return isfollowedbygroupby
public void setfollowedbygroupby boolean isfollowedbygroupby
this isfollowedbygroupby   isfollowedbygroupby
public parsecontext getparsectx
return parsectx
public void setparsectx parsecontext parsectx
this parsectx   parsectx
public void setdummyparentop list<operator<? extends serializable>> op
this dummyparentop   op
public list<operator<? extends serializable>> getdummyparentop
return this dummyparentop
public void adddummyparentop operator<? extends serializable> op
this dummyparentop add op