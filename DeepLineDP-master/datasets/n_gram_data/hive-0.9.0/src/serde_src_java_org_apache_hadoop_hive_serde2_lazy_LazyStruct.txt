/**
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hive serde2 lazy
import java util arraylist
import java util arrays
import java util list
import org apache commons logging log
import org apache commons logging logfactory
import org apache hadoop hive serde2 serdestatsstruct
import org apache hadoop hive serde2 lazy objectinspector lazysimplestructobjectinspector
import org apache hadoop hive serde2 objectinspector structfield
import org apache hadoop hive serde2 objectinspector structobjectinspector
import org apache hadoop io text
/**
* lazyobject for storing a struct. the field of a struct can be primitive or
* non-primitive.
*
* lazystruct does not deal with the case of a null struct. that is handled by
* the parent lazyobject.
*/
public class lazystruct extends lazynonprimitive<lazysimplestructobjectinspector> implements
serdestatsstruct
private static log log   logfactory getlog lazystruct class getname
/**
* whether the data is already parsed or not.
*/
boolean parsed
/**
* size of serialized data
*/
long serializedsize
/**
* the start positions of struct fields. only valid when the data is parsed.
* note that startposition[arraylength] = begin + length + 1; that makes sure
* we can use the same formula to compute the length of each element of the
* array.
*/
int startposition
/**
* the fields of the struct.
*/
lazyobject fields
/**
* whether init() has been called on the field or not.
*/
boolean fieldinited
/**
* construct a lazystruct object with the objectinspector.
*/
public lazystruct lazysimplestructobjectinspector oi
super oi
/**
* set the row data for this lazystruct.
*
* @see lazyobject#init(bytearrayref, int, int)
*/
@override
public void init bytearrayref bytes  int start  int length
super init bytes  start  length
parsed   false
serializedsize   length
boolean missingfieldwarned   false
boolean extrafieldwarned   false
/**
* parse the byte[] and fill each field.
*/
private void parse
byte separator   oi getseparator
boolean lastcolumntakesrest   oi getlastcolumntakesrest
boolean isescaped   oi isescaped
byte escapechar   oi getescapechar
if  fields    null
list<? extends structfield> fieldrefs     structobjectinspector  oi
getallstructfieldrefs
fields   new lazyobject
for  int i   0  i < fields length  i
fields   lazyfactory createlazyobject fieldrefs get i
getfieldobjectinspector
fieldinited   new boolean
// extra element to make sure we have the same formula to compute the
// length of each element of the array.
startposition   new int
int structbyteend   start   length
int fieldid   0
int fieldbytebegin   start
int fieldbyteend   start
byte bytes   this bytes getdata
// go through all bytes in the byte[]
while  fieldbyteend <  structbyteend
if  fieldbyteend    structbyteend    bytes    separator
// reached the end of a field?
if  lastcolumntakesrest    fieldid    fields length   1
fieldbyteend   structbyteend
startposition   fieldbytebegin
fieldid
if  fieldid    fields length    fieldbyteend    structbyteend
// all fields have been parsed, or bytes have been parsed.
// we need to set the startposition of fields.length to ensure we
// can use the same formula to calculate the length of each field.
// for missing fields, their starting positions will all be the same,
// which will make their lengths to be -1 and uncheckedgetfield will
// return these fields as nulls.
for  int i   fieldid  i <  fields length  i
startposition   fieldbyteend   1
break
fieldbytebegin   fieldbyteend   1
fieldbyteend
else
if  isescaped    bytes    escapechar
fieldbyteend   1 < structbyteend
// ignore the char after escape_char
fieldbyteend    2
else
fieldbyteend
// extra bytes at the end?
if   extrafieldwarned    fieldbyteend < structbyteend
extrafieldwarned   true
log warn
// missing fields?
if   missingfieldwarned    fieldid < fields length
missingfieldwarned   true
log info     fields length
fieldid
arrays fill fieldinited  false
parsed   true
/**
* get one field out of the struct.
*
* if the field is a primitive field, return the actual object. otherwise
* return the lazyobject. this is because primitiveobjectinspector does not
* have control over the object used by the user - the user simply directly
* use the object instead of going through object
* primitiveobjectinspector.get(object).
*
* @param fieldid
*          the field id
* @return the field as a lazyobject
*/
public object getfield int fieldid
if   parsed
parse
return uncheckedgetfield fieldid
/**
* get the field out of the row without checking parsed. this is called by
* both getfield and getfieldsaslist.
*
* @param fieldid
*          the id of the field starting from 0.
* @param nullsequence
*          the sequence representing null value.
* @return the value of the field
*/
private object uncheckedgetfield int fieldid
text nullsequence   oi getnullsequence
// test the length first so in most cases we avoid doing a byte[]
// comparison.
int fieldbytebegin   startposition
int fieldlength   startposition   startposition   1
if   fieldlength < 0
fieldlength    nullsequence getlength      lazyutils compare bytes
getdata    fieldbytebegin  fieldlength  nullsequence getbytes
0  nullsequence getlength       0
return null
if   fieldinited
fieldinited   true
fields init bytes  fieldbytebegin  fieldlength
return fields getobject
arraylist<object> cachedlist
/**
* get the values of the fields as an arraylist.
*
* @return the values of the fields as an arraylist.
*/
public arraylist<object> getfieldsaslist
if   parsed
parse
if  cachedlist    null
cachedlist   new arraylist<object>
else
cachedlist clear
for  int i   0  i < fields length  i
cachedlist add uncheckedgetfield i
return cachedlist
@override
public object getobject
return this
protected boolean getparsed
return parsed
protected void setparsed boolean parsed
this parsed   parsed
protected lazyobject getfields
return fields
protected void setfields lazyobject fields
this fields   fields
protected boolean getfieldinited
return fieldinited
protected void setfieldinited boolean fieldinited
this fieldinited   fieldinited
public long getrawdataserializedsize
return serializedsize