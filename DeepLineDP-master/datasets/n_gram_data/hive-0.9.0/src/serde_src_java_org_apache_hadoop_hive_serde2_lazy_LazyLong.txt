/**
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hive serde2 lazy
import java io ioexception
import java io outputstream
import org apache hadoop hive serde2 lazy objectinspector primitive lazylongobjectinspector
import org apache hadoop io longwritable
/**
* lazyobject for storing a value of long.
*
* <p>
* part of the code is adapted from apache harmony project.
*
* as with the specification, this implementation relied on code laid out in <a
* href="http://www.hackersdelight.org/">henry s. warren, jr.'s hacker's
* delight, (addison wesley, 2002)</a> as well as <a
* href="http://aggregate.org/magic/">the aggregate's magic algorithms</a>.
* </p>
*
*/
public class lazylong extends
lazyprimitive<lazylongobjectinspector  longwritable>
public lazylong lazylongobjectinspector oi
super oi
data   new longwritable
public lazylong lazylong copy
super copy
data   new longwritable copy data get
@override
public void init bytearrayref bytes  int start  int length
try
data set parselong bytes getdata    start  length  10
isnull   false
catch  numberformatexception e
isnull   true
logexceptionmessage bytes  start  length
/**
* parses the string argument as if it was a long value and returns the
* result. throws numberformatexception if the string does not represent a
* long quantity.
*
* @param bytes
* @param start
* @param length
*          a utf-8 encoded string representation of a long quantity.
* @return long the value represented by the argument
* @exception numberformatexception
*              if the argument could not be parsed as a long quantity.
*/
public static long parselong byte bytes  int start  int length
return parselong bytes  start  length  10
/**
* parses the string argument as if it was an long value and returns the
* result. throws numberformatexception if the string does not represent an
* long quantity. the second argument specifies the radix to use when parsing
* the value.
*
* @param bytes
* @param start
* @param length
*          a utf-8 encoded string representation of a long quantity.
* @param radix
*          the base to use for conversion.
* @return the value represented by the argument
* @exception numberformatexception
*              if the argument could not be parsed as an long quantity.
*/
public static long parselong byte bytes  int start  int length  int radix
if  bytes    null
throw new numberformatexception
if  radix < character min_radix    radix > character max_radix
throw new numberformatexception     radix
if  length    0
throw new numberformatexception
int offset   start
boolean negative   bytes
if  negative    bytes
offset
if  length    1
throw new numberformatexception lazyutils converttostring bytes  start
length
return parse bytes  start  length  offset  radix  negative
/**
* /** parses the string argument as if it was an long value and returns the
* result. throws numberformatexception if the string does not represent an
* long quantity. the second argument specifies the radix to use when parsing
* the value.
*
* @param bytes
* @param start
* @param length
*          a utf-8 encoded string representation of a long quantity.
* @param offset
*          the starting position after the sign (if exists)
* @param radix
*          the base to use for conversion.
* @param negative
*          whether the number is negative.
* @return the value represented by the argument
* @exception numberformatexception
*              if the argument could not be parsed as an long quantity.
*/
private static long parse byte bytes  int start  int length  int offset
int radix  boolean negative
long max   long min_value   radix
long result   0  end   start   length
while  offset < end
int digit   lazyutils digit bytes  radix
if  digit     1    max > result
throw new numberformatexception lazyutils converttostring bytes  start
length
long next   result   radix   digit
if  next > result
throw new numberformatexception lazyutils converttostring bytes  start
length
result   next
if   negative
result    result
if  result < 0
throw new numberformatexception lazyutils converttostring bytes  start
length
return result
/**
* writes out the text representation of an integer using base 10 to an
* outputstream in utf-8 encoding.
*
* note: division by a constant (like 10) is much faster than division by a
* variable. that's one of the reasons that we don't make radix a parameter
* here.
*
* @param out
*          the outputstream to write to
* @param i
*          an int to write out
* @throws ioexception
*/
public static void writeutf8 outputstream out  long i  throws ioexception
if  i    0
out write
return
boolean negative   i < 0
if  negative
out write
else
// negative range is bigger than positive range, so there is no risk
// of overflow here.
i    i
long start   1000000000000000000l
while  i   start    0
start    10
while  start > 0
out write      int    i   start  % 10
start    10
public static void writeutf8noexception outputstream out  long i
try
writeutf8 out  i
catch  ioexception e
throw new runtimeexception e