/**
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hive ql optimizer ppr
import java util arraylist
import java util hashmap
import java util linkedhashmap
import java util list
import java util map
import java util stack
import org apache hadoop hive ql exec functionregistry
import org apache hadoop hive ql lib defaultgraphwalker
import org apache hadoop hive ql lib defaultruledispatcher
import org apache hadoop hive ql lib dispatcher
import org apache hadoop hive ql lib graphwalker
import org apache hadoop hive ql lib node
import org apache hadoop hive ql lib nodeprocessor
import org apache hadoop hive ql lib nodeprocessorctx
import org apache hadoop hive ql lib rule
import org apache hadoop hive ql lib ruleregexp
import org apache hadoop hive ql parse semanticexception
import org apache hadoop hive ql plan exprnodecolumndesc
import org apache hadoop hive ql plan exprnodeconstantdesc
import org apache hadoop hive ql plan exprnodedesc
import org apache hadoop hive ql plan exprnodefielddesc
import org apache hadoop hive ql plan exprnodegenericfuncdesc
import org apache hadoop hive ql plan exprnodenulldesc
/**
* expression processor factory for partition pruning. each processor tries to
* convert the expression subtree into a partition pruning expression. this
* expression is then used to figure out whether a particular partition should
* be scanned or not.
*/
public final class exprprocfactory
private exprprocfactory
// prevent instantiation
/**
* processor for column expressions.
*/
public static class columnexprprocessor implements nodeprocessor
@override
public object process node nd  stack<node> stack  nodeprocessorctx procctx
object    nodeoutputs  throws semanticexception
exprnodedesc newcd   null
exprnodecolumndesc cd    exprnodecolumndesc  nd
exprprocctx epc    exprprocctx  procctx
if  cd gettabalias   equalsignorecase epc gettabalias
cd getispartitioncolorvirtualcol
newcd   cd clone
else
newcd   new exprnodeconstantdesc cd gettypeinfo    null
epc sethasnonpartcols true
return newcd
/**
* if all children are candidates and refer only to one table alias then this
* expr is a candidate else it is not a candidate but its children could be
* final candidates.
*/
public static class genericfuncexprprocessor implements nodeprocessor
@override
public object process node nd  stack<node> stack  nodeprocessorctx procctx
object    nodeoutputs  throws semanticexception
exprnodedesc newfd   null
exprnodegenericfuncdesc fd    exprnodegenericfuncdesc  nd
boolean unknown   false
if  functionregistry isopandornot fd
// do nothing because "and" and "or" and "not" supports null value
// evaluation
// note: in the future all udfs that treats null value as unknown (both
// in parameters and return
// values) should derive from a common base class udfnullasunknown, so
// instead of listing the classes
// here we would test whether a class is derived from that base class.
// if all childs are null, set unknown to true
boolean isallnull   true
for  object child   nodeoutputs
exprnodedesc child_nd    exprnodedesc  child
if    child_nd instanceof exprnodeconstantdesc
exprnodeconstantdesc  child_nd  getvalue      null
isallnull   false
unknown   isallnull
else if   functionregistry isdeterministic fd getgenericudf
// if it's a non-deterministic udf, set unknown to true
unknown   true
else
// if any child is null, set unknown to true
for  object child   nodeoutputs
exprnodedesc child_nd    exprnodedesc  child
if  child_nd instanceof exprnodeconstantdesc
exprnodeconstantdesc  child_nd  getvalue      null
unknown   true
if  unknown
newfd   new exprnodeconstantdesc fd gettypeinfo    null
else
// create the list of children
arraylist<exprnodedesc> children   new arraylist<exprnodedesc>
for  object child   nodeoutputs
children add  exprnodedesc  child
// create a copy of the function descriptor
newfd   new exprnodegenericfuncdesc fd gettypeinfo    fd
getgenericudf    children
return newfd
/**
* fieldexprprocessor.
*
*/
public static class fieldexprprocessor implements nodeprocessor
@override
public object process node nd  stack<node> stack  nodeprocessorctx procctx
object    nodeoutputs  throws semanticexception
exprnodefielddesc fnd    exprnodefielddesc  nd
boolean unknown   false
int idx   0
exprnodedesc left_nd   null
for  object child   nodeoutputs
exprnodedesc child_nd    exprnodedesc  child
if  child_nd instanceof exprnodeconstantdesc
exprnodeconstantdesc  child_nd  getvalue      null
unknown   true
left_nd   child_nd
assert  idx    0
exprnodedesc newnd   null
if  unknown
newnd   new exprnodeconstantdesc fnd gettypeinfo    null
else
newnd   new exprnodefielddesc fnd gettypeinfo    left_nd  fnd
getfieldname    fnd getislist
return newnd
/**
* processor for constants and null expressions. for such expressions the
* processor simply clones the exprnodedesc and returns it.
*/
public static class defaultexprprocessor implements nodeprocessor
@override
public object process node nd  stack<node> stack  nodeprocessorctx procctx
object    nodeoutputs  throws semanticexception
if  nd instanceof exprnodeconstantdesc
return   exprnodeconstantdesc  nd  clone
else if  nd instanceof exprnodenulldesc
return   exprnodenulldesc  nd  clone
assert  false
return null
public static nodeprocessor getdefaultexprprocessor
return new defaultexprprocessor
public static nodeprocessor getgenericfuncprocessor
return new genericfuncexprprocessor
public static nodeprocessor getfieldprocessor
return new fieldexprprocessor
public static nodeprocessor getcolumnprocessor
return new columnexprprocessor
/**
* generates the partition pruner for the expression tree.
*
* @param tabalias
*          the table alias of the partition table that is being considered
*          for pruning
* @param pred
*          the predicate from which the partition pruner needs to be
*          generated
* @return hasnonpartcols returns true/false depending upon whether this pred
*         has a non partition column
* @throws semanticexception
*/
public static exprnodedesc genpruner string tabalias  exprnodedesc pred
boolean hasnonpartcols  throws semanticexception
// create the walker, the rules dispatcher and the context.
exprprocctx pprctx   new exprprocctx tabalias
// create a walker which walks the tree in a dfs manner while maintaining
// the operator stack. the dispatcher
// generates the plan from the operator tree
map<rule  nodeprocessor> exprrules   new linkedhashmap<rule  nodeprocessor>
exprrules put
new ruleregexp    exprnodecolumndesc class getname
getcolumnprocessor
exprrules put
new ruleregexp    exprnodefielddesc class getname
getfieldprocessor
exprrules put new ruleregexp    exprnodegenericfuncdesc class getname
getgenericfuncprocessor
// the dispatcher fires the processor corresponding to the closest matching
// rule and passes the context along
dispatcher disp   new defaultruledispatcher getdefaultexprprocessor
exprrules  pprctx
graphwalker egw   new defaultgraphwalker disp
list<node> startnodes   new arraylist<node>
startnodes add pred
hashmap<node  object> outputmap   new hashmap<node  object>
egw startwalking startnodes  outputmap
hasnonpartcols   pprctx gethasnonpartcols
// get the exprnodedesc corresponding to the first start node;
return  exprnodedesc  outputmap get pred