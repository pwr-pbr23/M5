/**
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hive ql optimizer
import java io serializable
import java util arraylist
import java util list
import java util map
import java util stack
import org apache hadoop hive conf hiveconf
import org apache hadoop hive ql context
import org apache hadoop hive ql exec abstractmapjoinoperator
import org apache hadoop hive ql exec operator
import org apache hadoop hive ql exec operatorfactory
import org apache hadoop hive ql exec task
import org apache hadoop hive ql exec taskfactory
import org apache hadoop hive ql exec unionoperator
import org apache hadoop hive ql lib node
import org apache hadoop hive ql lib nodeprocessor
import org apache hadoop hive ql lib nodeprocessorctx
import org apache hadoop hive ql optimizer genmrproccontext genmrmapjoinctx
import org apache hadoop hive ql optimizer genmrproccontext genmrunionctx
import org apache hadoop hive ql optimizer genmrproccontext genmapredctx
import org apache hadoop hive ql optimizer unionproc unionproccontext
import org apache hadoop hive ql optimizer unionproc unionprocfactory
import org apache hadoop hive ql optimizer unionproc unionproccontext unionparsecontext
import org apache hadoop hive ql parse parsecontext
import org apache hadoop hive ql parse semanticexception
import org apache hadoop hive ql plan filesinkdesc
import org apache hadoop hive ql plan mapjoindesc
import org apache hadoop hive ql plan mapredwork
import org apache hadoop hive ql plan partitiondesc
import org apache hadoop hive ql plan planutils
import org apache hadoop hive ql plan tabledesc
import org apache hadoop hive ql plan tablescandesc
/**
* processor for the rule - tablescan followed by union.
*/
public class genmrunion1 implements nodeprocessor
public genmrunion1
/**
* process the union if all sub-queries are map-only
*
* @return
* @throws semanticexception
*/
private object processmaponlyunion unionoperator union  stack<node> stack
genmrproccontext ctx  unionproccontext uctx  throws semanticexception
// merge currtask from multiple topops
genmrunionctx uctxtask   ctx getuniontask union
if  uctxtask    null
// get task associated with this union
task<? extends serializable> utask   ctx getuniontask union  getutask
if  utask    null
if  ctx getcurrtask      null    ctx getcurrtask      utask
// if ctx.getcurrtask() is in roottasks, should be removed
ctx getroottasks   remove ctx getcurrtask
ctx setcurrtask utask
unionparsecontext uprsctx   uctx getunionparsecontext union
if   uprsctx    null      uprsctx getmapjoinquery
genmapredutils mergemapjoinunion union  ctx
unionprocfactory getpositionparent union  stack
else
ctx getmapcurrctx   put
operator<? extends serializable>  union
new genmapredctx ctx getcurrtask    ctx getcurrtopop
ctx getcurraliasid
// if the union is the first time seen, set current task to genmrunionctx
uctxtask   ctx getuniontask union
if  uctxtask    null
uctxtask   new genmrunionctx
uctxtask setutask ctx getcurrtask
ctx setuniontask union  uctxtask
task<? extends serializable> utask ctx getcurrtask
if  utask getparenttasks      null
utask getparenttasks   isempty
if   ctx getroottasks   contains utask
ctx getroottasks   add utask
return null
/**
* process the union when the parent is a map-reduce job. create a temporary
* output, and let the union task read from the temporary output.
*
* the files created for all the inputs are in the union context and later
* used to initialize the union plan
*
* @param parent
* @param child
* @param utask
* @param ctx
* @param uctxtask
*/
private void processsubqueryunioncreateintermediate
operator<? extends serializable> parent
operator<? extends serializable> child
task<? extends serializable> utask  genmrproccontext ctx
genmrunionctx uctxtask
parsecontext parsectx   ctx getparsectx
tabledesc tt_desc   planutils getintermediatefiletabledesc planutils getfieldschemasfromrowschema
parent getschema
// generate the temporary file
context basectx   parsectx getcontext
string tasktmpdir   basectx getmrtmpfileuri
// create a file sink operator for this file name
operator<? extends serializable> fs_op   operatorfactory get
new filesinkdesc tasktmpdir  tt_desc  parsectx getconf   getboolvar
hiveconf confvars compressintermediate    parent getschema
assert parent getchildoperators   size      1
parent getchildoperators   set 0  fs_op
list<operator<? extends serializable>> parentoplist   new arraylist<operator<? extends serializable>>
parentoplist add parent
fs_op setparentoperators parentoplist
// create a dummy table scan operator
operator<? extends serializable> ts_op   operatorfactory get
new tablescandesc    parent getschema
list<operator<? extends serializable>> childoplist   new arraylist<operator<? extends serializable>>
childoplist add child
ts_op setchildoperators childoplist
child replaceparent parent  ts_op
// add the path to alias mapping
uctxtask addtasktmpdir tasktmpdir
uctxtask addttdesc tt_desc
uctxtask addlisttopoperators ts_op
// the union task is empty. the files created for all the inputs are
// assembled in the union context and later used to initialize the union
// plan
task<? extends serializable> currtask   ctx getcurrtask
currtask adddependenttask utask
if  ctx getroottasks   contains utask
ctx getroottasks   remove utask
if   ctx getroottasks   contains currtask
ctx getroottasks   add currtask
/**
* union operator encountered. a map-only query is encountered at the given
* position. however, at least one sub-query is a map-reduce job. copy the
* information from the current top operator to the union context.
*
* @param ctx
* @param uctxtask
* @param union
* @param stack
* @throws semanticexception
*/
private void processsubqueryunionmerge genmrproccontext ctx
genmrunionctx uctxtask  unionoperator union  stack<node> stack
throws semanticexception
// the current plan can be thrown away after being merged with the union
// plan
task<? extends serializable> utask   uctxtask getutask
mapredwork plan    mapredwork  utask getwork
ctx setcurrtask utask
list<operator<? extends serializable>> seenops   ctx getseenops
operator<? extends serializable> topop   ctx getcurrtopop
if   seenops contains topop     topop    null
seenops add topop
genmapredutils settaskplan ctx getcurraliasid    ctx
getcurrtopop    plan  false  ctx
private void processsubqueryunionmapjoin genmrproccontext ctx
abstractmapjoinoperator<? extends mapjoindesc> mjop   ctx getcurrmapjoinop
assert mjop    null
genmrmapjoinctx mjctx   ctx getmapjoinctx mjop
assert mjctx    null
mapredwork plan    mapredwork  ctx getcurrtask   getwork
string tasktmpdir   mjctx gettasktmpdir
tabledesc tt_desc   mjctx getttdesc
assert plan getpathtoaliases   get tasktmpdir     null
plan getpathtoaliases   put tasktmpdir  new arraylist<string>
plan getpathtoaliases   get tasktmpdir  add tasktmpdir
plan getpathtopartitioninfo   put tasktmpdir
new partitiondesc tt_desc  null
plan getaliastowork   put tasktmpdir  mjctx getrootmapjoinop
/**
* union operator encountered . currently, the algorithm is pretty simple: if
* all the sub-queries are map-only, don't do anything. however, if there is a
* mapjoin followed by the union, merge at the union otherwise, insert a
* filesink on top of all the sub-queries.
*
* this can be optimized later on.
*
* @param nd
*          the file sink operator encountered
* @param opprocctx
*          context
*/
public object process node nd  stack<node> stack  nodeprocessorctx opprocctx
object    nodeoutputs  throws semanticexception
unionoperator union    unionoperator  nd
genmrproccontext ctx    genmrproccontext  opprocctx
parsecontext parsectx   ctx getparsectx
unionproccontext uctx   parsectx getuctx
// map-only subqueries can be optimized in future to not write to a file in
// future
map<operator<? extends serializable>  genmapredctx> mapcurrctx   ctx getmapcurrctx
unionparsecontext uprsctx   uctx getunionparsecontext union
ctx setcurrunionop union
// the plan needs to be broken only if one of the sub-queries involve a
// map-reduce job
if  uprsctx allmaponlysubq
return processmaponlyunion union  stack  ctx  uctx
assert uprsctx    null
task<? extends serializable> currtask   ctx getcurrtask
int pos   unionprocfactory getpositionparent union  stack
task<? extends serializable> utask   null
mapredwork uplan   null
// union is encountered for the first time
genmrunionctx uctxtask   ctx getuniontask union
if  uctxtask    null
uctxtask   new genmrunionctx
uplan   genmapredutils getmapredwork parsectx
utask   taskfactory get uplan  parsectx getconf
uctxtask setutask utask
ctx setuniontask union  uctxtask
else
utask   uctxtask getutask
// copy into the current union task plan if
if  uprsctx getmaponlysubq pos
uprsctx getmapjoinsubq pos     uprsctx getroottask pos
processsubqueryunionmerge ctx  uctxtask  union  stack
// if it a map-reduce job, create a temporary file
else
// is the current task a root task
if  shouldberoottask currtask  parsectx
ctx getroottasks   contains currtask
ctx getroottasks   add currtask
// if there is a mapjoin at position 'pos'
if  uprsctx getmapjoinsubq pos
processsubqueryunionmapjoin ctx
processsubqueryunioncreateintermediate union getparentoperators   get pos   union  utask  ctx  uctxtask
//the curraliasid and currtopop is not valid any more
ctx setcurraliasid null
ctx setcurrtopop null
ctx getoptaskmap   put null  utask
ctx setcurrtask utask
mapcurrctx put  operator<? extends serializable>  nd
new genmapredctx ctx getcurrtask    null  null
return null
private boolean shouldberoottask
task<? extends serializable> currtask  parsecontext parsecontext
return currtask getparenttasks      null
currtask getparenttasks   size      0