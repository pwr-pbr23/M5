/**
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hive ql udf
import java util arraylist
import java util collections
import java util comparator
import java util hashmap
import java util list
import java util map
import java util set
import org apache hadoop hive ql exec description
import org apache hadoop hive ql exec udaf
import org apache hadoop hive ql exec udafevaluator
import org apache hadoop hive serde2 io doublewritable
import org apache hadoop io longwritable
/**
* udaf for calculating the percentile values.
* there are several definitions of percentile, and we take the method recommended by
* nist.
* @see <a href="http://en.wikipedia.org/wiki/percentile#alternative_methods">
*      percentile references</a>
*/
@description name
value
public class udafpercentile extends udaf
/**
* a state class to store intermediate aggregation results.
*/
public static class state
private map<longwritable  longwritable> counts
private list<doublewritable> percentiles
/**
* a comparator to sort the entries in order.
*/
public static class mycomparator implements comparator<map entry<longwritable  longwritable>>
@override
public int compare map entry<longwritable  longwritable> o1
map entry<longwritable  longwritable> o2
return o1 getkey   compareto o2 getkey
/**
* increment the state object with o as the key, and i as the count.
*/
private static void increment state s  longwritable o  long i
if  s counts    null
s counts   new hashmap<longwritable  longwritable>
longwritable count   s counts get o
if  count    null
// we have to create a new object, because the object o belongs
// to the code that creates it and may get its value changed.
longwritable key   new longwritable
key set o get
s counts put key  new longwritable i
else
count set count get     i
/**
* get the percentile value.
*/
private static double getpercentile list<map entry<longwritable  longwritable>> entrieslist
double position
// we may need to do linear interpolation to get the exact percentile
long lower    long math floor position
long higher    long math ceil position
// linear search since this won't take much time from the total execution anyway
// lower has the range of [0 .. total-1]
// the first entry with accumulated count (lower+1) corresponds to the lower position.
int i   0
while  entrieslist get i  getvalue   get   < lower   1
i
long lowerkey   entrieslist get i  getkey   get
if  higher    lower
// no interpolation needed because position does not have a fraction
return lowerkey
if  entrieslist get i  getvalue   get   < higher   1
i
long higherkey   entrieslist get i  getkey   get
if  higherkey    lowerkey
// no interpolation needed because lower position and higher position has the same key
return lowerkey
// linear interpolation to get the exact percentile
return  higher   position    lowerkey    position   lower    higherkey
/**
* the evaluator for percentile computation based on long.
*/
public static class percentilelongevaluator implements udafevaluator
private final state state
public percentilelongevaluator
state   new state
public void init
if  state counts    null
// we reuse the same hashmap to reduce new object allocation.
// this means counts can be empty when there is no input data.
state counts clear
/** note that percentile can be null in a global aggregation with
*  0 input rows:  "select percentile(col, 0.5) from t where false"
*  in that case, iterate(null, null) will be called once.
*/
public boolean iterate longwritable o  double percentile
if  o    null    percentile    null
return false
if  state percentiles    null
if  percentile < 0 0    percentile > 1 0
throw new runtimeexception
state percentiles   new arraylist<doublewritable> 1
state percentiles add new doublewritable percentile doublevalue
if  o    null
increment state  o  1
return true
public state terminatepartial
return state
public boolean merge state other
if  other    null    other counts    null    other percentiles    null
return false
if  state percentiles    null
state percentiles   new arraylist<doublewritable> other percentiles
for  map entry<longwritable  longwritable> e  other counts entryset
increment state  e getkey    e getvalue   get
return true
private doublewritable result
public doublewritable terminate
// no input data.
if  state counts    null    state counts size      0
return null
// get all items into an array and sort them.
set<map entry<longwritable  longwritable>> entries   state counts entryset
list<map entry<longwritable  longwritable>> entrieslist
new arraylist<map entry<longwritable  longwritable>> entries
collections sort entrieslist  new mycomparator
// accumulate the counts.
long total   0
for  int i   0  i < entrieslist size    i
longwritable count   entrieslist get i  getvalue
total    count get
count set total
// initialize the result.
if  result    null
result   new doublewritable
// maxposition is the 1.0 percentile
long maxposition   total   1
double position   maxposition   state percentiles get 0  get
result set getpercentile entrieslist  position
return result
/**
* the evaluator for percentile computation based on long for an array of percentiles.
*/
public static class percentilelongarrayevaluator implements udafevaluator
private final state state
public percentilelongarrayevaluator
state   new state
public void init
if  state counts    null
// we reuse the same hashmap to reduce new object allocation.
// this means counts can be empty when there is no input data.
state counts clear
public boolean iterate longwritable o  list<doublewritable> percentiles
if  state percentiles    null
if percentiles    null
for  int i   0  i < percentiles size    i
if  percentiles get i  get   < 0 0    percentiles get i  get   > 1 0
throw new runtimeexception
state percentiles   new arraylist<doublewritable> percentiles
else
state percentiles   new arraylist<doublewritable>
if  o    null
increment state  o  1
return true
public state terminatepartial
return state
public boolean merge state other
if  other    null    other counts    null    other percentiles    null
return true
if  state percentiles    null
state percentiles   new arraylist<doublewritable> other percentiles
for  map entry<longwritable  longwritable> e  other counts entryset
increment state  e getkey    e getvalue   get
return true
private list<doublewritable> results
public list<doublewritable> terminate
// no input data
if  state counts    null    state counts size      0
return null
// get all items into an array and sort them
set<map entry<longwritable  longwritable>> entries   state counts entryset
list<map entry<longwritable  longwritable>> entrieslist
new arraylist<map entry<longwritable  longwritable>> entries
collections sort entrieslist  new mycomparator
// accumulate the counts
long total   0
for  int i   0  i < entrieslist size    i
longwritable count   entrieslist get i  getvalue
total    count get
count set total
// maxposition is the 1.0 percentile
long maxposition   total   1
// initialize the results
if  results    null
results   new arraylist<doublewritable>
for  int i   0  i < state percentiles size    i
results add new doublewritable
// set the results
for  int i   0  i < state percentiles size    i
double position   maxposition   state percentiles get i  get
results get i  set getpercentile entrieslist  position
return results