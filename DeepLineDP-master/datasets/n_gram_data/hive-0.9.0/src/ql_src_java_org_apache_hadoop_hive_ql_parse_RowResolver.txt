/**
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hive ql parse
import java io serializable
import java util arraylist
import java util hashmap
import java util linkedhashmap
import java util list
import java util map
import java util set
import org apache commons logging log
import org apache commons logging logfactory
import org apache hadoop hive ql exec columninfo
import org apache hadoop hive ql exec rowschema
/**
* implementation of the row resolver.
*
*/
public class rowresolver implements serializable
private static final long serialversionuid   1l
private  rowschema rowschema
private  hashmap<string  linkedhashmap<string  columninfo>> rslvmap
private  hashmap<string  string> invrslvmap
private  map<string  astnode> expressionmap
// todo: refactor this and do in a more object oriented manner
private boolean isexprresolver
@suppresswarnings
private static final log log   logfactory getlog rowresolver class getname
public rowresolver
rowschema   new rowschema
rslvmap   new hashmap<string  linkedhashmap<string  columninfo>>
invrslvmap   new hashmap<string  string>
expressionmap   new hashmap<string  astnode>
isexprresolver   false
/**
* puts a resolver entry corresponding to a source expression which is to be
* used for identical expression recognition (e.g. for matching expressions
* in the select list with the group by clause).  the convention for such
* entries is an empty-string ("") as the table alias together with the
* string rendering of the astnode as the column alias.
*/
public void putexpression astnode node  columninfo colinfo
string treeasstring   node tostringtree
expressionmap put treeasstring  node
put    treeasstring  colinfo
/**
* retrieves the columninfo corresponding to a source expression which
* exactly matches the string rendering of the given astnode.
*/
public columninfo getexpression astnode node  throws semanticexception
return get    node tostringtree
/**
* retrieves the source expression matching a given astnode's
* string rendering exactly.
*/
public astnode getexpressionsource astnode node
return expressionmap get node tostringtree
public void put string tab_alias  string col_alias  columninfo colinfo
if  tab_alias    null
tab_alias   tab_alias tolowercase
col_alias   col_alias tolowercase
if  rowschema getsignature      null
rowschema setsignature new arraylist<columninfo>
rowschema getsignature   add colinfo
linkedhashmap<string  columninfo> f_map   rslvmap get tab_alias
if  f_map    null
f_map   new linkedhashmap<string  columninfo>
rslvmap put tab_alias  f_map
f_map put col_alias  colinfo
string qualifiedalias   new string
qualifiedalias   tab_alias
qualifiedalias   col_alias
invrslvmap put colinfo getinternalname    qualifiedalias
public boolean hastablealias string tab_alias
return rslvmap get tab_alias tolowercase       null
/**
* gets the column info to tab_alias.col_alias type of a column reference. i
* the tab_alias is not provided as can be the case with an non aliased
* column, this function looks up the column in all the table aliases in this
* row resolver and returns the match. it also throws an exception if the
* column is found in multiple table aliases. if no match is found a null
* values is returned.
*
* this allows us to interpret both select t.c1 type of references and select
* c1 kind of refereneces. the later kind are what we call non aliased column
* references in the query.
*
* @param tab_alias
*          the table alias to match (this is null if the column reference is
*          non aliased)
* @param col_alias
*          the column name that is being searched for
* @return columninfo
* @throws semanticexception
*/
public columninfo get string tab_alias  string col_alias  throws semanticexception
col_alias   col_alias tolowercase
columninfo ret   null
if  tab_alias    null
tab_alias   tab_alias tolowercase
hashmap<string  columninfo> f_map   rslvmap get tab_alias
if  f_map    null
return null
ret   f_map get col_alias
else
boolean found   false
for  linkedhashmap<string  columninfo> cmap   rslvmap values
for  map entry<string  columninfo> cmapent   cmap entryset
if  col_alias equalsignorecase cmapent getkey
if  found
throw new semanticexception     col_alias
found   true
ret   cmapent getvalue
return ret
public arraylist<columninfo> getcolumninfos
return rowschema getsignature
/**
* get a list of non-hidden column names
* @param max the maximum number of columns to return
* @return a list of non-hidden column names no greater in size than max
*/
public list<string> getnonhiddencolumnnames int max
list<string> columnnames   new arraylist<string>
int count   0
for  columninfo columninfo   getcolumninfos
if  max > 0    count >  max
break
if   columninfo ishiddenvirtualcol
columnnames add columninfo getinternalname
count
return columnnames
public hashmap<string  columninfo> getfieldmap string tabalias
if  tabalias    null
return rslvmap get null
else
return rslvmap get tabalias tolowercase
public int getposition string internalname
int pos    1
for  columninfo var   rowschema getsignature
pos
if  var getinternalname   equals internalname
return pos
return  1
public set<string> gettablenames
return rslvmap keyset
public string reverselookup string internalname
return invrslvmap get internalname
public void setisexprresolver boolean isexprresolver
this isexprresolver   isexprresolver
public boolean getisexprresolver
return isexprresolver
@override
public string tostring
stringbuilder sb   new stringbuilder
for  map entry<string  linkedhashmap<string  columninfo>> e   rslvmap
entryset
string tab   e getkey
sb append tab
hashmap<string  columninfo> f_map   e getvalue
if  f_map    null
for  map entry<string  columninfo> entry   f_map entryset
sb append     entry getkey         entry getvalue   tostring
sb append
return sb tostring
public rowschema getrowschema
return rowschema
public hashmap<string  linkedhashmap<string  columninfo>> getrslvmap
return rslvmap
public hashmap<string  string> getinvrslvmap
return invrslvmap
public map<string  astnode> getexpressionmap
return expressionmap
public void setexprresolver boolean isexprresolver
this isexprresolver   isexprresolver
public void setrowschema rowschema rowschema
this rowschema   rowschema
public void setrslvmap hashmap<string  linkedhashmap<string  columninfo>> rslvmap
this rslvmap   rslvmap
public void setinvrslvmap hashmap<string  string> invrslvmap
this invrslvmap   invrslvmap
public void setexpressionmap map<string  astnode> expressionmap
this expressionmap   expressionmap