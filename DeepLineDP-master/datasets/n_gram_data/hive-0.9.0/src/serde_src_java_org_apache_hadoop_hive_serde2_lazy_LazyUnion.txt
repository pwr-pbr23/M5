/**
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hive serde2 lazy
import org apache hadoop hive serde2 lazy objectinspector lazyunionobjectinspector
import org apache hadoop hive serde2 objectinspector objectinspector
import org apache hadoop io text
/**
* lazyobject for storing a union. the field of a union can be primitive or
* non-primitive.
*
*/
public class lazyunion extends
lazynonprimitive<lazyunionobjectinspector>
/**
* whether the data is already parsed or not.
*/
private boolean parsed
/**
* the start position of union field. only valid when the data is parsed.
*/
private int startposition
/**
* the object of the union.
*/
private lazyobject<? extends objectinspector> field
/**
* tag of the union
*/
private byte tag
/**
* whether init() has been called on the field or not.
*/
private boolean fieldinited   false
/**
* construct a lazyunion object with the objectinspector.
*/
public lazyunion lazyunionobjectinspector oi
super oi
/**
* set the row data for this lazyunion.
*
* @see lazyobject#init(bytearrayref, int, int)
*/
@override
public void init bytearrayref bytes  int start  int length
super init bytes  start  length
parsed   false
/**
* parse the byte[] and fill each field.
*/
@suppresswarnings
private void parse
byte separator   oi getseparator
boolean isescaped   oi isescaped
byte escapechar   oi getescapechar
boolean tagstarted   false
boolean tagparsed   false
int tagstart    1
int tagend    1
int unionbyteend   start   length
int fieldbyteend   start
byte bytes   this bytes getdata
// go through all bytes in the byte[]
while  fieldbyteend < unionbyteend
if  bytes    separator
if  isescaped    bytes    escapechar
fieldbyteend   1 < unionbyteend
// ignore the char after escape_char
fieldbyteend    1
else
if   tagstarted
tagstart   fieldbyteend
tagstarted   true
else       bytes    separator
if   tagparsed
// reached the end of the tag
tagend   fieldbyteend   1
startposition   fieldbyteend   1
tagparsed   true
fieldbyteend
tag   lazybyte parsebyte bytes  tagstart   tagend   tagstart    1
field   lazyfactory createlazyobject oi getobjectinspectors   get tag
fieldinited   false
parsed   true
/**
* get the field out of the row without checking parsed.
*
* @return the value of the field
*/
private object uncheckedgetfield
text nullsequence   oi getnullsequence
int fieldlength   start   length   startposition
if  fieldlength    0    fieldlength    nullsequence getlength
lazyutils compare bytes getdata    startposition  fieldlength
nullsequence getbytes    0  nullsequence getlength       0
return null
if   fieldinited
fieldinited   true
field init bytes  startposition  fieldlength
return field getobject
/**
* get the field out of the union.
*
* @return the field as a lazyobject
*/
public object getfield
if   parsed
parse
return uncheckedgetfield
/**
* get the tag of the union
*
* @return the tag byte
*/
public byte gettag
if   parsed
parse
return tag