/**
* licensed to the apache software foundation (asf) under one
* or more contributor license agreements.  see the notice file
* distributed with this work for additional information
* regarding copyright ownership.  the asf licenses this file
* to you under the apache license, version 2.0 (the
* "license"); you may not use this file except in compliance
* with the license.  you may obtain a copy of the license at
*
*     http://www.apache.org/licenses/license-2.0
*
* unless required by applicable law or agreed to in writing, software
* distributed under the license is distributed on an "as is" basis,
* without warranties or conditions of any kind, either express or implied.
* see the license for the specific language governing permissions and
* limitations under the license.
*/
package org apache hadoop hive ql io
import java io ioexception
import java util arraylist
import java util list
import org apache commons logging log
import org apache commons logging logfactory
import org apache hadoop fs filesystem
import org apache hadoop fs path
import org apache hadoop hive io hiveioexceptionhandlerutil
import org apache hadoop hive ql io iocontext comparison
import org apache hadoop hive ql udf generic genericudfopequal
import org apache hadoop hive ql udf generic genericudfopequalorgreaterthan
import org apache hadoop hive ql udf generic genericudfopequalorlessthan
import org apache hadoop hive ql udf generic genericudfopgreaterthan
import org apache hadoop hive ql udf generic genericudfoplessthan
import org apache hadoop io sequencefile
import org apache hadoop mapred filesplit
import org apache hadoop mapred inputsplit
import org apache hadoop mapred jobconf
import org apache hadoop mapred recordreader
/** this class prepares an iocontext, and provides the ability to perform a binary search on the
* data.  the binary search can be used by setting the value of inputformatsorted in the
* mapreducework to true, but it should only be used if the data is going to a filteroperator,
* which filters by comparing a value in the data with a constant, using one of the comparisons
* =, <, >, <=, >=.  if the recordreader's underlying format is an rcfile, this object can perform
* a binary search to find the block to begin reading from, and stop reading once it can be
* determined no other entries will match the filter.
*/
public abstract class hivecontextawarerecordreader<k  v> implements recordreader<k  v>
private static final log log   logfactory getlog hivecontextawarerecordreader class getname
private boolean initdone   false
private long rangestart
private long rangeend
private long splitend
private long previousposition    1
private boolean wasusingsortedsearch   false
private string genericudfclassname   null
private final list<comparison> stopcomparisons   new arraylist<comparison>
protected recordreader recordreader
protected jobconf jobconf
protected boolean issorted   false
public hivecontextawarerecordreader jobconf conf  throws ioexception
this null  conf
public hivecontextawarerecordreader recordreader recordreader
this recordreader   recordreader
public hivecontextawarerecordreader recordreader recordreader  jobconf conf
throws ioexception
this recordreader   recordreader
this jobconf   conf
public void setrecordreader recordreader recordreader
this recordreader   recordreader
/**
* close this {@link inputsplit} to future operations.
*
* @throws ioexception
*/
public abstract void doclose   throws ioexception
private iocontext iocxtref    null
@override
public void close   throws ioexception
doclose
initdone   false
iocxtref   null
@override
public boolean next k key  v value  throws ioexception
if  initdone
throw new ioexception
updateiocontext
try
return donext key  value
catch  ioexception e
iocxtref setioexceptions true
throw e
protected void updateiocontext
throws ioexception
long pointerpos   this getpos
if   iocxtref isblockpointer
iocxtref currentblockstart   pointerpos
iocxtref currentrow   0
return
iocxtref currentrow
if  iocxtref nextblockstart     1
iocxtref nextblockstart   pointerpos
iocxtref currentrow   0
if  pointerpos    iocxtref nextblockstart
// the reader pointer has moved to the end of next block, or the end of
// current record.
iocxtref currentrow   0
if  iocxtref currentblockstart    iocxtref nextblockstart
iocxtref currentrow   1
iocxtref currentblockstart   iocxtref nextblockstart
iocxtref nextblockstart   pointerpos
public iocontext getiocontext
return iocontext get
public void initiocontext long startpos  boolean isblockpointer  string inputfile
iocxtref   this getiocontext
iocxtref currentblockstart   startpos
iocxtref isblockpointer   isblockpointer
iocxtref inputfile   inputfile
log info     inputfile
initdone   true
public void initiocontext filesplit split  jobconf job
class inputformatclass  throws ioexception
this initiocontext split  job  inputformatclass  null
public void initiocontext filesplit split  jobconf job
class inputformatclass  recordreader recordreader  throws ioexception
boolean blockpointer   false
long blockstart    1
filesplit filesplit    filesplit  split
path path   filesplit getpath
filesystem fs   path getfilesystem job
if  inputformatclass getname   contains
sequencefile reader in   new sequencefile reader fs  path  job
blockpointer   in isblockcompressed
in sync filesplit getstart
blockstart   in getposition
in close
else if  recordreader instanceof rcfilerecordreader
blockpointer   true
blockstart     rcfilerecordreader  recordreader  getstart
else if  inputformatclass getname   contains
blockpointer   true
rcfile reader in   new rcfile reader fs  path  job
in sync filesplit getstart
blockstart   in getposition
in close
this initiocontext blockstart  blockpointer  path makequalified fs  tostring
this initiocontextsortedprops split  recordreader  job
public void initiocontextsortedprops filesplit split  recordreader recordreader  jobconf job
this getiocontext   resetsortingvalues
this issorted   jobconf getboolean    false
this rangestart   split getstart
this rangeend   split getstart     split getlength
this splitend   rangeend
if  recordreader instanceof rcfilerecordreader    rangeend    0    this issorted
// binary search only works if we know the size of the split, and the recordreader is an
// rcfilerecordreader
this getiocontext   setusesorted true
this getiocontext   setisbinarysearching true
this wasusingsortedsearch   true
else
// use the defalut methods for next in the child class
this issorted   false
@override
public float getprogress   throws ioexception
if  this getiocontext   isbinarysearching
return 0
else
return recordreader getprogress
public boolean donext k key  v value  throws ioexception
if  this issorted
if  this getiocontext   shouldendbinarysearch
this getiocontext   usesorted      this wasusingsortedsearch
beginlinearsearch
this wasusingsortedsearch   false
this getiocontext   setendbinarysearch false
if  this getiocontext   usesorted
if  this genericudfclassname    null
this getiocontext   getgenericudfclassname      null
setgenericudfclassname this getiocontext   getgenericudfclassname
if  this getiocontext   isbinarysearching
// proceed with a binary search
if  this getiocontext   getcomparison      null
switch  this getiocontext   getcomparison
case greater
case equal
// indexes have only one entry per value, could go linear from here, if we want to
// use this for any sorted table, we'll need to continue the search
rangeend   previousposition
break
case less
rangestart   previousposition
break
default
break
long position    rangestart   rangeend    2
sync position
long newposition   getsyncedposition
// if the newposition is the same as the previousposition, we've reached the end of the
// binary search, if the new position at least as big as the size of the split, any
// matching rows must be in the final block, so we can end the binary search.
if  newposition    previousposition    newposition >  splitend
this getiocontext   setisbinarysearching false
sync rangestart
previousposition   newposition
else if  foundalltargets
// found all possible rows which will not be filtered
return false
try
return recordreader next key   value
catch  exception e
return hiveioexceptionhandlerutil handlerecordreadernextexception e  jobconf
private void sync long position  throws ioexception
rcfilerecordreader recordreader  sync position
rcfilerecordreader recordreader  resetbuffer
private long getsyncedposition   throws ioexception
return recordreader getpos
/**
* this uses the name of the generic udf being used by the filter to determine whether we should
* perform a binary search, and what the comparisons we should use to signal the end of the
* linear scan are.
* @param genericudfclassname
* @throws ioexception
*/
private void setgenericudfclassname string genericudfclassname  throws ioexception
this genericudfclassname   genericudfclassname
if  genericudfclassname equals genericudfopequal class getname
stopcomparisons add comparison greater
else if  genericudfclassname equals genericudfoplessthan class getname
stopcomparisons add comparison equal
stopcomparisons add comparison greater
if  this getiocontext   isbinarysearching
beginlinearsearch
else if  genericudfclassname equals genericudfopequalorlessthan class getname
stopcomparisons add comparison greater
if  this getiocontext   isbinarysearching
beginlinearsearch
else if  genericudfclassname equals genericudfopgreaterthan class getname
genericudfclassname equals genericudfopequalorgreaterthan class getname
// do nothing
else
// this is an unsupported operator
log debug genericudfclassname
if  this getiocontext   isbinarysearching
beginlinearsearch
/**
* this should be called after the binary search is finished and before the linear scan begins
* @throws ioexception
*/
private void beginlinearsearch   throws ioexception
sync rangestart
this getiocontext   setisbinarysearching false
this wasusingsortedsearch   false
/**
* returns true if the current comparison is in the list of stop comparisons, i.e. we've found
* all records which won't be filtered
* @return true if the current comparison is found
*/
public boolean foundalltargets
if  this getiocontext   getcomparison      null
stopcomparisons contains this getiocontext   getcomparison
return false
return true